"use strict";function _typeof(e){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}!function(t){var r={};function o(e){if(r[e])return r[e].exports;var n=r[e]={i:e,l:!1,exports:{}};return t[e].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=t,o.c=r,o.d=function(e,n,t){o.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"===_typeof(n)&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(n,"a",n),n},o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},o.p="",o(o.s="./src/js/app.js")}({"./node_modules/@popperjs/core/lib/createPopper.js":function node_modulesPopperjsCoreLibCreatePopperJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "popperGenerator", function() { return popperGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPopper", function() { return createPopper; });\n/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");\n/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");\n/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");\n/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/orderModifiers.js */ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js");\n/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/debounce.js */ "./node_modules/@popperjs/core/lib/utils/debounce.js");\n/* harmony import */ var _utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/validateModifiers.js */ "./node_modules/@popperjs/core/lib/utils/validateModifiers.js");\n/* harmony import */ var _utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/uniqueBy.js */ "./node_modules/@popperjs/core/lib/utils/uniqueBy.js");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/mergeByName.js */ "./node_modules/@popperjs/core/lib/utils/mergeByName.js");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectOverflow", function() { return _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });\n\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar INVALID_ELEMENT_ERROR = \'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\';\nvar INFINITE_LOOP_ERROR = \'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\';\nvar DEFAULT_OPTIONS = {\n  placement: \'bottom\',\n  modifiers: [],\n  strategy: \'absolute\'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === \'function\');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: \'bottom\',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(options) {\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_12__["isElement"])(reference) ? Object(_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(reference) : reference.contextElement ? Object(_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(reference.contextElement) : [],\n          popper: Object(_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = Object(_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_5__["default"])(Object(_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_10__["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (true) {\n          var modifiers = Object(_utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_8__["default"])([].concat(orderedModifiers, state.options.modifiers), function (_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          Object(_utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_7__["default"])(modifiers);\n\n          if (Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.options.placement) === _enums_js__WEBPACK_IMPORTED_MODULE_13__["auto"]) {\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\n              var name = _ref2.name;\n              return name === \'flip\';\n            });\n\n            if (!flipModifier) {\n              console.error([\'Popper: "auto" placements require the "flip" modifier be\', \'present and enabled to work.\'].join(\' \'));\n            }\n          }\n\n          var _getComputedStyle = Object(_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(popper),\n              marginTop = _getComputedStyle.marginTop,\n              marginRight = _getComputedStyle.marginRight,\n              marginBottom = _getComputedStyle.marginBottom,\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we\'ll warn the consumer\n\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn([\'Popper: CSS "margin" styles cannot be used to apply padding\', \'between the popper and its reference element or boundary.\', \'To replicate margin, use the `offset` modifier, as well as\', \'the `padding` option in the `preventOverflow` and `flip`\', \'modifiers.\'].join(\' \'));\n          }\n        }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don\'t proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (true) {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: Object(_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(reference, Object(_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper), state.options.strategy === \'fixed\'),\n          popper: Object(_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn\'t persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (true) {\n            __debug_loops__ += 1;\n\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === \'function\') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: Object(_utils_debounce_js__WEBPACK_IMPORTED_MODULE_6__["default"])(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (true) {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === \'function\') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nvar createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\n\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/createPopper.js?')},"./node_modules/@popperjs/core/lib/dom-utils/contains.js":function node_modulesPopperjsCoreLibDomUtilsContainsJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return contains; });\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__["isShadowRoot"])(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/contains.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":function node_modulesPopperjsCoreLibDomUtilsGetBoundingClientRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getBoundingClientRect; });\nfunction getBoundingClientRect(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    width: rect.width,\n    height: rect.height,\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    x: rect.left,\n    y: rect.top\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":function node_modulesPopperjsCoreLibDomUtilsGetClippingRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getClippingRect; });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getViewportRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js");\n/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js");\n/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");\n/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");\n/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");\n/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getInnerBoundingClientRect(element) {\n  var rect = Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_8__["default"])(element);\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_0__["viewport"] ? Object(_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Object(_getViewportRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) : Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__["isHTMLElement"])(clippingParent) ? getInnerBoundingClientRect(clippingParent) : Object(_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Object(_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(element)));\n} // A "clipping parent" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = Object(_listScrollParents_js__WEBPACK_IMPORTED_MODULE_3__["default"])(Object(_getParentNode_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element));\n  var canEscapeClipping = [\'absolute\', \'fixed\'].indexOf(Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element).position) >= 0;\n  var clipperElement = canEscapeClipping && Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__["isHTMLElement"])(element) ? Object(_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(element) : element;\n\n  if (!Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__["isElement"])(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__["isElement"])(clippingParent) && Object(_contains_js__WEBPACK_IMPORTED_MODULE_10__["default"])(clippingParent, clipperElement) && Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_11__["default"])(clippingParent) !== \'body\';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === \'clippingParents\' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    accRect.top = Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_13__["max"])(rect.top, accRect.top);\n    accRect.right = Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_13__["min"])(rect.right, accRect.right);\n    accRect.bottom = Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_13__["min"])(rect.bottom, accRect.bottom);\n    accRect.left = Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_13__["max"])(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":function node_modulesPopperjsCoreLibDomUtilsGetCompositeRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getCompositeRect; });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");\n/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getNodeScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");\n\n\n\n\n\n\n // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var documentElement = Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(offsetParent);\n  var rect = Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(elementOrVirtualElement);\n  var isOffsetParentAnElement = Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(offsetParent);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent) !== \'body\' || // https://github.com/popperjs/popper-core/issues/1078\n    Object(_isScrollParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(documentElement)) {\n      scroll = Object(_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent);\n    }\n\n    if (Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(offsetParent)) {\n      offsets = Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(offsetParent);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = Object(_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_4__["default"])(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":function node_modulesPopperjsCoreLibDomUtilsGetComputedStyleJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getComputedStyle; });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n\nfunction getComputedStyle(element) {\n  return Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element).getComputedStyle(element);\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":function node_modulesPopperjsCoreLibDomUtilsGetDocumentElementJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getDocumentElement; });\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return ((Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__["isElement"])(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":function node_modulesPopperjsCoreLibDomUtilsGetDocumentRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getDocumentRect; });\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");\n\n\n\n\n // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);\n  var winScroll = Object(_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_4__["max"])(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_4__["max"])(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + Object(_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);\n  var y = -winScroll.scrollTop;\n\n  if (Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(body || html).direction === \'rtl\') {\n    x += Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_4__["max"])(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":function node_modulesPopperjsCoreLibDomUtilsGetHTMLElementScrollJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getHTMLElementScroll; });\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":function node_modulesPopperjsCoreLibDomUtilsGetLayoutRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getLayoutRect; });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");\n // Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn\'t take into account transforms.\n\nfunction getLayoutRect(element) {\n  var clientRect = Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element); // Use the clientRect sizes if it\'s not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":function node_modulesPopperjsCoreLibDomUtilsGetNodeNameJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getNodeName; });\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js?")},"./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":function node_modulesPopperjsCoreLibDomUtilsGetNodeScrollJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getNodeScroll; });\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js");\n\n\n\n\nfunction getNodeScroll(node) {\n  if (node === Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node) || !Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_2__["isHTMLElement"])(node)) {\n    return Object(_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);\n  } else {\n    return Object(_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node);\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":function node_modulesPopperjsCoreLibDomUtilsGetOffsetParentJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getOffsetParent; });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isTableElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");\n\n\n\n\n\n\n\nfunction getTrueOffsetParent(element) {\n  if (!Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(element) || // https://github.com/popperjs/popper-core/issues/837\n  Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).position === \'fixed\') {\n    return null;\n  }\n\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var isFirefox = navigator.userAgent.toLowerCase().indexOf(\'firefox\') !== -1;\n  var isIE = navigator.userAgent.indexOf(\'Trident\') !== -1;\n\n  if (isIE && Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);\n\n    if (elementCss.position === \'fixed\') {\n      return null;\n    }\n  }\n\n  var currentNode = Object(_getParentNode_js__WEBPACK_IMPORTED_MODULE_5__["default"])(element);\n\n  while (Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(currentNode) && [\'html\', \'body\'].indexOf(Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(currentNode)) < 0) {\n    var css = Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== \'none\' || css.perspective !== \'none\' || css.contain === \'paint\' || [\'transform\', \'perspective\'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === \'filter\' || isFirefox && css.filter && css.filter !== \'none\') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  var window = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && Object(_isTableElement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) && Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent).position === \'static\') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent) === \'html\' || Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent) === \'body\' && Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent).position === \'static\')) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":function node_modulesPopperjsCoreLibDomUtilsGetParentNodeJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getParentNode; });\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n\n\n\nfunction getParentNode(element) {\n  if (Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element) === \'html\') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_2__["isShadowRoot"])(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element) // fallback\n\n  );\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":function node_modulesPopperjsCoreLibDomUtilsGetScrollParentJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getScrollParent; });\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n\n\n\n\nfunction getScrollParent(node) {\n  if ([\'html\', \'body\', \'#document\'].indexOf(Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(node) && Object(_isScrollParent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node)) {\n    return node;\n  }\n\n  return getScrollParent(Object(_getParentNode_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node));\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":function node_modulesPopperjsCoreLibDomUtilsGetViewportRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getViewportRect; });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");\n\n\n\nfunction getViewportRect(element) {\n  var win = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);\n  var html = Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0; // NB: This isn\'t supported on iOS <= 12. If the keyboard is open, the popper\n  // can be obscured underneath it.\n  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n  // if it isn\'t open, so if this isn\'t available, the popper will be detected\n  // to overflow the bottom of the screen too early.\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n    // errors due to floating point numbers, so we need to check precision.\n    // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n    // Feature detection fails in mobile emulation mode in Chrome.\n    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n    // 0.001\n    // Fallback here: "Not Safari" userAgent\n\n    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + Object(_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element),\n    y: y\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js":function node_modulesPopperjsCoreLibDomUtilsGetWindowJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getWindow; });\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getWindow.js?")},"./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":function node_modulesPopperjsCoreLibDomUtilsGetWindowScrollJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getWindowScroll; });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n\nfunction getWindowScroll(node) {\n  var win = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":function node_modulesPopperjsCoreLibDomUtilsGetWindowScrollBarXJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getWindowScrollBarX; });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");\n\n\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let\'s assume\n  // it\'s not an issue. I don\'t think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn\'t cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)).left + Object(_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).scrollLeft;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js?')},"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":function node_modulesPopperjsCoreLibDomUtilsInstanceOfJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isElement", function() { return isElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isHTMLElement", function() { return isHTMLElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isShadowRoot", function() { return isShadowRoot; });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n\n\nfunction isElement(node) {\n  var OwnElement = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\nfunction isHTMLElement(node) {\n  var OwnElement = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === \'undefined\') {\n    return false;\n  }\n\n  var OwnElement = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js?')},"./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":function node_modulesPopperjsCoreLibDomUtilsIsScrollParentJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isScrollParent; });\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js?')},"./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":function node_modulesPopperjsCoreLibDomUtilsIsTableElementJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return isTableElement; });\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element)) >= 0;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js?")},"./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":function node_modulesPopperjsCoreLibDomUtilsListScrollParentsJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return listScrollParents; });\n/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");\n\n\n\n\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we\'ll need to re-calculate the\nreference element\'s position.\n*/\n\nfunction listScrollParents(element, list) {\n  var _element$ownerDocumen;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = Object(_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], Object(_isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(Object(_getParentNode_js__WEBPACK_IMPORTED_MODULE_1__["default"])(target)));\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js?')},"./node_modules/@popperjs/core/lib/enums.js":function node_modulesPopperjsCoreLibEnumsJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "top", function() { return top; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bottom", function() { return bottom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "right", function() { return right; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "left", function() { return left; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "auto", function() { return auto; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basePlacements", function() { return basePlacements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "start", function() { return start; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "end", function() { return end; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clippingParents", function() { return clippingParents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewport", function() { return viewport; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "popper", function() { return popper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reference", function() { return reference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variationPlacements", function() { return variationPlacements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "placements", function() { return placements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beforeRead", function() { return beforeRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "read", function() { return read; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "afterRead", function() { return afterRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beforeMain", function() { return beforeMain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "main", function() { return main; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "afterMain", function() { return afterMain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beforeWrite", function() { return beforeWrite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "write", function() { return write; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "afterWrite", function() { return afterWrite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifierPhases", function() { return modifierPhases; });\nvar top = \'top\';\nvar bottom = \'bottom\';\nvar right = \'right\';\nvar left = \'left\';\nvar auto = \'auto\';\nvar basePlacements = [top, bottom, right, left];\nvar start = \'start\';\nvar end = \'end\';\nvar clippingParents = \'clippingParents\';\nvar viewport = \'viewport\';\nvar popper = \'popper\';\nvar reference = \'reference\';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + "-" + start, placement + "-" + end]);\n}, []);\nvar placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = \'beforeRead\';\nvar read = \'read\';\nvar afterRead = \'afterRead\'; // pure-logic modifiers\n\nvar beforeMain = \'beforeMain\';\nvar main = \'main\';\nvar afterMain = \'afterMain\'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = \'beforeWrite\';\nvar write = \'write\';\nvar afterWrite = \'afterWrite\';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/enums.js?')},"./node_modules/@popperjs/core/lib/index.js":function node_modulesPopperjsCoreLibIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "top", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["top"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bottom", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["bottom"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "right", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["right"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "left", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["left"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "auto", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["auto"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "basePlacements", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["basePlacements"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "start", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["start"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "end", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["end"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clippingParents", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["clippingParents"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "viewport", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["viewport"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popper", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["popper"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reference", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["reference"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variationPlacements", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["variationPlacements"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "placements", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["placements"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "beforeRead", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["beforeRead"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "read", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["read"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "afterRead", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["afterRead"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "beforeMain", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["beforeMain"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "main", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["main"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "afterMain", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["afterMain"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "beforeWrite", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["beforeWrite"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "write", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["write"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "afterWrite", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["afterWrite"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "modifierPhases", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["modifierPhases"]; });\n\n/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyStyles", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["applyStyles"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "arrow", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["arrow"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeStyles", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["computeStyles"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eventListeners", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["eventListeners"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flip", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["flip"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hide", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["hide"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "offset", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["offset"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popperOffsets", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["popperOffsets"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "preventOverflow", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["preventOverflow"]; });\n\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popperGenerator", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_2__["popperGenerator"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectOverflow", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_2__["detectOverflow"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPopperBase", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_2__["createPopper"]; });\n\n/* harmony import */ var _popper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./popper.js */ "./node_modules/@popperjs/core/lib/popper.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPopper", function() { return _popper_js__WEBPACK_IMPORTED_MODULE_3__["createPopper"]; });\n\n/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPopperLite", function() { return _popper_lite_js__WEBPACK_IMPORTED_MODULE_4__["createPopper"]; });\n\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/index.js?')},"./node_modules/@popperjs/core/lib/modifiers/applyStyles.js":function node_modulesPopperjsCoreLibModifiersApplyStylesJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__[\"isHTMLElement\"])(element) || !Object(_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__[\"isHTMLElement\"])(element) || !Object(_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect,\n  requires: ['computeStyles']\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/applyStyles.js?")},"./node_modules/@popperjs/core/lib/modifiers/arrow.js":function node_modulesPopperjsCoreLibModifiersArrowJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");\n/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");\n/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");\n/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");\n/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");\n/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === \'function\' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return Object(_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_6__["default"])(typeof padding !== \'number\' ? padding : Object(_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_7__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_8__["basePlacements"]));\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.placement);\n  var axis = Object(_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(basePlacement);\n  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_8__["left"], _enums_js__WEBPACK_IMPORTED_MODULE_8__["right"]].indexOf(basePlacement) >= 0;\n  var len = isVertical ? \'height\' : \'width\';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = Object(_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arrowElement);\n  var minProp = axis === \'y\' ? _enums_js__WEBPACK_IMPORTED_MODULE_8__["top"] : _enums_js__WEBPACK_IMPORTED_MODULE_8__["left"];\n  var maxProp = axis === \'y\' ? _enums_js__WEBPACK_IMPORTED_MODULE_8__["bottom"] : _enums_js__WEBPACK_IMPORTED_MODULE_8__["right"];\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = Object(_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === \'y\' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn\'t overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = Object(_utils_within_js__WEBPACK_IMPORTED_MODULE_5__["default"])(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? \'[data-popper-arrow]\' : _options$element;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === \'string\') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (true) {\n    if (!Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_9__["isHTMLElement"])(arrowElement)) {\n      console.error([\'Popper: "arrow" element must be an HTMLElement (not an SVGElement).\', \'To use an SVG arrow, wrap it in an HTMLElement that will be used as\', \'the arrow.\'].join(\' \'));\n    }\n  }\n\n  if (!Object(_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.elements.popper, arrowElement)) {\n    if (true) {\n      console.error([\'Popper: "arrow" modifier\\\'s `element` must be a child of the popper\', \'element.\'].join(\' \'));\n    }\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  name: \'arrow\',\n  enabled: true,\n  phase: \'main\',\n  fn: arrow,\n  effect: effect,\n  requires: [\'popperOffsets\'],\n  requiresIfExists: [\'preventOverflow\']\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/arrow.js?')},"./node_modules/@popperjs/core/lib/modifiers/computeStyles.js":function node_modulesPopperjsCoreLibModifiersComputeStylesJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapToStyles\", function() { return mapToStyles; });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_6__[\"round\"])(Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_6__[\"round\"])(x * dpr) / dpr) || 0,\n    y: Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_6__[\"round\"])(Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_6__[\"round\"])(y * dpr) / dpr) || 0\n  };\n}\n\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets;\n\n  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,\n      _ref3$x = _ref3.x,\n      x = _ref3$x === void 0 ? 0 : _ref3$x,\n      _ref3$y = _ref3.y,\n      y = _ref3$y === void 0 ? 0 : _ref3$y;\n\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__[\"left\"];\n  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__[\"top\"];\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = Object(_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n\n    if (offsetParent === Object(_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(popper)) {\n      offsetParent = Object(_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(popper);\n\n      if (Object(_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(offsetParent).position !== 'static') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n    offsetParent = offsetParent;\n\n    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__[\"top\"]) {\n      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__[\"bottom\"]; // $FlowFixMe[prop-missing]\n\n      y -= offsetParent[heightProp] - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__[\"left\"]) {\n      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__[\"right\"]; // $FlowFixMe[prop-missing]\n\n      x -= offsetParent[widthProp] - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref4) {\n  var state = _ref4.state,\n      options = _ref4.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n\n  if (true) {\n    var transitionProperty = Object(_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(state.elements.popper).transitionProperty || '';\n\n    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {\n      return transitionProperty.indexOf(property) >= 0;\n    })) {\n      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', '\\n\\n', 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\\n\\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));\n    }\n  }\n\n  var commonStyles = {\n    placement: Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/computeStyles.js?")},"./node_modules/@popperjs/core/lib/modifiers/eventListeners.js":function node_modulesPopperjsCoreLibModifiersEventListenersJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = Object(_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/eventListeners.js?")},"./node_modules/@popperjs/core/lib/modifiers/flip.js":function node_modulesPopperjsCoreLibModifiersFlipJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");\n/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__["auto"]) {\n    return [];\n  }\n\n  var oppositePlacement = Object(_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);\n  return [Object(_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(placement), oppositePlacement, Object(_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [Object(_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__["auto"] ? Object(_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement);\n\n    var isStartVariation = Object(_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__["start"];\n    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_5__["top"], _enums_js__WEBPACK_IMPORTED_MODULE_5__["bottom"]].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? \'width\' : \'height\';\n    var overflow = Object(_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["right"] : _enums_js__WEBPACK_IMPORTED_MODULE_5__["left"] : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["bottom"] : _enums_js__WEBPACK_IMPORTED_MODULE_5__["top"];\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = Object(_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(mainVariationSide);\n    }\n\n    var altVariationSide = Object(_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return "break";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === "break") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  name: \'flip\',\n  enabled: true,\n  phase: \'main\',\n  fn: flip,\n  requiresIfExists: [\'offset\'],\n  data: {\n    _skip: false\n  }\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/flip.js?')},"./node_modules/@popperjs/core/lib/modifiers/hide.js":function node_modulesPopperjsCoreLibModifiersHideJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");\n\n\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__["top"], _enums_js__WEBPACK_IMPORTED_MODULE_0__["right"], _enums_js__WEBPACK_IMPORTED_MODULE_0__["bottom"], _enums_js__WEBPACK_IMPORTED_MODULE_0__["left"]].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = Object(_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {\n    elementContext: \'reference\'\n  });\n  var popperAltOverflow = Object(_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    \'data-popper-reference-hidden\': isReferenceHidden,\n    \'data-popper-escaped\': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  name: \'hide\',\n  enabled: true,\n  phase: \'main\',\n  requiresIfExists: [\'preventOverflow\'],\n  fn: hide\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/hide.js?')},"./node_modules/@popperjs/core/lib/modifiers/index.js":function node_modulesPopperjsCoreLibModifiersIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyStyles", function() { return _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _arrow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "arrow", function() { return _arrow_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeStyles", function() { return _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eventListeners", function() { return _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n/* harmony import */ var _flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flip", function() { return _flip_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });\n\n/* harmony import */ var _hide_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hide", function() { return _hide_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });\n\n/* harmony import */ var _offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "offset", function() { return _offset_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });\n\n/* harmony import */ var _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popperOffsets", function() { return _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });\n\n/* harmony import */ var _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "preventOverflow", function() { return _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/index.js?')},"./node_modules/@popperjs/core/lib/modifiers/offset.js":function node_modulesPopperjsCoreLibModifiersOffsetJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceAndSkiddingToXY", function() { return distanceAndSkiddingToXY; });\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);\n  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__["left"], _enums_js__WEBPACK_IMPORTED_MODULE_1__["top"]].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === \'function\' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__["left"], _enums_js__WEBPACK_IMPORTED_MODULE_1__["right"]].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__["placements"].reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  name: \'offset\',\n  enabled: true,\n  phase: \'main\',\n  requires: [\'popperOffsets\'],\n  fn: offset\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/offset.js?')},"./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":function node_modulesPopperjsCoreLibModifiersPopperOffsetsJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ \"./node_modules/@popperjs/core/lib/utils/computeOffsets.js\");\n\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = Object(_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js?")},"./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":function node_modulesPopperjsCoreLibModifiersPreventOverflowJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");\n/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getAltAxis.js */ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js");\n/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");\n/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");\n/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = Object(_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.placement);\n  var variation = Object(_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_8__["default"])(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = Object(_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(basePlacement);\n  var altAxis = Object(_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_3__["default"])(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === \'function\' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis || checkAltAxis) {\n    var mainSide = mainAxis === \'y\' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__["top"] : _enums_js__WEBPACK_IMPORTED_MODULE_0__["left"];\n    var altSide = mainAxis === \'y\' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__["bottom"] : _enums_js__WEBPACK_IMPORTED_MODULE_0__["right"];\n    var len = mainAxis === \'y\' ? \'height\' : \'width\';\n    var offset = popperOffsets[mainAxis];\n    var min = popperOffsets[mainAxis] + overflow[mainSide];\n    var max = popperOffsets[mainAxis] - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__["start"] ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__["start"] ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn\'t go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? Object(_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData[\'arrow#persistent\'] ? state.modifiersData[\'arrow#persistent\'].padding : Object(_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_9__["default"])();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don\'t want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = Object(_utils_within_js__WEBPACK_IMPORTED_MODULE_4__["default"])(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    var arrowOffsetParent = state.elements.arrow && Object(_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === \'y\' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n\n    if (checkMainAxis) {\n      var preventedOffset = Object(_utils_within_js__WEBPACK_IMPORTED_MODULE_4__["default"])(tether ? Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_10__["min"])(min, tetherMin) : min, offset, tether ? Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_10__["max"])(max, tetherMax) : max);\n      popperOffsets[mainAxis] = preventedOffset;\n      data[mainAxis] = preventedOffset - offset;\n    }\n\n    if (checkAltAxis) {\n      var _mainSide = mainAxis === \'x\' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__["top"] : _enums_js__WEBPACK_IMPORTED_MODULE_0__["left"];\n\n      var _altSide = mainAxis === \'x\' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__["bottom"] : _enums_js__WEBPACK_IMPORTED_MODULE_0__["right"];\n\n      var _offset = popperOffsets[altAxis];\n\n      var _min = _offset + overflow[_mainSide];\n\n      var _max = _offset - overflow[_altSide];\n\n      var _preventedOffset = Object(_utils_within_js__WEBPACK_IMPORTED_MODULE_4__["default"])(tether ? Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_10__["min"])(_min, tetherMin) : _min, _offset, tether ? Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_10__["max"])(_max, tetherMax) : _max);\n\n      popperOffsets[altAxis] = _preventedOffset;\n      data[altAxis] = _preventedOffset - _offset;\n    }\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  name: \'preventOverflow\',\n  enabled: true,\n  phase: \'main\',\n  fn: preventOverflow,\n  requiresIfExists: [\'offset\']\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js?')},"./node_modules/@popperjs/core/lib/popper-lite.js":function node_modulesPopperjsCoreLibPopperLiteJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPopper", function() { return createPopper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultModifiers", function() { return defaultModifiers; });\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popperGenerator", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_0__["popperGenerator"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectOverflow", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_0__["detectOverflow"]; });\n\n/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");\n/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");\n/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");\n/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");\n\n\n\n\n\nvar defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_4__["default"]];\nvar createPopper = /*#__PURE__*/Object(_createPopper_js__WEBPACK_IMPORTED_MODULE_0__["popperGenerator"])({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/popper-lite.js?')},"./node_modules/@popperjs/core/lib/popper.js":function node_modulesPopperjsCoreLibPopperJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPopper", function() { return createPopper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultModifiers", function() { return defaultModifiers; });\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popperGenerator", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_0__["popperGenerator"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectOverflow", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_0__["detectOverflow"]; });\n\n/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");\n/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");\n/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");\n/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");\n/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");\n/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");\n/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");\n/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");\n/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modifiers/hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");\n/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPopperLite", function() { return _popper_lite_js__WEBPACK_IMPORTED_MODULE_10__["createPopper"]; });\n\n/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyStyles", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["applyStyles"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "arrow", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["arrow"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeStyles", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["computeStyles"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eventListeners", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["eventListeners"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flip", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["flip"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hide", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["hide"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "offset", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["offset"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popperOffsets", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["popperOffsets"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "preventOverflow", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["preventOverflow"]; });\n\n\n\n\n\n\n\n\n\n\n\nvar defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_8__["default"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_9__["default"]];\nvar createPopper = /*#__PURE__*/Object(_createPopper_js__WEBPACK_IMPORTED_MODULE_0__["popperGenerator"])({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/popper.js?')},"./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":function node_modulesPopperjsCoreLibUtilsComputeAutoPlacementJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return computeAutoPlacement; });\n/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");\n/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n\n\n\n\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_1__["placements"] : _options$allowedAutoP;\n  var variation = Object(_getVariation_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);\n  var placements = variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_1__["variationPlacements"] : _enums_js__WEBPACK_IMPORTED_MODULE_1__["variationPlacements"].filter(function (placement) {\n    return Object(_getVariation_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === variation;\n  }) : _enums_js__WEBPACK_IMPORTED_MODULE_1__["basePlacements"];\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n\n    if (true) {\n      console.error([\'Popper: The `allowedAutoPlacements` option did not allow any\', \'placements. Ensure the `placement` option matches the variation\', \'of the allowed placements.\', \'For example, "auto" cannot be used to allow "bottom-start".\', \'Use "auto-start" instead.\'].join(\' \'));\n    }\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = Object(_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[Object(_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js?')},"./node_modules/@popperjs/core/lib/utils/computeOffsets.js":function node_modulesPopperjsCoreLibUtilsComputeOffsetsJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return computeOffsets; });\n/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");\n/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n\n\n\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? Object(_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) : null;\n  var variation = placement ? Object(_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case _enums_js__WEBPACK_IMPORTED_MODULE_3__["top"]:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_3__["bottom"]:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_3__["right"]:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_3__["left"]:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? Object(_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === \'y\' ? \'height\' : \'width\';\n\n    switch (variation) {\n      case _enums_js__WEBPACK_IMPORTED_MODULE_3__["start"]:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case _enums_js__WEBPACK_IMPORTED_MODULE_3__["end"]:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/computeOffsets.js?')},"./node_modules/@popperjs/core/lib/utils/debounce.js":function node_modulesPopperjsCoreLibUtilsDebounceJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return debounce; });\nfunction debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/debounce.js?')},"./node_modules/@popperjs/core/lib/utils/detectOverflow.js":function node_modulesPopperjsCoreLibUtilsDetectOverflowJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return detectOverflow; });\n/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");\n/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js");\n/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");\n/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");\n/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["clippingParents"] : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["viewport"] : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"] : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = Object(_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])(typeof padding !== \'number\' ? padding : Object(_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_8__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_5__["basePlacements"]));\n  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"] ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["reference"] : _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"];\n  var referenceElement = state.elements.reference;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = Object(_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__["isElement"])(element) ? element : element.contextElement || Object(_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = Object(_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(referenceElement);\n  var popperOffsets = Object(_computeOffsets_js__WEBPACK_IMPORTED_MODULE_3__["default"])({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: \'absolute\',\n    placement: placement\n  });\n  var popperClientRect = Object(_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_4__["default"])(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"] ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"] && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_5__["right"], _enums_js__WEBPACK_IMPORTED_MODULE_5__["bottom"]].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_5__["top"], _enums_js__WEBPACK_IMPORTED_MODULE_5__["bottom"]].indexOf(key) >= 0 ? \'y\' : \'x\';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/detectOverflow.js?')},"./node_modules/@popperjs/core/lib/utils/expandToHashMap.js":function node_modulesPopperjsCoreLibUtilsExpandToHashMapJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return expandToHashMap; });\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/expandToHashMap.js?')},"./node_modules/@popperjs/core/lib/utils/format.js":function node_modulesPopperjsCoreLibUtilsFormatJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return format; });\nfunction format(str) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return [].concat(args).reduce(function (p, c) {\n    return p.replace(/%s/, c);\n  }, str);\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/format.js?')},"./node_modules/@popperjs/core/lib/utils/getAltAxis.js":function node_modulesPopperjsCoreLibUtilsGetAltAxisJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getAltAxis; });\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getAltAxis.js?")},"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js":function node_modulesPopperjsCoreLibUtilsGetBasePlacementJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getBasePlacement; });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n\nfunction getBasePlacement(placement) {\n  return placement.split(\'-\')[0];\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getBasePlacement.js?')},"./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":function node_modulesPopperjsCoreLibUtilsGetFreshSideObjectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getFreshSideObject; });\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js?')},"./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":function node_modulesPopperjsCoreLibUtilsGetMainAxisFromPlacementJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getMainAxisFromPlacement; });\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js?")},"./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":function node_modulesPopperjsCoreLibUtilsGetOppositePlacementJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getOppositePlacement; });\nvar hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js?")},"./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":function node_modulesPopperjsCoreLibUtilsGetOppositeVariationPlacementJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getOppositeVariationPlacement; });\nvar hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js?")},"./node_modules/@popperjs/core/lib/utils/getVariation.js":function node_modulesPopperjsCoreLibUtilsGetVariationJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getVariation; });\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getVariation.js?")},"./node_modules/@popperjs/core/lib/utils/math.js":function node_modulesPopperjsCoreLibUtilsMathJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/math.js?')},"./node_modules/@popperjs/core/lib/utils/mergeByName.js":function node_modulesPopperjsCoreLibUtilsMergeByNameJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mergeByName; });\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/mergeByName.js?')},"./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":function node_modulesPopperjsCoreLibUtilsMergePaddingObjectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mergePaddingObject; });\n/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, Object(_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(), paddingObject);\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js?')},"./node_modules/@popperjs/core/lib/utils/orderModifiers.js":function node_modulesPopperjsCoreLibUtilsOrderModifiersJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return orderModifiers; });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return _enums_js__WEBPACK_IMPORTED_MODULE_0__["modifierPhases"].reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/orderModifiers.js?')},"./node_modules/@popperjs/core/lib/utils/rectToClientRect.js":function node_modulesPopperjsCoreLibUtilsRectToClientRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return rectToClientRect; });\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/rectToClientRect.js?')},"./node_modules/@popperjs/core/lib/utils/uniqueBy.js":function node_modulesPopperjsCoreLibUtilsUniqueByJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return uniqueBy; });\nfunction uniqueBy(arr, fn) {\n  var identifiers = new Set();\n  return arr.filter(function (item) {\n    var identifier = fn(item);\n\n    if (!identifiers.has(identifier)) {\n      identifiers.add(identifier);\n      return true;\n    }\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/uniqueBy.js?')},"./node_modules/@popperjs/core/lib/utils/validateModifiers.js":function node_modulesPopperjsCoreLibUtilsValidateModifiersJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return validateModifiers; });\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format.js */ "./node_modules/@popperjs/core/lib/utils/format.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n\n\nvar INVALID_MODIFIER_ERROR = \'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s\';\nvar MISSING_DEPENDENCY_ERROR = \'Popper: modifier "%s" requires "%s", but "%s" modifier is not available\';\nvar VALID_PROPERTIES = [\'name\', \'enabled\', \'phase\', \'fn\', \'effect\', \'requires\', \'options\'];\nfunction validateModifiers(modifiers) {\n  modifiers.forEach(function (modifier) {\n    Object.keys(modifier).forEach(function (key) {\n      switch (key) {\n        case \'name\':\n          if (typeof modifier.name !== \'string\') {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, String(modifier.name), \'"name"\', \'"string"\', "\\"" + String(modifier.name) + "\\""));\n          }\n\n          break;\n\n        case \'enabled\':\n          if (typeof modifier.enabled !== \'boolean\') {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, \'"enabled"\', \'"boolean"\', "\\"" + String(modifier.enabled) + "\\""));\n          }\n\n        case \'phase\':\n          if (_enums_js__WEBPACK_IMPORTED_MODULE_1__["modifierPhases"].indexOf(modifier.phase) < 0) {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, \'"phase"\', "either " + _enums_js__WEBPACK_IMPORTED_MODULE_1__["modifierPhases"].join(\', \'), "\\"" + String(modifier.phase) + "\\""));\n          }\n\n          break;\n\n        case \'fn\':\n          if (typeof modifier.fn !== \'function\') {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, \'"fn"\', \'"function"\', "\\"" + String(modifier.fn) + "\\""));\n          }\n\n          break;\n\n        case \'effect\':\n          if (typeof modifier.effect !== \'function\') {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, \'"effect"\', \'"function"\', "\\"" + String(modifier.fn) + "\\""));\n          }\n\n          break;\n\n        case \'requires\':\n          if (!Array.isArray(modifier.requires)) {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, \'"requires"\', \'"array"\', "\\"" + String(modifier.requires) + "\\""));\n          }\n\n          break;\n\n        case \'requiresIfExists\':\n          if (!Array.isArray(modifier.requiresIfExists)) {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, \'"requiresIfExists"\', \'"array"\', "\\"" + String(modifier.requiresIfExists) + "\\""));\n          }\n\n          break;\n\n        case \'options\':\n        case \'data\':\n          break;\n\n        default:\n          console.error("PopperJS: an invalid property has been provided to the \\"" + modifier.name + "\\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {\n            return "\\"" + s + "\\"";\n          }).join(\', \') + "; but \\"" + key + "\\" was provided.");\n      }\n\n      modifier.requires && modifier.requires.forEach(function (requirement) {\n        if (modifiers.find(function (mod) {\n          return mod.name === requirement;\n        }) == null) {\n          console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));\n        }\n      });\n    });\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/validateModifiers.js?')},"./node_modules/@popperjs/core/lib/utils/within.js":function node_modulesPopperjsCoreLibUtilsWithinJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return within; });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");\n\nfunction within(min, value, max) {\n  return Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["max"])(min, Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["min"])(value, max));\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/within.js?')},"./node_modules/bootstrap/dist/js/bootstrap.esm.js":function node_modulesBootstrapDistJsBootstrapEsmJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Alert\", function() { return Alert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Button\", function() { return Button; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Carousel\", function() { return Carousel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Collapse\", function() { return Collapse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dropdown\", function() { return Dropdown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Modal\", function() { return Modal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Offcanvas\", function() { return Offcanvas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Popover\", function() { return Popover; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollSpy\", function() { return ScrollSpy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tab\", function() { return Tab; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Toast\", function() { return Toast; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tooltip\", function() { return Tooltip; });\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ \"./node_modules/@popperjs/core/lib/index.js\");\n/*!\n  * Bootstrap v5.0.1 (https://getbootstrap.com/)\n  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): dom/selector-engine.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\nconst NODE_TEXT = 3;\nconst SelectorEngine = {\n  find(selector, element = document.documentElement) {\n    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\n  },\n\n  findOne(selector, element = document.documentElement) {\n    return Element.prototype.querySelector.call(element, selector);\n  },\n\n  children(element, selector) {\n    return [].concat(...element.children).filter(child => child.matches(selector));\n  },\n\n  parents(element, selector) {\n    const parents = [];\n    let ancestor = element.parentNode;\n\n    while (ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT) {\n      if (ancestor.matches(selector)) {\n        parents.push(ancestor);\n      }\n\n      ancestor = ancestor.parentNode;\n    }\n\n    return parents;\n  },\n\n  prev(element, selector) {\n    let previous = element.previousElementSibling;\n\n    while (previous) {\n      if (previous.matches(selector)) {\n        return [previous];\n      }\n\n      previous = previous.previousElementSibling;\n    }\n\n    return [];\n  },\n\n  next(element, selector) {\n    let next = element.nextElementSibling;\n\n    while (next) {\n      if (next.matches(selector)) {\n        return [next];\n      }\n\n      next = next.nextElementSibling;\n    }\n\n    return [];\n  }\n\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): util/index.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nconst MAX_UID = 1000000;\nconst MILLISECONDS_MULTIPLIER = 1000;\nconst TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\nconst toType = obj => {\n  if (obj === null || obj === undefined) {\n    return `${obj}`;\n  }\n\n  return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n};\n/**\n * --------------------------------------------------------------------------\n * Public Util Api\n * --------------------------------------------------------------------------\n */\n\n\nconst getUID = prefix => {\n  do {\n    prefix += Math.floor(Math.random() * MAX_UID);\n  } while (document.getElementById(prefix));\n\n  return prefix;\n};\n\nconst getSelector = element => {\n  let selector = element.getAttribute('data-bs-target');\n\n  if (!selector || selector === '#') {\n    let hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,\n    // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n    // `document.querySelector` will rightfully complain it is invalid.\n    // See https://github.com/twbs/bootstrap/issues/32273\n\n    if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {\n      return null;\n    } // Just in case some CMS puts out a full URL with the anchor appended\n\n\n    if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {\n      hrefAttr = `#${hrefAttr.split('#')[1]}`;\n    }\n\n    selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;\n  }\n\n  return selector;\n};\n\nconst getSelectorFromElement = element => {\n  const selector = getSelector(element);\n\n  if (selector) {\n    return document.querySelector(selector) ? selector : null;\n  }\n\n  return null;\n};\n\nconst getElementFromSelector = element => {\n  const selector = getSelector(element);\n  return selector ? document.querySelector(selector) : null;\n};\n\nconst getTransitionDurationFromElement = element => {\n  if (!element) {\n    return 0;\n  } // Get transition-duration of the element\n\n\n  let {\n    transitionDuration,\n    transitionDelay\n  } = window.getComputedStyle(element);\n  const floatTransitionDuration = Number.parseFloat(transitionDuration);\n  const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\n\n  if (!floatTransitionDuration && !floatTransitionDelay) {\n    return 0;\n  } // If multiple durations are defined, take the first\n\n\n  transitionDuration = transitionDuration.split(',')[0];\n  transitionDelay = transitionDelay.split(',')[0];\n  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n};\n\nconst triggerTransitionEnd = element => {\n  element.dispatchEvent(new Event(TRANSITION_END));\n};\n\nconst isElement = obj => {\n  if (!obj || typeof obj !== 'object') {\n    return false;\n  }\n\n  if (typeof obj.jquery !== 'undefined') {\n    obj = obj[0];\n  }\n\n  return typeof obj.nodeType !== 'undefined';\n};\n\nconst getElement = obj => {\n  if (isElement(obj)) {\n    // it's a jQuery object or a node element\n    return obj.jquery ? obj[0] : obj;\n  }\n\n  if (typeof obj === 'string' && obj.length > 0) {\n    return SelectorEngine.findOne(obj);\n  }\n\n  return null;\n};\n\nconst emulateTransitionEnd = (element, duration) => {\n  let called = false;\n  const durationPadding = 5;\n  const emulatedDuration = duration + durationPadding;\n\n  function listener() {\n    called = true;\n    element.removeEventListener(TRANSITION_END, listener);\n  }\n\n  element.addEventListener(TRANSITION_END, listener);\n  setTimeout(() => {\n    if (!called) {\n      triggerTransitionEnd(element);\n    }\n  }, emulatedDuration);\n};\n\nconst typeCheckConfig = (componentName, config, configTypes) => {\n  Object.keys(configTypes).forEach(property => {\n    const expectedTypes = configTypes[property];\n    const value = config[property];\n    const valueType = value && isElement(value) ? 'element' : toType(value);\n\n    if (!new RegExp(expectedTypes).test(valueType)) {\n      throw new TypeError(`${componentName.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\n    }\n  });\n};\n\nconst isVisible = element => {\n  if (!element) {\n    return false;\n  }\n\n  if (element.style && element.parentNode && element.parentNode.style) {\n    const elementStyle = getComputedStyle(element);\n    const parentNodeStyle = getComputedStyle(element.parentNode);\n    return elementStyle.display !== 'none' && parentNodeStyle.display !== 'none' && elementStyle.visibility !== 'hidden';\n  }\n\n  return false;\n};\n\nconst isDisabled = element => {\n  if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n    return true;\n  }\n\n  if (element.classList.contains('disabled')) {\n    return true;\n  }\n\n  if (typeof element.disabled !== 'undefined') {\n    return element.disabled;\n  }\n\n  return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';\n};\n\nconst findShadowRoot = element => {\n  if (!document.documentElement.attachShadow) {\n    return null;\n  } // Can find the shadow root otherwise it'll return the document\n\n\n  if (typeof element.getRootNode === 'function') {\n    const root = element.getRootNode();\n    return root instanceof ShadowRoot ? root : null;\n  }\n\n  if (element instanceof ShadowRoot) {\n    return element;\n  } // when we don't find a shadow root\n\n\n  if (!element.parentNode) {\n    return null;\n  }\n\n  return findShadowRoot(element.parentNode);\n};\n\nconst noop = () => {};\n\nconst reflow = element => element.offsetHeight;\n\nconst getjQuery = () => {\n  const {\n    jQuery\n  } = window;\n\n  if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\n    return jQuery;\n  }\n\n  return null;\n};\n\nconst onDOMContentLoaded = callback => {\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', callback);\n  } else {\n    callback();\n  }\n};\n\nconst isRTL = () => document.documentElement.dir === 'rtl';\n\nconst defineJQueryPlugin = plugin => {\n  onDOMContentLoaded(() => {\n    const $ = getjQuery();\n    /* istanbul ignore if */\n\n    if ($) {\n      const name = plugin.NAME;\n      const JQUERY_NO_CONFLICT = $.fn[name];\n      $.fn[name] = plugin.jQueryInterface;\n      $.fn[name].Constructor = plugin;\n\n      $.fn[name].noConflict = () => {\n        $.fn[name] = JQUERY_NO_CONFLICT;\n        return plugin.jQueryInterface;\n      };\n    }\n  });\n};\n\nconst execute = callback => {\n  if (typeof callback === 'function') {\n    callback();\n  }\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): dom/data.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\nconst elementMap = new Map();\nvar Data = {\n  set(element, key, instance) {\n    if (!elementMap.has(element)) {\n      elementMap.set(element, new Map());\n    }\n\n    const instanceMap = elementMap.get(element); // make it clear we only want one instance per element\n    // can be removed later when multiple key/instances are fine to be used\n\n    if (!instanceMap.has(key) && instanceMap.size !== 0) {\n      // eslint-disable-next-line no-console\n      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);\n      return;\n    }\n\n    instanceMap.set(key, instance);\n  },\n\n  get(element, key) {\n    if (elementMap.has(element)) {\n      return elementMap.get(element).get(key) || null;\n    }\n\n    return null;\n  },\n\n  remove(element, key) {\n    if (!elementMap.has(element)) {\n      return;\n    }\n\n    const instanceMap = elementMap.get(element);\n    instanceMap.delete(key); // free up element references if there are no instances left for an element\n\n    if (instanceMap.size === 0) {\n      elementMap.delete(element);\n    }\n  }\n\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): dom/event-handler.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\nconst stripNameRegex = /\\..*/;\nconst stripUidRegex = /::\\d+$/;\nconst eventRegistry = {}; // Events storage\n\nlet uidEvent = 1;\nconst customEvents = {\n  mouseenter: 'mouseover',\n  mouseleave: 'mouseout'\n};\nconst customEventsRegex = /^(mouseenter|mouseleave)/i;\nconst nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);\n/**\n * ------------------------------------------------------------------------\n * Private methods\n * ------------------------------------------------------------------------\n */\n\nfunction getUidEvent(element, uid) {\n  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;\n}\n\nfunction getEvent(element) {\n  const uid = getUidEvent(element);\n  element.uidEvent = uid;\n  eventRegistry[uid] = eventRegistry[uid] || {};\n  return eventRegistry[uid];\n}\n\nfunction bootstrapHandler(element, fn) {\n  return function handler(event) {\n    event.delegateTarget = element;\n\n    if (handler.oneOff) {\n      EventHandler.off(element, event.type, fn);\n    }\n\n    return fn.apply(element, [event]);\n  };\n}\n\nfunction bootstrapDelegationHandler(element, selector, fn) {\n  return function handler(event) {\n    const domElements = element.querySelectorAll(selector);\n\n    for (let {\n      target\n    } = event; target && target !== this; target = target.parentNode) {\n      for (let i = domElements.length; i--;) {\n        if (domElements[i] === target) {\n          event.delegateTarget = target;\n\n          if (handler.oneOff) {\n            // eslint-disable-next-line unicorn/consistent-destructuring\n            EventHandler.off(element, event.type, selector, fn);\n          }\n\n          return fn.apply(target, [event]);\n        }\n      }\n    } // To please ESLint\n\n\n    return null;\n  };\n}\n\nfunction findHandler(events, handler, delegationSelector = null) {\n  const uidEventList = Object.keys(events);\n\n  for (let i = 0, len = uidEventList.length; i < len; i++) {\n    const event = events[uidEventList[i]];\n\n    if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {\n      return event;\n    }\n  }\n\n  return null;\n}\n\nfunction normalizeParams(originalTypeEvent, handler, delegationFn) {\n  const delegation = typeof handler === 'string';\n  const originalHandler = delegation ? delegationFn : handler;\n  let typeEvent = getTypeEvent(originalTypeEvent);\n  const isNative = nativeEvents.has(typeEvent);\n\n  if (!isNative) {\n    typeEvent = originalTypeEvent;\n  }\n\n  return [delegation, originalHandler, typeEvent];\n}\n\nfunction addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {\n  if (typeof originalTypeEvent !== 'string' || !element) {\n    return;\n  }\n\n  if (!handler) {\n    handler = delegationFn;\n    delegationFn = null;\n  } // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\n  // this prevents the handler from being dispatched the same way as mouseover or mouseout does\n\n\n  if (customEventsRegex.test(originalTypeEvent)) {\n    const wrapFn = fn => {\n      return function (event) {\n        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n          return fn.call(this, event);\n        }\n      };\n    };\n\n    if (delegationFn) {\n      delegationFn = wrapFn(delegationFn);\n    } else {\n      handler = wrapFn(handler);\n    }\n  }\n\n  const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);\n  const events = getEvent(element);\n  const handlers = events[typeEvent] || (events[typeEvent] = {});\n  const previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);\n\n  if (previousFn) {\n    previousFn.oneOff = previousFn.oneOff && oneOff;\n    return;\n  }\n\n  const uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, ''));\n  const fn = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler);\n  fn.delegationSelector = delegation ? handler : null;\n  fn.originalHandler = originalHandler;\n  fn.oneOff = oneOff;\n  fn.uidEvent = uid;\n  handlers[uid] = fn;\n  element.addEventListener(typeEvent, fn, delegation);\n}\n\nfunction removeHandler(element, events, typeEvent, handler, delegationSelector) {\n  const fn = findHandler(events[typeEvent], handler, delegationSelector);\n\n  if (!fn) {\n    return;\n  }\n\n  element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\n  delete events[typeEvent][fn.uidEvent];\n}\n\nfunction removeNamespacedHandlers(element, events, typeEvent, namespace) {\n  const storeElementEvent = events[typeEvent] || {};\n  Object.keys(storeElementEvent).forEach(handlerKey => {\n    if (handlerKey.includes(namespace)) {\n      const event = storeElementEvent[handlerKey];\n      removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);\n    }\n  });\n}\n\nfunction getTypeEvent(event) {\n  // allow to get the native events from namespaced events ('click.bs.button' --\x3e 'click')\n  event = event.replace(stripNameRegex, '');\n  return customEvents[event] || event;\n}\n\nconst EventHandler = {\n  on(element, event, handler, delegationFn) {\n    addHandler(element, event, handler, delegationFn, false);\n  },\n\n  one(element, event, handler, delegationFn) {\n    addHandler(element, event, handler, delegationFn, true);\n  },\n\n  off(element, originalTypeEvent, handler, delegationFn) {\n    if (typeof originalTypeEvent !== 'string' || !element) {\n      return;\n    }\n\n    const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);\n    const inNamespace = typeEvent !== originalTypeEvent;\n    const events = getEvent(element);\n    const isNamespace = originalTypeEvent.startsWith('.');\n\n    if (typeof originalHandler !== 'undefined') {\n      // Simplest case: handler is passed, remove that listener ONLY.\n      if (!events || !events[typeEvent]) {\n        return;\n      }\n\n      removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null);\n      return;\n    }\n\n    if (isNamespace) {\n      Object.keys(events).forEach(elementEvent => {\n        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\n      });\n    }\n\n    const storeElementEvent = events[typeEvent] || {};\n    Object.keys(storeElementEvent).forEach(keyHandlers => {\n      const handlerKey = keyHandlers.replace(stripUidRegex, '');\n\n      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n        const event = storeElementEvent[keyHandlers];\n        removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);\n      }\n    });\n  },\n\n  trigger(element, event, args) {\n    if (typeof event !== 'string' || !element) {\n      return null;\n    }\n\n    const $ = getjQuery();\n    const typeEvent = getTypeEvent(event);\n    const inNamespace = event !== typeEvent;\n    const isNative = nativeEvents.has(typeEvent);\n    let jQueryEvent;\n    let bubbles = true;\n    let nativeDispatch = true;\n    let defaultPrevented = false;\n    let evt = null;\n\n    if (inNamespace && $) {\n      jQueryEvent = $.Event(event, args);\n      $(element).trigger(jQueryEvent);\n      bubbles = !jQueryEvent.isPropagationStopped();\n      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n      defaultPrevented = jQueryEvent.isDefaultPrevented();\n    }\n\n    if (isNative) {\n      evt = document.createEvent('HTMLEvents');\n      evt.initEvent(typeEvent, bubbles, true);\n    } else {\n      evt = new CustomEvent(event, {\n        bubbles,\n        cancelable: true\n      });\n    } // merge custom information in our event\n\n\n    if (typeof args !== 'undefined') {\n      Object.keys(args).forEach(key => {\n        Object.defineProperty(evt, key, {\n          get() {\n            return args[key];\n          }\n\n        });\n      });\n    }\n\n    if (defaultPrevented) {\n      evt.preventDefault();\n    }\n\n    if (nativeDispatch) {\n      element.dispatchEvent(evt);\n    }\n\n    if (evt.defaultPrevented && typeof jQueryEvent !== 'undefined') {\n      jQueryEvent.preventDefault();\n    }\n\n    return evt;\n  }\n\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): base-component.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst VERSION = '5.0.1';\n\nclass BaseComponent {\n  constructor(element) {\n    element = getElement(element);\n\n    if (!element) {\n      return;\n    }\n\n    this._element = element;\n    Data.set(this._element, this.constructor.DATA_KEY, this);\n  }\n\n  dispose() {\n    Data.remove(this._element, this.constructor.DATA_KEY);\n    EventHandler.off(this._element, this.constructor.EVENT_KEY);\n    Object.getOwnPropertyNames(this).forEach(propertyName => {\n      this[propertyName] = null;\n    });\n  }\n\n  _queueCallback(callback, element, isAnimated = true) {\n    if (!isAnimated) {\n      execute(callback);\n      return;\n    }\n\n    const transitionDuration = getTransitionDurationFromElement(element);\n    EventHandler.one(element, 'transitionend', () => execute(callback));\n    emulateTransitionEnd(element, transitionDuration);\n  }\n  /** Static */\n\n\n  static getInstance(element) {\n    return Data.get(element, this.DATA_KEY);\n  }\n\n  static get VERSION() {\n    return VERSION;\n  }\n\n  static get NAME() {\n    throw new Error('You have to implement the static method \"NAME\", for each component!');\n  }\n\n  static get DATA_KEY() {\n    return `bs.${this.NAME}`;\n  }\n\n  static get EVENT_KEY() {\n    return `.${this.DATA_KEY}`;\n  }\n\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): alert.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$c = 'alert';\nconst DATA_KEY$b = 'bs.alert';\nconst EVENT_KEY$b = `.${DATA_KEY$b}`;\nconst DATA_API_KEY$8 = '.data-api';\nconst SELECTOR_DISMISS = '[data-bs-dismiss=\"alert\"]';\nconst EVENT_CLOSE = `close${EVENT_KEY$b}`;\nconst EVENT_CLOSED = `closed${EVENT_KEY$b}`;\nconst EVENT_CLICK_DATA_API$7 = `click${EVENT_KEY$b}${DATA_API_KEY$8}`;\nconst CLASS_NAME_ALERT = 'alert';\nconst CLASS_NAME_FADE$6 = 'fade';\nconst CLASS_NAME_SHOW$9 = 'show';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Alert extends BaseComponent {\n  // Getters\n  static get NAME() {\n    return NAME$c;\n  } // Public\n\n\n  close(element) {\n    const rootElement = element ? this._getRootElement(element) : this._element;\n\n    const customEvent = this._triggerCloseEvent(rootElement);\n\n    if (customEvent === null || customEvent.defaultPrevented) {\n      return;\n    }\n\n    this._removeElement(rootElement);\n  } // Private\n\n\n  _getRootElement(element) {\n    return getElementFromSelector(element) || element.closest(`.${CLASS_NAME_ALERT}`);\n  }\n\n  _triggerCloseEvent(element) {\n    return EventHandler.trigger(element, EVENT_CLOSE);\n  }\n\n  _removeElement(element) {\n    element.classList.remove(CLASS_NAME_SHOW$9);\n    const isAnimated = element.classList.contains(CLASS_NAME_FADE$6);\n\n    this._queueCallback(() => this._destroyElement(element), element, isAnimated);\n  }\n\n  _destroyElement(element) {\n    if (element.parentNode) {\n      element.parentNode.removeChild(element);\n    }\n\n    EventHandler.trigger(element, EVENT_CLOSED);\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      let data = Data.get(this, DATA_KEY$b);\n\n      if (!data) {\n        data = new Alert(this);\n      }\n\n      if (config === 'close') {\n        data[config](this);\n      }\n    });\n  }\n\n  static handleDismiss(alertInstance) {\n    return function (event) {\n      if (event) {\n        event.preventDefault();\n      }\n\n      alertInstance.close(this);\n    };\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$7, SELECTOR_DISMISS, Alert.handleDismiss(new Alert()));\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Alert to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Alert);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): button.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$b = 'button';\nconst DATA_KEY$a = 'bs.button';\nconst EVENT_KEY$a = `.${DATA_KEY$a}`;\nconst DATA_API_KEY$7 = '.data-api';\nconst CLASS_NAME_ACTIVE$3 = 'active';\nconst SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\nconst EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$7}`;\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Button extends BaseComponent {\n  // Getters\n  static get NAME() {\n    return NAME$b;\n  } // Public\n\n\n  toggle() {\n    // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\n    this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      let data = Data.get(this, DATA_KEY$a);\n\n      if (!data) {\n        data = new Button(this);\n      }\n\n      if (config === 'toggle') {\n        data[config]();\n      }\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {\n  event.preventDefault();\n  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\n  let data = Data.get(button, DATA_KEY$a);\n\n  if (!data) {\n    data = new Button(button);\n  }\n\n  data.toggle();\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Button to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Button);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): dom/manipulator.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\nfunction normalizeData(val) {\n  if (val === 'true') {\n    return true;\n  }\n\n  if (val === 'false') {\n    return false;\n  }\n\n  if (val === Number(val).toString()) {\n    return Number(val);\n  }\n\n  if (val === '' || val === 'null') {\n    return null;\n  }\n\n  return val;\n}\n\nfunction normalizeDataKey(key) {\n  return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);\n}\n\nconst Manipulator = {\n  setDataAttribute(element, key, value) {\n    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);\n  },\n\n  removeDataAttribute(element, key) {\n    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);\n  },\n\n  getDataAttributes(element) {\n    if (!element) {\n      return {};\n    }\n\n    const attributes = {};\n    Object.keys(element.dataset).filter(key => key.startsWith('bs')).forEach(key => {\n      let pureKey = key.replace(/^bs/, '');\n      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\n      attributes[pureKey] = normalizeData(element.dataset[key]);\n    });\n    return attributes;\n  },\n\n  getDataAttribute(element, key) {\n    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));\n  },\n\n  offset(element) {\n    const rect = element.getBoundingClientRect();\n    return {\n      top: rect.top + document.body.scrollTop,\n      left: rect.left + document.body.scrollLeft\n    };\n  },\n\n  position(element) {\n    return {\n      top: element.offsetTop,\n      left: element.offsetLeft\n    };\n  }\n\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): carousel.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$a = 'carousel';\nconst DATA_KEY$9 = 'bs.carousel';\nconst EVENT_KEY$9 = `.${DATA_KEY$9}`;\nconst DATA_API_KEY$6 = '.data-api';\nconst ARROW_LEFT_KEY = 'ArrowLeft';\nconst ARROW_RIGHT_KEY = 'ArrowRight';\nconst TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\nconst SWIPE_THRESHOLD = 40;\nconst Default$9 = {\n  interval: 5000,\n  keyboard: true,\n  slide: false,\n  pause: 'hover',\n  wrap: true,\n  touch: true\n};\nconst DefaultType$9 = {\n  interval: '(number|boolean)',\n  keyboard: 'boolean',\n  slide: '(boolean|string)',\n  pause: '(string|boolean)',\n  wrap: 'boolean',\n  touch: 'boolean'\n};\nconst ORDER_NEXT = 'next';\nconst ORDER_PREV = 'prev';\nconst DIRECTION_LEFT = 'left';\nconst DIRECTION_RIGHT = 'right';\nconst EVENT_SLIDE = `slide${EVENT_KEY$9}`;\nconst EVENT_SLID = `slid${EVENT_KEY$9}`;\nconst EVENT_KEYDOWN = `keydown${EVENT_KEY$9}`;\nconst EVENT_MOUSEENTER = `mouseenter${EVENT_KEY$9}`;\nconst EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY$9}`;\nconst EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;\nconst EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;\nconst EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;\nconst EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;\nconst EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;\nconst EVENT_DRAG_START = `dragstart${EVENT_KEY$9}`;\nconst EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$9}${DATA_API_KEY$6}`;\nconst EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$9}${DATA_API_KEY$6}`;\nconst CLASS_NAME_CAROUSEL = 'carousel';\nconst CLASS_NAME_ACTIVE$2 = 'active';\nconst CLASS_NAME_SLIDE = 'slide';\nconst CLASS_NAME_END = 'carousel-item-end';\nconst CLASS_NAME_START = 'carousel-item-start';\nconst CLASS_NAME_NEXT = 'carousel-item-next';\nconst CLASS_NAME_PREV = 'carousel-item-prev';\nconst CLASS_NAME_POINTER_EVENT = 'pointer-event';\nconst SELECTOR_ACTIVE$1 = '.active';\nconst SELECTOR_ACTIVE_ITEM = '.active.carousel-item';\nconst SELECTOR_ITEM = '.carousel-item';\nconst SELECTOR_ITEM_IMG = '.carousel-item img';\nconst SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';\nconst SELECTOR_INDICATORS = '.carousel-indicators';\nconst SELECTOR_INDICATOR = '[data-bs-target]';\nconst SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\nconst SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\nconst POINTER_TYPE_TOUCH = 'touch';\nconst POINTER_TYPE_PEN = 'pen';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Carousel extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._items = null;\n    this._interval = null;\n    this._activeElement = null;\n    this._isPaused = false;\n    this._isSliding = false;\n    this.touchTimeout = null;\n    this.touchStartX = 0;\n    this.touchDeltaX = 0;\n    this._config = this._getConfig(config);\n    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\n    this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n    this._pointerEvent = Boolean(window.PointerEvent);\n\n    this._addEventListeners();\n  } // Getters\n\n\n  static get Default() {\n    return Default$9;\n  }\n\n  static get NAME() {\n    return NAME$a;\n  } // Public\n\n\n  next() {\n    if (!this._isSliding) {\n      this._slide(ORDER_NEXT);\n    }\n  }\n\n  nextWhenVisible() {\n    // Don't call next when the page isn't visible\n    // or the carousel or its parent isn't visible\n    if (!document.hidden && isVisible(this._element)) {\n      this.next();\n    }\n  }\n\n  prev() {\n    if (!this._isSliding) {\n      this._slide(ORDER_PREV);\n    }\n  }\n\n  pause(event) {\n    if (!event) {\n      this._isPaused = true;\n    }\n\n    if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) {\n      triggerTransitionEnd(this._element);\n      this.cycle(true);\n    }\n\n    clearInterval(this._interval);\n    this._interval = null;\n  }\n\n  cycle(event) {\n    if (!event) {\n      this._isPaused = false;\n    }\n\n    if (this._interval) {\n      clearInterval(this._interval);\n      this._interval = null;\n    }\n\n    if (this._config && this._config.interval && !this._isPaused) {\n      this._updateInterval();\n\n      this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\n    }\n  }\n\n  to(index) {\n    this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n\n    const activeIndex = this._getItemIndex(this._activeElement);\n\n    if (index > this._items.length - 1 || index < 0) {\n      return;\n    }\n\n    if (this._isSliding) {\n      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));\n      return;\n    }\n\n    if (activeIndex === index) {\n      this.pause();\n      this.cycle();\n      return;\n    }\n\n    const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n\n    this._slide(order, this._items[index]);\n  } // Private\n\n\n  _getConfig(config) {\n    config = { ...Default$9,\n      ...config\n    };\n    typeCheckConfig(NAME$a, config, DefaultType$9);\n    return config;\n  }\n\n  _handleSwipe() {\n    const absDeltax = Math.abs(this.touchDeltaX);\n\n    if (absDeltax <= SWIPE_THRESHOLD) {\n      return;\n    }\n\n    const direction = absDeltax / this.touchDeltaX;\n    this.touchDeltaX = 0;\n\n    if (!direction) {\n      return;\n    }\n\n    this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);\n  }\n\n  _addEventListeners() {\n    if (this._config.keyboard) {\n      EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));\n    }\n\n    if (this._config.pause === 'hover') {\n      EventHandler.on(this._element, EVENT_MOUSEENTER, event => this.pause(event));\n      EventHandler.on(this._element, EVENT_MOUSELEAVE, event => this.cycle(event));\n    }\n\n    if (this._config.touch && this._touchSupported) {\n      this._addTouchEventListeners();\n    }\n  }\n\n  _addTouchEventListeners() {\n    const start = event => {\n      if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {\n        this.touchStartX = event.clientX;\n      } else if (!this._pointerEvent) {\n        this.touchStartX = event.touches[0].clientX;\n      }\n    };\n\n    const move = event => {\n      // ensure swiping with one touch and not pinching\n      this.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this.touchStartX;\n    };\n\n    const end = event => {\n      if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {\n        this.touchDeltaX = event.clientX - this.touchStartX;\n      }\n\n      this._handleSwipe();\n\n      if (this._config.pause === 'hover') {\n        // If it's a touch-enabled device, mouseenter/leave are fired as\n        // part of the mouse compatibility events on first tap - the carousel\n        // would stop cycling until user tapped out of it;\n        // here, we listen for touchend, explicitly pause the carousel\n        // (as if it's the second time we tap on it, mouseenter compat event\n        // is NOT fired) and after a timeout (to allow for mouse compatibility\n        // events to fire) we explicitly restart cycling\n        this.pause();\n\n        if (this.touchTimeout) {\n          clearTimeout(this.touchTimeout);\n        }\n\n        this.touchTimeout = setTimeout(event => this.cycle(event), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\n      }\n    };\n\n    SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach(itemImg => {\n      EventHandler.on(itemImg, EVENT_DRAG_START, e => e.preventDefault());\n    });\n\n    if (this._pointerEvent) {\n      EventHandler.on(this._element, EVENT_POINTERDOWN, event => start(event));\n      EventHandler.on(this._element, EVENT_POINTERUP, event => end(event));\n\n      this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n    } else {\n      EventHandler.on(this._element, EVENT_TOUCHSTART, event => start(event));\n      EventHandler.on(this._element, EVENT_TOUCHMOVE, event => move(event));\n      EventHandler.on(this._element, EVENT_TOUCHEND, event => end(event));\n    }\n  }\n\n  _keydown(event) {\n    if (/input|textarea/i.test(event.target.tagName)) {\n      return;\n    }\n\n    if (event.key === ARROW_LEFT_KEY) {\n      event.preventDefault();\n\n      this._slide(DIRECTION_RIGHT);\n    } else if (event.key === ARROW_RIGHT_KEY) {\n      event.preventDefault();\n\n      this._slide(DIRECTION_LEFT);\n    }\n  }\n\n  _getItemIndex(element) {\n    this._items = element && element.parentNode ? SelectorEngine.find(SELECTOR_ITEM, element.parentNode) : [];\n    return this._items.indexOf(element);\n  }\n\n  _getItemByOrder(order, activeElement) {\n    const isNext = order === ORDER_NEXT;\n    const isPrev = order === ORDER_PREV;\n\n    const activeIndex = this._getItemIndex(activeElement);\n\n    const lastItemIndex = this._items.length - 1;\n    const isGoingToWrap = isPrev && activeIndex === 0 || isNext && activeIndex === lastItemIndex;\n\n    if (isGoingToWrap && !this._config.wrap) {\n      return activeElement;\n    }\n\n    const delta = isPrev ? -1 : 1;\n    const itemIndex = (activeIndex + delta) % this._items.length;\n    return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\n  }\n\n  _triggerSlideEvent(relatedTarget, eventDirectionName) {\n    const targetIndex = this._getItemIndex(relatedTarget);\n\n    const fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element));\n\n    return EventHandler.trigger(this._element, EVENT_SLIDE, {\n      relatedTarget,\n      direction: eventDirectionName,\n      from: fromIndex,\n      to: targetIndex\n    });\n  }\n\n  _setActiveIndicatorElement(element) {\n    if (this._indicatorsElement) {\n      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE$1, this._indicatorsElement);\n      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\n      activeIndicator.removeAttribute('aria-current');\n      const indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement);\n\n      for (let i = 0; i < indicators.length; i++) {\n        if (Number.parseInt(indicators[i].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(element)) {\n          indicators[i].classList.add(CLASS_NAME_ACTIVE$2);\n          indicators[i].setAttribute('aria-current', 'true');\n          break;\n        }\n      }\n    }\n  }\n\n  _updateInterval() {\n    const element = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n\n    if (!element) {\n      return;\n    }\n\n    const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\n\n    if (elementInterval) {\n      this._config.defaultInterval = this._config.defaultInterval || this._config.interval;\n      this._config.interval = elementInterval;\n    } else {\n      this._config.interval = this._config.defaultInterval || this._config.interval;\n    }\n  }\n\n  _slide(directionOrOrder, element) {\n    const order = this._directionToOrder(directionOrOrder);\n\n    const activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n\n    const activeElementIndex = this._getItemIndex(activeElement);\n\n    const nextElement = element || this._getItemByOrder(order, activeElement);\n\n    const nextElementIndex = this._getItemIndex(nextElement);\n\n    const isCycling = Boolean(this._interval);\n    const isNext = order === ORDER_NEXT;\n    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n\n    const eventDirectionName = this._orderToDirection(order);\n\n    if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE$2)) {\n      this._isSliding = false;\n      return;\n    }\n\n    const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\n\n    if (slideEvent.defaultPrevented) {\n      return;\n    }\n\n    if (!activeElement || !nextElement) {\n      // Some weirdness is happening, so we bail\n      return;\n    }\n\n    this._isSliding = true;\n\n    if (isCycling) {\n      this.pause();\n    }\n\n    this._setActiveIndicatorElement(nextElement);\n\n    this._activeElement = nextElement;\n\n    const triggerSlidEvent = () => {\n      EventHandler.trigger(this._element, EVENT_SLID, {\n        relatedTarget: nextElement,\n        direction: eventDirectionName,\n        from: activeElementIndex,\n        to: nextElementIndex\n      });\n    };\n\n    if (this._element.classList.contains(CLASS_NAME_SLIDE)) {\n      nextElement.classList.add(orderClassName);\n      reflow(nextElement);\n      activeElement.classList.add(directionalClassName);\n      nextElement.classList.add(directionalClassName);\n\n      const completeCallBack = () => {\n        nextElement.classList.remove(directionalClassName, orderClassName);\n        nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\n        this._isSliding = false;\n        setTimeout(triggerSlidEvent, 0);\n      };\n\n      this._queueCallback(completeCallBack, activeElement, true);\n    } else {\n      activeElement.classList.remove(CLASS_NAME_ACTIVE$2);\n      nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n      this._isSliding = false;\n      triggerSlidEvent();\n    }\n\n    if (isCycling) {\n      this.cycle();\n    }\n  }\n\n  _directionToOrder(direction) {\n    if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {\n      return direction;\n    }\n\n    if (isRTL()) {\n      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n    }\n\n    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n  }\n\n  _orderToDirection(order) {\n    if (![ORDER_NEXT, ORDER_PREV].includes(order)) {\n      return order;\n    }\n\n    if (isRTL()) {\n      return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n\n    return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n  } // Static\n\n\n  static carouselInterface(element, config) {\n    let data = Data.get(element, DATA_KEY$9);\n    let _config = { ...Default$9,\n      ...Manipulator.getDataAttributes(element)\n    };\n\n    if (typeof config === 'object') {\n      _config = { ..._config,\n        ...config\n      };\n    }\n\n    const action = typeof config === 'string' ? config : _config.slide;\n\n    if (!data) {\n      data = new Carousel(element, _config);\n    }\n\n    if (typeof config === 'number') {\n      data.to(config);\n    } else if (typeof action === 'string') {\n      if (typeof data[action] === 'undefined') {\n        throw new TypeError(`No method named \"${action}\"`);\n      }\n\n      data[action]();\n    } else if (_config.interval && _config.ride) {\n      data.pause();\n      data.cycle();\n    }\n  }\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      Carousel.carouselInterface(this, config);\n    });\n  }\n\n  static dataApiClickHandler(event) {\n    const target = getElementFromSelector(this);\n\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n      return;\n    }\n\n    const config = { ...Manipulator.getDataAttributes(target),\n      ...Manipulator.getDataAttributes(this)\n    };\n    const slideIndex = this.getAttribute('data-bs-slide-to');\n\n    if (slideIndex) {\n      config.interval = false;\n    }\n\n    Carousel.carouselInterface(target, config);\n\n    if (slideIndex) {\n      Data.get(target, DATA_KEY$9).to(slideIndex);\n    }\n\n    event.preventDefault();\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);\nEventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {\n  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n\n  for (let i = 0, len = carousels.length; i < len; i++) {\n    Carousel.carouselInterface(carousels[i], Data.get(carousels[i], DATA_KEY$9));\n  }\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Carousel to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Carousel);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): collapse.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$9 = 'collapse';\nconst DATA_KEY$8 = 'bs.collapse';\nconst EVENT_KEY$8 = `.${DATA_KEY$8}`;\nconst DATA_API_KEY$5 = '.data-api';\nconst Default$8 = {\n  toggle: true,\n  parent: ''\n};\nconst DefaultType$8 = {\n  toggle: 'boolean',\n  parent: '(string|element)'\n};\nconst EVENT_SHOW$5 = `show${EVENT_KEY$8}`;\nconst EVENT_SHOWN$5 = `shown${EVENT_KEY$8}`;\nconst EVENT_HIDE$5 = `hide${EVENT_KEY$8}`;\nconst EVENT_HIDDEN$5 = `hidden${EVENT_KEY$8}`;\nconst EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;\nconst CLASS_NAME_SHOW$8 = 'show';\nconst CLASS_NAME_COLLAPSE = 'collapse';\nconst CLASS_NAME_COLLAPSING = 'collapsing';\nconst CLASS_NAME_COLLAPSED = 'collapsed';\nconst WIDTH = 'width';\nconst HEIGHT = 'height';\nconst SELECTOR_ACTIVES = '.show, .collapsing';\nconst SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Collapse extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._isTransitioning = false;\n    this._config = this._getConfig(config);\n    this._triggerArray = SelectorEngine.find(`${SELECTOR_DATA_TOGGLE$4}[href=\"#${this._element.id}\"],` + `${SELECTOR_DATA_TOGGLE$4}[data-bs-target=\"#${this._element.id}\"]`);\n    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\n\n    for (let i = 0, len = toggleList.length; i < len; i++) {\n      const elem = toggleList[i];\n      const selector = getSelectorFromElement(elem);\n      const filterElement = SelectorEngine.find(selector).filter(foundElem => foundElem === this._element);\n\n      if (selector !== null && filterElement.length) {\n        this._selector = selector;\n\n        this._triggerArray.push(elem);\n      }\n    }\n\n    this._parent = this._config.parent ? this._getParent() : null;\n\n    if (!this._config.parent) {\n      this._addAriaAndCollapsedClass(this._element, this._triggerArray);\n    }\n\n    if (this._config.toggle) {\n      this.toggle();\n    }\n  } // Getters\n\n\n  static get Default() {\n    return Default$8;\n  }\n\n  static get NAME() {\n    return NAME$9;\n  } // Public\n\n\n  toggle() {\n    if (this._element.classList.contains(CLASS_NAME_SHOW$8)) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n\n  show() {\n    if (this._isTransitioning || this._element.classList.contains(CLASS_NAME_SHOW$8)) {\n      return;\n    }\n\n    let actives;\n    let activesData;\n\n    if (this._parent) {\n      actives = SelectorEngine.find(SELECTOR_ACTIVES, this._parent).filter(elem => {\n        if (typeof this._config.parent === 'string') {\n          return elem.getAttribute('data-bs-parent') === this._config.parent;\n        }\n\n        return elem.classList.contains(CLASS_NAME_COLLAPSE);\n      });\n\n      if (actives.length === 0) {\n        actives = null;\n      }\n    }\n\n    const container = SelectorEngine.findOne(this._selector);\n\n    if (actives) {\n      const tempActiveData = actives.find(elem => container !== elem);\n      activesData = tempActiveData ? Data.get(tempActiveData, DATA_KEY$8) : null;\n\n      if (activesData && activesData._isTransitioning) {\n        return;\n      }\n    }\n\n    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$5);\n\n    if (startEvent.defaultPrevented) {\n      return;\n    }\n\n    if (actives) {\n      actives.forEach(elemActive => {\n        if (container !== elemActive) {\n          Collapse.collapseInterface(elemActive, 'hide');\n        }\n\n        if (!activesData) {\n          Data.set(elemActive, DATA_KEY$8, null);\n        }\n      });\n    }\n\n    const dimension = this._getDimension();\n\n    this._element.classList.remove(CLASS_NAME_COLLAPSE);\n\n    this._element.classList.add(CLASS_NAME_COLLAPSING);\n\n    this._element.style[dimension] = 0;\n\n    if (this._triggerArray.length) {\n      this._triggerArray.forEach(element => {\n        element.classList.remove(CLASS_NAME_COLLAPSED);\n        element.setAttribute('aria-expanded', true);\n      });\n    }\n\n    this.setTransitioning(true);\n\n    const complete = () => {\n      this._element.classList.remove(CLASS_NAME_COLLAPSING);\n\n      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$8);\n\n      this._element.style[dimension] = '';\n      this.setTransitioning(false);\n      EventHandler.trigger(this._element, EVENT_SHOWN$5);\n    };\n\n    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n    const scrollSize = `scroll${capitalizedDimension}`;\n\n    this._queueCallback(complete, this._element, true);\n\n    this._element.style[dimension] = `${this._element[scrollSize]}px`;\n  }\n\n  hide() {\n    if (this._isTransitioning || !this._element.classList.contains(CLASS_NAME_SHOW$8)) {\n      return;\n    }\n\n    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$5);\n\n    if (startEvent.defaultPrevented) {\n      return;\n    }\n\n    const dimension = this._getDimension();\n\n    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;\n    reflow(this._element);\n\n    this._element.classList.add(CLASS_NAME_COLLAPSING);\n\n    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$8);\n\n    const triggerArrayLength = this._triggerArray.length;\n\n    if (triggerArrayLength > 0) {\n      for (let i = 0; i < triggerArrayLength; i++) {\n        const trigger = this._triggerArray[i];\n        const elem = getElementFromSelector(trigger);\n\n        if (elem && !elem.classList.contains(CLASS_NAME_SHOW$8)) {\n          trigger.classList.add(CLASS_NAME_COLLAPSED);\n          trigger.setAttribute('aria-expanded', false);\n        }\n      }\n    }\n\n    this.setTransitioning(true);\n\n    const complete = () => {\n      this.setTransitioning(false);\n\n      this._element.classList.remove(CLASS_NAME_COLLAPSING);\n\n      this._element.classList.add(CLASS_NAME_COLLAPSE);\n\n      EventHandler.trigger(this._element, EVENT_HIDDEN$5);\n    };\n\n    this._element.style[dimension] = '';\n\n    this._queueCallback(complete, this._element, true);\n  }\n\n  setTransitioning(isTransitioning) {\n    this._isTransitioning = isTransitioning;\n  } // Private\n\n\n  _getConfig(config) {\n    config = { ...Default$8,\n      ...config\n    };\n    config.toggle = Boolean(config.toggle); // Coerce string values\n\n    typeCheckConfig(NAME$9, config, DefaultType$8);\n    return config;\n  }\n\n  _getDimension() {\n    return this._element.classList.contains(WIDTH) ? WIDTH : HEIGHT;\n  }\n\n  _getParent() {\n    let {\n      parent\n    } = this._config;\n    parent = getElement(parent);\n    const selector = `${SELECTOR_DATA_TOGGLE$4}[data-bs-parent=\"${parent}\"]`;\n    SelectorEngine.find(selector, parent).forEach(element => {\n      const selected = getElementFromSelector(element);\n\n      this._addAriaAndCollapsedClass(selected, [element]);\n    });\n    return parent;\n  }\n\n  _addAriaAndCollapsedClass(element, triggerArray) {\n    if (!element || !triggerArray.length) {\n      return;\n    }\n\n    const isOpen = element.classList.contains(CLASS_NAME_SHOW$8);\n    triggerArray.forEach(elem => {\n      if (isOpen) {\n        elem.classList.remove(CLASS_NAME_COLLAPSED);\n      } else {\n        elem.classList.add(CLASS_NAME_COLLAPSED);\n      }\n\n      elem.setAttribute('aria-expanded', isOpen);\n    });\n  } // Static\n\n\n  static collapseInterface(element, config) {\n    let data = Data.get(element, DATA_KEY$8);\n    const _config = { ...Default$8,\n      ...Manipulator.getDataAttributes(element),\n      ...(typeof config === 'object' && config ? config : {})\n    };\n\n    if (!data && _config.toggle && typeof config === 'string' && /show|hide/.test(config)) {\n      _config.toggle = false;\n    }\n\n    if (!data) {\n      data = new Collapse(element, _config);\n    }\n\n    if (typeof config === 'string') {\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n\n      data[config]();\n    }\n  }\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      Collapse.collapseInterface(this, config);\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {\n  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n  if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {\n    event.preventDefault();\n  }\n\n  const triggerData = Manipulator.getDataAttributes(this);\n  const selector = getSelectorFromElement(this);\n  const selectorElements = SelectorEngine.find(selector);\n  selectorElements.forEach(element => {\n    const data = Data.get(element, DATA_KEY$8);\n    let config;\n\n    if (data) {\n      // update parent attribute\n      if (data._parent === null && typeof triggerData.parent === 'string') {\n        data._config.parent = triggerData.parent;\n        data._parent = data._getParent();\n      }\n\n      config = 'toggle';\n    } else {\n      config = triggerData;\n    }\n\n    Collapse.collapseInterface(element, config);\n  });\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Collapse to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Collapse);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): dropdown.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$8 = 'dropdown';\nconst DATA_KEY$7 = 'bs.dropdown';\nconst EVENT_KEY$7 = `.${DATA_KEY$7}`;\nconst DATA_API_KEY$4 = '.data-api';\nconst ESCAPE_KEY$2 = 'Escape';\nconst SPACE_KEY = 'Space';\nconst TAB_KEY = 'Tab';\nconst ARROW_UP_KEY = 'ArrowUp';\nconst ARROW_DOWN_KEY = 'ArrowDown';\nconst RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\n\nconst REGEXP_KEYDOWN = new RegExp(`${ARROW_UP_KEY}|${ARROW_DOWN_KEY}|${ESCAPE_KEY$2}`);\nconst EVENT_HIDE$4 = `hide${EVENT_KEY$7}`;\nconst EVENT_HIDDEN$4 = `hidden${EVENT_KEY$7}`;\nconst EVENT_SHOW$4 = `show${EVENT_KEY$7}`;\nconst EVENT_SHOWN$4 = `shown${EVENT_KEY$7}`;\nconst EVENT_CLICK = `click${EVENT_KEY$7}`;\nconst EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;\nconst EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$7}${DATA_API_KEY$4}`;\nconst EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$7}${DATA_API_KEY$4}`;\nconst CLASS_NAME_SHOW$7 = 'show';\nconst CLASS_NAME_DROPUP = 'dropup';\nconst CLASS_NAME_DROPEND = 'dropend';\nconst CLASS_NAME_DROPSTART = 'dropstart';\nconst CLASS_NAME_NAVBAR = 'navbar';\nconst SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]';\nconst SELECTOR_MENU = '.dropdown-menu';\nconst SELECTOR_NAVBAR_NAV = '.navbar-nav';\nconst SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\nconst PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';\nconst PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';\nconst PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';\nconst PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';\nconst PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';\nconst PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';\nconst Default$7 = {\n  offset: [0, 2],\n  boundary: 'clippingParents',\n  reference: 'toggle',\n  display: 'dynamic',\n  popperConfig: null,\n  autoClose: true\n};\nconst DefaultType$7 = {\n  offset: '(array|string|function)',\n  boundary: '(string|element)',\n  reference: '(string|element|object)',\n  display: 'string',\n  popperConfig: '(null|object|function)',\n  autoClose: '(boolean|string)'\n};\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Dropdown extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._popper = null;\n    this._config = this._getConfig(config);\n    this._menu = this._getMenuElement();\n    this._inNavbar = this._detectNavbar();\n\n    this._addEventListeners();\n  } // Getters\n\n\n  static get Default() {\n    return Default$7;\n  }\n\n  static get DefaultType() {\n    return DefaultType$7;\n  }\n\n  static get NAME() {\n    return NAME$8;\n  } // Public\n\n\n  toggle() {\n    if (isDisabled(this._element)) {\n      return;\n    }\n\n    const isActive = this._element.classList.contains(CLASS_NAME_SHOW$7);\n\n    if (isActive) {\n      this.hide();\n      return;\n    }\n\n    this.show();\n  }\n\n  show() {\n    if (isDisabled(this._element) || this._menu.classList.contains(CLASS_NAME_SHOW$7)) {\n      return;\n    }\n\n    const parent = Dropdown.getParentFromElement(this._element);\n    const relatedTarget = {\n      relatedTarget: this._element\n    };\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, relatedTarget);\n\n    if (showEvent.defaultPrevented) {\n      return;\n    } // Totally disable Popper for Dropdowns in Navbar\n\n\n    if (this._inNavbar) {\n      Manipulator.setDataAttribute(this._menu, 'popper', 'none');\n    } else {\n      if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === 'undefined') {\n        throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org)');\n      }\n\n      let referenceElement = this._element;\n\n      if (this._config.reference === 'parent') {\n        referenceElement = parent;\n      } else if (isElement(this._config.reference)) {\n        referenceElement = getElement(this._config.reference);\n      } else if (typeof this._config.reference === 'object') {\n        referenceElement = this._config.reference;\n      }\n\n      const popperConfig = this._getPopperConfig();\n\n      const isDisplayStatic = popperConfig.modifiers.find(modifier => modifier.name === 'applyStyles' && modifier.enabled === false);\n      this._popper = _popperjs_core__WEBPACK_IMPORTED_MODULE_0__[\"createPopper\"](referenceElement, this._menu, popperConfig);\n\n      if (isDisplayStatic) {\n        Manipulator.setDataAttribute(this._menu, 'popper', 'static');\n      }\n    } // If this is a touch-enabled device we add extra\n    // empty mouseover listeners to the body's immediate children;\n    // only needed because of broken event delegation on iOS\n    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n\n    if ('ontouchstart' in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) {\n      [].concat(...document.body.children).forEach(elem => EventHandler.on(elem, 'mouseover', noop));\n    }\n\n    this._element.focus();\n\n    this._element.setAttribute('aria-expanded', true);\n\n    this._menu.classList.toggle(CLASS_NAME_SHOW$7);\n\n    this._element.classList.toggle(CLASS_NAME_SHOW$7);\n\n    EventHandler.trigger(this._element, EVENT_SHOWN$4, relatedTarget);\n  }\n\n  hide() {\n    if (isDisabled(this._element) || !this._menu.classList.contains(CLASS_NAME_SHOW$7)) {\n      return;\n    }\n\n    const relatedTarget = {\n      relatedTarget: this._element\n    };\n\n    this._completeHide(relatedTarget);\n  }\n\n  dispose() {\n    if (this._popper) {\n      this._popper.destroy();\n    }\n\n    super.dispose();\n  }\n\n  update() {\n    this._inNavbar = this._detectNavbar();\n\n    if (this._popper) {\n      this._popper.update();\n    }\n  } // Private\n\n\n  _addEventListeners() {\n    EventHandler.on(this._element, EVENT_CLICK, event => {\n      event.preventDefault();\n      this.toggle();\n    });\n  }\n\n  _completeHide(relatedTarget) {\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4, relatedTarget);\n\n    if (hideEvent.defaultPrevented) {\n      return;\n    } // If this is a touch-enabled device we remove the extra\n    // empty mouseover listeners we added for iOS support\n\n\n    if ('ontouchstart' in document.documentElement) {\n      [].concat(...document.body.children).forEach(elem => EventHandler.off(elem, 'mouseover', noop));\n    }\n\n    if (this._popper) {\n      this._popper.destroy();\n    }\n\n    this._menu.classList.remove(CLASS_NAME_SHOW$7);\n\n    this._element.classList.remove(CLASS_NAME_SHOW$7);\n\n    this._element.setAttribute('aria-expanded', 'false');\n\n    Manipulator.removeDataAttribute(this._menu, 'popper');\n    EventHandler.trigger(this._element, EVENT_HIDDEN$4, relatedTarget);\n  }\n\n  _getConfig(config) {\n    config = { ...this.constructor.Default,\n      ...Manipulator.getDataAttributes(this._element),\n      ...config\n    };\n    typeCheckConfig(NAME$8, config, this.constructor.DefaultType);\n\n    if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {\n      // Popper virtual elements require a getBoundingClientRect method\n      throw new TypeError(`${NAME$8.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`);\n    }\n\n    return config;\n  }\n\n  _getMenuElement() {\n    return SelectorEngine.next(this._element, SELECTOR_MENU)[0];\n  }\n\n  _getPlacement() {\n    const parentDropdown = this._element.parentNode;\n\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n      return PLACEMENT_RIGHT;\n    }\n\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n      return PLACEMENT_LEFT;\n    } // We need to trim the value because custom properties can also include spaces\n\n\n    const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';\n\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n    }\n\n    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n  }\n\n  _detectNavbar() {\n    return this._element.closest(`.${CLASS_NAME_NAVBAR}`) !== null;\n  }\n\n  _getOffset() {\n    const {\n      offset\n    } = this._config;\n\n    if (typeof offset === 'string') {\n      return offset.split(',').map(val => Number.parseInt(val, 10));\n    }\n\n    if (typeof offset === 'function') {\n      return popperData => offset(popperData, this._element);\n    }\n\n    return offset;\n  }\n\n  _getPopperConfig() {\n    const defaultBsPopperConfig = {\n      placement: this._getPlacement(),\n      modifiers: [{\n        name: 'preventOverflow',\n        options: {\n          boundary: this._config.boundary\n        }\n      }, {\n        name: 'offset',\n        options: {\n          offset: this._getOffset()\n        }\n      }]\n    }; // Disable Popper if we have a static display\n\n    if (this._config.display === 'static') {\n      defaultBsPopperConfig.modifiers = [{\n        name: 'applyStyles',\n        enabled: false\n      }];\n    }\n\n    return { ...defaultBsPopperConfig,\n      ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)\n    };\n  }\n\n  _selectMenuItem(event) {\n    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible);\n\n    if (!items.length) {\n      return;\n    }\n\n    let index = items.indexOf(event.target); // Up\n\n    if (event.key === ARROW_UP_KEY && index > 0) {\n      index--;\n    } // Down\n\n\n    if (event.key === ARROW_DOWN_KEY && index < items.length - 1) {\n      index++;\n    } // index is -1 if the first keydown is an ArrowUp\n\n\n    index = index === -1 ? 0 : index;\n    items[index].focus();\n  } // Static\n\n\n  static dropdownInterface(element, config) {\n    let data = Data.get(element, DATA_KEY$7);\n\n    const _config = typeof config === 'object' ? config : null;\n\n    if (!data) {\n      data = new Dropdown(element, _config);\n    }\n\n    if (typeof config === 'string') {\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n\n      data[config]();\n    }\n  }\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      Dropdown.dropdownInterface(this, config);\n    });\n  }\n\n  static clearMenus(event) {\n    if (event && (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY)) {\n      return;\n    }\n\n    const toggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE$3);\n\n    for (let i = 0, len = toggles.length; i < len; i++) {\n      const context = Data.get(toggles[i], DATA_KEY$7);\n\n      if (!context || context._config.autoClose === false) {\n        continue;\n      }\n\n      if (!context._element.classList.contains(CLASS_NAME_SHOW$7)) {\n        continue;\n      }\n\n      const relatedTarget = {\n        relatedTarget: context._element\n      };\n\n      if (event) {\n        const composedPath = event.composedPath();\n        const isMenuTarget = composedPath.includes(context._menu);\n\n        if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {\n          continue;\n        } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n\n\n        if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n          continue;\n        }\n\n        if (event.type === 'click') {\n          relatedTarget.clickEvent = event;\n        }\n      }\n\n      context._completeHide(relatedTarget);\n    }\n  }\n\n  static getParentFromElement(element) {\n    return getElementFromSelector(element) || element.parentNode;\n  }\n\n  static dataApiKeydownHandler(event) {\n    // If not input/textarea:\n    //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\n    // If input/textarea:\n    //  - If space key => not a dropdown command\n    //  - If key is other than escape\n    //    - If key is not up or down => not a dropdown command\n    //    - If trigger inside the menu => not a dropdown command\n    if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY$2 && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) {\n      return;\n    }\n\n    const isActive = this.classList.contains(CLASS_NAME_SHOW$7);\n\n    if (!isActive && event.key === ESCAPE_KEY$2) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (isDisabled(this)) {\n      return;\n    }\n\n    const getToggleButton = () => this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0];\n\n    if (event.key === ESCAPE_KEY$2) {\n      getToggleButton().focus();\n      Dropdown.clearMenus();\n      return;\n    }\n\n    if (!isActive && (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY)) {\n      getToggleButton().click();\n      return;\n    }\n\n    if (!isActive || event.key === SPACE_KEY) {\n      Dropdown.clearMenus();\n      return;\n    }\n\n    Dropdown.getInstance(getToggleButton())._selectMenuItem(event);\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\nEventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\nEventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\nEventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\nEventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\n  event.preventDefault();\n  Dropdown.dropdownInterface(this);\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Dropdown to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Dropdown);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): util/scrollBar.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\nconst SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\nconst SELECTOR_STICKY_CONTENT = '.sticky-top';\n\nconst getWidth = () => {\n  // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n  const documentWidth = document.documentElement.clientWidth;\n  return Math.abs(window.innerWidth - documentWidth);\n};\n\nconst hide = (width = getWidth()) => {\n  _disableOverFlow(); // give padding to element to balances the hidden scrollbar width\n\n\n  _setElementAttributes('body', 'paddingRight', calculatedValue => calculatedValue + width); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements, to keep shown fullwidth\n\n\n  _setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', calculatedValue => calculatedValue + width);\n\n  _setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', calculatedValue => calculatedValue - width);\n};\n\nconst _disableOverFlow = () => {\n  const actualValue = document.body.style.overflow;\n\n  if (actualValue) {\n    Manipulator.setDataAttribute(document.body, 'overflow', actualValue);\n  }\n\n  document.body.style.overflow = 'hidden';\n};\n\nconst _setElementAttributes = (selector, styleProp, callback) => {\n  const scrollbarWidth = getWidth();\n  SelectorEngine.find(selector).forEach(element => {\n    if (element !== document.body && window.innerWidth > element.clientWidth + scrollbarWidth) {\n      return;\n    }\n\n    const actualValue = element.style[styleProp];\n    const calculatedValue = window.getComputedStyle(element)[styleProp];\n    Manipulator.setDataAttribute(element, styleProp, actualValue);\n    element.style[styleProp] = `${callback(Number.parseFloat(calculatedValue))}px`;\n  });\n};\n\nconst reset = () => {\n  _resetElementAttributes('body', 'overflow');\n\n  _resetElementAttributes('body', 'paddingRight');\n\n  _resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight');\n\n  _resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight');\n};\n\nconst _resetElementAttributes = (selector, styleProp) => {\n  SelectorEngine.find(selector).forEach(element => {\n    const value = Manipulator.getDataAttribute(element, styleProp);\n\n    if (typeof value === 'undefined') {\n      element.style.removeProperty(styleProp);\n    } else {\n      Manipulator.removeDataAttribute(element, styleProp);\n      element.style[styleProp] = value;\n    }\n  });\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): util/backdrop.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nconst Default$6 = {\n  isVisible: true,\n  // if false, we use the backdrop helper without adding any element to the dom\n  isAnimated: false,\n  rootElement: document.body,\n  // give the choice to place backdrop under different elements\n  clickCallback: null\n};\nconst DefaultType$6 = {\n  isVisible: 'boolean',\n  isAnimated: 'boolean',\n  rootElement: 'element',\n  clickCallback: '(function|null)'\n};\nconst NAME$7 = 'backdrop';\nconst CLASS_NAME_BACKDROP = 'modal-backdrop';\nconst CLASS_NAME_FADE$5 = 'fade';\nconst CLASS_NAME_SHOW$6 = 'show';\nconst EVENT_MOUSEDOWN = `mousedown.bs.${NAME$7}`;\n\nclass Backdrop {\n  constructor(config) {\n    this._config = this._getConfig(config);\n    this._isAppended = false;\n    this._element = null;\n  }\n\n  show(callback) {\n    if (!this._config.isVisible) {\n      execute(callback);\n      return;\n    }\n\n    this._append();\n\n    if (this._config.isAnimated) {\n      reflow(this._getElement());\n    }\n\n    this._getElement().classList.add(CLASS_NAME_SHOW$6);\n\n    this._emulateAnimation(() => {\n      execute(callback);\n    });\n  }\n\n  hide(callback) {\n    if (!this._config.isVisible) {\n      execute(callback);\n      return;\n    }\n\n    this._getElement().classList.remove(CLASS_NAME_SHOW$6);\n\n    this._emulateAnimation(() => {\n      this.dispose();\n      execute(callback);\n    });\n  } // Private\n\n\n  _getElement() {\n    if (!this._element) {\n      const backdrop = document.createElement('div');\n      backdrop.className = CLASS_NAME_BACKDROP;\n\n      if (this._config.isAnimated) {\n        backdrop.classList.add(CLASS_NAME_FADE$5);\n      }\n\n      this._element = backdrop;\n    }\n\n    return this._element;\n  }\n\n  _getConfig(config) {\n    config = { ...Default$6,\n      ...(typeof config === 'object' ? config : {})\n    };\n    config.rootElement = config.rootElement || document.body;\n    typeCheckConfig(NAME$7, config, DefaultType$6);\n    return config;\n  }\n\n  _append() {\n    if (this._isAppended) {\n      return;\n    }\n\n    this._config.rootElement.appendChild(this._getElement());\n\n    EventHandler.on(this._getElement(), EVENT_MOUSEDOWN, () => {\n      execute(this._config.clickCallback);\n    });\n    this._isAppended = true;\n  }\n\n  dispose() {\n    if (!this._isAppended) {\n      return;\n    }\n\n    EventHandler.off(this._element, EVENT_MOUSEDOWN);\n\n    this._getElement().parentNode.removeChild(this._element);\n\n    this._isAppended = false;\n  }\n\n  _emulateAnimation(callback) {\n    if (!this._config.isAnimated) {\n      execute(callback);\n      return;\n    }\n\n    const backdropTransitionDuration = getTransitionDurationFromElement(this._getElement());\n    EventHandler.one(this._getElement(), 'transitionend', () => execute(callback));\n    emulateTransitionEnd(this._getElement(), backdropTransitionDuration);\n  }\n\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): modal.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$6 = 'modal';\nconst DATA_KEY$6 = 'bs.modal';\nconst EVENT_KEY$6 = `.${DATA_KEY$6}`;\nconst DATA_API_KEY$3 = '.data-api';\nconst ESCAPE_KEY$1 = 'Escape';\nconst Default$5 = {\n  backdrop: true,\n  keyboard: true,\n  focus: true\n};\nconst DefaultType$5 = {\n  backdrop: '(boolean|string)',\n  keyboard: 'boolean',\n  focus: 'boolean'\n};\nconst EVENT_HIDE$3 = `hide${EVENT_KEY$6}`;\nconst EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$6}`;\nconst EVENT_HIDDEN$3 = `hidden${EVENT_KEY$6}`;\nconst EVENT_SHOW$3 = `show${EVENT_KEY$6}`;\nconst EVENT_SHOWN$3 = `shown${EVENT_KEY$6}`;\nconst EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$6}`;\nconst EVENT_RESIZE = `resize${EVENT_KEY$6}`;\nconst EVENT_CLICK_DISMISS$2 = `click.dismiss${EVENT_KEY$6}`;\nconst EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$6}`;\nconst EVENT_MOUSEUP_DISMISS = `mouseup.dismiss${EVENT_KEY$6}`;\nconst EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$6}`;\nconst EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;\nconst CLASS_NAME_OPEN = 'modal-open';\nconst CLASS_NAME_FADE$4 = 'fade';\nconst CLASS_NAME_SHOW$5 = 'show';\nconst CLASS_NAME_STATIC = 'modal-static';\nconst SELECTOR_DIALOG = '.modal-dialog';\nconst SELECTOR_MODAL_BODY = '.modal-body';\nconst SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\nconst SELECTOR_DATA_DISMISS$2 = '[data-bs-dismiss=\"modal\"]';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Modal extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._config = this._getConfig(config);\n    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\n    this._backdrop = this._initializeBackDrop();\n    this._isShown = false;\n    this._ignoreBackdropClick = false;\n    this._isTransitioning = false;\n  } // Getters\n\n\n  static get Default() {\n    return Default$5;\n  }\n\n  static get NAME() {\n    return NAME$6;\n  } // Public\n\n\n  toggle(relatedTarget) {\n    return this._isShown ? this.hide() : this.show(relatedTarget);\n  }\n\n  show(relatedTarget) {\n    if (this._isShown || this._isTransitioning) {\n      return;\n    }\n\n    if (this._isAnimated()) {\n      this._isTransitioning = true;\n    }\n\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\n      relatedTarget\n    });\n\n    if (this._isShown || showEvent.defaultPrevented) {\n      return;\n    }\n\n    this._isShown = true;\n    hide();\n    document.body.classList.add(CLASS_NAME_OPEN);\n\n    this._adjustDialog();\n\n    this._setEscapeEvent();\n\n    this._setResizeEvent();\n\n    EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, SELECTOR_DATA_DISMISS$2, event => this.hide(event));\n    EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, () => {\n      EventHandler.one(this._element, EVENT_MOUSEUP_DISMISS, event => {\n        if (event.target === this._element) {\n          this._ignoreBackdropClick = true;\n        }\n      });\n    });\n\n    this._showBackdrop(() => this._showElement(relatedTarget));\n  }\n\n  hide(event) {\n    if (event) {\n      event.preventDefault();\n    }\n\n    if (!this._isShown || this._isTransitioning) {\n      return;\n    }\n\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n\n    this._isShown = false;\n\n    const isAnimated = this._isAnimated();\n\n    if (isAnimated) {\n      this._isTransitioning = true;\n    }\n\n    this._setEscapeEvent();\n\n    this._setResizeEvent();\n\n    EventHandler.off(document, EVENT_FOCUSIN$2);\n\n    this._element.classList.remove(CLASS_NAME_SHOW$5);\n\n    EventHandler.off(this._element, EVENT_CLICK_DISMISS$2);\n    EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS);\n\n    this._queueCallback(() => this._hideModal(), this._element, isAnimated);\n  }\n\n  dispose() {\n    [window, this._dialog].forEach(htmlElement => EventHandler.off(htmlElement, EVENT_KEY$6));\n\n    this._backdrop.dispose();\n\n    super.dispose();\n    /**\n     * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`\n     * Do not move `document` in `htmlElements` array\n     * It will remove `EVENT_CLICK_DATA_API` event that should remain\n     */\n\n    EventHandler.off(document, EVENT_FOCUSIN$2);\n  }\n\n  handleUpdate() {\n    this._adjustDialog();\n  } // Private\n\n\n  _initializeBackDrop() {\n    return new Backdrop({\n      isVisible: Boolean(this._config.backdrop),\n      // 'static' option will be translated to true, and booleans will keep their value\n      isAnimated: this._isAnimated()\n    });\n  }\n\n  _getConfig(config) {\n    config = { ...Default$5,\n      ...Manipulator.getDataAttributes(this._element),\n      ...config\n    };\n    typeCheckConfig(NAME$6, config, DefaultType$5);\n    return config;\n  }\n\n  _showElement(relatedTarget) {\n    const isAnimated = this._isAnimated();\n\n    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n\n    if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\n      // Don't move modal's DOM position\n      document.body.appendChild(this._element);\n    }\n\n    this._element.style.display = 'block';\n\n    this._element.removeAttribute('aria-hidden');\n\n    this._element.setAttribute('aria-modal', true);\n\n    this._element.setAttribute('role', 'dialog');\n\n    this._element.scrollTop = 0;\n\n    if (modalBody) {\n      modalBody.scrollTop = 0;\n    }\n\n    if (isAnimated) {\n      reflow(this._element);\n    }\n\n    this._element.classList.add(CLASS_NAME_SHOW$5);\n\n    if (this._config.focus) {\n      this._enforceFocus();\n    }\n\n    const transitionComplete = () => {\n      if (this._config.focus) {\n        this._element.focus();\n      }\n\n      this._isTransitioning = false;\n      EventHandler.trigger(this._element, EVENT_SHOWN$3, {\n        relatedTarget\n      });\n    };\n\n    this._queueCallback(transitionComplete, this._dialog, isAnimated);\n  }\n\n  _enforceFocus() {\n    EventHandler.off(document, EVENT_FOCUSIN$2); // guard against infinite focus loop\n\n    EventHandler.on(document, EVENT_FOCUSIN$2, event => {\n      if (document !== event.target && this._element !== event.target && !this._element.contains(event.target)) {\n        this._element.focus();\n      }\n    });\n  }\n\n  _setEscapeEvent() {\n    if (this._isShown) {\n      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {\n        if (this._config.keyboard && event.key === ESCAPE_KEY$1) {\n          event.preventDefault();\n          this.hide();\n        } else if (!this._config.keyboard && event.key === ESCAPE_KEY$1) {\n          this._triggerBackdropTransition();\n        }\n      });\n    } else {\n      EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS$1);\n    }\n  }\n\n  _setResizeEvent() {\n    if (this._isShown) {\n      EventHandler.on(window, EVENT_RESIZE, () => this._adjustDialog());\n    } else {\n      EventHandler.off(window, EVENT_RESIZE);\n    }\n  }\n\n  _hideModal() {\n    this._element.style.display = 'none';\n\n    this._element.setAttribute('aria-hidden', true);\n\n    this._element.removeAttribute('aria-modal');\n\n    this._element.removeAttribute('role');\n\n    this._isTransitioning = false;\n\n    this._backdrop.hide(() => {\n      document.body.classList.remove(CLASS_NAME_OPEN);\n\n      this._resetAdjustments();\n\n      reset();\n      EventHandler.trigger(this._element, EVENT_HIDDEN$3);\n    });\n  }\n\n  _showBackdrop(callback) {\n    EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, event => {\n      if (this._ignoreBackdropClick) {\n        this._ignoreBackdropClick = false;\n        return;\n      }\n\n      if (event.target !== event.currentTarget) {\n        return;\n      }\n\n      if (this._config.backdrop === true) {\n        this.hide();\n      } else if (this._config.backdrop === 'static') {\n        this._triggerBackdropTransition();\n      }\n    });\n\n    this._backdrop.show(callback);\n  }\n\n  _isAnimated() {\n    return this._element.classList.contains(CLASS_NAME_FADE$4);\n  }\n\n  _triggerBackdropTransition() {\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n\n    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n\n    if (!isModalOverflowing) {\n      this._element.style.overflowY = 'hidden';\n    }\n\n    this._element.classList.add(CLASS_NAME_STATIC);\n\n    const modalTransitionDuration = getTransitionDurationFromElement(this._dialog);\n    EventHandler.off(this._element, 'transitionend');\n    EventHandler.one(this._element, 'transitionend', () => {\n      this._element.classList.remove(CLASS_NAME_STATIC);\n\n      if (!isModalOverflowing) {\n        EventHandler.one(this._element, 'transitionend', () => {\n          this._element.style.overflowY = '';\n        });\n        emulateTransitionEnd(this._element, modalTransitionDuration);\n      }\n    });\n    emulateTransitionEnd(this._element, modalTransitionDuration);\n\n    this._element.focus();\n  } // ----------------------------------------------------------------------\n  // the following methods are used to handle overflowing modals\n  // ----------------------------------------------------------------------\n\n\n  _adjustDialog() {\n    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n    const scrollbarWidth = getWidth();\n    const isBodyOverflowing = scrollbarWidth > 0;\n\n    if (!isBodyOverflowing && isModalOverflowing && !isRTL() || isBodyOverflowing && !isModalOverflowing && isRTL()) {\n      this._element.style.paddingLeft = `${scrollbarWidth}px`;\n    }\n\n    if (isBodyOverflowing && !isModalOverflowing && !isRTL() || !isBodyOverflowing && isModalOverflowing && isRTL()) {\n      this._element.style.paddingRight = `${scrollbarWidth}px`;\n    }\n  }\n\n  _resetAdjustments() {\n    this._element.style.paddingLeft = '';\n    this._element.style.paddingRight = '';\n  } // Static\n\n\n  static jQueryInterface(config, relatedTarget) {\n    return this.each(function () {\n      const data = Modal.getInstance(this) || new Modal(this, typeof config === 'object' ? config : {});\n\n      if (typeof config !== 'string') {\n        return;\n      }\n\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n\n      data[config](relatedTarget);\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\n  const target = getElementFromSelector(this);\n\n  if (['A', 'AREA'].includes(this.tagName)) {\n    event.preventDefault();\n  }\n\n  EventHandler.one(target, EVENT_SHOW$3, showEvent => {\n    if (showEvent.defaultPrevented) {\n      // only register focus restorer if modal will actually get shown\n      return;\n    }\n\n    EventHandler.one(target, EVENT_HIDDEN$3, () => {\n      if (isVisible(this)) {\n        this.focus();\n      }\n    });\n  });\n  const data = Modal.getInstance(target) || new Modal(target);\n  data.toggle(this);\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Modal to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Modal);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): offcanvas.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$5 = 'offcanvas';\nconst DATA_KEY$5 = 'bs.offcanvas';\nconst EVENT_KEY$5 = `.${DATA_KEY$5}`;\nconst DATA_API_KEY$2 = '.data-api';\nconst EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$5}${DATA_API_KEY$2}`;\nconst ESCAPE_KEY = 'Escape';\nconst Default$4 = {\n  backdrop: true,\n  keyboard: true,\n  scroll: false\n};\nconst DefaultType$4 = {\n  backdrop: 'boolean',\n  keyboard: 'boolean',\n  scroll: 'boolean'\n};\nconst CLASS_NAME_SHOW$4 = 'show';\nconst OPEN_SELECTOR = '.offcanvas.show';\nconst EVENT_SHOW$2 = `show${EVENT_KEY$5}`;\nconst EVENT_SHOWN$2 = `shown${EVENT_KEY$5}`;\nconst EVENT_HIDE$2 = `hide${EVENT_KEY$5}`;\nconst EVENT_HIDDEN$2 = `hidden${EVENT_KEY$5}`;\nconst EVENT_FOCUSIN$1 = `focusin${EVENT_KEY$5}`;\nconst EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$5}${DATA_API_KEY$2}`;\nconst EVENT_CLICK_DISMISS$1 = `click.dismiss${EVENT_KEY$5}`;\nconst EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$5}`;\nconst SELECTOR_DATA_DISMISS$1 = '[data-bs-dismiss=\"offcanvas\"]';\nconst SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Offcanvas extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._config = this._getConfig(config);\n    this._isShown = false;\n    this._backdrop = this._initializeBackDrop();\n\n    this._addEventListeners();\n  } // Getters\n\n\n  static get NAME() {\n    return NAME$5;\n  }\n\n  static get Default() {\n    return Default$4;\n  } // Public\n\n\n  toggle(relatedTarget) {\n    return this._isShown ? this.hide() : this.show(relatedTarget);\n  }\n\n  show(relatedTarget) {\n    if (this._isShown) {\n      return;\n    }\n\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$2, {\n      relatedTarget\n    });\n\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n\n    this._isShown = true;\n    this._element.style.visibility = 'visible';\n\n    this._backdrop.show();\n\n    if (!this._config.scroll) {\n      hide();\n\n      this._enforceFocusOnElement(this._element);\n    }\n\n    this._element.removeAttribute('aria-hidden');\n\n    this._element.setAttribute('aria-modal', true);\n\n    this._element.setAttribute('role', 'dialog');\n\n    this._element.classList.add(CLASS_NAME_SHOW$4);\n\n    const completeCallBack = () => {\n      EventHandler.trigger(this._element, EVENT_SHOWN$2, {\n        relatedTarget\n      });\n    };\n\n    this._queueCallback(completeCallBack, this._element, true);\n  }\n\n  hide() {\n    if (!this._isShown) {\n      return;\n    }\n\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$2);\n\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n\n    EventHandler.off(document, EVENT_FOCUSIN$1);\n\n    this._element.blur();\n\n    this._isShown = false;\n\n    this._element.classList.remove(CLASS_NAME_SHOW$4);\n\n    this._backdrop.hide();\n\n    const completeCallback = () => {\n      this._element.setAttribute('aria-hidden', true);\n\n      this._element.removeAttribute('aria-modal');\n\n      this._element.removeAttribute('role');\n\n      this._element.style.visibility = 'hidden';\n\n      if (!this._config.scroll) {\n        reset();\n      }\n\n      EventHandler.trigger(this._element, EVENT_HIDDEN$2);\n    };\n\n    this._queueCallback(completeCallback, this._element, true);\n  }\n\n  dispose() {\n    this._backdrop.dispose();\n\n    super.dispose();\n    EventHandler.off(document, EVENT_FOCUSIN$1);\n  } // Private\n\n\n  _getConfig(config) {\n    config = { ...Default$4,\n      ...Manipulator.getDataAttributes(this._element),\n      ...(typeof config === 'object' ? config : {})\n    };\n    typeCheckConfig(NAME$5, config, DefaultType$4);\n    return config;\n  }\n\n  _initializeBackDrop() {\n    return new Backdrop({\n      isVisible: this._config.backdrop,\n      isAnimated: true,\n      rootElement: this._element.parentNode,\n      clickCallback: () => this.hide()\n    });\n  }\n\n  _enforceFocusOnElement(element) {\n    EventHandler.off(document, EVENT_FOCUSIN$1); // guard against infinite focus loop\n\n    EventHandler.on(document, EVENT_FOCUSIN$1, event => {\n      if (document !== event.target && element !== event.target && !element.contains(event.target)) {\n        element.focus();\n      }\n    });\n    element.focus();\n  }\n\n  _addEventListeners() {\n    EventHandler.on(this._element, EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, () => this.hide());\n    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {\n      if (this._config.keyboard && event.key === ESCAPE_KEY) {\n        this.hide();\n      }\n    });\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Data.get(this, DATA_KEY$5) || new Offcanvas(this, typeof config === 'object' ? config : {});\n\n      if (typeof config !== 'string') {\n        return;\n      }\n\n      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n\n      data[config](this);\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\n  const target = getElementFromSelector(this);\n\n  if (['A', 'AREA'].includes(this.tagName)) {\n    event.preventDefault();\n  }\n\n  if (isDisabled(this)) {\n    return;\n  }\n\n  EventHandler.one(target, EVENT_HIDDEN$2, () => {\n    // focus on trigger when it is closed\n    if (isVisible(this)) {\n      this.focus();\n    }\n  }); // avoid conflict when clicking a toggler of an offcanvas, while another is open\n\n  const allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\n\n  if (allReadyOpen && allReadyOpen !== target) {\n    Offcanvas.getInstance(allReadyOpen).hide();\n  }\n\n  const data = Data.get(target, DATA_KEY$5) || new Offcanvas(target);\n  data.toggle(this);\n});\nEventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {\n  SelectorEngine.find(OPEN_SELECTOR).forEach(el => (Data.get(el, DATA_KEY$5) || new Offcanvas(el)).show());\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n */\n\ndefineJQueryPlugin(Offcanvas);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): util/sanitizer.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\nconst uriAttrs = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);\nconst ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n *\n * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n */\n\nconst SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i;\n/**\n * A pattern that matches safe data URLs. Only matches image, video and audio types.\n *\n * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n */\n\nconst DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i;\n\nconst allowedAttribute = (attr, allowedAttributeList) => {\n  const attrName = attr.nodeName.toLowerCase();\n\n  if (allowedAttributeList.includes(attrName)) {\n    if (uriAttrs.has(attrName)) {\n      return Boolean(SAFE_URL_PATTERN.test(attr.nodeValue) || DATA_URL_PATTERN.test(attr.nodeValue));\n    }\n\n    return true;\n  }\n\n  const regExp = allowedAttributeList.filter(attrRegex => attrRegex instanceof RegExp); // Check if a regular expression validates the attribute.\n\n  for (let i = 0, len = regExp.length; i < len; i++) {\n    if (regExp[i].test(attrName)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst DefaultAllowlist = {\n  // Global attributes allowed on any supplied element below.\n  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n  a: ['target', 'href', 'title', 'rel'],\n  area: [],\n  b: [],\n  br: [],\n  col: [],\n  code: [],\n  div: [],\n  em: [],\n  hr: [],\n  h1: [],\n  h2: [],\n  h3: [],\n  h4: [],\n  h5: [],\n  h6: [],\n  i: [],\n  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n  li: [],\n  ol: [],\n  p: [],\n  pre: [],\n  s: [],\n  small: [],\n  span: [],\n  sub: [],\n  sup: [],\n  strong: [],\n  u: [],\n  ul: []\n};\nfunction sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {\n  if (!unsafeHtml.length) {\n    return unsafeHtml;\n  }\n\n  if (sanitizeFn && typeof sanitizeFn === 'function') {\n    return sanitizeFn(unsafeHtml);\n  }\n\n  const domParser = new window.DOMParser();\n  const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\n  const allowlistKeys = Object.keys(allowList);\n  const elements = [].concat(...createdDocument.body.querySelectorAll('*'));\n\n  for (let i = 0, len = elements.length; i < len; i++) {\n    const el = elements[i];\n    const elName = el.nodeName.toLowerCase();\n\n    if (!allowlistKeys.includes(elName)) {\n      el.parentNode.removeChild(el);\n      continue;\n    }\n\n    const attributeList = [].concat(...el.attributes);\n    const allowedAttributes = [].concat(allowList['*'] || [], allowList[elName] || []);\n    attributeList.forEach(attr => {\n      if (!allowedAttribute(attr, allowedAttributes)) {\n        el.removeAttribute(attr.nodeName);\n      }\n    });\n  }\n\n  return createdDocument.body.innerHTML;\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): tooltip.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$4 = 'tooltip';\nconst DATA_KEY$4 = 'bs.tooltip';\nconst EVENT_KEY$4 = `.${DATA_KEY$4}`;\nconst CLASS_PREFIX$1 = 'bs-tooltip';\nconst BSCLS_PREFIX_REGEX$1 = new RegExp(`(^|\\\\s)${CLASS_PREFIX$1}\\\\S+`, 'g');\nconst DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);\nconst DefaultType$3 = {\n  animation: 'boolean',\n  template: 'string',\n  title: '(string|element|function)',\n  trigger: 'string',\n  delay: '(number|object)',\n  html: 'boolean',\n  selector: '(string|boolean)',\n  placement: '(string|function)',\n  offset: '(array|string|function)',\n  container: '(string|element|boolean)',\n  fallbackPlacements: 'array',\n  boundary: '(string|element)',\n  customClass: '(string|function)',\n  sanitize: 'boolean',\n  sanitizeFn: '(null|function)',\n  allowList: 'object',\n  popperConfig: '(null|object|function)'\n};\nconst AttachmentMap = {\n  AUTO: 'auto',\n  TOP: 'top',\n  RIGHT: isRTL() ? 'left' : 'right',\n  BOTTOM: 'bottom',\n  LEFT: isRTL() ? 'right' : 'left'\n};\nconst Default$3 = {\n  animation: true,\n  template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + '</div>',\n  trigger: 'hover focus',\n  title: '',\n  delay: 0,\n  html: false,\n  selector: false,\n  placement: 'top',\n  offset: [0, 0],\n  container: false,\n  fallbackPlacements: ['top', 'right', 'bottom', 'left'],\n  boundary: 'clippingParents',\n  customClass: '',\n  sanitize: true,\n  sanitizeFn: null,\n  allowList: DefaultAllowlist,\n  popperConfig: null\n};\nconst Event$2 = {\n  HIDE: `hide${EVENT_KEY$4}`,\n  HIDDEN: `hidden${EVENT_KEY$4}`,\n  SHOW: `show${EVENT_KEY$4}`,\n  SHOWN: `shown${EVENT_KEY$4}`,\n  INSERTED: `inserted${EVENT_KEY$4}`,\n  CLICK: `click${EVENT_KEY$4}`,\n  FOCUSIN: `focusin${EVENT_KEY$4}`,\n  FOCUSOUT: `focusout${EVENT_KEY$4}`,\n  MOUSEENTER: `mouseenter${EVENT_KEY$4}`,\n  MOUSELEAVE: `mouseleave${EVENT_KEY$4}`\n};\nconst CLASS_NAME_FADE$3 = 'fade';\nconst CLASS_NAME_MODAL = 'modal';\nconst CLASS_NAME_SHOW$3 = 'show';\nconst HOVER_STATE_SHOW = 'show';\nconst HOVER_STATE_OUT = 'out';\nconst SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\nconst TRIGGER_HOVER = 'hover';\nconst TRIGGER_FOCUS = 'focus';\nconst TRIGGER_CLICK = 'click';\nconst TRIGGER_MANUAL = 'manual';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Tooltip extends BaseComponent {\n  constructor(element, config) {\n    if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === 'undefined') {\n      throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org)');\n    }\n\n    super(element); // private\n\n    this._isEnabled = true;\n    this._timeout = 0;\n    this._hoverState = '';\n    this._activeTrigger = {};\n    this._popper = null; // Protected\n\n    this._config = this._getConfig(config);\n    this.tip = null;\n\n    this._setListeners();\n  } // Getters\n\n\n  static get Default() {\n    return Default$3;\n  }\n\n  static get NAME() {\n    return NAME$4;\n  }\n\n  static get Event() {\n    return Event$2;\n  }\n\n  static get DefaultType() {\n    return DefaultType$3;\n  } // Public\n\n\n  enable() {\n    this._isEnabled = true;\n  }\n\n  disable() {\n    this._isEnabled = false;\n  }\n\n  toggleEnabled() {\n    this._isEnabled = !this._isEnabled;\n  }\n\n  toggle(event) {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    if (event) {\n      const context = this._initializeOnDelegatedTarget(event);\n\n      context._activeTrigger.click = !context._activeTrigger.click;\n\n      if (context._isWithActiveTrigger()) {\n        context._enter(null, context);\n      } else {\n        context._leave(null, context);\n      }\n    } else {\n      if (this.getTipElement().classList.contains(CLASS_NAME_SHOW$3)) {\n        this._leave(null, this);\n\n        return;\n      }\n\n      this._enter(null, this);\n    }\n  }\n\n  dispose() {\n    clearTimeout(this._timeout);\n    EventHandler.off(this._element.closest(`.${CLASS_NAME_MODAL}`), 'hide.bs.modal', this._hideModalHandler);\n\n    if (this.tip && this.tip.parentNode) {\n      this.tip.parentNode.removeChild(this.tip);\n    }\n\n    if (this._popper) {\n      this._popper.destroy();\n    }\n\n    super.dispose();\n  }\n\n  show() {\n    if (this._element.style.display === 'none') {\n      throw new Error('Please use show on visible elements');\n    }\n\n    if (!(this.isWithContent() && this._isEnabled)) {\n      return;\n    }\n\n    const showEvent = EventHandler.trigger(this._element, this.constructor.Event.SHOW);\n    const shadowRoot = findShadowRoot(this._element);\n    const isInTheDom = shadowRoot === null ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);\n\n    if (showEvent.defaultPrevented || !isInTheDom) {\n      return;\n    }\n\n    const tip = this.getTipElement();\n    const tipId = getUID(this.constructor.NAME);\n    tip.setAttribute('id', tipId);\n\n    this._element.setAttribute('aria-describedby', tipId);\n\n    this.setContent();\n\n    if (this._config.animation) {\n      tip.classList.add(CLASS_NAME_FADE$3);\n    }\n\n    const placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;\n\n    const attachment = this._getAttachment(placement);\n\n    this._addAttachmentClass(attachment);\n\n    const {\n      container\n    } = this._config;\n    Data.set(tip, this.constructor.DATA_KEY, this);\n\n    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n      container.appendChild(tip);\n      EventHandler.trigger(this._element, this.constructor.Event.INSERTED);\n    }\n\n    if (this._popper) {\n      this._popper.update();\n    } else {\n      this._popper = _popperjs_core__WEBPACK_IMPORTED_MODULE_0__[\"createPopper\"](this._element, tip, this._getPopperConfig(attachment));\n    }\n\n    tip.classList.add(CLASS_NAME_SHOW$3);\n    const customClass = typeof this._config.customClass === 'function' ? this._config.customClass() : this._config.customClass;\n\n    if (customClass) {\n      tip.classList.add(...customClass.split(' '));\n    } // If this is a touch-enabled device we add extra\n    // empty mouseover listeners to the body's immediate children;\n    // only needed because of broken event delegation on iOS\n    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n\n    if ('ontouchstart' in document.documentElement) {\n      [].concat(...document.body.children).forEach(element => {\n        EventHandler.on(element, 'mouseover', noop);\n      });\n    }\n\n    const complete = () => {\n      const prevHoverState = this._hoverState;\n      this._hoverState = null;\n      EventHandler.trigger(this._element, this.constructor.Event.SHOWN);\n\n      if (prevHoverState === HOVER_STATE_OUT) {\n        this._leave(null, this);\n      }\n    };\n\n    const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$3);\n\n    this._queueCallback(complete, this.tip, isAnimated);\n  }\n\n  hide() {\n    if (!this._popper) {\n      return;\n    }\n\n    const tip = this.getTipElement();\n\n    const complete = () => {\n      if (this._isWithActiveTrigger()) {\n        return;\n      }\n\n      if (this._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {\n        tip.parentNode.removeChild(tip);\n      }\n\n      this._cleanTipClass();\n\n      this._element.removeAttribute('aria-describedby');\n\n      EventHandler.trigger(this._element, this.constructor.Event.HIDDEN);\n\n      if (this._popper) {\n        this._popper.destroy();\n\n        this._popper = null;\n      }\n    };\n\n    const hideEvent = EventHandler.trigger(this._element, this.constructor.Event.HIDE);\n\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n\n    tip.classList.remove(CLASS_NAME_SHOW$3); // If this is a touch-enabled device we remove the extra\n    // empty mouseover listeners we added for iOS support\n\n    if ('ontouchstart' in document.documentElement) {\n      [].concat(...document.body.children).forEach(element => EventHandler.off(element, 'mouseover', noop));\n    }\n\n    this._activeTrigger[TRIGGER_CLICK] = false;\n    this._activeTrigger[TRIGGER_FOCUS] = false;\n    this._activeTrigger[TRIGGER_HOVER] = false;\n    const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$3);\n\n    this._queueCallback(complete, this.tip, isAnimated);\n\n    this._hoverState = '';\n  }\n\n  update() {\n    if (this._popper !== null) {\n      this._popper.update();\n    }\n  } // Protected\n\n\n  isWithContent() {\n    return Boolean(this.getTitle());\n  }\n\n  getTipElement() {\n    if (this.tip) {\n      return this.tip;\n    }\n\n    const element = document.createElement('div');\n    element.innerHTML = this._config.template;\n    this.tip = element.children[0];\n    return this.tip;\n  }\n\n  setContent() {\n    const tip = this.getTipElement();\n    this.setElementContent(SelectorEngine.findOne(SELECTOR_TOOLTIP_INNER, tip), this.getTitle());\n    tip.classList.remove(CLASS_NAME_FADE$3, CLASS_NAME_SHOW$3);\n  }\n\n  setElementContent(element, content) {\n    if (element === null) {\n      return;\n    }\n\n    if (isElement(content)) {\n      content = getElement(content); // content is a DOM node or a jQuery\n\n      if (this._config.html) {\n        if (content.parentNode !== element) {\n          element.innerHTML = '';\n          element.appendChild(content);\n        }\n      } else {\n        element.textContent = content.textContent;\n      }\n\n      return;\n    }\n\n    if (this._config.html) {\n      if (this._config.sanitize) {\n        content = sanitizeHtml(content, this._config.allowList, this._config.sanitizeFn);\n      }\n\n      element.innerHTML = content;\n    } else {\n      element.textContent = content;\n    }\n  }\n\n  getTitle() {\n    let title = this._element.getAttribute('data-bs-original-title');\n\n    if (!title) {\n      title = typeof this._config.title === 'function' ? this._config.title.call(this._element) : this._config.title;\n    }\n\n    return title;\n  }\n\n  updateAttachment(attachment) {\n    if (attachment === 'right') {\n      return 'end';\n    }\n\n    if (attachment === 'left') {\n      return 'start';\n    }\n\n    return attachment;\n  } // Private\n\n\n  _initializeOnDelegatedTarget(event, context) {\n    const dataKey = this.constructor.DATA_KEY;\n    context = context || Data.get(event.delegateTarget, dataKey);\n\n    if (!context) {\n      context = new this.constructor(event.delegateTarget, this._getDelegateConfig());\n      Data.set(event.delegateTarget, dataKey, context);\n    }\n\n    return context;\n  }\n\n  _getOffset() {\n    const {\n      offset\n    } = this._config;\n\n    if (typeof offset === 'string') {\n      return offset.split(',').map(val => Number.parseInt(val, 10));\n    }\n\n    if (typeof offset === 'function') {\n      return popperData => offset(popperData, this._element);\n    }\n\n    return offset;\n  }\n\n  _getPopperConfig(attachment) {\n    const defaultBsPopperConfig = {\n      placement: attachment,\n      modifiers: [{\n        name: 'flip',\n        options: {\n          fallbackPlacements: this._config.fallbackPlacements\n        }\n      }, {\n        name: 'offset',\n        options: {\n          offset: this._getOffset()\n        }\n      }, {\n        name: 'preventOverflow',\n        options: {\n          boundary: this._config.boundary\n        }\n      }, {\n        name: 'arrow',\n        options: {\n          element: `.${this.constructor.NAME}-arrow`\n        }\n      }, {\n        name: 'onChange',\n        enabled: true,\n        phase: 'afterWrite',\n        fn: data => this._handlePopperPlacementChange(data)\n      }],\n      onFirstUpdate: data => {\n        if (data.options.placement !== data.placement) {\n          this._handlePopperPlacementChange(data);\n        }\n      }\n    };\n    return { ...defaultBsPopperConfig,\n      ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)\n    };\n  }\n\n  _addAttachmentClass(attachment) {\n    this.getTipElement().classList.add(`${CLASS_PREFIX$1}-${this.updateAttachment(attachment)}`);\n  }\n\n  _getAttachment(placement) {\n    return AttachmentMap[placement.toUpperCase()];\n  }\n\n  _setListeners() {\n    const triggers = this._config.trigger.split(' ');\n\n    triggers.forEach(trigger => {\n      if (trigger === 'click') {\n        EventHandler.on(this._element, this.constructor.Event.CLICK, this._config.selector, event => this.toggle(event));\n      } else if (trigger !== TRIGGER_MANUAL) {\n        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN;\n        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;\n        EventHandler.on(this._element, eventIn, this._config.selector, event => this._enter(event));\n        EventHandler.on(this._element, eventOut, this._config.selector, event => this._leave(event));\n      }\n    });\n\n    this._hideModalHandler = () => {\n      if (this._element) {\n        this.hide();\n      }\n    };\n\n    EventHandler.on(this._element.closest(`.${CLASS_NAME_MODAL}`), 'hide.bs.modal', this._hideModalHandler);\n\n    if (this._config.selector) {\n      this._config = { ...this._config,\n        trigger: 'manual',\n        selector: ''\n      };\n    } else {\n      this._fixTitle();\n    }\n  }\n\n  _fixTitle() {\n    const title = this._element.getAttribute('title');\n\n    const originalTitleType = typeof this._element.getAttribute('data-bs-original-title');\n\n    if (title || originalTitleType !== 'string') {\n      this._element.setAttribute('data-bs-original-title', title || '');\n\n      if (title && !this._element.getAttribute('aria-label') && !this._element.textContent) {\n        this._element.setAttribute('aria-label', title);\n      }\n\n      this._element.setAttribute('title', '');\n    }\n  }\n\n  _enter(event, context) {\n    context = this._initializeOnDelegatedTarget(event, context);\n\n    if (event) {\n      context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n    }\n\n    if (context.getTipElement().classList.contains(CLASS_NAME_SHOW$3) || context._hoverState === HOVER_STATE_SHOW) {\n      context._hoverState = HOVER_STATE_SHOW;\n      return;\n    }\n\n    clearTimeout(context._timeout);\n    context._hoverState = HOVER_STATE_SHOW;\n\n    if (!context._config.delay || !context._config.delay.show) {\n      context.show();\n      return;\n    }\n\n    context._timeout = setTimeout(() => {\n      if (context._hoverState === HOVER_STATE_SHOW) {\n        context.show();\n      }\n    }, context._config.delay.show);\n  }\n\n  _leave(event, context) {\n    context = this._initializeOnDelegatedTarget(event, context);\n\n    if (event) {\n      context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n    }\n\n    if (context._isWithActiveTrigger()) {\n      return;\n    }\n\n    clearTimeout(context._timeout);\n    context._hoverState = HOVER_STATE_OUT;\n\n    if (!context._config.delay || !context._config.delay.hide) {\n      context.hide();\n      return;\n    }\n\n    context._timeout = setTimeout(() => {\n      if (context._hoverState === HOVER_STATE_OUT) {\n        context.hide();\n      }\n    }, context._config.delay.hide);\n  }\n\n  _isWithActiveTrigger() {\n    for (const trigger in this._activeTrigger) {\n      if (this._activeTrigger[trigger]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _getConfig(config) {\n    const dataAttributes = Manipulator.getDataAttributes(this._element);\n    Object.keys(dataAttributes).forEach(dataAttr => {\n      if (DISALLOWED_ATTRIBUTES.has(dataAttr)) {\n        delete dataAttributes[dataAttr];\n      }\n    });\n    config = { ...this.constructor.Default,\n      ...dataAttributes,\n      ...(typeof config === 'object' && config ? config : {})\n    };\n    config.container = config.container === false ? document.body : getElement(config.container);\n\n    if (typeof config.delay === 'number') {\n      config.delay = {\n        show: config.delay,\n        hide: config.delay\n      };\n    }\n\n    if (typeof config.title === 'number') {\n      config.title = config.title.toString();\n    }\n\n    if (typeof config.content === 'number') {\n      config.content = config.content.toString();\n    }\n\n    typeCheckConfig(NAME$4, config, this.constructor.DefaultType);\n\n    if (config.sanitize) {\n      config.template = sanitizeHtml(config.template, config.allowList, config.sanitizeFn);\n    }\n\n    return config;\n  }\n\n  _getDelegateConfig() {\n    const config = {};\n\n    if (this._config) {\n      for (const key in this._config) {\n        if (this.constructor.Default[key] !== this._config[key]) {\n          config[key] = this._config[key];\n        }\n      }\n    }\n\n    return config;\n  }\n\n  _cleanTipClass() {\n    const tip = this.getTipElement();\n    const tabClass = tip.getAttribute('class').match(BSCLS_PREFIX_REGEX$1);\n\n    if (tabClass !== null && tabClass.length > 0) {\n      tabClass.map(token => token.trim()).forEach(tClass => tip.classList.remove(tClass));\n    }\n  }\n\n  _handlePopperPlacementChange(popperData) {\n    const {\n      state\n    } = popperData;\n\n    if (!state) {\n      return;\n    }\n\n    this.tip = state.elements.popper;\n\n    this._cleanTipClass();\n\n    this._addAttachmentClass(this._getAttachment(state.placement));\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      let data = Data.get(this, DATA_KEY$4);\n\n      const _config = typeof config === 'object' && config;\n\n      if (!data && /dispose|hide/.test(config)) {\n        return;\n      }\n\n      if (!data) {\n        data = new Tooltip(this, _config);\n      }\n\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      }\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Tooltip to jQuery only if jQuery is present\n */\n\n\ndefineJQueryPlugin(Tooltip);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): popover.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$3 = 'popover';\nconst DATA_KEY$3 = 'bs.popover';\nconst EVENT_KEY$3 = `.${DATA_KEY$3}`;\nconst CLASS_PREFIX = 'bs-popover';\nconst BSCLS_PREFIX_REGEX = new RegExp(`(^|\\\\s)${CLASS_PREFIX}\\\\S+`, 'g');\nconst Default$2 = { ...Tooltip.Default,\n  placement: 'right',\n  offset: [0, 8],\n  trigger: 'click',\n  content: '',\n  template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + '</div>'\n};\nconst DefaultType$2 = { ...Tooltip.DefaultType,\n  content: '(string|element|function)'\n};\nconst Event$1 = {\n  HIDE: `hide${EVENT_KEY$3}`,\n  HIDDEN: `hidden${EVENT_KEY$3}`,\n  SHOW: `show${EVENT_KEY$3}`,\n  SHOWN: `shown${EVENT_KEY$3}`,\n  INSERTED: `inserted${EVENT_KEY$3}`,\n  CLICK: `click${EVENT_KEY$3}`,\n  FOCUSIN: `focusin${EVENT_KEY$3}`,\n  FOCUSOUT: `focusout${EVENT_KEY$3}`,\n  MOUSEENTER: `mouseenter${EVENT_KEY$3}`,\n  MOUSELEAVE: `mouseleave${EVENT_KEY$3}`\n};\nconst CLASS_NAME_FADE$2 = 'fade';\nconst CLASS_NAME_SHOW$2 = 'show';\nconst SELECTOR_TITLE = '.popover-header';\nconst SELECTOR_CONTENT = '.popover-body';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Popover extends Tooltip {\n  // Getters\n  static get Default() {\n    return Default$2;\n  }\n\n  static get NAME() {\n    return NAME$3;\n  }\n\n  static get Event() {\n    return Event$1;\n  }\n\n  static get DefaultType() {\n    return DefaultType$2;\n  } // Overrides\n\n\n  isWithContent() {\n    return this.getTitle() || this._getContent();\n  }\n\n  setContent() {\n    const tip = this.getTipElement(); // we use append for html objects to maintain js events\n\n    this.setElementContent(SelectorEngine.findOne(SELECTOR_TITLE, tip), this.getTitle());\n\n    let content = this._getContent();\n\n    if (typeof content === 'function') {\n      content = content.call(this._element);\n    }\n\n    this.setElementContent(SelectorEngine.findOne(SELECTOR_CONTENT, tip), content);\n    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);\n  } // Private\n\n\n  _addAttachmentClass(attachment) {\n    this.getTipElement().classList.add(`${CLASS_PREFIX}-${this.updateAttachment(attachment)}`);\n  }\n\n  _getContent() {\n    return this._element.getAttribute('data-bs-content') || this._config.content;\n  }\n\n  _cleanTipClass() {\n    const tip = this.getTipElement();\n    const tabClass = tip.getAttribute('class').match(BSCLS_PREFIX_REGEX);\n\n    if (tabClass !== null && tabClass.length > 0) {\n      tabClass.map(token => token.trim()).forEach(tClass => tip.classList.remove(tClass));\n    }\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      let data = Data.get(this, DATA_KEY$3);\n\n      const _config = typeof config === 'object' ? config : null;\n\n      if (!data && /dispose|hide/.test(config)) {\n        return;\n      }\n\n      if (!data) {\n        data = new Popover(this, _config);\n        Data.set(this, DATA_KEY$3, data);\n      }\n\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      }\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Popover to jQuery only if jQuery is present\n */\n\n\ndefineJQueryPlugin(Popover);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): scrollspy.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$2 = 'scrollspy';\nconst DATA_KEY$2 = 'bs.scrollspy';\nconst EVENT_KEY$2 = `.${DATA_KEY$2}`;\nconst DATA_API_KEY$1 = '.data-api';\nconst Default$1 = {\n  offset: 10,\n  method: 'auto',\n  target: ''\n};\nconst DefaultType$1 = {\n  offset: 'number',\n  method: 'string',\n  target: '(string|element)'\n};\nconst EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;\nconst EVENT_SCROLL = `scroll${EVENT_KEY$2}`;\nconst EVENT_LOAD_DATA_API = `load${EVENT_KEY$2}${DATA_API_KEY$1}`;\nconst CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\nconst CLASS_NAME_ACTIVE$1 = 'active';\nconst SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\nconst SELECTOR_NAV_LIST_GROUP$1 = '.nav, .list-group';\nconst SELECTOR_NAV_LINKS = '.nav-link';\nconst SELECTOR_NAV_ITEMS = '.nav-item';\nconst SELECTOR_LIST_ITEMS = '.list-group-item';\nconst SELECTOR_DROPDOWN$1 = '.dropdown';\nconst SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\nconst METHOD_OFFSET = 'offset';\nconst METHOD_POSITION = 'position';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass ScrollSpy extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._scrollElement = this._element.tagName === 'BODY' ? window : this._element;\n    this._config = this._getConfig(config);\n    this._selector = `${this._config.target} ${SELECTOR_NAV_LINKS}, ${this._config.target} ${SELECTOR_LIST_ITEMS}, ${this._config.target} .${CLASS_NAME_DROPDOWN_ITEM}`;\n    this._offsets = [];\n    this._targets = [];\n    this._activeTarget = null;\n    this._scrollHeight = 0;\n    EventHandler.on(this._scrollElement, EVENT_SCROLL, () => this._process());\n    this.refresh();\n\n    this._process();\n  } // Getters\n\n\n  static get Default() {\n    return Default$1;\n  }\n\n  static get NAME() {\n    return NAME$2;\n  } // Public\n\n\n  refresh() {\n    const autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;\n    const offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\n    const offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;\n    this._offsets = [];\n    this._targets = [];\n    this._scrollHeight = this._getScrollHeight();\n    const targets = SelectorEngine.find(this._selector);\n    targets.map(element => {\n      const targetSelector = getSelectorFromElement(element);\n      const target = targetSelector ? SelectorEngine.findOne(targetSelector) : null;\n\n      if (target) {\n        const targetBCR = target.getBoundingClientRect();\n\n        if (targetBCR.width || targetBCR.height) {\n          return [Manipulator[offsetMethod](target).top + offsetBase, targetSelector];\n        }\n      }\n\n      return null;\n    }).filter(item => item).sort((a, b) => a[0] - b[0]).forEach(item => {\n      this._offsets.push(item[0]);\n\n      this._targets.push(item[1]);\n    });\n  }\n\n  dispose() {\n    EventHandler.off(this._scrollElement, EVENT_KEY$2);\n    super.dispose();\n  } // Private\n\n\n  _getConfig(config) {\n    config = { ...Default$1,\n      ...Manipulator.getDataAttributes(this._element),\n      ...(typeof config === 'object' && config ? config : {})\n    };\n\n    if (typeof config.target !== 'string' && isElement(config.target)) {\n      let {\n        id\n      } = config.target;\n\n      if (!id) {\n        id = getUID(NAME$2);\n        config.target.id = id;\n      }\n\n      config.target = `#${id}`;\n    }\n\n    typeCheckConfig(NAME$2, config, DefaultType$1);\n    return config;\n  }\n\n  _getScrollTop() {\n    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n  }\n\n  _getScrollHeight() {\n    return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n  }\n\n  _getOffsetHeight() {\n    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n  }\n\n  _process() {\n    const scrollTop = this._getScrollTop() + this._config.offset;\n\n    const scrollHeight = this._getScrollHeight();\n\n    const maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();\n\n    if (this._scrollHeight !== scrollHeight) {\n      this.refresh();\n    }\n\n    if (scrollTop >= maxScroll) {\n      const target = this._targets[this._targets.length - 1];\n\n      if (this._activeTarget !== target) {\n        this._activate(target);\n      }\n\n      return;\n    }\n\n    if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {\n      this._activeTarget = null;\n\n      this._clear();\n\n      return;\n    }\n\n    for (let i = this._offsets.length; i--;) {\n      const isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);\n\n      if (isActiveTarget) {\n        this._activate(this._targets[i]);\n      }\n    }\n  }\n\n  _activate(target) {\n    this._activeTarget = target;\n\n    this._clear();\n\n    const queries = this._selector.split(',').map(selector => `${selector}[data-bs-target=\"${target}\"],${selector}[href=\"${target}\"]`);\n\n    const link = SelectorEngine.findOne(queries.join(','));\n\n    if (link.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, link.closest(SELECTOR_DROPDOWN$1)).classList.add(CLASS_NAME_ACTIVE$1);\n      link.classList.add(CLASS_NAME_ACTIVE$1);\n    } else {\n      // Set triggered link as active\n      link.classList.add(CLASS_NAME_ACTIVE$1);\n      SelectorEngine.parents(link, SELECTOR_NAV_LIST_GROUP$1).forEach(listGroup => {\n        // Set triggered links parents as active\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n        SelectorEngine.prev(listGroup, `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`).forEach(item => item.classList.add(CLASS_NAME_ACTIVE$1)); // Handle special case when .nav-link is inside .nav-item\n\n        SelectorEngine.prev(listGroup, SELECTOR_NAV_ITEMS).forEach(navItem => {\n          SelectorEngine.children(navItem, SELECTOR_NAV_LINKS).forEach(item => item.classList.add(CLASS_NAME_ACTIVE$1));\n        });\n      });\n    }\n\n    EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, {\n      relatedTarget: target\n    });\n  }\n\n  _clear() {\n    SelectorEngine.find(this._selector).filter(node => node.classList.contains(CLASS_NAME_ACTIVE$1)).forEach(node => node.classList.remove(CLASS_NAME_ACTIVE$1));\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = ScrollSpy.getInstance(this) || new ScrollSpy(this, typeof config === 'object' ? config : {});\n\n      if (typeof config !== 'string') {\n        return;\n      }\n\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n\n      data[config]();\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(window, EVENT_LOAD_DATA_API, () => {\n  SelectorEngine.find(SELECTOR_DATA_SPY).forEach(spy => new ScrollSpy(spy));\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .ScrollSpy to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(ScrollSpy);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): tab.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$1 = 'tab';\nconst DATA_KEY$1 = 'bs.tab';\nconst EVENT_KEY$1 = `.${DATA_KEY$1}`;\nconst DATA_API_KEY = '.data-api';\nconst EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;\nconst EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;\nconst EVENT_SHOW$1 = `show${EVENT_KEY$1}`;\nconst EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;\nconst EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}${DATA_API_KEY}`;\nconst CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';\nconst CLASS_NAME_ACTIVE = 'active';\nconst CLASS_NAME_FADE$1 = 'fade';\nconst CLASS_NAME_SHOW$1 = 'show';\nconst SELECTOR_DROPDOWN = '.dropdown';\nconst SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\nconst SELECTOR_ACTIVE = '.active';\nconst SELECTOR_ACTIVE_UL = ':scope > li > .active';\nconst SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]';\nconst SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\nconst SELECTOR_DROPDOWN_ACTIVE_CHILD = ':scope > .dropdown-menu .active';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Tab extends BaseComponent {\n  // Getters\n  static get NAME() {\n    return NAME$1;\n  } // Public\n\n\n  show() {\n    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(CLASS_NAME_ACTIVE)) {\n      return;\n    }\n\n    let previous;\n    const target = getElementFromSelector(this._element);\n\n    const listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);\n\n    if (listElement) {\n      const itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;\n      previous = SelectorEngine.find(itemSelector, listElement);\n      previous = previous[previous.length - 1];\n    }\n\n    const hideEvent = previous ? EventHandler.trigger(previous, EVENT_HIDE$1, {\n      relatedTarget: this._element\n    }) : null;\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$1, {\n      relatedTarget: previous\n    });\n\n    if (showEvent.defaultPrevented || hideEvent !== null && hideEvent.defaultPrevented) {\n      return;\n    }\n\n    this._activate(this._element, listElement);\n\n    const complete = () => {\n      EventHandler.trigger(previous, EVENT_HIDDEN$1, {\n        relatedTarget: this._element\n      });\n      EventHandler.trigger(this._element, EVENT_SHOWN$1, {\n        relatedTarget: previous\n      });\n    };\n\n    if (target) {\n      this._activate(target, target.parentNode, complete);\n    } else {\n      complete();\n    }\n  } // Private\n\n\n  _activate(element, container, callback) {\n    const activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? SelectorEngine.find(SELECTOR_ACTIVE_UL, container) : SelectorEngine.children(container, SELECTOR_ACTIVE);\n    const active = activeElements[0];\n    const isTransitioning = callback && active && active.classList.contains(CLASS_NAME_FADE$1);\n\n    const complete = () => this._transitionComplete(element, active, callback);\n\n    if (active && isTransitioning) {\n      active.classList.remove(CLASS_NAME_SHOW$1);\n\n      this._queueCallback(complete, element, true);\n    } else {\n      complete();\n    }\n  }\n\n  _transitionComplete(element, active, callback) {\n    if (active) {\n      active.classList.remove(CLASS_NAME_ACTIVE);\n      const dropdownChild = SelectorEngine.findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);\n\n      if (dropdownChild) {\n        dropdownChild.classList.remove(CLASS_NAME_ACTIVE);\n      }\n\n      if (active.getAttribute('role') === 'tab') {\n        active.setAttribute('aria-selected', false);\n      }\n    }\n\n    element.classList.add(CLASS_NAME_ACTIVE);\n\n    if (element.getAttribute('role') === 'tab') {\n      element.setAttribute('aria-selected', true);\n    }\n\n    reflow(element);\n\n    if (element.classList.contains(CLASS_NAME_FADE$1)) {\n      element.classList.add(CLASS_NAME_SHOW$1);\n    }\n\n    let parent = element.parentNode;\n\n    if (parent && parent.nodeName === 'LI') {\n      parent = parent.parentNode;\n    }\n\n    if (parent && parent.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {\n      const dropdownElement = element.closest(SELECTOR_DROPDOWN);\n\n      if (dropdownElement) {\n        SelectorEngine.find(SELECTOR_DROPDOWN_TOGGLE, dropdownElement).forEach(dropdown => dropdown.classList.add(CLASS_NAME_ACTIVE));\n      }\n\n      element.setAttribute('aria-expanded', true);\n    }\n\n    if (callback) {\n      callback();\n    }\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Data.get(this, DATA_KEY$1) || new Tab(this);\n\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      }\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\n  if (['A', 'AREA'].includes(this.tagName)) {\n    event.preventDefault();\n  }\n\n  if (isDisabled(this)) {\n    return;\n  }\n\n  const data = Data.get(this, DATA_KEY$1) || new Tab(this);\n  data.show();\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Tab to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Tab);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): toast.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME = 'toast';\nconst DATA_KEY = 'bs.toast';\nconst EVENT_KEY = `.${DATA_KEY}`;\nconst EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY}`;\nconst EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;\nconst EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;\nconst EVENT_FOCUSIN = `focusin${EVENT_KEY}`;\nconst EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;\nconst EVENT_HIDE = `hide${EVENT_KEY}`;\nconst EVENT_HIDDEN = `hidden${EVENT_KEY}`;\nconst EVENT_SHOW = `show${EVENT_KEY}`;\nconst EVENT_SHOWN = `shown${EVENT_KEY}`;\nconst CLASS_NAME_FADE = 'fade';\nconst CLASS_NAME_HIDE = 'hide';\nconst CLASS_NAME_SHOW = 'show';\nconst CLASS_NAME_SHOWING = 'showing';\nconst DefaultType = {\n  animation: 'boolean',\n  autohide: 'boolean',\n  delay: 'number'\n};\nconst Default = {\n  animation: true,\n  autohide: true,\n  delay: 5000\n};\nconst SELECTOR_DATA_DISMISS = '[data-bs-dismiss=\"toast\"]';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Toast extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._config = this._getConfig(config);\n    this._timeout = null;\n    this._hasMouseInteraction = false;\n    this._hasKeyboardInteraction = false;\n\n    this._setListeners();\n  } // Getters\n\n\n  static get DefaultType() {\n    return DefaultType;\n  }\n\n  static get Default() {\n    return Default;\n  }\n\n  static get NAME() {\n    return NAME;\n  } // Public\n\n\n  show() {\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\n\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n\n    this._clearTimeout();\n\n    if (this._config.animation) {\n      this._element.classList.add(CLASS_NAME_FADE);\n    }\n\n    const complete = () => {\n      this._element.classList.remove(CLASS_NAME_SHOWING);\n\n      this._element.classList.add(CLASS_NAME_SHOW);\n\n      EventHandler.trigger(this._element, EVENT_SHOWN);\n\n      this._maybeScheduleHide();\n    };\n\n    this._element.classList.remove(CLASS_NAME_HIDE);\n\n    reflow(this._element);\n\n    this._element.classList.add(CLASS_NAME_SHOWING);\n\n    this._queueCallback(complete, this._element, this._config.animation);\n  }\n\n  hide() {\n    if (!this._element.classList.contains(CLASS_NAME_SHOW)) {\n      return;\n    }\n\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\n\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n\n    const complete = () => {\n      this._element.classList.add(CLASS_NAME_HIDE);\n\n      EventHandler.trigger(this._element, EVENT_HIDDEN);\n    };\n\n    this._element.classList.remove(CLASS_NAME_SHOW);\n\n    this._queueCallback(complete, this._element, this._config.animation);\n  }\n\n  dispose() {\n    this._clearTimeout();\n\n    if (this._element.classList.contains(CLASS_NAME_SHOW)) {\n      this._element.classList.remove(CLASS_NAME_SHOW);\n    }\n\n    super.dispose();\n  } // Private\n\n\n  _getConfig(config) {\n    config = { ...Default,\n      ...Manipulator.getDataAttributes(this._element),\n      ...(typeof config === 'object' && config ? config : {})\n    };\n    typeCheckConfig(NAME, config, this.constructor.DefaultType);\n    return config;\n  }\n\n  _maybeScheduleHide() {\n    if (!this._config.autohide) {\n      return;\n    }\n\n    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n      return;\n    }\n\n    this._timeout = setTimeout(() => {\n      this.hide();\n    }, this._config.delay);\n  }\n\n  _onInteraction(event, isInteracting) {\n    switch (event.type) {\n      case 'mouseover':\n      case 'mouseout':\n        this._hasMouseInteraction = isInteracting;\n        break;\n\n      case 'focusin':\n      case 'focusout':\n        this._hasKeyboardInteraction = isInteracting;\n        break;\n    }\n\n    if (isInteracting) {\n      this._clearTimeout();\n\n      return;\n    }\n\n    const nextElement = event.relatedTarget;\n\n    if (this._element === nextElement || this._element.contains(nextElement)) {\n      return;\n    }\n\n    this._maybeScheduleHide();\n  }\n\n  _setListeners() {\n    EventHandler.on(this._element, EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, () => this.hide());\n    EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));\n    EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));\n    EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));\n    EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));\n  }\n\n  _clearTimeout() {\n    clearTimeout(this._timeout);\n    this._timeout = null;\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      let data = Data.get(this, DATA_KEY);\n\n      const _config = typeof config === 'object' && config;\n\n      if (!data) {\n        data = new Toast(this, _config);\n      }\n\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config](this);\n      }\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Toast to jQuery only if jQuery is present\n */\n\n\ndefineJQueryPlugin(Toast);\n\n\n//# sourceMappingURL=bootstrap.esm.js.map\n\n\n//# sourceURL=webpack:///./node_modules/bootstrap/dist/js/bootstrap.esm.js?")},"./node_modules/feather-icons/dist/feather.js":function node_modulesFeatherIconsDistFeatherJs(module,exports,__webpack_require__){eval('(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(typeof self !== \'undefined\' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tObject.defineProperty(exports, \'__esModule\', { value: true });\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module[\'default\']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, \'a\', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ "./dist/icons.json":\n/*!*************************!*\\\n  !*** ./dist/icons.json ***!\n  \\*************************/\n/*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, aperture, archive, arrow-down-circle, arrow-down-left, arrow-down-right, arrow-down, arrow-left-circle, arrow-left, arrow-right-circle, arrow-right, arrow-up-circle, arrow-up-left, arrow-up-right, arrow-up, at-sign, award, bar-chart-2, bar-chart, battery-charging, battery, bell-off, bell, bluetooth, bold, book-open, book, bookmark, box, briefcase, calendar, camera-off, camera, cast, check-circle, check-square, check, chevron-down, chevron-left, chevron-right, chevron-up, chevrons-down, chevrons-left, chevrons-right, chevrons-up, chrome, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-off, cloud-rain, cloud-snow, cloud, code, codepen, codesandbox, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, divide-circle, divide-square, divide, dollar-sign, download-cloud, download, dribbble, droplet, edit-2, edit-3, edit, external-link, eye-off, eye, facebook, fast-forward, feather, figma, file-minus, file-plus, file-text, file, film, filter, flag, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, grid, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, info, instagram, italic, key, layers, layout, life-buoy, link-2, link, linkedin, list, loader, lock, log-in, log-out, mail, map-pin, map, maximize-2, maximize, meh, menu, message-circle, message-square, mic-off, mic, minimize-2, minimize, minus-circle, minus-square, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation-2, navigation, octagon, package, paperclip, pause-circle, pause, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, pie-chart, play-circle, play, plus-circle, plus-square, plus, pocket, power, printer, radio, refresh-ccw, refresh-cw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, server, settings, share-2, share, shield-off, shield, shopping-bag, shopping-cart, shuffle, sidebar, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, square, star, stop-circle, sun, sunrise, sunset, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, tool, trash-2, trash, trello, trending-down, trending-up, triangle, truck, tv, twitch, twitter, type, umbrella, underline, unlock, upload-cloud, upload, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume-1, volume-2, volume-x, volume, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default */\n/***/ (function(module) {\n\nmodule.exports = {"activity":"<polyline points=\\"22 12 18 12 15 21 9 3 6 12 2 12\\"></polyline>","airplay":"<path d=\\"M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1\\"></path><polygon points=\\"12 15 17 21 7 21 12 15\\"></polygon>","alert-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"16\\" x2=\\"12.01\\" y2=\\"16\\"></line>","alert-octagon":"<polygon points=\\"7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2\\"></polygon><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"16\\" x2=\\"12.01\\" y2=\\"16\\"></line>","alert-triangle":"<path d=\\"M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z\\"></path><line x1=\\"12\\" y1=\\"9\\" x2=\\"12\\" y2=\\"13\\"></line><line x1=\\"12\\" y1=\\"17\\" x2=\\"12.01\\" y2=\\"17\\"></line>","align-center":"<line x1=\\"18\\" y1=\\"10\\" x2=\\"6\\" y2=\\"10\\"></line><line x1=\\"21\\" y1=\\"6\\" x2=\\"3\\" y2=\\"6\\"></line><line x1=\\"21\\" y1=\\"14\\" x2=\\"3\\" y2=\\"14\\"></line><line x1=\\"18\\" y1=\\"18\\" x2=\\"6\\" y2=\\"18\\"></line>","align-justify":"<line x1=\\"21\\" y1=\\"10\\" x2=\\"3\\" y2=\\"10\\"></line><line x1=\\"21\\" y1=\\"6\\" x2=\\"3\\" y2=\\"6\\"></line><line x1=\\"21\\" y1=\\"14\\" x2=\\"3\\" y2=\\"14\\"></line><line x1=\\"21\\" y1=\\"18\\" x2=\\"3\\" y2=\\"18\\"></line>","align-left":"<line x1=\\"17\\" y1=\\"10\\" x2=\\"3\\" y2=\\"10\\"></line><line x1=\\"21\\" y1=\\"6\\" x2=\\"3\\" y2=\\"6\\"></line><line x1=\\"21\\" y1=\\"14\\" x2=\\"3\\" y2=\\"14\\"></line><line x1=\\"17\\" y1=\\"18\\" x2=\\"3\\" y2=\\"18\\"></line>","align-right":"<line x1=\\"21\\" y1=\\"10\\" x2=\\"7\\" y2=\\"10\\"></line><line x1=\\"21\\" y1=\\"6\\" x2=\\"3\\" y2=\\"6\\"></line><line x1=\\"21\\" y1=\\"14\\" x2=\\"3\\" y2=\\"14\\"></line><line x1=\\"21\\" y1=\\"18\\" x2=\\"7\\" y2=\\"18\\"></line>","anchor":"<circle cx=\\"12\\" cy=\\"5\\" r=\\"3\\"></circle><line x1=\\"12\\" y1=\\"22\\" x2=\\"12\\" y2=\\"8\\"></line><path d=\\"M5 12H2a10 10 0 0 0 20 0h-3\\"></path>","aperture":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"14.31\\" y1=\\"8\\" x2=\\"20.05\\" y2=\\"17.94\\"></line><line x1=\\"9.69\\" y1=\\"8\\" x2=\\"21.17\\" y2=\\"8\\"></line><line x1=\\"7.38\\" y1=\\"12\\" x2=\\"13.12\\" y2=\\"2.06\\"></line><line x1=\\"9.69\\" y1=\\"16\\" x2=\\"3.95\\" y2=\\"6.06\\"></line><line x1=\\"14.31\\" y1=\\"16\\" x2=\\"2.83\\" y2=\\"16\\"></line><line x1=\\"16.62\\" y1=\\"12\\" x2=\\"10.88\\" y2=\\"21.94\\"></line>","archive":"<polyline points=\\"21 8 21 21 3 21 3 8\\"></polyline><rect x=\\"1\\" y=\\"3\\" width=\\"22\\" height=\\"5\\"></rect><line x1=\\"10\\" y1=\\"12\\" x2=\\"14\\" y2=\\"12\\"></line>","arrow-down-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polyline points=\\"8 12 12 16 16 12\\"></polyline><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"16\\"></line>","arrow-down-left":"<line x1=\\"17\\" y1=\\"7\\" x2=\\"7\\" y2=\\"17\\"></line><polyline points=\\"17 17 7 17 7 7\\"></polyline>","arrow-down-right":"<line x1=\\"7\\" y1=\\"7\\" x2=\\"17\\" y2=\\"17\\"></line><polyline points=\\"17 7 17 17 7 17\\"></polyline>","arrow-down":"<line x1=\\"12\\" y1=\\"5\\" x2=\\"12\\" y2=\\"19\\"></line><polyline points=\\"19 12 12 19 5 12\\"></polyline>","arrow-left-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polyline points=\\"12 8 8 12 12 16\\"></polyline><line x1=\\"16\\" y1=\\"12\\" x2=\\"8\\" y2=\\"12\\"></line>","arrow-left":"<line x1=\\"19\\" y1=\\"12\\" x2=\\"5\\" y2=\\"12\\"></line><polyline points=\\"12 19 5 12 12 5\\"></polyline>","arrow-right-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polyline points=\\"12 16 16 12 12 8\\"></polyline><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line>","arrow-right":"<line x1=\\"5\\" y1=\\"12\\" x2=\\"19\\" y2=\\"12\\"></line><polyline points=\\"12 5 19 12 12 19\\"></polyline>","arrow-up-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polyline points=\\"16 12 12 8 8 12\\"></polyline><line x1=\\"12\\" y1=\\"16\\" x2=\\"12\\" y2=\\"8\\"></line>","arrow-up-left":"<line x1=\\"17\\" y1=\\"17\\" x2=\\"7\\" y2=\\"7\\"></line><polyline points=\\"7 17 7 7 17 7\\"></polyline>","arrow-up-right":"<line x1=\\"7\\" y1=\\"17\\" x2=\\"17\\" y2=\\"7\\"></line><polyline points=\\"7 7 17 7 17 17\\"></polyline>","arrow-up":"<line x1=\\"12\\" y1=\\"19\\" x2=\\"12\\" y2=\\"5\\"></line><polyline points=\\"5 12 12 5 19 12\\"></polyline>","at-sign":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"4\\"></circle><path d=\\"M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94\\"></path>","award":"<circle cx=\\"12\\" cy=\\"8\\" r=\\"7\\"></circle><polyline points=\\"8.21 13.89 7 23 12 20 17 23 15.79 13.88\\"></polyline>","bar-chart-2":"<line x1=\\"18\\" y1=\\"20\\" x2=\\"18\\" y2=\\"10\\"></line><line x1=\\"12\\" y1=\\"20\\" x2=\\"12\\" y2=\\"4\\"></line><line x1=\\"6\\" y1=\\"20\\" x2=\\"6\\" y2=\\"14\\"></line>","bar-chart":"<line x1=\\"12\\" y1=\\"20\\" x2=\\"12\\" y2=\\"10\\"></line><line x1=\\"18\\" y1=\\"20\\" x2=\\"18\\" y2=\\"4\\"></line><line x1=\\"6\\" y1=\\"20\\" x2=\\"6\\" y2=\\"16\\"></line>","battery-charging":"<path d=\\"M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19\\"></path><line x1=\\"23\\" y1=\\"13\\" x2=\\"23\\" y2=\\"11\\"></line><polyline points=\\"11 6 7 12 13 12 9 18\\"></polyline>","battery":"<rect x=\\"1\\" y=\\"6\\" width=\\"18\\" height=\\"12\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"23\\" y1=\\"13\\" x2=\\"23\\" y2=\\"11\\"></line>","bell-off":"<path d=\\"M13.73 21a2 2 0 0 1-3.46 0\\"></path><path d=\\"M18.63 13A17.89 17.89 0 0 1 18 8\\"></path><path d=\\"M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14\\"></path><path d=\\"M18 8a6 6 0 0 0-9.33-5\\"></path><line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line>","bell":"<path d=\\"M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9\\"></path><path d=\\"M13.73 21a2 2 0 0 1-3.46 0\\"></path>","bluetooth":"<polyline points=\\"6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5\\"></polyline>","bold":"<path d=\\"M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z\\"></path><path d=\\"M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z\\"></path>","book-open":"<path d=\\"M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z\\"></path><path d=\\"M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z\\"></path>","book":"<path d=\\"M4 19.5A2.5 2.5 0 0 1 6.5 17H20\\"></path><path d=\\"M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z\\"></path>","bookmark":"<path d=\\"M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z\\"></path>","box":"<path d=\\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\\"></path><polyline points=\\"3.27 6.96 12 12.01 20.73 6.96\\"></polyline><line x1=\\"12\\" y1=\\"22.08\\" x2=\\"12\\" y2=\\"12\\"></line>","briefcase":"<rect x=\\"2\\" y=\\"7\\" width=\\"20\\" height=\\"14\\" rx=\\"2\\" ry=\\"2\\"></rect><path d=\\"M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16\\"></path>","calendar":"<rect x=\\"3\\" y=\\"4\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"16\\" y1=\\"2\\" x2=\\"16\\" y2=\\"6\\"></line><line x1=\\"8\\" y1=\\"2\\" x2=\\"8\\" y2=\\"6\\"></line><line x1=\\"3\\" y1=\\"10\\" x2=\\"21\\" y2=\\"10\\"></line>","camera-off":"<line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line><path d=\\"M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56\\"></path>","camera":"<path d=\\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\\"></path><circle cx=\\"12\\" cy=\\"13\\" r=\\"4\\"></circle>","cast":"<path d=\\"M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6\\"></path><line x1=\\"2\\" y1=\\"20\\" x2=\\"2.01\\" y2=\\"20\\"></line>","check-circle":"<path d=\\"M22 11.08V12a10 10 0 1 1-5.93-9.14\\"></path><polyline points=\\"22 4 12 14.01 9 11.01\\"></polyline>","check-square":"<polyline points=\\"9 11 12 14 22 4\\"></polyline><path d=\\"M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11\\"></path>","check":"<polyline points=\\"20 6 9 17 4 12\\"></polyline>","chevron-down":"<polyline points=\\"6 9 12 15 18 9\\"></polyline>","chevron-left":"<polyline points=\\"15 18 9 12 15 6\\"></polyline>","chevron-right":"<polyline points=\\"9 18 15 12 9 6\\"></polyline>","chevron-up":"<polyline points=\\"18 15 12 9 6 15\\"></polyline>","chevrons-down":"<polyline points=\\"7 13 12 18 17 13\\"></polyline><polyline points=\\"7 6 12 11 17 6\\"></polyline>","chevrons-left":"<polyline points=\\"11 17 6 12 11 7\\"></polyline><polyline points=\\"18 17 13 12 18 7\\"></polyline>","chevrons-right":"<polyline points=\\"13 17 18 12 13 7\\"></polyline><polyline points=\\"6 17 11 12 6 7\\"></polyline>","chevrons-up":"<polyline points=\\"17 11 12 6 7 11\\"></polyline><polyline points=\\"17 18 12 13 7 18\\"></polyline>","chrome":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><circle cx=\\"12\\" cy=\\"12\\" r=\\"4\\"></circle><line x1=\\"21.17\\" y1=\\"8\\" x2=\\"12\\" y2=\\"8\\"></line><line x1=\\"3.95\\" y1=\\"6.06\\" x2=\\"8.54\\" y2=\\"14\\"></line><line x1=\\"10.88\\" y1=\\"21.94\\" x2=\\"15.46\\" y2=\\"14\\"></line>","circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle>","clipboard":"<path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect>","clock":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polyline points=\\"12 6 12 12 16 14\\"></polyline>","cloud-drizzle":"<line x1=\\"8\\" y1=\\"19\\" x2=\\"8\\" y2=\\"21\\"></line><line x1=\\"8\\" y1=\\"13\\" x2=\\"8\\" y2=\\"15\\"></line><line x1=\\"16\\" y1=\\"19\\" x2=\\"16\\" y2=\\"21\\"></line><line x1=\\"16\\" y1=\\"13\\" x2=\\"16\\" y2=\\"15\\"></line><line x1=\\"12\\" y1=\\"21\\" x2=\\"12\\" y2=\\"23\\"></line><line x1=\\"12\\" y1=\\"15\\" x2=\\"12\\" y2=\\"17\\"></line><path d=\\"M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25\\"></path>","cloud-lightning":"<path d=\\"M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9\\"></path><polyline points=\\"13 11 9 17 15 17 11 23\\"></polyline>","cloud-off":"<path d=\\"M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3\\"></path><line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line>","cloud-rain":"<line x1=\\"16\\" y1=\\"13\\" x2=\\"16\\" y2=\\"21\\"></line><line x1=\\"8\\" y1=\\"13\\" x2=\\"8\\" y2=\\"21\\"></line><line x1=\\"12\\" y1=\\"15\\" x2=\\"12\\" y2=\\"23\\"></line><path d=\\"M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25\\"></path>","cloud-snow":"<path d=\\"M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25\\"></path><line x1=\\"8\\" y1=\\"16\\" x2=\\"8.01\\" y2=\\"16\\"></line><line x1=\\"8\\" y1=\\"20\\" x2=\\"8.01\\" y2=\\"20\\"></line><line x1=\\"12\\" y1=\\"18\\" x2=\\"12.01\\" y2=\\"18\\"></line><line x1=\\"12\\" y1=\\"22\\" x2=\\"12.01\\" y2=\\"22\\"></line><line x1=\\"16\\" y1=\\"16\\" x2=\\"16.01\\" y2=\\"16\\"></line><line x1=\\"16\\" y1=\\"20\\" x2=\\"16.01\\" y2=\\"20\\"></line>","cloud":"<path d=\\"M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z\\"></path>","code":"<polyline points=\\"16 18 22 12 16 6\\"></polyline><polyline points=\\"8 6 2 12 8 18\\"></polyline>","codepen":"<polygon points=\\"12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2\\"></polygon><line x1=\\"12\\" y1=\\"22\\" x2=\\"12\\" y2=\\"15.5\\"></line><polyline points=\\"22 8.5 12 15.5 2 8.5\\"></polyline><polyline points=\\"2 15.5 12 8.5 22 15.5\\"></polyline><line x1=\\"12\\" y1=\\"2\\" x2=\\"12\\" y2=\\"8.5\\"></line>","codesandbox":"<path d=\\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\\"></path><polyline points=\\"7.5 4.21 12 6.81 16.5 4.21\\"></polyline><polyline points=\\"7.5 19.79 7.5 14.6 3 12\\"></polyline><polyline points=\\"21 12 16.5 14.6 16.5 19.79\\"></polyline><polyline points=\\"3.27 6.96 12 12.01 20.73 6.96\\"></polyline><line x1=\\"12\\" y1=\\"22.08\\" x2=\\"12\\" y2=\\"12\\"></line>","coffee":"<path d=\\"M18 8h1a4 4 0 0 1 0 8h-1\\"></path><path d=\\"M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z\\"></path><line x1=\\"6\\" y1=\\"1\\" x2=\\"6\\" y2=\\"4\\"></line><line x1=\\"10\\" y1=\\"1\\" x2=\\"10\\" y2=\\"4\\"></line><line x1=\\"14\\" y1=\\"1\\" x2=\\"14\\" y2=\\"4\\"></line>","columns":"<path d=\\"M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18\\"></path>","command":"<path d=\\"M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z\\"></path>","compass":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polygon points=\\"16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76\\"></polygon>","copy":"<rect x=\\"9\\" y=\\"9\\" width=\\"13\\" height=\\"13\\" rx=\\"2\\" ry=\\"2\\"></rect><path d=\\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\\"></path>","corner-down-left":"<polyline points=\\"9 10 4 15 9 20\\"></polyline><path d=\\"M20 4v7a4 4 0 0 1-4 4H4\\"></path>","corner-down-right":"<polyline points=\\"15 10 20 15 15 20\\"></polyline><path d=\\"M4 4v7a4 4 0 0 0 4 4h12\\"></path>","corner-left-down":"<polyline points=\\"14 15 9 20 4 15\\"></polyline><path d=\\"M20 4h-7a4 4 0 0 0-4 4v12\\"></path>","corner-left-up":"<polyline points=\\"14 9 9 4 4 9\\"></polyline><path d=\\"M20 20h-7a4 4 0 0 1-4-4V4\\"></path>","corner-right-down":"<polyline points=\\"10 15 15 20 20 15\\"></polyline><path d=\\"M4 4h7a4 4 0 0 1 4 4v12\\"></path>","corner-right-up":"<polyline points=\\"10 9 15 4 20 9\\"></polyline><path d=\\"M4 20h7a4 4 0 0 0 4-4V4\\"></path>","corner-up-left":"<polyline points=\\"9 14 4 9 9 4\\"></polyline><path d=\\"M20 20v-7a4 4 0 0 0-4-4H4\\"></path>","corner-up-right":"<polyline points=\\"15 14 20 9 15 4\\"></polyline><path d=\\"M4 20v-7a4 4 0 0 1 4-4h12\\"></path>","cpu":"<rect x=\\"4\\" y=\\"4\\" width=\\"16\\" height=\\"16\\" rx=\\"2\\" ry=\\"2\\"></rect><rect x=\\"9\\" y=\\"9\\" width=\\"6\\" height=\\"6\\"></rect><line x1=\\"9\\" y1=\\"1\\" x2=\\"9\\" y2=\\"4\\"></line><line x1=\\"15\\" y1=\\"1\\" x2=\\"15\\" y2=\\"4\\"></line><line x1=\\"9\\" y1=\\"20\\" x2=\\"9\\" y2=\\"23\\"></line><line x1=\\"15\\" y1=\\"20\\" x2=\\"15\\" y2=\\"23\\"></line><line x1=\\"20\\" y1=\\"9\\" x2=\\"23\\" y2=\\"9\\"></line><line x1=\\"20\\" y1=\\"14\\" x2=\\"23\\" y2=\\"14\\"></line><line x1=\\"1\\" y1=\\"9\\" x2=\\"4\\" y2=\\"9\\"></line><line x1=\\"1\\" y1=\\"14\\" x2=\\"4\\" y2=\\"14\\"></line>","credit-card":"<rect x=\\"1\\" y=\\"4\\" width=\\"22\\" height=\\"16\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"1\\" y1=\\"10\\" x2=\\"23\\" y2=\\"10\\"></line>","crop":"<path d=\\"M6.13 1L6 16a2 2 0 0 0 2 2h15\\"></path><path d=\\"M1 6.13L16 6a2 2 0 0 1 2 2v15\\"></path>","crosshair":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"22\\" y1=\\"12\\" x2=\\"18\\" y2=\\"12\\"></line><line x1=\\"6\\" y1=\\"12\\" x2=\\"2\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"6\\" x2=\\"12\\" y2=\\"2\\"></line><line x1=\\"12\\" y1=\\"22\\" x2=\\"12\\" y2=\\"18\\"></line>","database":"<ellipse cx=\\"12\\" cy=\\"5\\" rx=\\"9\\" ry=\\"3\\"></ellipse><path d=\\"M21 12c0 1.66-4 3-9 3s-9-1.34-9-3\\"></path><path d=\\"M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5\\"></path>","delete":"<path d=\\"M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z\\"></path><line x1=\\"18\\" y1=\\"9\\" x2=\\"12\\" y2=\\"15\\"></line><line x1=\\"12\\" y1=\\"9\\" x2=\\"18\\" y2=\\"15\\"></line>","disc":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><circle cx=\\"12\\" cy=\\"12\\" r=\\"3\\"></circle>","divide-circle":"<line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"16\\" x2=\\"12\\" y2=\\"16\\"></line><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"8\\"></line><circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle>","divide-square":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"16\\" x2=\\"12\\" y2=\\"16\\"></line><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"8\\"></line>","divide":"<circle cx=\\"12\\" cy=\\"6\\" r=\\"2\\"></circle><line x1=\\"5\\" y1=\\"12\\" x2=\\"19\\" y2=\\"12\\"></line><circle cx=\\"12\\" cy=\\"18\\" r=\\"2\\"></circle>","dollar-sign":"<line x1=\\"12\\" y1=\\"1\\" x2=\\"12\\" y2=\\"23\\"></line><path d=\\"M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6\\"></path>","download-cloud":"<polyline points=\\"8 17 12 21 16 17\\"></polyline><line x1=\\"12\\" y1=\\"12\\" x2=\\"12\\" y2=\\"21\\"></line><path d=\\"M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29\\"></path>","download":"<path d=\\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\\"></path><polyline points=\\"7 10 12 15 17 10\\"></polyline><line x1=\\"12\\" y1=\\"15\\" x2=\\"12\\" y2=\\"3\\"></line>","dribbble":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><path d=\\"M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32\\"></path>","droplet":"<path d=\\"M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z\\"></path>","edit-2":"<path d=\\"M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z\\"></path>","edit-3":"<path d=\\"M12 20h9\\"></path><path d=\\"M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z\\"></path>","edit":"<path d=\\"M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7\\"></path><path d=\\"M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z\\"></path>","external-link":"<path d=\\"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\\"></path><polyline points=\\"15 3 21 3 21 9\\"></polyline><line x1=\\"10\\" y1=\\"14\\" x2=\\"21\\" y2=\\"3\\"></line>","eye-off":"<path d=\\"M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24\\"></path><line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line>","eye":"<path d=\\"M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z\\"></path><circle cx=\\"12\\" cy=\\"12\\" r=\\"3\\"></circle>","facebook":"<path d=\\"M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z\\"></path>","fast-forward":"<polygon points=\\"13 19 22 12 13 5 13 19\\"></polygon><polygon points=\\"2 19 11 12 2 5 2 19\\"></polygon>","feather":"<path d=\\"M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z\\"></path><line x1=\\"16\\" y1=\\"8\\" x2=\\"2\\" y2=\\"22\\"></line><line x1=\\"17.5\\" y1=\\"15\\" x2=\\"9\\" y2=\\"15\\"></line>","figma":"<path d=\\"M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z\\"></path><path d=\\"M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z\\"></path><path d=\\"M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z\\"></path><path d=\\"M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z\\"></path><path d=\\"M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z\\"></path>","file-minus":"<path d=\\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\\"></path><polyline points=\\"14 2 14 8 20 8\\"></polyline><line x1=\\"9\\" y1=\\"15\\" x2=\\"15\\" y2=\\"15\\"></line>","file-plus":"<path d=\\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\\"></path><polyline points=\\"14 2 14 8 20 8\\"></polyline><line x1=\\"12\\" y1=\\"18\\" x2=\\"12\\" y2=\\"12\\"></line><line x1=\\"9\\" y1=\\"15\\" x2=\\"15\\" y2=\\"15\\"></line>","file-text":"<path d=\\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\\"></path><polyline points=\\"14 2 14 8 20 8\\"></polyline><line x1=\\"16\\" y1=\\"13\\" x2=\\"8\\" y2=\\"13\\"></line><line x1=\\"16\\" y1=\\"17\\" x2=\\"8\\" y2=\\"17\\"></line><polyline points=\\"10 9 9 9 8 9\\"></polyline>","file":"<path d=\\"M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z\\"></path><polyline points=\\"13 2 13 9 20 9\\"></polyline>","film":"<rect x=\\"2\\" y=\\"2\\" width=\\"20\\" height=\\"20\\" rx=\\"2.18\\" ry=\\"2.18\\"></rect><line x1=\\"7\\" y1=\\"2\\" x2=\\"7\\" y2=\\"22\\"></line><line x1=\\"17\\" y1=\\"2\\" x2=\\"17\\" y2=\\"22\\"></line><line x1=\\"2\\" y1=\\"12\\" x2=\\"22\\" y2=\\"12\\"></line><line x1=\\"2\\" y1=\\"7\\" x2=\\"7\\" y2=\\"7\\"></line><line x1=\\"2\\" y1=\\"17\\" x2=\\"7\\" y2=\\"17\\"></line><line x1=\\"17\\" y1=\\"17\\" x2=\\"22\\" y2=\\"17\\"></line><line x1=\\"17\\" y1=\\"7\\" x2=\\"22\\" y2=\\"7\\"></line>","filter":"<polygon points=\\"22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3\\"></polygon>","flag":"<path d=\\"M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z\\"></path><line x1=\\"4\\" y1=\\"22\\" x2=\\"4\\" y2=\\"15\\"></line>","folder-minus":"<path d=\\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\\"></path><line x1=\\"9\\" y1=\\"14\\" x2=\\"15\\" y2=\\"14\\"></line>","folder-plus":"<path d=\\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\\"></path><line x1=\\"12\\" y1=\\"11\\" x2=\\"12\\" y2=\\"17\\"></line><line x1=\\"9\\" y1=\\"14\\" x2=\\"15\\" y2=\\"14\\"></line>","folder":"<path d=\\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\\"></path>","framer":"<path d=\\"M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7\\"></path>","frown":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><path d=\\"M16 16s-1.5-2-4-2-4 2-4 2\\"></path><line x1=\\"9\\" y1=\\"9\\" x2=\\"9.01\\" y2=\\"9\\"></line><line x1=\\"15\\" y1=\\"9\\" x2=\\"15.01\\" y2=\\"9\\"></line>","gift":"<polyline points=\\"20 12 20 22 4 22 4 12\\"></polyline><rect x=\\"2\\" y=\\"7\\" width=\\"20\\" height=\\"5\\"></rect><line x1=\\"12\\" y1=\\"22\\" x2=\\"12\\" y2=\\"7\\"></line><path d=\\"M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z\\"></path><path d=\\"M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z\\"></path>","git-branch":"<line x1=\\"6\\" y1=\\"3\\" x2=\\"6\\" y2=\\"15\\"></line><circle cx=\\"18\\" cy=\\"6\\" r=\\"3\\"></circle><circle cx=\\"6\\" cy=\\"18\\" r=\\"3\\"></circle><path d=\\"M18 9a9 9 0 0 1-9 9\\"></path>","git-commit":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"4\\"></circle><line x1=\\"1.05\\" y1=\\"12\\" x2=\\"7\\" y2=\\"12\\"></line><line x1=\\"17.01\\" y1=\\"12\\" x2=\\"22.96\\" y2=\\"12\\"></line>","git-merge":"<circle cx=\\"18\\" cy=\\"18\\" r=\\"3\\"></circle><circle cx=\\"6\\" cy=\\"6\\" r=\\"3\\"></circle><path d=\\"M6 21V9a9 9 0 0 0 9 9\\"></path>","git-pull-request":"<circle cx=\\"18\\" cy=\\"18\\" r=\\"3\\"></circle><circle cx=\\"6\\" cy=\\"6\\" r=\\"3\\"></circle><path d=\\"M13 6h3a2 2 0 0 1 2 2v7\\"></path><line x1=\\"6\\" y1=\\"9\\" x2=\\"6\\" y2=\\"21\\"></line>","github":"<path d=\\"M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22\\"></path>","gitlab":"<path d=\\"M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z\\"></path>","globe":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"2\\" y1=\\"12\\" x2=\\"22\\" y2=\\"12\\"></line><path d=\\"M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z\\"></path>","grid":"<rect x=\\"3\\" y=\\"3\\" width=\\"7\\" height=\\"7\\"></rect><rect x=\\"14\\" y=\\"3\\" width=\\"7\\" height=\\"7\\"></rect><rect x=\\"14\\" y=\\"14\\" width=\\"7\\" height=\\"7\\"></rect><rect x=\\"3\\" y=\\"14\\" width=\\"7\\" height=\\"7\\"></rect>","hard-drive":"<line x1=\\"22\\" y1=\\"12\\" x2=\\"2\\" y2=\\"12\\"></line><path d=\\"M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z\\"></path><line x1=\\"6\\" y1=\\"16\\" x2=\\"6.01\\" y2=\\"16\\"></line><line x1=\\"10\\" y1=\\"16\\" x2=\\"10.01\\" y2=\\"16\\"></line>","hash":"<line x1=\\"4\\" y1=\\"9\\" x2=\\"20\\" y2=\\"9\\"></line><line x1=\\"4\\" y1=\\"15\\" x2=\\"20\\" y2=\\"15\\"></line><line x1=\\"10\\" y1=\\"3\\" x2=\\"8\\" y2=\\"21\\"></line><line x1=\\"16\\" y1=\\"3\\" x2=\\"14\\" y2=\\"21\\"></line>","headphones":"<path d=\\"M3 18v-6a9 9 0 0 1 18 0v6\\"></path><path d=\\"M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z\\"></path>","heart":"<path d=\\"M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z\\"></path>","help-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><path d=\\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\\"></path><line x1=\\"12\\" y1=\\"17\\" x2=\\"12.01\\" y2=\\"17\\"></line>","hexagon":"<path d=\\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\\"></path>","home":"<path d=\\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\\"></path><polyline points=\\"9 22 9 12 15 12 15 22\\"></polyline>","image":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><circle cx=\\"8.5\\" cy=\\"8.5\\" r=\\"1.5\\"></circle><polyline points=\\"21 15 16 10 5 21\\"></polyline>","inbox":"<polyline points=\\"22 12 16 12 14 15 10 15 8 12 2 12\\"></polyline><path d=\\"M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z\\"></path>","info":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"12\\" y1=\\"16\\" x2=\\"12\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"8\\" x2=\\"12.01\\" y2=\\"8\\"></line>","instagram":"<rect x=\\"2\\" y=\\"2\\" width=\\"20\\" height=\\"20\\" rx=\\"5\\" ry=\\"5\\"></rect><path d=\\"M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z\\"></path><line x1=\\"17.5\\" y1=\\"6.5\\" x2=\\"17.51\\" y2=\\"6.5\\"></line>","italic":"<line x1=\\"19\\" y1=\\"4\\" x2=\\"10\\" y2=\\"4\\"></line><line x1=\\"14\\" y1=\\"20\\" x2=\\"5\\" y2=\\"20\\"></line><line x1=\\"15\\" y1=\\"4\\" x2=\\"9\\" y2=\\"20\\"></line>","key":"<path d=\\"M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4\\"></path>","layers":"<polygon points=\\"12 2 2 7 12 12 22 7 12 2\\"></polygon><polyline points=\\"2 17 12 22 22 17\\"></polyline><polyline points=\\"2 12 12 17 22 12\\"></polyline>","layout":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"3\\" y1=\\"9\\" x2=\\"21\\" y2=\\"9\\"></line><line x1=\\"9\\" y1=\\"21\\" x2=\\"9\\" y2=\\"9\\"></line>","life-buoy":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><circle cx=\\"12\\" cy=\\"12\\" r=\\"4\\"></circle><line x1=\\"4.93\\" y1=\\"4.93\\" x2=\\"9.17\\" y2=\\"9.17\\"></line><line x1=\\"14.83\\" y1=\\"14.83\\" x2=\\"19.07\\" y2=\\"19.07\\"></line><line x1=\\"14.83\\" y1=\\"9.17\\" x2=\\"19.07\\" y2=\\"4.93\\"></line><line x1=\\"14.83\\" y1=\\"9.17\\" x2=\\"18.36\\" y2=\\"5.64\\"></line><line x1=\\"4.93\\" y1=\\"19.07\\" x2=\\"9.17\\" y2=\\"14.83\\"></line>","link-2":"<path d=\\"M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3\\"></path><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line>","link":"<path d=\\"M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71\\"></path><path d=\\"M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71\\"></path>","linkedin":"<path d=\\"M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z\\"></path><rect x=\\"2\\" y=\\"9\\" width=\\"4\\" height=\\"12\\"></rect><circle cx=\\"4\\" cy=\\"4\\" r=\\"2\\"></circle>","list":"<line x1=\\"8\\" y1=\\"6\\" x2=\\"21\\" y2=\\"6\\"></line><line x1=\\"8\\" y1=\\"12\\" x2=\\"21\\" y2=\\"12\\"></line><line x1=\\"8\\" y1=\\"18\\" x2=\\"21\\" y2=\\"18\\"></line><line x1=\\"3\\" y1=\\"6\\" x2=\\"3.01\\" y2=\\"6\\"></line><line x1=\\"3\\" y1=\\"12\\" x2=\\"3.01\\" y2=\\"12\\"></line><line x1=\\"3\\" y1=\\"18\\" x2=\\"3.01\\" y2=\\"18\\"></line>","loader":"<line x1=\\"12\\" y1=\\"2\\" x2=\\"12\\" y2=\\"6\\"></line><line x1=\\"12\\" y1=\\"18\\" x2=\\"12\\" y2=\\"22\\"></line><line x1=\\"4.93\\" y1=\\"4.93\\" x2=\\"7.76\\" y2=\\"7.76\\"></line><line x1=\\"16.24\\" y1=\\"16.24\\" x2=\\"19.07\\" y2=\\"19.07\\"></line><line x1=\\"2\\" y1=\\"12\\" x2=\\"6\\" y2=\\"12\\"></line><line x1=\\"18\\" y1=\\"12\\" x2=\\"22\\" y2=\\"12\\"></line><line x1=\\"4.93\\" y1=\\"19.07\\" x2=\\"7.76\\" y2=\\"16.24\\"></line><line x1=\\"16.24\\" y1=\\"7.76\\" x2=\\"19.07\\" y2=\\"4.93\\"></line>","lock":"<rect x=\\"3\\" y=\\"11\\" width=\\"18\\" height=\\"11\\" rx=\\"2\\" ry=\\"2\\"></rect><path d=\\"M7 11V7a5 5 0 0 1 10 0v4\\"></path>","log-in":"<path d=\\"M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4\\"></path><polyline points=\\"10 17 15 12 10 7\\"></polyline><line x1=\\"15\\" y1=\\"12\\" x2=\\"3\\" y2=\\"12\\"></line>","log-out":"<path d=\\"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4\\"></path><polyline points=\\"16 17 21 12 16 7\\"></polyline><line x1=\\"21\\" y1=\\"12\\" x2=\\"9\\" y2=\\"12\\"></line>","mail":"<path d=\\"M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z\\"></path><polyline points=\\"22,6 12,13 2,6\\"></polyline>","map-pin":"<path d=\\"M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z\\"></path><circle cx=\\"12\\" cy=\\"10\\" r=\\"3\\"></circle>","map":"<polygon points=\\"1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6\\"></polygon><line x1=\\"8\\" y1=\\"2\\" x2=\\"8\\" y2=\\"18\\"></line><line x1=\\"16\\" y1=\\"6\\" x2=\\"16\\" y2=\\"22\\"></line>","maximize-2":"<polyline points=\\"15 3 21 3 21 9\\"></polyline><polyline points=\\"9 21 3 21 3 15\\"></polyline><line x1=\\"21\\" y1=\\"3\\" x2=\\"14\\" y2=\\"10\\"></line><line x1=\\"3\\" y1=\\"21\\" x2=\\"10\\" y2=\\"14\\"></line>","maximize":"<path d=\\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\\"></path>","meh":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"8\\" y1=\\"15\\" x2=\\"16\\" y2=\\"15\\"></line><line x1=\\"9\\" y1=\\"9\\" x2=\\"9.01\\" y2=\\"9\\"></line><line x1=\\"15\\" y1=\\"9\\" x2=\\"15.01\\" y2=\\"9\\"></line>","menu":"<line x1=\\"3\\" y1=\\"12\\" x2=\\"21\\" y2=\\"12\\"></line><line x1=\\"3\\" y1=\\"6\\" x2=\\"21\\" y2=\\"6\\"></line><line x1=\\"3\\" y1=\\"18\\" x2=\\"21\\" y2=\\"18\\"></line>","message-circle":"<path d=\\"M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z\\"></path>","message-square":"<path d=\\"M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z\\"></path>","mic-off":"<line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line><path d=\\"M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6\\"></path><path d=\\"M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23\\"></path><line x1=\\"12\\" y1=\\"19\\" x2=\\"12\\" y2=\\"23\\"></line><line x1=\\"8\\" y1=\\"23\\" x2=\\"16\\" y2=\\"23\\"></line>","mic":"<path d=\\"M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z\\"></path><path d=\\"M19 10v2a7 7 0 0 1-14 0v-2\\"></path><line x1=\\"12\\" y1=\\"19\\" x2=\\"12\\" y2=\\"23\\"></line><line x1=\\"8\\" y1=\\"23\\" x2=\\"16\\" y2=\\"23\\"></line>","minimize-2":"<polyline points=\\"4 14 10 14 10 20\\"></polyline><polyline points=\\"20 10 14 10 14 4\\"></polyline><line x1=\\"14\\" y1=\\"10\\" x2=\\"21\\" y2=\\"3\\"></line><line x1=\\"3\\" y1=\\"21\\" x2=\\"10\\" y2=\\"14\\"></line>","minimize":"<path d=\\"M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3\\"></path>","minus-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line>","minus-square":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line>","minus":"<line x1=\\"5\\" y1=\\"12\\" x2=\\"19\\" y2=\\"12\\"></line>","monitor":"<rect x=\\"2\\" y=\\"3\\" width=\\"20\\" height=\\"14\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"8\\" y1=\\"21\\" x2=\\"16\\" y2=\\"21\\"></line><line x1=\\"12\\" y1=\\"17\\" x2=\\"12\\" y2=\\"21\\"></line>","moon":"<path d=\\"M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z\\"></path>","more-horizontal":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"1\\"></circle><circle cx=\\"19\\" cy=\\"12\\" r=\\"1\\"></circle><circle cx=\\"5\\" cy=\\"12\\" r=\\"1\\"></circle>","more-vertical":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"1\\"></circle><circle cx=\\"12\\" cy=\\"5\\" r=\\"1\\"></circle><circle cx=\\"12\\" cy=\\"19\\" r=\\"1\\"></circle>","mouse-pointer":"<path d=\\"M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z\\"></path><path d=\\"M13 13l6 6\\"></path>","move":"<polyline points=\\"5 9 2 12 5 15\\"></polyline><polyline points=\\"9 5 12 2 15 5\\"></polyline><polyline points=\\"15 19 12 22 9 19\\"></polyline><polyline points=\\"19 9 22 12 19 15\\"></polyline><line x1=\\"2\\" y1=\\"12\\" x2=\\"22\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"2\\" x2=\\"12\\" y2=\\"22\\"></line>","music":"<path d=\\"M9 18V5l12-2v13\\"></path><circle cx=\\"6\\" cy=\\"18\\" r=\\"3\\"></circle><circle cx=\\"18\\" cy=\\"16\\" r=\\"3\\"></circle>","navigation-2":"<polygon points=\\"12 2 19 21 12 17 5 21 12 2\\"></polygon>","navigation":"<polygon points=\\"3 11 22 2 13 21 11 13 3 11\\"></polygon>","octagon":"<polygon points=\\"7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2\\"></polygon>","package":"<line x1=\\"16.5\\" y1=\\"9.4\\" x2=\\"7.5\\" y2=\\"4.21\\"></line><path d=\\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\\"></path><polyline points=\\"3.27 6.96 12 12.01 20.73 6.96\\"></polyline><line x1=\\"12\\" y1=\\"22.08\\" x2=\\"12\\" y2=\\"12\\"></line>","paperclip":"<path d=\\"M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48\\"></path>","pause-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"10\\" y1=\\"15\\" x2=\\"10\\" y2=\\"9\\"></line><line x1=\\"14\\" y1=\\"15\\" x2=\\"14\\" y2=\\"9\\"></line>","pause":"<rect x=\\"6\\" y=\\"4\\" width=\\"4\\" height=\\"16\\"></rect><rect x=\\"14\\" y=\\"4\\" width=\\"4\\" height=\\"16\\"></rect>","pen-tool":"<path d=\\"M12 19l7-7 3 3-7 7-3-3z\\"></path><path d=\\"M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z\\"></path><path d=\\"M2 2l7.586 7.586\\"></path><circle cx=\\"11\\" cy=\\"11\\" r=\\"2\\"></circle>","percent":"<line x1=\\"19\\" y1=\\"5\\" x2=\\"5\\" y2=\\"19\\"></line><circle cx=\\"6.5\\" cy=\\"6.5\\" r=\\"2.5\\"></circle><circle cx=\\"17.5\\" cy=\\"17.5\\" r=\\"2.5\\"></circle>","phone-call":"<path d=\\"M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\\"></path>","phone-forwarded":"<polyline points=\\"19 1 23 5 19 9\\"></polyline><line x1=\\"15\\" y1=\\"5\\" x2=\\"23\\" y2=\\"5\\"></line><path d=\\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\\"></path>","phone-incoming":"<polyline points=\\"16 2 16 8 22 8\\"></polyline><line x1=\\"23\\" y1=\\"1\\" x2=\\"16\\" y2=\\"8\\"></line><path d=\\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\\"></path>","phone-missed":"<line x1=\\"23\\" y1=\\"1\\" x2=\\"17\\" y2=\\"7\\"></line><line x1=\\"17\\" y1=\\"1\\" x2=\\"23\\" y2=\\"7\\"></line><path d=\\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\\"></path>","phone-off":"<path d=\\"M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91\\"></path><line x1=\\"23\\" y1=\\"1\\" x2=\\"1\\" y2=\\"23\\"></line>","phone-outgoing":"<polyline points=\\"23 7 23 1 17 1\\"></polyline><line x1=\\"16\\" y1=\\"8\\" x2=\\"23\\" y2=\\"1\\"></line><path d=\\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\\"></path>","phone":"<path d=\\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\\"></path>","pie-chart":"<path d=\\"M21.21 15.89A10 10 0 1 1 8 2.83\\"></path><path d=\\"M22 12A10 10 0 0 0 12 2v10z\\"></path>","play-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polygon points=\\"10 8 16 12 10 16 10 8\\"></polygon>","play":"<polygon points=\\"5 3 19 12 5 21 5 3\\"></polygon>","plus-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"16\\"></line><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line>","plus-square":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"16\\"></line><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line>","plus":"<line x1=\\"12\\" y1=\\"5\\" x2=\\"12\\" y2=\\"19\\"></line><line x1=\\"5\\" y1=\\"12\\" x2=\\"19\\" y2=\\"12\\"></line>","pocket":"<path d=\\"M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z\\"></path><polyline points=\\"8 10 12 14 16 10\\"></polyline>","power":"<path d=\\"M18.36 6.64a9 9 0 1 1-12.73 0\\"></path><line x1=\\"12\\" y1=\\"2\\" x2=\\"12\\" y2=\\"12\\"></line>","printer":"<polyline points=\\"6 9 6 2 18 2 18 9\\"></polyline><path d=\\"M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2\\"></path><rect x=\\"6\\" y=\\"14\\" width=\\"12\\" height=\\"8\\"></rect>","radio":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"2\\"></circle><path d=\\"M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14\\"></path>","refresh-ccw":"<polyline points=\\"1 4 1 10 7 10\\"></polyline><polyline points=\\"23 20 23 14 17 14\\"></polyline><path d=\\"M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15\\"></path>","refresh-cw":"<polyline points=\\"23 4 23 10 17 10\\"></polyline><polyline points=\\"1 20 1 14 7 14\\"></polyline><path d=\\"M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15\\"></path>","repeat":"<polyline points=\\"17 1 21 5 17 9\\"></polyline><path d=\\"M3 11V9a4 4 0 0 1 4-4h14\\"></path><polyline points=\\"7 23 3 19 7 15\\"></polyline><path d=\\"M21 13v2a4 4 0 0 1-4 4H3\\"></path>","rewind":"<polygon points=\\"11 19 2 12 11 5 11 19\\"></polygon><polygon points=\\"22 19 13 12 22 5 22 19\\"></polygon>","rotate-ccw":"<polyline points=\\"1 4 1 10 7 10\\"></polyline><path d=\\"M3.51 15a9 9 0 1 0 2.13-9.36L1 10\\"></path>","rotate-cw":"<polyline points=\\"23 4 23 10 17 10\\"></polyline><path d=\\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\\"></path>","rss":"<path d=\\"M4 11a9 9 0 0 1 9 9\\"></path><path d=\\"M4 4a16 16 0 0 1 16 16\\"></path><circle cx=\\"5\\" cy=\\"19\\" r=\\"1\\"></circle>","save":"<path d=\\"M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z\\"></path><polyline points=\\"17 21 17 13 7 13 7 21\\"></polyline><polyline points=\\"7 3 7 8 15 8\\"></polyline>","scissors":"<circle cx=\\"6\\" cy=\\"6\\" r=\\"3\\"></circle><circle cx=\\"6\\" cy=\\"18\\" r=\\"3\\"></circle><line x1=\\"20\\" y1=\\"4\\" x2=\\"8.12\\" y2=\\"15.88\\"></line><line x1=\\"14.47\\" y1=\\"14.48\\" x2=\\"20\\" y2=\\"20\\"></line><line x1=\\"8.12\\" y1=\\"8.12\\" x2=\\"12\\" y2=\\"12\\"></line>","search":"<circle cx=\\"11\\" cy=\\"11\\" r=\\"8\\"></circle><line x1=\\"21\\" y1=\\"21\\" x2=\\"16.65\\" y2=\\"16.65\\"></line>","send":"<line x1=\\"22\\" y1=\\"2\\" x2=\\"11\\" y2=\\"13\\"></line><polygon points=\\"22 2 15 22 11 13 2 9 22 2\\"></polygon>","server":"<rect x=\\"2\\" y=\\"2\\" width=\\"20\\" height=\\"8\\" rx=\\"2\\" ry=\\"2\\"></rect><rect x=\\"2\\" y=\\"14\\" width=\\"20\\" height=\\"8\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"6\\" y1=\\"6\\" x2=\\"6.01\\" y2=\\"6\\"></line><line x1=\\"6\\" y1=\\"18\\" x2=\\"6.01\\" y2=\\"18\\"></line>","settings":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"3\\"></circle><path d=\\"M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z\\"></path>","share-2":"<circle cx=\\"18\\" cy=\\"5\\" r=\\"3\\"></circle><circle cx=\\"6\\" cy=\\"12\\" r=\\"3\\"></circle><circle cx=\\"18\\" cy=\\"19\\" r=\\"3\\"></circle><line x1=\\"8.59\\" y1=\\"13.51\\" x2=\\"15.42\\" y2=\\"17.49\\"></line><line x1=\\"15.41\\" y1=\\"6.51\\" x2=\\"8.59\\" y2=\\"10.49\\"></line>","share":"<path d=\\"M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8\\"></path><polyline points=\\"16 6 12 2 8 6\\"></polyline><line x1=\\"12\\" y1=\\"2\\" x2=\\"12\\" y2=\\"15\\"></line>","shield-off":"<path d=\\"M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18\\"></path><path d=\\"M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38\\"></path><line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line>","shield":"<path d=\\"M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z\\"></path>","shopping-bag":"<path d=\\"M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z\\"></path><line x1=\\"3\\" y1=\\"6\\" x2=\\"21\\" y2=\\"6\\"></line><path d=\\"M16 10a4 4 0 0 1-8 0\\"></path>","shopping-cart":"<circle cx=\\"9\\" cy=\\"21\\" r=\\"1\\"></circle><circle cx=\\"20\\" cy=\\"21\\" r=\\"1\\"></circle><path d=\\"M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6\\"></path>","shuffle":"<polyline points=\\"16 3 21 3 21 8\\"></polyline><line x1=\\"4\\" y1=\\"20\\" x2=\\"21\\" y2=\\"3\\"></line><polyline points=\\"21 16 21 21 16 21\\"></polyline><line x1=\\"15\\" y1=\\"15\\" x2=\\"21\\" y2=\\"21\\"></line><line x1=\\"4\\" y1=\\"4\\" x2=\\"9\\" y2=\\"9\\"></line>","sidebar":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"9\\" y1=\\"3\\" x2=\\"9\\" y2=\\"21\\"></line>","skip-back":"<polygon points=\\"19 20 9 12 19 4 19 20\\"></polygon><line x1=\\"5\\" y1=\\"19\\" x2=\\"5\\" y2=\\"5\\"></line>","skip-forward":"<polygon points=\\"5 4 15 12 5 20 5 4\\"></polygon><line x1=\\"19\\" y1=\\"5\\" x2=\\"19\\" y2=\\"19\\"></line>","slack":"<path d=\\"M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z\\"></path><path d=\\"M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z\\"></path><path d=\\"M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z\\"></path><path d=\\"M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z\\"></path><path d=\\"M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z\\"></path><path d=\\"M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z\\"></path><path d=\\"M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z\\"></path><path d=\\"M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z\\"></path>","slash":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"4.93\\" y1=\\"4.93\\" x2=\\"19.07\\" y2=\\"19.07\\"></line>","sliders":"<line x1=\\"4\\" y1=\\"21\\" x2=\\"4\\" y2=\\"14\\"></line><line x1=\\"4\\" y1=\\"10\\" x2=\\"4\\" y2=\\"3\\"></line><line x1=\\"12\\" y1=\\"21\\" x2=\\"12\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"3\\"></line><line x1=\\"20\\" y1=\\"21\\" x2=\\"20\\" y2=\\"16\\"></line><line x1=\\"20\\" y1=\\"12\\" x2=\\"20\\" y2=\\"3\\"></line><line x1=\\"1\\" y1=\\"14\\" x2=\\"7\\" y2=\\"14\\"></line><line x1=\\"9\\" y1=\\"8\\" x2=\\"15\\" y2=\\"8\\"></line><line x1=\\"17\\" y1=\\"16\\" x2=\\"23\\" y2=\\"16\\"></line>","smartphone":"<rect x=\\"5\\" y=\\"2\\" width=\\"14\\" height=\\"20\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"12\\" y1=\\"18\\" x2=\\"12.01\\" y2=\\"18\\"></line>","smile":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><path d=\\"M8 14s1.5 2 4 2 4-2 4-2\\"></path><line x1=\\"9\\" y1=\\"9\\" x2=\\"9.01\\" y2=\\"9\\"></line><line x1=\\"15\\" y1=\\"9\\" x2=\\"15.01\\" y2=\\"9\\"></line>","speaker":"<rect x=\\"4\\" y=\\"2\\" width=\\"16\\" height=\\"20\\" rx=\\"2\\" ry=\\"2\\"></rect><circle cx=\\"12\\" cy=\\"14\\" r=\\"4\\"></circle><line x1=\\"12\\" y1=\\"6\\" x2=\\"12.01\\" y2=\\"6\\"></line>","square":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect>","star":"<polygon points=\\"12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2\\"></polygon>","stop-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><rect x=\\"9\\" y=\\"9\\" width=\\"6\\" height=\\"6\\"></rect>","sun":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"5\\"></circle><line x1=\\"12\\" y1=\\"1\\" x2=\\"12\\" y2=\\"3\\"></line><line x1=\\"12\\" y1=\\"21\\" x2=\\"12\\" y2=\\"23\\"></line><line x1=\\"4.22\\" y1=\\"4.22\\" x2=\\"5.64\\" y2=\\"5.64\\"></line><line x1=\\"18.36\\" y1=\\"18.36\\" x2=\\"19.78\\" y2=\\"19.78\\"></line><line x1=\\"1\\" y1=\\"12\\" x2=\\"3\\" y2=\\"12\\"></line><line x1=\\"21\\" y1=\\"12\\" x2=\\"23\\" y2=\\"12\\"></line><line x1=\\"4.22\\" y1=\\"19.78\\" x2=\\"5.64\\" y2=\\"18.36\\"></line><line x1=\\"18.36\\" y1=\\"5.64\\" x2=\\"19.78\\" y2=\\"4.22\\"></line>","sunrise":"<path d=\\"M17 18a5 5 0 0 0-10 0\\"></path><line x1=\\"12\\" y1=\\"2\\" x2=\\"12\\" y2=\\"9\\"></line><line x1=\\"4.22\\" y1=\\"10.22\\" x2=\\"5.64\\" y2=\\"11.64\\"></line><line x1=\\"1\\" y1=\\"18\\" x2=\\"3\\" y2=\\"18\\"></line><line x1=\\"21\\" y1=\\"18\\" x2=\\"23\\" y2=\\"18\\"></line><line x1=\\"18.36\\" y1=\\"11.64\\" x2=\\"19.78\\" y2=\\"10.22\\"></line><line x1=\\"23\\" y1=\\"22\\" x2=\\"1\\" y2=\\"22\\"></line><polyline points=\\"8 6 12 2 16 6\\"></polyline>","sunset":"<path d=\\"M17 18a5 5 0 0 0-10 0\\"></path><line x1=\\"12\\" y1=\\"9\\" x2=\\"12\\" y2=\\"2\\"></line><line x1=\\"4.22\\" y1=\\"10.22\\" x2=\\"5.64\\" y2=\\"11.64\\"></line><line x1=\\"1\\" y1=\\"18\\" x2=\\"3\\" y2=\\"18\\"></line><line x1=\\"21\\" y1=\\"18\\" x2=\\"23\\" y2=\\"18\\"></line><line x1=\\"18.36\\" y1=\\"11.64\\" x2=\\"19.78\\" y2=\\"10.22\\"></line><line x1=\\"23\\" y1=\\"22\\" x2=\\"1\\" y2=\\"22\\"></line><polyline points=\\"16 5 12 9 8 5\\"></polyline>","tablet":"<rect x=\\"4\\" y=\\"2\\" width=\\"16\\" height=\\"20\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"12\\" y1=\\"18\\" x2=\\"12.01\\" y2=\\"18\\"></line>","tag":"<path d=\\"M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z\\"></path><line x1=\\"7\\" y1=\\"7\\" x2=\\"7.01\\" y2=\\"7\\"></line>","target":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><circle cx=\\"12\\" cy=\\"12\\" r=\\"6\\"></circle><circle cx=\\"12\\" cy=\\"12\\" r=\\"2\\"></circle>","terminal":"<polyline points=\\"4 17 10 11 4 5\\"></polyline><line x1=\\"12\\" y1=\\"19\\" x2=\\"20\\" y2=\\"19\\"></line>","thermometer":"<path d=\\"M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z\\"></path>","thumbs-down":"<path d=\\"M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17\\"></path>","thumbs-up":"<path d=\\"M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3\\"></path>","toggle-left":"<rect x=\\"1\\" y=\\"5\\" width=\\"22\\" height=\\"14\\" rx=\\"7\\" ry=\\"7\\"></rect><circle cx=\\"8\\" cy=\\"12\\" r=\\"3\\"></circle>","toggle-right":"<rect x=\\"1\\" y=\\"5\\" width=\\"22\\" height=\\"14\\" rx=\\"7\\" ry=\\"7\\"></rect><circle cx=\\"16\\" cy=\\"12\\" r=\\"3\\"></circle>","tool":"<path d=\\"M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z\\"></path>","trash-2":"<polyline points=\\"3 6 5 6 21 6\\"></polyline><path d=\\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\\"></path><line x1=\\"10\\" y1=\\"11\\" x2=\\"10\\" y2=\\"17\\"></line><line x1=\\"14\\" y1=\\"11\\" x2=\\"14\\" y2=\\"17\\"></line>","trash":"<polyline points=\\"3 6 5 6 21 6\\"></polyline><path d=\\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\\"></path>","trello":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><rect x=\\"7\\" y=\\"7\\" width=\\"3\\" height=\\"9\\"></rect><rect x=\\"14\\" y=\\"7\\" width=\\"3\\" height=\\"5\\"></rect>","trending-down":"<polyline points=\\"23 18 13.5 8.5 8.5 13.5 1 6\\"></polyline><polyline points=\\"17 18 23 18 23 12\\"></polyline>","trending-up":"<polyline points=\\"23 6 13.5 15.5 8.5 10.5 1 18\\"></polyline><polyline points=\\"17 6 23 6 23 12\\"></polyline>","triangle":"<path d=\\"M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z\\"></path>","truck":"<rect x=\\"1\\" y=\\"3\\" width=\\"15\\" height=\\"13\\"></rect><polygon points=\\"16 8 20 8 23 11 23 16 16 16 16 8\\"></polygon><circle cx=\\"5.5\\" cy=\\"18.5\\" r=\\"2.5\\"></circle><circle cx=\\"18.5\\" cy=\\"18.5\\" r=\\"2.5\\"></circle>","tv":"<rect x=\\"2\\" y=\\"7\\" width=\\"20\\" height=\\"15\\" rx=\\"2\\" ry=\\"2\\"></rect><polyline points=\\"17 2 12 7 7 2\\"></polyline>","twitch":"<path d=\\"M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7\\"></path>","twitter":"<path d=\\"M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z\\"></path>","type":"<polyline points=\\"4 7 4 4 20 4 20 7\\"></polyline><line x1=\\"9\\" y1=\\"20\\" x2=\\"15\\" y2=\\"20\\"></line><line x1=\\"12\\" y1=\\"4\\" x2=\\"12\\" y2=\\"20\\"></line>","umbrella":"<path d=\\"M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7\\"></path>","underline":"<path d=\\"M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3\\"></path><line x1=\\"4\\" y1=\\"21\\" x2=\\"20\\" y2=\\"21\\"></line>","unlock":"<rect x=\\"3\\" y=\\"11\\" width=\\"18\\" height=\\"11\\" rx=\\"2\\" ry=\\"2\\"></rect><path d=\\"M7 11V7a5 5 0 0 1 9.9-1\\"></path>","upload-cloud":"<polyline points=\\"16 16 12 12 8 16\\"></polyline><line x1=\\"12\\" y1=\\"12\\" x2=\\"12\\" y2=\\"21\\"></line><path d=\\"M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3\\"></path><polyline points=\\"16 16 12 12 8 16\\"></polyline>","upload":"<path d=\\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\\"></path><polyline points=\\"17 8 12 3 7 8\\"></polyline><line x1=\\"12\\" y1=\\"3\\" x2=\\"12\\" y2=\\"15\\"></line>","user-check":"<path d=\\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\\"></path><circle cx=\\"8.5\\" cy=\\"7\\" r=\\"4\\"></circle><polyline points=\\"17 11 19 13 23 9\\"></polyline>","user-minus":"<path d=\\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\\"></path><circle cx=\\"8.5\\" cy=\\"7\\" r=\\"4\\"></circle><line x1=\\"23\\" y1=\\"11\\" x2=\\"17\\" y2=\\"11\\"></line>","user-plus":"<path d=\\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\\"></path><circle cx=\\"8.5\\" cy=\\"7\\" r=\\"4\\"></circle><line x1=\\"20\\" y1=\\"8\\" x2=\\"20\\" y2=\\"14\\"></line><line x1=\\"23\\" y1=\\"11\\" x2=\\"17\\" y2=\\"11\\"></line>","user-x":"<path d=\\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\\"></path><circle cx=\\"8.5\\" cy=\\"7\\" r=\\"4\\"></circle><line x1=\\"18\\" y1=\\"8\\" x2=\\"23\\" y2=\\"13\\"></line><line x1=\\"23\\" y1=\\"8\\" x2=\\"18\\" y2=\\"13\\"></line>","user":"<path d=\\"M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2\\"></path><circle cx=\\"12\\" cy=\\"7\\" r=\\"4\\"></circle>","users":"<path d=\\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\\"></path><circle cx=\\"9\\" cy=\\"7\\" r=\\"4\\"></circle><path d=\\"M23 21v-2a4 4 0 0 0-3-3.87\\"></path><path d=\\"M16 3.13a4 4 0 0 1 0 7.75\\"></path>","video-off":"<path d=\\"M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10\\"></path><line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line>","video":"<polygon points=\\"23 7 16 12 23 17 23 7\\"></polygon><rect x=\\"1\\" y=\\"5\\" width=\\"15\\" height=\\"14\\" rx=\\"2\\" ry=\\"2\\"></rect>","voicemail":"<circle cx=\\"5.5\\" cy=\\"11.5\\" r=\\"4.5\\"></circle><circle cx=\\"18.5\\" cy=\\"11.5\\" r=\\"4.5\\"></circle><line x1=\\"5.5\\" y1=\\"16\\" x2=\\"18.5\\" y2=\\"16\\"></line>","volume-1":"<polygon points=\\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\\"></polygon><path d=\\"M15.54 8.46a5 5 0 0 1 0 7.07\\"></path>","volume-2":"<polygon points=\\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\\"></polygon><path d=\\"M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07\\"></path>","volume-x":"<polygon points=\\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\\"></polygon><line x1=\\"23\\" y1=\\"9\\" x2=\\"17\\" y2=\\"15\\"></line><line x1=\\"17\\" y1=\\"9\\" x2=\\"23\\" y2=\\"15\\"></line>","volume":"<polygon points=\\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\\"></polygon>","watch":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"7\\"></circle><polyline points=\\"12 9 12 12 13.5 13.5\\"></polyline><path d=\\"M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83\\"></path>","wifi-off":"<line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line><path d=\\"M16.72 11.06A10.94 10.94 0 0 1 19 12.55\\"></path><path d=\\"M5 12.55a10.94 10.94 0 0 1 5.17-2.39\\"></path><path d=\\"M10.71 5.05A16 16 0 0 1 22.58 9\\"></path><path d=\\"M1.42 9a15.91 15.91 0 0 1 4.7-2.88\\"></path><path d=\\"M8.53 16.11a6 6 0 0 1 6.95 0\\"></path><line x1=\\"12\\" y1=\\"20\\" x2=\\"12.01\\" y2=\\"20\\"></line>","wifi":"<path d=\\"M5 12.55a11 11 0 0 1 14.08 0\\"></path><path d=\\"M1.42 9a16 16 0 0 1 21.16 0\\"></path><path d=\\"M8.53 16.11a6 6 0 0 1 6.95 0\\"></path><line x1=\\"12\\" y1=\\"20\\" x2=\\"12.01\\" y2=\\"20\\"></line>","wind":"<path d=\\"M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2\\"></path>","x-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"15\\" y1=\\"9\\" x2=\\"9\\" y2=\\"15\\"></line><line x1=\\"9\\" y1=\\"9\\" x2=\\"15\\" y2=\\"15\\"></line>","x-octagon":"<polygon points=\\"7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2\\"></polygon><line x1=\\"15\\" y1=\\"9\\" x2=\\"9\\" y2=\\"15\\"></line><line x1=\\"9\\" y1=\\"9\\" x2=\\"15\\" y2=\\"15\\"></line>","x-square":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"9\\" y1=\\"9\\" x2=\\"15\\" y2=\\"15\\"></line><line x1=\\"15\\" y1=\\"9\\" x2=\\"9\\" y2=\\"15\\"></line>","x":"<line x1=\\"18\\" y1=\\"6\\" x2=\\"6\\" y2=\\"18\\"></line><line x1=\\"6\\" y1=\\"6\\" x2=\\"18\\" y2=\\"18\\"></line>","youtube":"<path d=\\"M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z\\"></path><polygon points=\\"9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02\\"></polygon>","zap-off":"<polyline points=\\"12.41 6.75 13 2 10.57 4.92\\"></polyline><polyline points=\\"18.57 12.91 21 10 15.66 10\\"></polyline><polyline points=\\"8 8 3 14 12 14 11 22 16 16\\"></polyline><line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line>","zap":"<polygon points=\\"13 2 3 14 12 14 11 22 21 10 12 10 13 2\\"></polygon>","zoom-in":"<circle cx=\\"11\\" cy=\\"11\\" r=\\"8\\"></circle><line x1=\\"21\\" y1=\\"21\\" x2=\\"16.65\\" y2=\\"16.65\\"></line><line x1=\\"11\\" y1=\\"8\\" x2=\\"11\\" y2=\\"14\\"></line><line x1=\\"8\\" y1=\\"11\\" x2=\\"14\\" y2=\\"11\\"></line>","zoom-out":"<circle cx=\\"11\\" cy=\\"11\\" r=\\"8\\"></circle><line x1=\\"21\\" y1=\\"21\\" x2=\\"16.65\\" y2=\\"16.65\\"></line><line x1=\\"8\\" y1=\\"11\\" x2=\\"14\\" y2=\\"11\\"></line>"};\n\n/***/ }),\n\n/***/ "./node_modules/classnames/dedupe.js":\n/*!*******************************************!*\\\n  !*** ./node_modules/classnames/dedupe.js ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2016 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t\'use strict\';\n\n\tvar classNames = (function () {\n\t\t// don\'t inherit from Object so we can skip hasOwnProperty check later\n\t\t// http://stackoverflow.com/questions/15518328/creating-js-object-with-object-createnull#answer-21079232\n\t\tfunction StorageObject() {}\n\t\tStorageObject.prototype = Object.create(null);\n\n\t\tfunction _parseArray (resultSet, array) {\n\t\t\tvar length = array.length;\n\n\t\t\tfor (var i = 0; i < length; ++i) {\n\t\t\t\t_parse(resultSet, array[i]);\n\t\t\t}\n\t\t}\n\n\t\tvar hasOwn = {}.hasOwnProperty;\n\n\t\tfunction _parseNumber (resultSet, num) {\n\t\t\tresultSet[num] = true;\n\t\t}\n\n\t\tfunction _parseObject (resultSet, object) {\n\t\t\tfor (var k in object) {\n\t\t\t\tif (hasOwn.call(object, k)) {\n\t\t\t\t\t// set value to false instead of deleting it to avoid changing object structure\n\t\t\t\t\t// https://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/#de-referencing-misconceptions\n\t\t\t\t\tresultSet[k] = !!object[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar SPACE = /\\s+/;\n\t\tfunction _parseString (resultSet, str) {\n\t\t\tvar array = str.split(SPACE);\n\t\t\tvar length = array.length;\n\n\t\t\tfor (var i = 0; i < length; ++i) {\n\t\t\t\tresultSet[array[i]] = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction _parse (resultSet, arg) {\n\t\t\tif (!arg) return;\n\t\t\tvar argType = typeof arg;\n\n\t\t\t// \'foo bar\'\n\t\t\tif (argType === \'string\') {\n\t\t\t\t_parseString(resultSet, arg);\n\n\t\t\t// [\'foo\', \'bar\', ...]\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\t_parseArray(resultSet, arg);\n\n\t\t\t// { \'foo\': true, ... }\n\t\t\t} else if (argType === \'object\') {\n\t\t\t\t_parseObject(resultSet, arg);\n\n\t\t\t// \'130\'\n\t\t\t} else if (argType === \'number\') {\n\t\t\t\t_parseNumber(resultSet, arg);\n\t\t\t}\n\t\t}\n\n\t\tfunction _classNames () {\n\t\t\t// don\'t leak arguments\n\t\t\t// https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n\t\t\tvar len = arguments.length;\n\t\t\tvar args = Array(len);\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\targs[i] = arguments[i];\n\t\t\t}\n\n\t\t\tvar classSet = new StorageObject();\n\t\t\t_parseArray(classSet, args);\n\n\t\t\tvar list = [];\n\n\t\t\tfor (var k in classSet) {\n\t\t\t\tif (classSet[k]) {\n\t\t\t\t\tlist.push(k)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn list.join(\' \');\n\t\t}\n\n\t\treturn _classNames;\n\t})();\n\n\tif (typeof module !== \'undefined\' && module.exports) {\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as \'classnames\', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/es/array/from.js":\n/*!***********************************************!*\\\n  !*** ./node_modules/core-js/es/array/from.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(/*! ../../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");\n__webpack_require__(/*! ../../modules/es.array.from */ "./node_modules/core-js/modules/es.array.from.js");\nvar path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");\n\nmodule.exports = path.Array.from;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/a-function.js":\n/*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/a-function.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  if (typeof it != \'function\') {\n    throw TypeError(String(it) + \' is not a function\');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/an-object.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/an-object.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\n\nmodule.exports = function (it) {\n  if (!isObject(it)) {\n    throw TypeError(String(it) + \' is not an object\');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/array-from.js":\n/*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-from.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");\nvar isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");\nvar toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");\nvar createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");\nvar getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");\n\n// `Array.from` method\n// https://tc39.github.io/ecma262/#sec-array.from\nmodule.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n  var O = toObject(arrayLike);\n  var C = typeof this == \'function\' ? this : Array;\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  var index = 0;\n  var iteratorMethod = getIteratorMethod(O);\n  var length, result, step, iterator;\n  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);\n  // if the target is not iterable or it\'s an array with the default iterator - use a simple case\n  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n    iterator = iteratorMethod.call(O);\n    result = new C();\n    for (;!(step = iterator.next()).done; index++) {\n      createProperty(result, index, mapping\n        ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true)\n        : step.value\n      );\n    }\n  } else {\n    length = toLength(O.length);\n    result = new C(length);\n    for (;length > index; index++) {\n      createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n    }\n  }\n  result.length = index;\n  return result;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/array-includes.js":\n/*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-includes.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");\nvar toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\n// false -> Array#indexOf\n// https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n// true  -> Array#includes\n// https://tc39.github.io/ecma262/#sec-array.prototype.includes\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/bind-context.js":\n/*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/bind-context.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");\n\n// optional / simple context binding\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 0: return function () {\n      return fn.call(that);\n    };\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js":\n/*!****************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!\n  \\****************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\n\n// call something on iterator step with safe closing on error\nmodule.exports = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (error) {\n    var returnMethod = iterator[\'return\'];\n    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));\n    throw error;\n  }\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/check-correctness-of-iteration.js":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!\n  \\**************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    \'return\': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR] = function () {\n    return this;\n  };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nmodule.exports = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/classof-raw.js":\n/*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/classof-raw.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/classof.js":\n/*!***************************************************!*\\\n  !*** ./node_modules/core-js/internals/classof.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar TO_STRING_TAG = wellKnownSymbol(\'toStringTag\');\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == \'Arguments\';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = function (it) {\n  var O, tag, result;\n  return it === undefined ? \'Undefined\' : it === null ? \'Null\'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == \'string\' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == \'Object\' && typeof O.callee == \'function\' ? \'Arguments\' : result;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");\nvar getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":\n/*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\nmodule.exports = !fails(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/create-iterator-constructor.js":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;\nvar create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\nvar setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (IteratorConstructor, NAME, next) {\n  var TO_STRING_TAG = NAME + \' Iterator\';\n  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });\n  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n  Iterators[TO_STRING_TAG] = returnThis;\n  return IteratorConstructor;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/create-property-descriptor.js":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/create-property.js":\n/*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-property.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPrimitive(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/define-iterator.js":\n/*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/define-iterator.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");\nvar getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");\nvar setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");\nvar setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");\nvar hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");\nvar redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\nvar IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");\n\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar KEYS = \'keys\';\nvar VALUES = \'values\';\nvar ENTRIES = \'entries\';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + \' Iterator\';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR]\n    || IterablePrototype[\'@@iterator\']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == \'Array\' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf) {\n          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (typeof CurrentIteratorPrototype[ITERATOR] != \'function\') {\n          hide(CurrentIteratorPrototype, ITERATOR, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\n    }\n  }\n\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    INCORRECT_VALUES_NAME = true;\n    defaultIterator = function values() { return nativeIterator.call(this); };\n  }\n\n  // define iterator\n  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n    hide(IterablePrototype, ITERATOR, defaultIterator);\n  }\n  Iterators[NAME] = defaultIterator;\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        redefine(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  return methods;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/descriptors.js":\n/*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/descriptors.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\n// Thank\'s IE8 for his funny defineProperty\nmodule.exports = !fails(function () {\n  return Object.defineProperty({}, \'a\', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/document-create-element.js":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/document-create-element.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\n\nvar document = global.document;\n// typeof document.createElement is \'object\' in old IE\nvar exist = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return exist ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/enum-bug-keys.js":\n/*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n// IE8- don\'t enum bug keys\nmodule.exports = [\n  \'constructor\',\n  \'hasOwnProperty\',\n  \'isPrototypeOf\',\n  \'propertyIsEnumerable\',\n  \'toLocaleString\',\n  \'toString\',\n  \'valueOf\'\n];\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/export.js":\n/*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/export.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;\nvar hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");\nvar redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");\nvar setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");\nvar copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");\nvar isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \'.\' : \'#\') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty === typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      hide(sourceProperty, \'sham\', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/fails.js":\n/*!*************************************************!*\\\n  !*** ./node_modules/core-js/internals/fails.js ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/function-to-string.js":\n/*!**************************************************************!*\\\n  !*** ./node_modules/core-js/internals/function-to-string.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\n\nmodule.exports = shared(\'native-function-to-string\', Function.toString);\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/get-iterator-method.js":\n/*!***************************************************************!*\\\n  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\n\nmodule.exports = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it[\'@@iterator\']\n    || Iterators[classof(it)];\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/global.js":\n/*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/global.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var O = \'object\';\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line no-undef\n  check(typeof globalThis == O && globalThis) ||\n  check(typeof window == O && window) ||\n  check(typeof self == O && self) ||\n  check(typeof global == O && global) ||\n  // eslint-disable-next-line no-new-func\n  Function(\'return this\')();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/has.js":\n/*!***********************************************!*\\\n  !*** ./node_modules/core-js/internals/has.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/hidden-keys.js":\n/*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/hidden-keys.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/hide.js":\n/*!************************************************!*\\\n  !*** ./node_modules/core-js/internals/hide.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/html.js":\n/*!************************************************!*\\\n  !*** ./node_modules/core-js/internals/html.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\n\nvar document = global.document;\n\nmodule.exports = document && document.documentElement;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/ie8-dom-define.js":\n/*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");\n\n// Thank\'s IE8 for his funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  return Object.defineProperty(createElement(\'div\'), \'a\', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/indexed-object.js":\n/*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/indexed-object.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");\n\nvar split = \'\'.split;\n\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins\n  return !Object(\'z\').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == \'String\' ? split.call(it, \'\') : Object(it);\n} : Object;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/internal-state.js":\n/*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/internal-state.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");\nvar objectHas = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\n\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError(\'Incompatible receiver, \' + TYPE + \' required\');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP) {\n  var store = new WeakMap();\n  var wmget = store.get;\n  var wmhas = store.has;\n  var wmset = store.set;\n  set = function (it, metadata) {\n    wmset.call(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget.call(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas.call(store, it);\n  };\n} else {\n  var STATE = sharedKey(\'state\');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    hide(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return objectHas(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return objectHas(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/is-array-iterator-method.js":\n/*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/is-forced.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-forced.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : typeof detection == \'function\' ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, \'.\').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = \'N\';\nvar POLYFILL = isForced.POLYFILL = \'P\';\n\nmodule.exports = isForced;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/is-object.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-object.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  return typeof it === \'object\' ? it !== null : typeof it === \'function\';\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/is-pure.js":\n/*!***************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-pure.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = false;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/iterators-core.js":\n/*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/iterators-core.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");\nvar hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar BUGGY_SAFARI_ITERATORS = false;\n\nvar returnThis = function () { return this; };\n\n// `%IteratorPrototype%` object\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!(\'next\' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nif (IteratorPrototype == undefined) IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nif (!IS_PURE && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n\nmodule.exports = {\n  IteratorPrototype: IteratorPrototype,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/iterators.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/iterators.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/native-symbol.js":\n/*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/native-symbol.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  // Chrome 38 Symbol has incorrect toString conversion\n  // eslint-disable-next-line no-undef\n  return !String(Symbol());\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/native-weak-map.js":\n/*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/native-weak-map.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ "./node_modules/core-js/internals/function-to-string.js");\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = typeof WeakMap === \'function\' && /native code/.test(nativeFunctionToString.call(WeakMap));\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-create.js":\n/*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-create.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\nvar html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");\nvar documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");\nvar IE_PROTO = sharedKey(\'IE_PROTO\');\n\nvar PROTOTYPE = \'prototype\';\nvar Empty = function () { /* empty */ };\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement(\'iframe\');\n  var length = enumBugKeys.length;\n  var lt = \'<\';\n  var script = \'script\';\n  var gt = \'>\';\n  var js = \'java\' + script + \':\';\n  var iframeDocument;\n  iframe.style.display = \'none\';\n  html.appendChild(iframe);\n  iframe.src = String(js);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + script + gt + \'document.F=Object\' + lt + \'/\' + script + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];\n  return createDict();\n};\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add "__proto__" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : defineProperties(result, Properties);\n};\n\nhiddenKeys[IE_PROTO] = true;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-define-properties.js":\n/*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-define-properties.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");\n\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var key;\n  while (length > i) definePropertyModule.f(O, key = keys[i++], Properties[key]);\n  return O;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-define-property.js":\n/*!******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-define-property.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");\n\nvar nativeDefineProperty = Object.defineProperty;\n\nexports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return nativeDefineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if (\'get\' in Attributes || \'set\' in Attributes) throw TypeError(\'Accessors not supported\');\n  if (\'value\' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":\n/*!******************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!\n  \\******************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");\n\nvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\nexports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return nativeGetOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!\n  \\*************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");\n\nvar hiddenKeys = enumBugKeys.concat(\'length\', \'prototype\');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":\n/*!***************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!\n  \\***************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nexports.f = Object.getOwnPropertySymbols;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");\nvar CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");\n\nvar IE_PROTO = sharedKey(\'IE_PROTO\');\nvar ObjectPrototype = Object.prototype;\n\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == \'function\' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectPrototype : null;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-keys-internal.js":\n/*!****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar arrayIncludes = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\n\nvar arrayIndexOf = arrayIncludes(false);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n  // Don\'t enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-keys.js":\n/*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-keys.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!\n  \\*************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : nativePropertyIsEnumerable;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar validateSetPrototypeOfArguments = __webpack_require__(/*! ../internals/validate-set-prototype-of-arguments */ "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js");\n\n// Works with __proto__ only. Old v8 can\'t work with null proto objects.\n/* eslint-disable no-proto */\nmodule.exports = Object.setPrototypeOf || (\'__proto__\' in {} ? function () {\n  var correctSetter = false;\n  var test = {};\n  var setter;\n  try {\n    setter = Object.getOwnPropertyDescriptor(Object.prototype, \'__proto__\').set;\n    setter.call(test, []);\n    correctSetter = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    validateSetPrototypeOfArguments(O, proto);\n    if (correctSetter) setter.call(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/own-keys.js":\n/*!****************************************************!*\\\n  !*** ./node_modules/core-js/internals/own-keys.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");\nvar getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\n\nvar Reflect = global.Reflect;\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/path.js":\n/*!************************************************!*\\\n  !*** ./node_modules/core-js/internals/path.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/redefine.js":\n/*!****************************************************!*\\\n  !*** ./node_modules/core-js/internals/redefine.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");\nvar nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ "./node_modules/core-js/internals/function-to-string.js");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");\n\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(nativeFunctionToString).split(\'toString\');\n\nshared(\'inspectSource\', function (it) {\n  return nativeFunctionToString.call(it);\n});\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  if (typeof value == \'function\') {\n    if (typeof key == \'string\' && !has(value, \'name\')) hide(value, \'name\', key);\n    enforceInternalState(value).source = TEMPLATE.join(typeof key == \'string\' ? key : \'\');\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else hide(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, \'toString\', function toString() {\n  return typeof this == \'function\' && getInternalState(this).source || nativeFunctionToString.call(this);\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/require-object-coercible.js":\n/*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.github.io/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError("Can\'t call method on " + it);\n  return it;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/set-global.js":\n/*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/set-global.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");\n\nmodule.exports = function (key, value) {\n  try {\n    hide(global, key, value);\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/set-to-string-tag.js":\n/*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar TO_STRING_TAG = wellKnownSymbol(\'toStringTag\');\n\nmodule.exports = function (it, TAG, STATIC) {\n  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });\n  }\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/shared-key.js":\n/*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/shared-key.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\n\nvar keys = shared(\'keys\');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/shared.js":\n/*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/shared.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");\n\nvar SHARED = \'__core-js_shared__\';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})(\'versions\', []).push({\n  version: \'3.1.3\',\n  mode: IS_PURE ? \'pure\' : \'global\',\n  copyright: \'© 2019 Denis Pushkarev (zloirock.ru)\'\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/string-at.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/string-at.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\n// CONVERT_TO_STRING: true  -> String#at\n// CONVERT_TO_STRING: false -> String#codePointAt\nmodule.exports = function (that, pos, CONVERT_TO_STRING) {\n  var S = String(requireObjectCoercible(that));\n  var position = toInteger(pos);\n  var size = S.length;\n  var first, second;\n  if (position < 0 || position >= size) return CONVERT_TO_STRING ? \'\' : undefined;\n  first = S.charCodeAt(position);\n  return first < 0xD800 || first > 0xDBFF || position + 1 === size\n    || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF\n      ? CONVERT_TO_STRING ? S.charAt(position) : first\n      : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/to-absolute-index.js":\n/*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).\nmodule.exports = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/to-indexed-object.js":\n/*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/to-integer.js":\n/*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-integer.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToInteger` abstract operation\n// https://tc39.github.io/ecma262/#sec-tointeger\nmodule.exports = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/to-length.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-length.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.github.io/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/to-object.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-object.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\n// `ToObject` abstract operation\n// https://tc39.github.io/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/to-primitive.js":\n/*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-primitive.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\n// instead of the ES6 spec version, we didn\'t implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == \'function\' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == \'function\' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == \'function\' && !isObject(val = fn.call(it))) return val;\n  throw TypeError("Can\'t convert object to primitive value");\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/uid.js":\n/*!***********************************************!*\\\n  !*** ./node_modules/core-js/internals/uid.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar id = 0;\nvar postfix = Math.random();\n\nmodule.exports = function (key) {\n  return \'Symbol(\'.concat(key === undefined ? \'\' : key, \')_\', (++id + postfix).toString(36));\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js":\n/*!*******************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/validate-set-prototype-of-arguments.js ***!\n  \\*******************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\n\nmodule.exports = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) {\n    throw TypeError("Can\'t set " + String(proto) + \' as a prototype\');\n  }\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/well-known-symbol.js":\n/*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\nvar NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");\n\nvar Symbol = global.Symbol;\nvar store = shared(\'wks\');\n\nmodule.exports = function (name) {\n  return store[name] || (store[name] = NATIVE_SYMBOL && Symbol[name]\n    || (NATIVE_SYMBOL ? Symbol : uid)(\'Symbol.\' + name));\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/modules/es.array.from.js":\n/*!*******************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.from.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar from = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");\nvar checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");\n\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n  Array.from(iterable);\n});\n\n// `Array.from` method\n// https://tc39.github.io/ecma262/#sec-array.from\n$({ target: \'Array\', stat: true, forced: INCORRECT_ITERATION }, {\n  from: from\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/modules/es.string.iterator.js":\n/*!************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar codePointAt = __webpack_require__(/*! ../internals/string-at */ "./node_modules/core-js/internals/string-at.js");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");\nvar defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");\n\nvar STRING_ITERATOR = \'String Iterator\';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\n\n// `String.prototype[@@iterator]` method\n// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator\ndefineIterator(String, \'String\', function (iterated) {\n  setInternalState(this, {\n    type: STRING_ITERATOR,\n    string: String(iterated),\n    index: 0\n  });\n// `%StringIteratorPrototype%.next` method\n// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return { value: undefined, done: true };\n  point = codePointAt(string, index, true);\n  state.index += point.length;\n  return { value: point, done: false };\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/webpack/buildin/global.js":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/global.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1, eval)("this");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === "object") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n\n/***/ "./src/default-attrs.json":\n/*!********************************!*\\\n  !*** ./src/default-attrs.json ***!\n  \\********************************/\n/*! exports provided: xmlns, width, height, viewBox, fill, stroke, stroke-width, stroke-linecap, stroke-linejoin, default */\n/***/ (function(module) {\n\nmodule.exports = {"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","stroke-width":2,"stroke-linecap":"round","stroke-linejoin":"round"};\n\n/***/ }),\n\n/***/ "./src/icon.js":\n/*!*********************!*\\\n  !*** ./src/icon.js ***!\n  \\*********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _dedupe = __webpack_require__(/*! classnames/dedupe */ "./node_modules/classnames/dedupe.js");\n\nvar _dedupe2 = _interopRequireDefault(_dedupe);\n\nvar _defaultAttrs = __webpack_require__(/*! ./default-attrs.json */ "./src/default-attrs.json");\n\nvar _defaultAttrs2 = _interopRequireDefault(_defaultAttrs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar Icon = function () {\n  function Icon(name, contents) {\n    var tags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    _classCallCheck(this, Icon);\n\n    this.name = name;\n    this.contents = contents;\n    this.tags = tags;\n    this.attrs = _extends({}, _defaultAttrs2.default, { class: \'feather feather-\' + name });\n  }\n\n  /**\n   * Create an SVG string.\n   * @param {Object} attrs\n   * @returns {string}\n   */\n\n\n  _createClass(Icon, [{\n    key: \'toSvg\',\n    value: function toSvg() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var combinedAttrs = _extends({}, this.attrs, attrs, { class: (0, _dedupe2.default)(this.attrs.class, attrs.class) });\n\n      return \'<svg \' + attrsToString(combinedAttrs) + \'>\' + this.contents + \'</svg>\';\n    }\n\n    /**\n     * Return string representation of an `Icon`.\n     *\n     * Added for backward compatibility. If old code expects `feather.icons.<name>`\n     * to be a string, `toString()` will get implicitly called.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: \'toString\',\n    value: function toString() {\n      return this.contents;\n    }\n  }]);\n\n  return Icon;\n}();\n\n/**\n * Convert attributes object to string of HTML attributes.\n * @param {Object} attrs\n * @returns {string}\n */\n\n\nfunction attrsToString(attrs) {\n  return Object.keys(attrs).map(function (key) {\n    return key + \'="\' + attrs[key] + \'"\';\n  }).join(\' \');\n}\n\nexports.default = Icon;\n\n/***/ }),\n\n/***/ "./src/icons.js":\n/*!**********************!*\\\n  !*** ./src/icons.js ***!\n  \\**********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _icon = __webpack_require__(/*! ./icon */ "./src/icon.js");\n\nvar _icon2 = _interopRequireDefault(_icon);\n\nvar _icons = __webpack_require__(/*! ../dist/icons.json */ "./dist/icons.json");\n\nvar _icons2 = _interopRequireDefault(_icons);\n\nvar _tags = __webpack_require__(/*! ./tags.json */ "./src/tags.json");\n\nvar _tags2 = _interopRequireDefault(_tags);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = Object.keys(_icons2.default).map(function (key) {\n  return new _icon2.default(key, _icons2.default[key], _tags2.default[key]);\n}).reduce(function (object, icon) {\n  object[icon.name] = icon;\n  return object;\n}, {});\n\n/***/ }),\n\n/***/ "./src/index.js":\n/*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nvar _icons = __webpack_require__(/*! ./icons */ "./src/icons.js");\n\nvar _icons2 = _interopRequireDefault(_icons);\n\nvar _toSvg = __webpack_require__(/*! ./to-svg */ "./src/to-svg.js");\n\nvar _toSvg2 = _interopRequireDefault(_toSvg);\n\nvar _replace = __webpack_require__(/*! ./replace */ "./src/replace.js");\n\nvar _replace2 = _interopRequireDefault(_replace);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = { icons: _icons2.default, toSvg: _toSvg2.default, replace: _replace2.default };\n\n/***/ }),\n\n/***/ "./src/replace.js":\n/*!************************!*\\\n  !*** ./src/replace.js ***!\n  \\************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint-env browser */\n\n\nvar _dedupe = __webpack_require__(/*! classnames/dedupe */ "./node_modules/classnames/dedupe.js");\n\nvar _dedupe2 = _interopRequireDefault(_dedupe);\n\nvar _icons = __webpack_require__(/*! ./icons */ "./src/icons.js");\n\nvar _icons2 = _interopRequireDefault(_icons);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Replace all HTML elements that have a `data-feather` attribute with SVG markup\n * corresponding to the element\'s `data-feather` attribute value.\n * @param {Object} attrs\n */\nfunction replace() {\n  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (typeof document === \'undefined\') {\n    throw new Error(\'`feather.replace()` only works in a browser environment.\');\n  }\n\n  var elementsToReplace = document.querySelectorAll(\'[data-feather]\');\n\n  Array.from(elementsToReplace).forEach(function (element) {\n    return replaceElement(element, attrs);\n  });\n}\n\n/**\n * Replace a single HTML element with SVG markup\n * corresponding to the element\'s `data-feather` attribute value.\n * @param {HTMLElement} element\n * @param {Object} attrs\n */\nfunction replaceElement(element) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var elementAttrs = getAttrs(element);\n  var name = elementAttrs[\'data-feather\'];\n  delete elementAttrs[\'data-feather\'];\n\n  var svgString = _icons2.default[name].toSvg(_extends({}, attrs, elementAttrs, { class: (0, _dedupe2.default)(attrs.class, elementAttrs.class) }));\n  var svgDocument = new DOMParser().parseFromString(svgString, \'image/svg+xml\');\n  var svgElement = svgDocument.querySelector(\'svg\');\n\n  element.parentNode.replaceChild(svgElement, element);\n}\n\n/**\n * Get the attributes of an HTML element.\n * @param {HTMLElement} element\n * @returns {Object}\n */\nfunction getAttrs(element) {\n  return Array.from(element.attributes).reduce(function (attrs, attr) {\n    attrs[attr.name] = attr.value;\n    return attrs;\n  }, {});\n}\n\nexports.default = replace;\n\n/***/ }),\n\n/***/ "./src/tags.json":\n/*!***********************!*\\\n  !*** ./src/tags.json ***!\n  \\***********************/\n/*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, archive, at-sign, award, aperture, bar-chart, bar-chart-2, battery, battery-charging, bell, bell-off, bluetooth, book-open, book, bookmark, box, briefcase, calendar, camera, cast, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-rain, cloud-snow, cloud, codepen, codesandbox, code, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, dollar-sign, droplet, edit, edit-2, edit-3, eye, eye-off, external-link, facebook, fast-forward, figma, file-minus, file-plus, file-text, film, filter, flag, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, instagram, key, layers, layout, life-bouy, link, link-2, linkedin, list, lock, log-in, log-out, mail, map-pin, map, maximize, maximize-2, meh, menu, message-circle, message-square, mic-off, mic, minimize, minimize-2, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation, navigation-2, octagon, package, paperclip, pause, pause-circle, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, play, pie-chart, play-circle, plus, plus-circle, plus-square, pocket, power, printer, radio, refresh-cw, refresh-ccw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, settings, share-2, shield, shield-off, shopping-bag, shopping-cart, shuffle, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, star, stop-circle, sun, sunrise, sunset, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, tool, trash, trash-2, triangle, truck, tv, twitch, twitter, type, umbrella, unlock, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume, volume-1, volume-2, volume-x, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default */\n/***/ (function(module) {\n\nmodule.exports = {"activity":["pulse","health","action","motion"],"airplay":["stream","cast","mirroring"],"alert-circle":["warning","alert","danger"],"alert-octagon":["warning","alert","danger"],"alert-triangle":["warning","alert","danger"],"align-center":["text alignment","center"],"align-justify":["text alignment","justified"],"align-left":["text alignment","left"],"align-right":["text alignment","right"],"anchor":[],"archive":["index","box"],"at-sign":["mention","at","email","message"],"award":["achievement","badge"],"aperture":["camera","photo"],"bar-chart":["statistics","diagram","graph"],"bar-chart-2":["statistics","diagram","graph"],"battery":["power","electricity"],"battery-charging":["power","electricity"],"bell":["alarm","notification","sound"],"bell-off":["alarm","notification","silent"],"bluetooth":["wireless"],"book-open":["read","library"],"book":["read","dictionary","booklet","magazine","library"],"bookmark":["read","clip","marker","tag"],"box":["cube"],"briefcase":["work","bag","baggage","folder"],"calendar":["date"],"camera":["photo"],"cast":["chromecast","airplay"],"circle":["off","zero","record"],"clipboard":["copy"],"clock":["time","watch","alarm"],"cloud-drizzle":["weather","shower"],"cloud-lightning":["weather","bolt"],"cloud-rain":["weather"],"cloud-snow":["weather","blizzard"],"cloud":["weather"],"codepen":["logo"],"codesandbox":["logo"],"code":["source","programming"],"coffee":["drink","cup","mug","tea","cafe","hot","beverage"],"columns":["layout"],"command":["keyboard","cmd","terminal","prompt"],"compass":["navigation","safari","travel","direction"],"copy":["clone","duplicate"],"corner-down-left":["arrow","return"],"corner-down-right":["arrow"],"corner-left-down":["arrow"],"corner-left-up":["arrow"],"corner-right-down":["arrow"],"corner-right-up":["arrow"],"corner-up-left":["arrow"],"corner-up-right":["arrow"],"cpu":["processor","technology"],"credit-card":["purchase","payment","cc"],"crop":["photo","image"],"crosshair":["aim","target"],"database":["storage","memory"],"delete":["remove"],"disc":["album","cd","dvd","music"],"dollar-sign":["currency","money","payment"],"droplet":["water"],"edit":["pencil","change"],"edit-2":["pencil","change"],"edit-3":["pencil","change"],"eye":["view","watch"],"eye-off":["view","watch","hide","hidden"],"external-link":["outbound"],"facebook":["logo","social"],"fast-forward":["music"],"figma":["logo","design","tool"],"file-minus":["delete","remove","erase"],"file-plus":["add","create","new"],"file-text":["data","txt","pdf"],"film":["movie","video"],"filter":["funnel","hopper"],"flag":["report"],"folder-minus":["directory"],"folder-plus":["directory"],"folder":["directory"],"framer":["logo","design","tool"],"frown":["emoji","face","bad","sad","emotion"],"gift":["present","box","birthday","party"],"git-branch":["code","version control"],"git-commit":["code","version control"],"git-merge":["code","version control"],"git-pull-request":["code","version control"],"github":["logo","version control"],"gitlab":["logo","version control"],"globe":["world","browser","language","translate"],"hard-drive":["computer","server","memory","data"],"hash":["hashtag","number","pound"],"headphones":["music","audio","sound"],"heart":["like","love","emotion"],"help-circle":["question mark"],"hexagon":["shape","node.js","logo"],"home":["house","living"],"image":["picture"],"inbox":["email"],"instagram":["logo","camera"],"key":["password","login","authentication","secure"],"layers":["stack"],"layout":["window","webpage"],"life-bouy":["help","life ring","support"],"link":["chain","url"],"link-2":["chain","url"],"linkedin":["logo","social media"],"list":["options"],"lock":["security","password","secure"],"log-in":["sign in","arrow","enter"],"log-out":["sign out","arrow","exit"],"mail":["email","message"],"map-pin":["location","navigation","travel","marker"],"map":["location","navigation","travel"],"maximize":["fullscreen"],"maximize-2":["fullscreen","arrows","expand"],"meh":["emoji","face","neutral","emotion"],"menu":["bars","navigation","hamburger"],"message-circle":["comment","chat"],"message-square":["comment","chat"],"mic-off":["record","sound","mute"],"mic":["record","sound","listen"],"minimize":["exit fullscreen","close"],"minimize-2":["exit fullscreen","arrows","close"],"minus":["subtract"],"monitor":["tv","screen","display"],"moon":["dark","night"],"more-horizontal":["ellipsis"],"more-vertical":["ellipsis"],"mouse-pointer":["arrow","cursor"],"move":["arrows"],"music":["note"],"navigation":["location","travel"],"navigation-2":["location","travel"],"octagon":["stop"],"package":["box","container"],"paperclip":["attachment"],"pause":["music","stop"],"pause-circle":["music","audio","stop"],"pen-tool":["vector","drawing"],"percent":["discount"],"phone-call":["ring"],"phone-forwarded":["call"],"phone-incoming":["call"],"phone-missed":["call"],"phone-off":["call","mute"],"phone-outgoing":["call"],"phone":["call"],"play":["music","start"],"pie-chart":["statistics","diagram"],"play-circle":["music","start"],"plus":["add","new"],"plus-circle":["add","new"],"plus-square":["add","new"],"pocket":["logo","save"],"power":["on","off"],"printer":["fax","office","device"],"radio":["signal"],"refresh-cw":["synchronise","arrows"],"refresh-ccw":["arrows"],"repeat":["loop","arrows"],"rewind":["music"],"rotate-ccw":["arrow"],"rotate-cw":["arrow"],"rss":["feed","subscribe"],"save":["floppy disk"],"scissors":["cut"],"search":["find","magnifier","magnifying glass"],"send":["message","mail","email","paper airplane","paper aeroplane"],"settings":["cog","edit","gear","preferences"],"share-2":["network","connections"],"shield":["security","secure"],"shield-off":["security","insecure"],"shopping-bag":["ecommerce","cart","purchase","store"],"shopping-cart":["ecommerce","cart","purchase","store"],"shuffle":["music"],"skip-back":["music"],"skip-forward":["music"],"slack":["logo"],"slash":["ban","no"],"sliders":["settings","controls"],"smartphone":["cellphone","device"],"smile":["emoji","face","happy","good","emotion"],"speaker":["audio","music"],"star":["bookmark","favorite","like"],"stop-circle":["media","music"],"sun":["brightness","weather","light"],"sunrise":["weather","time","morning","day"],"sunset":["weather","time","evening","night"],"tablet":["device"],"tag":["label"],"target":["logo","bullseye"],"terminal":["code","command line","prompt"],"thermometer":["temperature","celsius","fahrenheit","weather"],"thumbs-down":["dislike","bad","emotion"],"thumbs-up":["like","good","emotion"],"toggle-left":["on","off","switch"],"toggle-right":["on","off","switch"],"tool":["settings","spanner"],"trash":["garbage","delete","remove","bin"],"trash-2":["garbage","delete","remove","bin"],"triangle":["delta"],"truck":["delivery","van","shipping","transport","lorry"],"tv":["television","stream"],"twitch":["logo"],"twitter":["logo","social"],"type":["text"],"umbrella":["rain","weather"],"unlock":["security"],"user-check":["followed","subscribed"],"user-minus":["delete","remove","unfollow","unsubscribe"],"user-plus":["new","add","create","follow","subscribe"],"user-x":["delete","remove","unfollow","unsubscribe","unavailable"],"user":["person","account"],"users":["group"],"video-off":["camera","movie","film"],"video":["camera","movie","film"],"voicemail":["phone"],"volume":["music","sound","mute"],"volume-1":["music","sound"],"volume-2":["music","sound"],"volume-x":["music","sound","mute"],"watch":["clock","time"],"wifi-off":["disabled"],"wifi":["connection","signal","wireless"],"wind":["weather","air"],"x-circle":["cancel","close","delete","remove","times","clear"],"x-octagon":["delete","stop","alert","warning","times","clear"],"x-square":["cancel","close","delete","remove","times","clear"],"x":["cancel","close","delete","remove","times","clear"],"youtube":["logo","video","play"],"zap-off":["flash","camera","lightning"],"zap":["flash","camera","lightning"],"zoom-in":["magnifying glass"],"zoom-out":["magnifying glass"]};\n\n/***/ }),\n\n/***/ "./src/to-svg.js":\n/*!***********************!*\\\n  !*** ./src/to-svg.js ***!\n  \\***********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _icons = __webpack_require__(/*! ./icons */ "./src/icons.js");\n\nvar _icons2 = _interopRequireDefault(_icons);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Create an SVG string.\n * @deprecated\n * @param {string} name\n * @param {Object} attrs\n * @returns {string}\n */\nfunction toSvg(name) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  console.warn(\'feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead.\');\n\n  if (!name) {\n    throw new Error(\'The required `key` (icon name) parameter is missing.\');\n  }\n\n  if (!_icons2.default[name]) {\n    throw new Error(\'No icon matching \\\'\' + name + \'\\\'. See the complete list of icons at https://feathericons.com\');\n  }\n\n  return _icons2.default[name].toSvg(attrs);\n}\n\nexports.default = toSvg;\n\n/***/ }),\n\n/***/ 0:\n/*!**************************************************!*\\\n  !*** multi core-js/es/array/from ./src/index.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(/*! core-js/es/array/from */"./node_modules/core-js/es/array/from.js");\nmodule.exports = __webpack_require__(/*! /home/travis/build/feathericons/feather/src/index.js */"./src/index.js");\n\n\n/***/ })\n\n/******/ });\n});\n//# sourceMappingURL=feather.js.map\n\n//# sourceURL=webpack:///./node_modules/feather-icons/dist/feather.js?')},"./src/js/app.js":function srcJsAppJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_bootstrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/bootstrap */ \"./src/js/modules/bootstrap.js\");\n/* harmony import */ var _modules_feather_icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/feather-icons */ \"./src/js/modules/feather-icons.js\");\n/*\n * -----------------------------------------\n *  REQUIREDS\n * - - - - - - - - - - - - - - - - - - - - -\n */\n\n\n\n/*\n * -----------------------------------------\n *  READY\n * - - - - - - - - - - - - - - - - - - - - -\n */\ndocument.addEventListener('DOMContentLoaded', () => {\n\n  console.log('APP READY!');\n\n});\n\n\n//# sourceURL=webpack:///./src/js/app.js?")},"./src/js/modules/bootstrap.js":function srcJsModulesBootstrapJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");\n/*\n * -----------------------------------------\n *  REQUIRED\n * - - - - - - - - - - - - - - - - - - - - -\n */\n\n\n/*\n * -----------------------------------------\n *  GLOBAL\n * - - - - - - - - - - - - - - - - - - - - -\n *  Note: If you want to make bootstrap globally available, e.g. for using `bootstrap.modal`\n * - - - - - - - - - - - - - - - - - - - - -\n */\nwindow.bootstrap = bootstrap__WEBPACK_IMPORTED_MODULE_0__;\n\n/*\n * -----------------------------------------\n *  POPOVERS\n * - - - - - - - - - - - - - - - - - - - - -\n *  Note: Disable this if you\'re not using Bootstrap\'s Popovers\n * - - - - - - - - - - - - - - - - - - - - -\n */\nconst popoverTriggerList = []\n  .slice.call(document.querySelectorAll(\'[data-bs-toggle="popover"]\'));\npopoverTriggerList.map((popoverTriggerEl) => {\n  return new bootstrap__WEBPACK_IMPORTED_MODULE_0__["Popover"](popoverTriggerEl);\n});\n\n/*\n * -----------------------------------------\n *  TOOLTIPS\n * - - - - - - - - - - - - - - - - - - - - -\n *  Note: Disable this if you\'re not using Bootstrap\'s Tooltips\n * - - - - - - - - - - - - - - - - - - - - -\n */\nconst tooltipTriggerList = [].slice\n  .call(document.querySelectorAll(\'[data-bs-toggle="tooltip"]\'));\ntooltipTriggerList.map((tooltipTriggerEl) => {\n  return new bootstrap__WEBPACK_IMPORTED_MODULE_0__["Tooltip"](tooltipTriggerEl);\n});\n\n\n//# sourceURL=webpack:///./src/js/modules/bootstrap.js?')},"./src/js/modules/feather-icons.js":function srcJsModulesFeatherIconsJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var feather_icons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! feather-icons */ \"./node_modules/feather-icons/dist/feather.js\");\n/* harmony import */ var feather_icons__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(feather_icons__WEBPACK_IMPORTED_MODULE_0__);\n/*\n * -----------------------------------------\n *  REQUIRED\n * - - - - - - - - - - - - - - - - - - - - -\n */\n\nwindow.feather = feather_icons__WEBPACK_IMPORTED_MODULE_0___default.a;\n\n/*\n * -----------------------------------------\n *  INIT\n * - - - - - - - - - - - - - - - - - - - - -\n */\ndocument.addEventListener('DOMContentLoaded', () => {\n  feather_icons__WEBPACK_IMPORTED_MODULE_0___default.a.replace();\n});\n\n\n//# sourceURL=webpack:///./src/js/modules/feather-icons.js?")}});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwLmpzIiwic291cmNlcyI6WyJhcHAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyoqKioqKi9cbihmdW5jdGlvbiAobW9kdWxlcykge1xuICAvLyB3ZWJwYWNrQm9vdHN0cmFwXG5cbiAgLyoqKioqKi9cbiAgLy8gVGhlIG1vZHVsZSBjYWNoZVxuXG4gIC8qKioqKiovXG4gIHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4gIC8qKioqKiovXG5cbiAgLyoqKioqKi9cbiAgLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cblxuICAvKioqKioqL1xuXG4gIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbiAgICAvKioqKioqL1xuXG4gICAgLyoqKioqKi9cbiAgICAvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblxuICAgIC8qKioqKiovXG4gICAgaWYgKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gICAgICAvKioqKioqL1xuICAgICAgcmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gICAgICAvKioqKioqL1xuICAgIH1cbiAgICAvKioqKioqL1xuICAgIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cbiAgICAvKioqKioqL1xuXG5cbiAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gICAgICAvKioqKioqL1xuICAgICAgaTogbW9kdWxlSWQsXG5cbiAgICAgIC8qKioqKiovXG4gICAgICBsOiBmYWxzZSxcblxuICAgICAgLyoqKioqKi9cbiAgICAgIGV4cG9ydHM6IHt9XG4gICAgICAvKioqKioqL1xuXG4gICAgfTtcbiAgICAvKioqKioqL1xuXG4gICAgLyoqKioqKi9cbiAgICAvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblxuICAgIC8qKioqKiovXG5cbiAgICBtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbiAgICAvKioqKioqL1xuXG4gICAgLyoqKioqKi9cbiAgICAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cbiAgICAvKioqKioqL1xuXG4gICAgbW9kdWxlLmwgPSB0cnVlO1xuICAgIC8qKioqKiovXG5cbiAgICAvKioqKioqL1xuICAgIC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cbiAgICAvKioqKioqL1xuXG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuICAgIC8qKioqKiovXG4gIH1cbiAgLyoqKioqKi9cblxuICAvKioqKioqL1xuXG4gIC8qKioqKiovXG4gIC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5cbiAgLyoqKioqKi9cblxuXG4gIF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4gIC8qKioqKiovXG5cbiAgLyoqKioqKi9cbiAgLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcblxuICAvKioqKioqL1xuXG4gIF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4gIC8qKioqKiovXG5cbiAgLyoqKioqKi9cbiAgLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG5cbiAgLyoqKioqKi9cblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbiAoZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gICAgLyoqKioqKi9cbiAgICBpZiAoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuICAgICAgLyoqKioqKi9cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZ2V0dGVyXG4gICAgICB9KTtcbiAgICAgIC8qKioqKiovXG4gICAgfVxuICAgIC8qKioqKiovXG5cbiAgfTtcbiAgLyoqKioqKi9cblxuICAvKioqKioqL1xuICAvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5cbiAgLyoqKioqKi9cblxuXG4gIF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgLyoqKioqKi9cbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gICAgICAvKioqKioqL1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgICAgICB2YWx1ZTogJ01vZHVsZSdcbiAgICAgIH0pO1xuICAgICAgLyoqKioqKi9cbiAgICB9XG4gICAgLyoqKioqKi9cblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICAvKioqKioqL1xuICB9O1xuICAvKioqKioqL1xuXG4gIC8qKioqKiovXG4gIC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuXG4gIC8qKioqKiovXG4gIC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuXG4gIC8qKioqKiovXG4gIC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuXG4gIC8qKioqKiovXG4gIC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuXG4gIC8qKioqKiovXG4gIC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcblxuICAvKioqKioqL1xuXG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24gKHZhbHVlLCBtb2RlKSB7XG4gICAgLyoqKioqKi9cbiAgICBpZiAobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gICAgLyoqKioqKi9cblxuICAgIGlmIChtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuICAgIC8qKioqKiovXG5cbiAgICBpZiAobW9kZSAmIDQgJiYgX3R5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiAgICAvKioqKioqL1xuXG4gICAgdmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAvKioqKioqL1xuXG4gICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiAgICAvKioqKioqL1xuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0Jywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICAgIC8qKioqKiovXG5cbiAgICBpZiAobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICAgICAgfS5iaW5kKG51bGwsIGtleSkpO1xuICAgIH1cbiAgICAvKioqKioqL1xuXG4gICAgcmV0dXJuIG5zO1xuICAgIC8qKioqKiovXG4gIH07XG4gIC8qKioqKiovXG5cbiAgLyoqKioqKi9cbiAgLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcblxuICAvKioqKioqL1xuXG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIC8qKioqKiovXG4gICAgdmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gICAgLyoqKioqKi9cbiAgICBmdW5jdGlvbiBnZXREZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddO1xuICAgIH0gOlxuICAgIC8qKioqKiovXG4gICAgZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHtcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfTtcbiAgICAvKioqKioqL1xuXG4gICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuICAgIC8qKioqKiovXG5cblxuICAgIHJldHVybiBnZXR0ZXI7XG4gICAgLyoqKioqKi9cbiAgfTtcbiAgLyoqKioqKi9cblxuICAvKioqKioqL1xuICAvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcblxuICAvKioqKioqL1xuXG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuICB9O1xuICAvKioqKioqL1xuXG4gIC8qKioqKiovXG4gIC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG5cbiAgLyoqKioqKi9cblxuXG4gIF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4gIC8qKioqKiovXG5cbiAgLyoqKioqKi9cblxuICAvKioqKioqL1xuICAvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcblxuICAvKioqKioqL1xuXG4gIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvanMvYXBwLmpzXCIpO1xuICAvKioqKioqL1xufSkoXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKioqKioqL1xue1xuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9jcmVhdGVQb3BwZXIuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHBvcHBlckdlbmVyYXRvciwgY3JlYXRlUG9wcGVyLCBkZXRlY3RPdmVyZmxvdyAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkNyZWF0ZVBvcHBlckpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJwb3BwZXJHZW5lcmF0b3JcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBvcHBlckdlbmVyYXRvcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY3JlYXRlUG9wcGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVQb3BwZXI7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldENvbXBvc2l0ZVJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldExheW91dFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2xpc3RTY3JvbGxQYXJlbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldE9mZnNldFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldENvbXB1dGVkU3R5bGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfb3JkZXJNb2RpZmllcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvb3JkZXJNb2RpZmllcnMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9vcmRlck1vZGlmaWVycy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZGVib3VuY2VfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvZGVib3VuY2UuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZWJvdW5jZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdmFsaWRhdGVNb2RpZmllcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvdmFsaWRhdGVNb2RpZmllcnMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdW5pcXVlQnlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvdW5pcXVlQnkuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy91bmlxdWVCeS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZ2V0QmFzZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbWVyZ2VCeU5hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL21lcmdlQnlOYW1lLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2RldGVjdE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZXRlY3RPdmVyZmxvd1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3V0aWxzX2RldGVjdE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1xcXCJkZWZhdWx0XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lbnVtcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxudmFyIElOVkFMSURfRUxFTUVOVF9FUlJPUiA9ICdQb3BwZXI6IEludmFsaWQgcmVmZXJlbmNlIG9yIHBvcHBlciBhcmd1bWVudCBwcm92aWRlZC4gVGhleSBtdXN0IGJlIGVpdGhlciBhIERPTSBlbGVtZW50IG9yIHZpcnR1YWwgZWxlbWVudC4nO1xcbnZhciBJTkZJTklURV9MT09QX0VSUk9SID0gJ1BvcHBlcjogQW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgbW9kaWZpZXJzIGN5Y2xlIGhhcyBiZWVuIGRldGVjdGVkISBUaGUgY3ljbGUgaGFzIGJlZW4gaW50ZXJydXB0ZWQgdG8gcHJldmVudCBhIGJyb3dzZXIgY3Jhc2guJztcXG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xcbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcXG4gIG1vZGlmaWVyczogW10sXFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xcbn07XFxuXFxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xcbiAgfVxcblxcbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcXG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xcbiAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XFxuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XFxuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcXG4gIH1cXG5cXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XFxuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xcbiAgICB9XFxuXFxuICAgIHZhciBzdGF0ZSA9IHtcXG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgZGVmYXVsdE9wdGlvbnMpLFxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxcbiAgICAgIGVsZW1lbnRzOiB7XFxuICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXFxuICAgICAgfSxcXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcXG4gICAgICBzdHlsZXM6IHt9XFxuICAgIH07XFxuICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XFxuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xcbiAgICB2YXIgaW5zdGFuY2UgPSB7XFxuICAgICAgc3RhdGU6IHN0YXRlLFxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcXG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XFxuICAgICAgICAgIHJlZmVyZW5jZTogT2JqZWN0KF9kb21fdXRpbHNfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcXFwiaXNFbGVtZW50XFxcIl0pKHJlZmVyZW5jZSkgPyBPYmplY3QoX2RvbV91dGlsc19saXN0U2Nyb2xsUGFyZW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBPYmplY3QoX2RvbV91dGlsc19saXN0U2Nyb2xsUGFyZW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcXG4gICAgICAgICAgcG9wcGVyOiBPYmplY3QoX2RvbV91dGlsc19saXN0U2Nyb2xsUGFyZW50c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKHBvcHBlcilcXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxcbiAgICAgICAgLy8gcHJvcGVydGllc1xcblxcbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBPYmplY3QoX3V0aWxzX29yZGVyTW9kaWZpZXJzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcImRlZmF1bHRcXFwiXSkoT2JqZWN0KF91dGlsc19tZXJnZUJ5TmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcXFwiZGVmYXVsdFxcXCJdKShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcXG5cXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xcbiAgICAgICAgfSk7IC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBtb2RpZmllcnMgc28gdGhhdCB0aGUgY29uc3VtZXIgd2lsbCBnZXQgd2FybmVkXFxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1vZGlmaWVycyBpcyBpbnZhbGlkIGZvciBhbnkgcmVhc29uXFxuXFxuICAgICAgICBpZiAodHJ1ZSkge1xcbiAgICAgICAgICB2YXIgbW9kaWZpZXJzID0gT2JqZWN0KF91dGlsc191bmlxdWVCeV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1xcXCJkZWZhdWx0XFxcIl0pKFtdLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycyksIGZ1bmN0aW9uIChfcmVmKSB7XFxuICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XFxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QoX3V0aWxzX3ZhbGlkYXRlTW9kaWZpZXJzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcImRlZmF1bHRcXFwiXSkobW9kaWZpZXJzKTtcXG5cXG4gICAgICAgICAgaWYgKE9iamVjdChfdXRpbHNfZ2V0QmFzZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1xcXCJkZWZhdWx0XFxcIl0pKHN0YXRlLm9wdGlvbnMucGxhY2VtZW50KSA9PT0gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1xcXCJhdXRvXFxcIl0pIHtcXG4gICAgICAgICAgICB2YXIgZmxpcE1vZGlmaWVyID0gc3RhdGUub3JkZXJlZE1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChfcmVmMikge1xcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lO1xcbiAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdmbGlwJztcXG4gICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICBpZiAoIWZsaXBNb2RpZmllcikge1xcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXFxcImF1dG9cXFwiIHBsYWNlbWVudHMgcmVxdWlyZSB0aGUgXFxcImZsaXBcXFwiIG1vZGlmaWVyIGJlJywgJ3ByZXNlbnQgYW5kIGVuYWJsZWQgdG8gd29yay4nXS5qb2luKCcgJykpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBPYmplY3QoX2RvbV91dGlsc19nZXRDb21wdXRlZFN0eWxlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXSkocG9wcGVyKSxcXG4gICAgICAgICAgICAgIG1hcmdpblRvcCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblRvcCxcXG4gICAgICAgICAgICAgIG1hcmdpblJpZ2h0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luUmlnaHQsXFxuICAgICAgICAgICAgICBtYXJnaW5Cb3R0b20gPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Cb3R0b20sXFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luTGVmdDsgLy8gV2Ugbm8gbG9uZ2VyIHRha2UgaW50byBhY2NvdW50IGBtYXJnaW5zYCBvbiB0aGUgcG9wcGVyLCBhbmQgaXQgY2FuXFxuICAgICAgICAgIC8vIGNhdXNlIGJ1Z3Mgd2l0aCBwb3NpdGlvbmluZywgc28gd2UnbGwgd2FybiB0aGUgY29uc3VtZXJcXG5cXG5cXG4gICAgICAgICAgaWYgKFttYXJnaW5Ub3AsIG1hcmdpblJpZ2h0LCBtYXJnaW5Cb3R0b20sIG1hcmdpbkxlZnRdLnNvbWUoZnVuY3Rpb24gKG1hcmdpbikge1xcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hcmdpbik7XFxuICAgICAgICAgIH0pKSB7XFxuICAgICAgICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBDU1MgXFxcIm1hcmdpblxcXCIgc3R5bGVzIGNhbm5vdCBiZSB1c2VkIHRvIGFwcGx5IHBhZGRpbmcnLCAnYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgb3IgYm91bmRhcnkuJywgJ1RvIHJlcGxpY2F0ZSBtYXJnaW4sIHVzZSB0aGUgYG9mZnNldGAgbW9kaWZpZXIsIGFzIHdlbGwgYXMnLCAndGhlIGBwYWRkaW5nYCBvcHRpb24gaW4gdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIGFuZCBgZmxpcGAnLCAnbW9kaWZpZXJzLiddLmpvaW4oJyAnKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xcbiAgICAgIH0sXFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXFxuICAgICAgLy8gbG9naWMuXFxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XFxuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXFxuICAgICAgICAvLyBhbnltb3JlXFxuXFxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XFxuICAgICAgICAgIGlmICh0cnVlKSB7XFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXFxuXFxuXFxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcXG4gICAgICAgICAgcmVmZXJlbmNlOiBPYmplY3QoX2RvbV91dGlsc19nZXRDb21wb3NpdGVSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkocmVmZXJlbmNlLCBPYmplY3QoX2RvbV91dGlsc19nZXRPZmZzZXRQYXJlbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdKShwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcXG4gICAgICAgICAgcG9wcGVyOiBPYmplY3QoX2RvbV91dGlsc19nZXRMYXlvdXRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkocG9wcGVyKVxcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXFxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxcblxcbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcXG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50OyAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXFxuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxcbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXFxuXFxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XFxuICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHZhciBfX2RlYnVnX2xvb3BzX18gPSAwO1xcblxcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XFxuICAgICAgICAgIGlmICh0cnVlKSB7XFxuICAgICAgICAgICAgX19kZWJ1Z19sb29wc19fICs9IDE7XFxuXFxuICAgICAgICAgICAgaWYgKF9fZGVidWdfbG9vcHNfXyA+IDEwMCkge1xcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTkZJTklURV9MT09QX0VSUk9SKTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcXG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXFxuICAgICAgICAgICAgICBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm9wdGlvbnMsXFxuICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcXG5cXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxcbiAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXFxuICAgICAgICAgICAgfSkgfHwgc3RhdGU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxcbiAgICAgIHVwZGF0ZTogT2JqZWN0KF91dGlsc19kZWJvdW5jZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJkZWZhdWx0XFxcIl0pKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pLFxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XFxuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XFxuICAgICAgaWYgKHRydWUpIHtcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xcbiAgICB9XFxuXFxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcXG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcXG4gICAgICB9XFxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcXG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXFxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxcbiAgICAvLyBvbmUuXFxuXFxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcXG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XFxuICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWUsXFxuICAgICAgICAgICAgX3JlZjMkb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnMsXFxuICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYzJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjMkb3B0aW9ucyxcXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3Q7XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xcbiAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xcblxcbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcXG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XFxuICAgICAgICByZXR1cm4gZm4oKTtcXG4gICAgICB9KTtcXG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGluc3RhbmNlO1xcbiAgfTtcXG59XFxudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvY3JlYXRlUG9wcGVyLmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzQ29udGFpbnNKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29udGFpbnM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnN0YW5jZU9mLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XFxuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXFxuXFxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcXG4gIGVsc2UgaWYgKHJvb3ROb2RlICYmIE9iamVjdChfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJpc1NoYWRvd1Jvb3RcXFwiXSkocm9vdE5vZGUpKSB7XFxuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcXG5cXG4gICAgICBkbyB7XFxuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxcblxcblxcbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XFxuICAgICAgfSB3aGlsZSAobmV4dCk7XFxuICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxcblxcblxcbiAgcmV0dXJuIGZhbHNlO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRCb3VuZGluZ0NsaWVudFJlY3RKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0OyB9KTtcXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgcmV0dXJuIHtcXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXFxuICAgIHRvcDogcmVjdC50b3AsXFxuICAgIHJpZ2h0OiByZWN0LnJpZ2h0LFxcbiAgICBib3R0b206IHJlY3QuYm90dG9tLFxcbiAgICBsZWZ0OiByZWN0LmxlZnQsXFxuICAgIHg6IHJlY3QubGVmdCxcXG4gICAgeTogcmVjdC50b3BcXG4gIH07XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRDbGlwcGluZ1JlY3RKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0Q2xpcHBpbmdSZWN0OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lbnVtcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRWaWV3cG9ydFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0Vmlld3BvcnRSZWN0LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFZpZXdwb3J0UmVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0RG9jdW1lbnRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldERvY3VtZW50UmVjdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudFJlY3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xpc3RTY3JvbGxQYXJlbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpc3RTY3JvbGxQYXJlbnRzLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRPZmZzZXRQYXJlbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0T2Zmc2V0UGFyZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0RG9jdW1lbnRFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldERvY3VtZW50RWxlbWVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldENvbXB1dGVkU3R5bGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0Q29tcHV0ZWRTdHlsZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2luc3RhbmNlT2YuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0Qm91bmRpbmdDbGllbnRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFBhcmVudE5vZGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0UGFyZW50Tm9kZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb250YWluc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udGFpbnMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvY29udGFpbnMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldE5vZGVOYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXROb2RlTmFtZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfcmVjdFRvQ2xpZW50UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tYXRoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvbWF0aC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XFxuICB2YXIgcmVjdCA9IE9iamVjdChfZ2V0Qm91bmRpbmdDbGllbnRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCk7XFxuICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XFxuICByZWN0LmxlZnQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XFxuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XFxuICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcXG4gIHJlY3Qud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcXG4gIHJlY3QueCA9IHJlY3QubGVmdDtcXG4gIHJlY3QueSA9IHJlY3QudG9wO1xcbiAgcmV0dXJuIHJlY3Q7XFxufVxcblxcbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KSB7XFxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ2aWV3cG9ydFxcXCJdID8gT2JqZWN0KF91dGlsc19yZWN0VG9DbGllbnRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1xcXCJkZWZhdWx0XFxcIl0pKE9iamVjdChfZ2V0Vmlld3BvcnRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCkpIDogT2JqZWN0KF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcImlzSFRNTEVsZW1lbnRcXFwiXSkoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQpIDogT2JqZWN0KF91dGlsc19yZWN0VG9DbGllbnRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1xcXCJkZWZhdWx0XFxcIl0pKE9iamVjdChfZ2V0RG9jdW1lbnRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoT2JqZWN0KF9nZXREb2N1bWVudEVsZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KSkpO1xcbn0gLy8gQSBcXFwiY2xpcHBpbmcgcGFyZW50XFxcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXFxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXFxuLy8gYGluaXRpYWxgXFxuXFxuXFxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIHtcXG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBPYmplY3QoX2xpc3RTY3JvbGxQYXJlbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImRlZmF1bHRcXFwiXSkoT2JqZWN0KF9nZXRQYXJlbnROb2RlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCkpO1xcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoT2JqZWN0KF9nZXRDb21wdXRlZFN0eWxlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCkucG9zaXRpb24pID49IDA7XFxuICB2YXIgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBPYmplY3QoX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcXFwiaXNIVE1MRWxlbWVudFxcXCJdKShlbGVtZW50KSA/IE9iamVjdChfZ2V0T2Zmc2V0UGFyZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCkgOiBlbGVtZW50O1xcblxcbiAgaWYgKCFPYmplY3QoX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcXFwiaXNFbGVtZW50XFxcIl0pKGNsaXBwZXJFbGVtZW50KSkge1xcbiAgICByZXR1cm4gW107XFxuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XFxuXFxuXFxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcXG4gICAgcmV0dXJuIE9iamVjdChfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJpc0VsZW1lbnRcXFwiXSkoY2xpcHBpbmdQYXJlbnQpICYmIE9iamVjdChfY29udGFpbnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXFxcImRlZmF1bHRcXFwiXSkoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBPYmplY3QoX2dldE5vZGVOYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1xcXCJkZWZhdWx0XFxcIl0pKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xcbiAgfSk7XFxufSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXFxuLy8gY2xpcHBpbmcgcGFyZW50c1xcblxcblxcbmZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KSB7XFxuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XFxuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcXG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XFxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpO1xcbiAgICBhY2NSZWN0LnRvcCA9IE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcXFwibWF4XFxcIl0pKHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XFxuICAgIGFjY1JlY3QucmlnaHQgPSBPYmplY3QoX3V0aWxzX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXFxcIm1pblxcXCJdKShyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcXG4gICAgYWNjUmVjdC5ib3R0b20gPSBPYmplY3QoX3V0aWxzX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXFxcIm1pblxcXCJdKShyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xcbiAgICBhY2NSZWN0LmxlZnQgPSBPYmplY3QoX3V0aWxzX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXFxcIm1heFxcXCJdKShyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XFxuICAgIHJldHVybiBhY2NSZWN0O1xcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgZmlyc3RDbGlwcGluZ1BhcmVudCkpO1xcbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XFxuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XFxuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRDb21wb3NpdGVSZWN0SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldENvbXBvc2l0ZVJlY3Q7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0Qm91bmRpbmdDbGllbnRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldE5vZGVTY3JvbGxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0Tm9kZVNjcm9sbC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXROb2RlTmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXROb2RlTmFtZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnN0YW5jZU9mLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFdpbmRvd1Njcm9sbEJhclhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXREb2N1bWVudEVsZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaXNTY3JvbGxQYXJlbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNTY3JvbGxQYXJlbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG4gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50Llxcbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cXG5cXG5mdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcXG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcXG4gICAgaXNGaXhlZCA9IGZhbHNlO1xcbiAgfVxcblxcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IE9iamVjdChfZ2V0RG9jdW1lbnRFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcImRlZmF1bHRcXFwiXSkob2Zmc2V0UGFyZW50KTtcXG4gIHZhciByZWN0ID0gT2JqZWN0KF9nZXRCb3VuZGluZ0NsaWVudFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCk7XFxuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBPYmplY3QoX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiaXNIVE1MRWxlbWVudFxcXCJdKShvZmZzZXRQYXJlbnQpO1xcbiAgdmFyIHNjcm9sbCA9IHtcXG4gICAgc2Nyb2xsTGVmdDogMCxcXG4gICAgc2Nyb2xsVG9wOiAwXFxuICB9O1xcbiAgdmFyIG9mZnNldHMgPSB7XFxuICAgIHg6IDAsXFxuICAgIHk6IDBcXG4gIH07XFxuXFxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XFxuICAgIGlmIChPYmplY3QoX2dldE5vZGVOYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxcbiAgICBPYmplY3QoX2lzU2Nyb2xsUGFyZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcImRlZmF1bHRcXFwiXSkoZG9jdW1lbnRFbGVtZW50KSkge1xcbiAgICAgIHNjcm9sbCA9IE9iamVjdChfZ2V0Tm9kZVNjcm9sbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKG9mZnNldFBhcmVudCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKE9iamVjdChfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJpc0hUTUxFbGVtZW50XFxcIl0pKG9mZnNldFBhcmVudCkpIHtcXG4gICAgICBvZmZzZXRzID0gT2JqZWN0KF9nZXRCb3VuZGluZ0NsaWVudFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShvZmZzZXRQYXJlbnQpO1xcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcXG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcXG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcXG4gICAgICBvZmZzZXRzLnggPSBPYmplY3QoX2dldFdpbmRvd1Njcm9sbEJhclhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVmYXVsdFxcXCJdKShkb2N1bWVudEVsZW1lbnQpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4ge1xcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxcbiAgfTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0Q29tcHV0ZWRTdHlsZUpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRDb21wdXRlZFN0eWxlOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRXaW5kb3cuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXFxcIik7XFxuXFxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XFxuICByZXR1cm4gT2JqZWN0KF9nZXRXaW5kb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldERvY3VtZW50RWxlbWVudEpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXREb2N1bWVudEVsZW1lbnQ7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnN0YW5jZU9mLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxcbiAgcmV0dXJuICgoT2JqZWN0KF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImlzRWxlbWVudFxcXCJdKShlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxcbiAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXREb2N1bWVudFJlY3RKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0RG9jdW1lbnRSZWN0OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldERvY3VtZW50RWxlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXREb2N1bWVudEVsZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRDb21wdXRlZFN0eWxlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldENvbXB1dGVkU3R5bGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0V2luZG93U2Nyb2xsQmFyWF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFdpbmRvd1Njcm9sbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRXaW5kb3dTY3JvbGwuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tYXRoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tYXRoLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qc1xcXCIpO1xcblxcblxcblxcblxcbiAvLyBHZXRzIHRoZSBlbnRpcmUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBkb2N1bWVudCBhcmVhLCBldmVuIGV4dGVuZGluZyBvdXRzaWRlXFxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxcblxcbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XFxuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xcblxcbiAgdmFyIGh0bWwgPSBPYmplY3QoX2dldERvY3VtZW50RWxlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpO1xcbiAgdmFyIHdpblNjcm9sbCA9IE9iamVjdChfZ2V0V2luZG93U2Nyb2xsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCk7XFxuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcXG4gIHZhciB3aWR0aCA9IE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJtYXhcXFwiXSkoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xcbiAgdmFyIGhlaWdodCA9IE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJtYXhcXFwiXSkoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcXG4gIHZhciB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgT2JqZWN0KF9nZXRXaW5kb3dTY3JvbGxCYXJYX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCk7XFxuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xcblxcbiAgaWYgKE9iamVjdChfZ2V0Q29tcHV0ZWRTdHlsZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xcbiAgICB4ICs9IE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJtYXhcXFwiXSkoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xcbiAgfVxcblxcbiAgcmV0dXJuIHtcXG4gICAgd2lkdGg6IHdpZHRoLFxcbiAgICBoZWlnaHQ6IGhlaWdodCxcXG4gICAgeDogeCxcXG4gICAgeTogeVxcbiAgfTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0SFRNTEVsZW1lbnRTY3JvbGxKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGw7IH0pO1xcbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcXG4gIHJldHVybiB7XFxuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxcbiAgfTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldExheW91dFJlY3RKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0TGF5b3V0UmVjdDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRCb3VuZGluZ0NsaWVudFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1xcXCIpO1xcbiAvLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxcbi8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cXG5cXG5mdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcXG4gIHZhciBjbGllbnRSZWN0ID0gT2JqZWN0KF9nZXRCb3VuZGluZ0NsaWVudFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXFxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcXG5cXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XFxuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XFxuXFxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XFxuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcXG4gIH1cXG5cXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xcbiAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXFxuICAgIHdpZHRoOiB3aWR0aCxcXG4gICAgaGVpZ2h0OiBoZWlnaHRcXG4gIH07XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXROb2RlTmFtZUpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXROb2RlTmFtZTsgfSk7XFxuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXROb2RlU2Nyb2xsSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldE5vZGVTY3JvbGw7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0V2luZG93U2Nyb2xsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldFdpbmRvd1Njcm9sbC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRXaW5kb3cuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2luc3RhbmNlT2YuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0SFRNTEVsZW1lbnRTY3JvbGxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcXG4gIGlmIChub2RlID09PSBPYmplY3QoX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKG5vZGUpIHx8ICFPYmplY3QoX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiaXNIVE1MRWxlbWVudFxcXCJdKShub2RlKSkge1xcbiAgICByZXR1cm4gT2JqZWN0KF9nZXRXaW5kb3dTY3JvbGxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShub2RlKTtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBPYmplY3QoX2dldEhUTUxFbGVtZW50U2Nyb2xsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImRlZmF1bHRcXFwiXSkobm9kZSk7XFxuICB9XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0T2Zmc2V0UGFyZW50SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldE9mZnNldFBhcmVudDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRXaW5kb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0V2luZG93LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0Tm9kZU5hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0Tm9kZU5hbWUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldENvbXB1dGVkU3R5bGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0Q29tcHV0ZWRTdHlsZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2luc3RhbmNlT2YuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaXNUYWJsZUVsZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNUYWJsZUVsZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFBhcmVudE5vZGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0UGFyZW50Tm9kZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XFxuICBpZiAoIU9iamVjdChfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJpc0hUTUxFbGVtZW50XFxcIl0pKGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XFxuICBPYmplY3QoX2dldENvbXB1dGVkU3R5bGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcXG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXFxuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXFxuXFxuXFxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcXG4gIHZhciBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMTtcXG4gIHZhciBpc0lFID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgIT09IC0xO1xcblxcbiAgaWYgKGlzSUUgJiYgT2JqZWN0KF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImlzSFRNTEVsZW1lbnRcXFwiXSkoZWxlbWVudCkpIHtcXG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxcbiAgICB2YXIgZWxlbWVudENzcyA9IE9iamVjdChfZ2V0Q29tcHV0ZWRTdHlsZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpO1xcblxcbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgY3VycmVudE5vZGUgPSBPYmplY3QoX2dldFBhcmVudE5vZGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KTtcXG5cXG4gIHdoaWxlIChPYmplY3QoX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiaXNIVE1MRWxlbWVudFxcXCJdKShjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKE9iamVjdChfZ2V0Tm9kZU5hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShjdXJyZW50Tm9kZSkpIDwgMCkge1xcbiAgICB2YXIgY3NzID0gT2JqZWN0KF9nZXRDb21wdXRlZFN0eWxlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoY3VycmVudE5vZGUpOyAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcXG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcXG5cXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBudWxsO1xcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXFxuXFxuXFxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcXG4gIHZhciB3aW5kb3cgPSBPYmplY3QoX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpO1xcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XFxuXFxuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIE9iamVjdChfaXNUYWJsZUVsZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVmYXVsdFxcXCJdKShvZmZzZXRQYXJlbnQpICYmIE9iamVjdChfZ2V0Q29tcHV0ZWRTdHlsZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XFxuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcXG4gIH1cXG5cXG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKE9iamVjdChfZ2V0Tm9kZU5hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgT2JqZWN0KF9nZXROb2RlTmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBPYmplY3QoX2dldENvbXB1dGVkU3R5bGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpIHtcXG4gICAgcmV0dXJuIHdpbmRvdztcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRQYXJlbnROb2RlSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFBhcmVudE5vZGU7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0Tm9kZU5hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0Tm9kZU5hbWUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldERvY3VtZW50RWxlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXREb2N1bWVudEVsZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2luc3RhbmNlT2YuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1xcXCIpO1xcblxcblxcblxcbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xcbiAgaWYgKE9iamVjdChfZ2V0Tm9kZU5hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XFxuICAgIHJldHVybiBlbGVtZW50O1xcbiAgfVxcblxcbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXFxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxcbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxcbiAgICBPYmplY3QoX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiaXNTaGFkb3dSb290XFxcIl0pKGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXFxuICAgIE9iamVjdChfZ2V0RG9jdW1lbnRFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCkgLy8gZmFsbGJhY2tcXG5cXG4gICk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0U2Nyb2xsUGFyZW50SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFNjcm9sbFBhcmVudDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRQYXJlbnROb2RlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldFBhcmVudE5vZGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaXNTY3JvbGxQYXJlbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNTY3JvbGxQYXJlbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldE5vZGVOYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldE5vZGVOYW1lLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2luc3RhbmNlT2YuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1xcXCIpO1xcblxcblxcblxcblxcbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XFxuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihPYmplY3QoX2dldE5vZGVOYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkobm9kZSkpID49IDApIHtcXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XFxuICB9XFxuXFxuICBpZiAoT2JqZWN0KF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImlzSFRNTEVsZW1lbnRcXFwiXSkobm9kZSkgJiYgT2JqZWN0KF9pc1Njcm9sbFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKG5vZGUpKSB7XFxuICAgIHJldHVybiBub2RlO1xcbiAgfVxcblxcbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChPYmplY3QoX2dldFBhcmVudE5vZGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShub2RlKSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFZpZXdwb3J0UmVjdC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRWaWV3cG9ydFJlY3RKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0Vmlld3BvcnRSZWN0OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRXaW5kb3cuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXREb2N1bWVudEVsZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0V2luZG93U2Nyb2xsQmFyWF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanNcXFwiKTtcXG5cXG5cXG5cXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkge1xcbiAgdmFyIHdpbiA9IE9iamVjdChfZ2V0V2luZG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCk7XFxuICB2YXIgaHRtbCA9IE9iamVjdChfZ2V0RG9jdW1lbnRFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCk7XFxuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XFxuICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xcbiAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xcbiAgdmFyIHggPSAwO1xcbiAgdmFyIHkgPSAwOyAvLyBOQjogVGhpcyBpc24ndCBzdXBwb3J0ZWQgb24gaU9TIDw9IDEyLiBJZiB0aGUga2V5Ym9hcmQgaXMgb3BlbiwgdGhlIHBvcHBlclxcbiAgLy8gY2FuIGJlIG9ic2N1cmVkIHVuZGVybmVhdGggaXQuXFxuICAvLyBBbHNvLCBgaHRtbC5jbGllbnRIZWlnaHRgIGFkZHMgdGhlIGJvdHRvbSBiYXIgaGVpZ2h0IGluIFNhZmFyaSBpT1MsIGV2ZW5cXG4gIC8vIGlmIGl0IGlzbid0IG9wZW4sIHNvIGlmIHRoaXMgaXNuJ3QgYXZhaWxhYmxlLCB0aGUgcG9wcGVyIHdpbGwgYmUgZGV0ZWN0ZWRcXG4gIC8vIHRvIG92ZXJmbG93IHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiB0b28gZWFybHkuXFxuXFxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcXG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcXG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0OyAvLyBVc2VzIExheW91dCBWaWV3cG9ydCAobGlrZSBDaHJvbWU7IFNhZmFyaSBkb2VzIG5vdCBjdXJyZW50bHkpXFxuICAgIC8vIEluIENocm9tZSwgaXQgcmV0dXJucyBhIHZhbHVlIHZlcnkgY2xvc2UgdG8gMCAoKy8tKSBidXQgY29udGFpbnMgcm91bmRpbmdcXG4gICAgLy8gZXJyb3JzIGR1ZSB0byBmbG9hdGluZyBwb2ludCBudW1iZXJzLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIHByZWNpc2lvbi5cXG4gICAgLy8gU2FmYXJpIHJldHVybnMgYSBudW1iZXIgPD0gMCwgdXN1YWxseSA8IC0xIHdoZW4gcGluY2gtem9vbWVkXFxuICAgIC8vIEZlYXR1cmUgZGV0ZWN0aW9uIGZhaWxzIGluIG1vYmlsZSBlbXVsYXRpb24gbW9kZSBpbiBDaHJvbWUuXFxuICAgIC8vIE1hdGguYWJzKHdpbi5pbm5lcldpZHRoIC8gdmlzdWFsVmlld3BvcnQuc2NhbGUgLSB2aXN1YWxWaWV3cG9ydC53aWR0aCkgPFxcbiAgICAvLyAwLjAwMVxcbiAgICAvLyBGYWxsYmFjayBoZXJlOiBcXFwiTm90IFNhZmFyaVxcXCIgdXNlckFnZW50XFxuXFxuICAgIGlmICghL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIHdpZHRoOiB3aWR0aCxcXG4gICAgaGVpZ2h0OiBoZWlnaHQsXFxuICAgIHg6IHggKyBPYmplY3QoX2dldFdpbmRvd1Njcm9sbEJhclhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KSxcXG4gICAgeTogeVxcbiAgfTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldFdpbmRvd0pzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRXaW5kb3c7IH0pO1xcbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XFxuICBpZiAobm9kZSA9PSBudWxsKSB7XFxuICAgIHJldHVybiB3aW5kb3c7XFxuICB9XFxuXFxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcXG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcXG4gIH1cXG5cXG4gIHJldHVybiBub2RlO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0V2luZG93U2Nyb2xsSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFdpbmRvd1Njcm9sbDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRXaW5kb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0V2luZG93LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XFxuICB2YXIgd2luID0gT2JqZWN0KF9nZXRXaW5kb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShub2RlKTtcXG4gIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcXG4gIHJldHVybiB7XFxuICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXFxuICB9O1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldFdpbmRvd1Njcm9sbEJhclhKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0V2luZG93U2Nyb2xsQmFyWDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRCb3VuZGluZ0NsaWVudFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0RG9jdW1lbnRFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldERvY3VtZW50RWxlbWVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFdpbmRvd1Njcm9sbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRXaW5kb3dTY3JvbGwuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzXFxcIik7XFxuXFxuXFxuXFxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XFxuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXFxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cXG4gIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXFxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XFxuICAvLyBhbnl3YXkuXFxuICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcXG4gIHJldHVybiBPYmplY3QoX2dldEJvdW5kaW5nQ2xpZW50UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKE9iamVjdChfZ2V0RG9jdW1lbnRFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCkpLmxlZnQgKyBPYmplY3QoX2dldFdpbmRvd1Njcm9sbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpLnNjcm9sbExlZnQ7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNJbnN0YW5jZU9mSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImlzRWxlbWVudFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNFbGVtZW50OyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJpc0hUTUxFbGVtZW50XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0hUTUxFbGVtZW50OyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJpc1NoYWRvd1Jvb3RcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzU2hhZG93Um9vdDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRXaW5kb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0V2luZG93LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XFxuICB2YXIgT3duRWxlbWVudCA9IE9iamVjdChfZ2V0V2luZG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkobm9kZSkuRWxlbWVudDtcXG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcXG59XFxuXFxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XFxuICB2YXIgT3duRWxlbWVudCA9IE9iamVjdChfZ2V0V2luZG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkobm9kZSkuSFRNTEVsZW1lbnQ7XFxuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xcbn1cXG5cXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcXG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgdmFyIE93bkVsZW1lbnQgPSBPYmplY3QoX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKG5vZGUpLlNoYWRvd1Jvb3Q7XFxuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XFxufVxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNJc1Njcm9sbFBhcmVudEpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1Njcm9sbFBhcmVudDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRDb21wdXRlZFN0eWxlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldENvbXB1dGVkU3R5bGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcXG4gIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IE9iamVjdChfZ2V0Q29tcHV0ZWRTdHlsZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpLFxcbiAgICAgIG92ZXJmbG93ID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3csXFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcXG5cXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0lzVGFibGVFbGVtZW50SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzVGFibGVFbGVtZW50OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldE5vZGVOYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldE5vZGVOYW1lLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXFxcIik7XFxuXFxuZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKE9iamVjdChfZ2V0Tm9kZU5hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KSkgPj0gMDtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNMaXN0U2Nyb2xsUGFyZW50c0pzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsaXN0U2Nyb2xsUGFyZW50czsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRTY3JvbGxQYXJlbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0U2Nyb2xsUGFyZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0UGFyZW50Tm9kZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRQYXJlbnROb2RlLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRXaW5kb3cuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc1Njcm9sbFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1Njcm9sbFBhcmVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qc1xcXCIpO1xcblxcblxcblxcblxcbi8qXFxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcXG51bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxcbiovXFxuXFxuZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcXG5cXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcXG4gICAgbGlzdCA9IFtdO1xcbiAgfVxcblxcbiAgdmFyIHNjcm9sbFBhcmVudCA9IE9iamVjdChfZ2V0U2Nyb2xsUGFyZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCk7XFxuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcXG4gIHZhciB3aW4gPSBPYmplY3QoX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKHNjcm9sbFBhcmVudCk7XFxuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgT2JqZWN0KF9pc1Njcm9sbFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl0pKHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XFxuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXFxuICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoT2JqZWN0KF9nZXRQYXJlbnROb2RlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkodGFyZ2V0KSkpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0LCBhdXRvLCBiYXNlUGxhY2VtZW50cywgc3RhcnQsIGVuZCwgY2xpcHBpbmdQYXJlbnRzLCB2aWV3cG9ydCwgcG9wcGVyLCByZWZlcmVuY2UsIHZhcmlhdGlvblBsYWNlbWVudHMsIHBsYWNlbWVudHMsIGJlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGUsIG1vZGlmaWVyUGhhc2VzICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRW51bXNKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidG9wXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0b3A7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImJvdHRvbVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYm90dG9tOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyaWdodFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmlnaHQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImxlZnRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxlZnQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImF1dG9cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGF1dG87IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImJhc2VQbGFjZW1lbnRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBiYXNlUGxhY2VtZW50czsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic3RhcnRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHN0YXJ0OyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJlbmRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGVuZDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY2xpcHBpbmdQYXJlbnRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjbGlwcGluZ1BhcmVudHM7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInZpZXdwb3J0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB2aWV3cG9ydDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicG9wcGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwb3BwZXI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJlZmVyZW5jZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVmZXJlbmNlOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ2YXJpYXRpb25QbGFjZW1lbnRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB2YXJpYXRpb25QbGFjZW1lbnRzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJwbGFjZW1lbnRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwbGFjZW1lbnRzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJiZWZvcmVSZWFkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBiZWZvcmVSZWFkOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyZWFkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZWFkOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhZnRlclJlYWRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFmdGVyUmVhZDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYmVmb3JlTWFpblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmVmb3JlTWFpbjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibWFpblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWFpbjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYWZ0ZXJNYWluXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhZnRlck1haW47IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImJlZm9yZVdyaXRlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBiZWZvcmVXcml0ZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwid3JpdGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdyaXRlOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhZnRlcldyaXRlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhZnRlcldyaXRlOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJtb2RpZmllclBoYXNlc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kaWZpZXJQaGFzZXM7IH0pO1xcbnZhciB0b3AgPSAndG9wJztcXG52YXIgYm90dG9tID0gJ2JvdHRvbSc7XFxudmFyIHJpZ2h0ID0gJ3JpZ2h0JztcXG52YXIgbGVmdCA9ICdsZWZ0JztcXG52YXIgYXV0byA9ICdhdXRvJztcXG52YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcXG52YXIgc3RhcnQgPSAnc3RhcnQnO1xcbnZhciBlbmQgPSAnZW5kJztcXG52YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XFxudmFyIHZpZXdwb3J0ID0gJ3ZpZXdwb3J0JztcXG52YXIgcG9wcGVyID0gJ3BvcHBlcic7XFxudmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xcbnZhciB2YXJpYXRpb25QbGFjZW1lbnRzID0gLyojX19QVVJFX18qL2Jhc2VQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcXG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcXFwiLVxcXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXFxcIi1cXFwiICsgZW5kXSk7XFxufSwgW10pO1xcbnZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XFxuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcXFwiLVxcXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXFxcIi1cXFwiICsgZW5kXSk7XFxufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxcblxcbnZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xcbnZhciByZWFkID0gJ3JlYWQnO1xcbnZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcXG5cXG52YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcXG52YXIgbWFpbiA9ICdtYWluJztcXG52YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcXG5cXG52YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xcbnZhciB3cml0ZSA9ICd3cml0ZSc7XFxudmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XFxudmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvaW5kZXguanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvaW5kZXguanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHRvcCwgYm90dG9tLCByaWdodCwgbGVmdCwgYXV0bywgYmFzZVBsYWNlbWVudHMsIHN0YXJ0LCBlbmQsIGNsaXBwaW5nUGFyZW50cywgdmlld3BvcnQsIHBvcHBlciwgcmVmZXJlbmNlLCB2YXJpYXRpb25QbGFjZW1lbnRzLCBwbGFjZW1lbnRzLCBiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlLCBtb2RpZmllclBoYXNlcywgYXBwbHlTdHlsZXMsIGFycm93LCBjb21wdXRlU3R5bGVzLCBldmVudExpc3RlbmVycywgZmxpcCwgaGlkZSwgb2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCBwcmV2ZW50T3ZlcmZsb3csIHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3csIGNyZWF0ZVBvcHBlckJhc2UsIGNyZWF0ZVBvcHBlciwgY3JlYXRlUG9wcGVyTGl0ZSAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkluZGV4SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZW51bXMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidG9wXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwidG9wXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYm90dG9tXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiYm90dG9tXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmlnaHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJyaWdodFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImxlZnRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJsZWZ0XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYXV0b1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImF1dG9cXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJiYXNlUGxhY2VtZW50c1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImJhc2VQbGFjZW1lbnRzXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwic3RhcnRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJzdGFydFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImVuZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImVuZFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNsaXBwaW5nUGFyZW50c1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImNsaXBwaW5nUGFyZW50c1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInZpZXdwb3J0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwidmlld3BvcnRcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJwb3BwZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJwb3BwZXJcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyZWZlcmVuY2VcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJyZWZlcmVuY2VcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ2YXJpYXRpb25QbGFjZW1lbnRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwidmFyaWF0aW9uUGxhY2VtZW50c1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInBsYWNlbWVudHNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJwbGFjZW1lbnRzXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYmVmb3JlUmVhZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImJlZm9yZVJlYWRcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyZWFkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicmVhZFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFmdGVyUmVhZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImFmdGVyUmVhZFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImJlZm9yZU1haW5cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJiZWZvcmVNYWluXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibWFpblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIm1haW5cXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhZnRlck1haW5cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJhZnRlck1haW5cXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJiZWZvcmVXcml0ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImJlZm9yZVdyaXRlXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwid3JpdGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ3cml0ZVxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFmdGVyV3JpdGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJhZnRlcldyaXRlXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibW9kaWZpZXJQaGFzZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJtb2RpZmllclBoYXNlc1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21vZGlmaWVyc19pbmRleF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2RpZmllcnMvaW5kZXguanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFwcGx5U3R5bGVzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImFwcGx5U3R5bGVzXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYXJyb3dcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tb2RpZmllcnNfaW5kZXhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiYXJyb3dcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJjb21wdXRlU3R5bGVzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImNvbXB1dGVTdHlsZXNcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJldmVudExpc3RlbmVyc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21vZGlmaWVyc19pbmRleF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJldmVudExpc3RlbmVyc1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImZsaXBcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tb2RpZmllcnNfaW5kZXhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZmxpcFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImhpZGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tb2RpZmllcnNfaW5kZXhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiaGlkZVxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm9mZnNldFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21vZGlmaWVyc19pbmRleF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJvZmZzZXRcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJwb3BwZXJPZmZzZXRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInBvcHBlck9mZnNldHNcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJwcmV2ZW50T3ZlcmZsb3dcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tb2RpZmllcnNfaW5kZXhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwicHJldmVudE92ZXJmbG93XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY3JlYXRlUG9wcGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NyZWF0ZVBvcHBlci5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicG9wcGVyR2VuZXJhdG9yXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfY3JlYXRlUG9wcGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcInBvcHBlckdlbmVyYXRvclxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRldGVjdE92ZXJmbG93XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfY3JlYXRlUG9wcGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRldGVjdE92ZXJmbG93XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY3JlYXRlUG9wcGVyQmFzZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2NyZWF0ZVBvcHBlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJjcmVhdGVQb3BwZXJcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wb3BwZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcG9wcGVyLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJjcmVhdGVQb3BwZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9wb3BwZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiY3JlYXRlUG9wcGVyXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcG9wcGVyX2xpdGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcG9wcGVyLWxpdGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXItbGl0ZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY3JlYXRlUG9wcGVyTGl0ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3BvcHBlcl9saXRlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImNyZWF0ZVBvcHBlclxcXCJdOyB9KTtcXG5cXG5cXG4gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xcblxcbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxuIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2luZGV4LmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYk1vZGlmaWVyc0FwcGx5U3R5bGVzSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldE5vZGVOYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RvbV91dGlsc19pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXFxcIik7XFxuXFxuIC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXFxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xcblxcbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XFxuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XFxuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcXG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXFxuXFxuICAgIGlmICghT2JqZWN0KF9kb21fdXRpbHNfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJpc0hUTUxFbGVtZW50XFxcIl0pKGVsZW1lbnQpIHx8ICFPYmplY3QoX2RvbV91dGlsc19nZXROb2RlTmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cXG5cXG5cXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XFxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcXG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xcblxcbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9KTtcXG59XFxuXFxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XFxuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcXG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xcbiAgICBwb3BwZXI6IHtcXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcXG4gICAgICBsZWZ0OiAnMCcsXFxuICAgICAgdG9wOiAnMCcsXFxuICAgICAgbWFyZ2luOiAnMCdcXG4gICAgfSxcXG4gICAgYXJyb3c6IHtcXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xcbiAgICB9LFxcbiAgICByZWZlcmVuY2U6IHt9XFxuICB9O1xcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcXG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XFxuXFxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcXG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XFxuICB9XFxuXFxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XFxuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xcbiAgICAgIHZhciBzdHlsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBzdGF0ZS5zdHlsZXNbbmFtZV0gOiBpbml0aWFsU3R5bGVzW25hbWVdKTsgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cXG5cXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcXG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXFxuXFxuICAgICAgaWYgKCFPYmplY3QoX2RvbV91dGlsc19pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImlzSFRNTEVsZW1lbnRcXFwiXSkoZWxlbWVudCkgfHwgIU9iamVjdChfZG9tX3V0aWxzX2dldE5vZGVOYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XFxuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XFxuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xcbiAgICAgIH0pO1xcbiAgICB9KTtcXG4gIH07XFxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1xcXCJkZWZhdWx0XFxcIl0gPSAoe1xcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcXG4gIGVuYWJsZWQ6IHRydWUsXFxuICBwaGFzZTogJ3dyaXRlJyxcXG4gIGZuOiBhcHBseVN0eWxlcyxcXG4gIGVmZmVjdDogZWZmZWN0LFxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXJyb3cuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzQXJyb3dKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldExheW91dFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RvbV91dGlsc19jb250YWluc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZG9tLXV0aWxzL2NvbnRhaW5zLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0T2Zmc2V0UGFyZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3dpdGhpbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvd2l0aGluLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tZXJnZVBhZGRpbmdPYmplY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZXhwYW5kVG9IYXNoTWFwX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9leHBhbmRUb0hhc2hNYXAuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9leHBhbmRUb0hhc2hNYXAuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lbnVtcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1xcXCIpO1xcblxcblxcblxcblxcblxcblxcblxcblxcblxcbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxudmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xcbiAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxcbiAgfSkpIDogcGFkZGluZztcXG4gIHJldHVybiBPYmplY3QoX3V0aWxzX21lcmdlUGFkZGluZ09iamVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJkZWZhdWx0XFxcIl0pKHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBPYmplY3QoX3V0aWxzX2V4cGFuZFRvSGFzaE1hcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJkZWZhdWx0XFxcIl0pKHBhZGRpbmcsIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1xcXCJiYXNlUGxhY2VtZW50c1xcXCJdKSk7XFxufTtcXG5cXG5mdW5jdGlvbiBhcnJvdyhfcmVmKSB7XFxuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xcblxcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XFxuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gT2JqZWN0KF91dGlsc19nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUucGxhY2VtZW50KTtcXG4gIHZhciBheGlzID0gT2JqZWN0KF91dGlsc19nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVmYXVsdFxcXCJdKShiYXNlUGxhY2VtZW50KTtcXG4gIHZhciBpc1ZlcnRpY2FsID0gW19lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1xcXCJsZWZ0XFxcIl0sIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1xcXCJyaWdodFxcXCJdXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XFxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcXG5cXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xcbiAgdmFyIGFycm93UmVjdCA9IE9iamVjdChfZG9tX3V0aWxzX2dldExheW91dFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShhcnJvd0VsZW1lbnQpO1xcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcXFwidG9wXFxcIl0gOiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcXFwibGVmdFxcXCJdO1xcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcXFwiYm90dG9tXFxcIl0gOiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcXFwicmlnaHRcXFwiXTtcXG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XFxuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcXG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IE9iamVjdChfZG9tX3V0aWxzX2dldE9mZnNldFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl0pKGFycm93RWxlbWVudCk7XFxuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcXG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xcblxcbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XFxuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcXG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xcbiAgdmFyIG9mZnNldCA9IE9iamVjdChfdXRpbHNfd2l0aGluX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcImRlZmF1bHRcXFwiXSkobWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cXG5cXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xcbn1cXG5cXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcXG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXFxuICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudDtcXG5cXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xcbiAgICByZXR1cm47XFxuICB9IC8vIENTUyBzZWxlY3RvclxcblxcblxcbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XFxuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XFxuXFxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAodHJ1ZSkge1xcbiAgICBpZiAoIU9iamVjdChfZG9tX3V0aWxzX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcXFwiaXNIVE1MRWxlbWVudFxcXCJdKShhcnJvd0VsZW1lbnQpKSB7XFxuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXFxcImFycm93XFxcIiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnQgKG5vdCBhbiBTVkdFbGVtZW50KS4nLCAnVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhcycsICd0aGUgYXJyb3cuJ10uam9pbignICcpKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKCFPYmplY3QoX2RvbV91dGlsc19jb250YWluc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xcbiAgICBpZiAodHJ1ZSkge1xcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFxcXCJhcnJvd1xcXCIgbW9kaWZpZXJcXFxcJ3MgYGVsZW1lbnRgIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgcG9wcGVyJywgJ2VsZW1lbnQuJ10uam9pbignICcpKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcXG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9ICh7XFxuICBuYW1lOiAnYXJyb3cnLFxcbiAgZW5hYmxlZDogdHJ1ZSxcXG4gIHBoYXNlOiAnbWFpbicsXFxuICBmbjogYXJyb3csXFxuICBlZmZlY3Q6IGVmZmVjdCxcXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogbWFwVG9TdHlsZXMsIGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJNb2RpZmllcnNDb21wdXRlU3R5bGVzSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm1hcFRvU3R5bGVzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtYXBUb1N0eWxlczsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZW51bXMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldE9mZnNldFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RvbV91dGlsc19nZXRXaW5kb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RvbS11dGlscy9nZXRXaW5kb3cuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0RG9jdW1lbnRFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldENvbXB1dGVkU3R5bGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2dldEJhc2VQbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tYXRoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tYXRoLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qc1xcXCIpO1xcblxcblxcblxcblxcblxcblxcbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxudmFyIHVuc2V0U2lkZXMgPSB7XFxuICB0b3A6ICdhdXRvJyxcXG4gIHJpZ2h0OiAnYXV0bycsXFxuICBib3R0b206ICdhdXRvJyxcXG4gIGxlZnQ6ICdhdXRvJ1xcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXFxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcXG4vLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cXG5cXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmKSB7XFxuICB2YXIgeCA9IF9yZWYueCxcXG4gICAgICB5ID0gX3JlZi55O1xcbiAgdmFyIHdpbiA9IHdpbmRvdztcXG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xcbiAgcmV0dXJuIHtcXG4gICAgeDogT2JqZWN0KF91dGlsc19tYXRoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcInJvdW5kXFxcIl0pKE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJyb3VuZFxcXCJdKSh4ICogZHByKSAvIGRwcikgfHwgMCxcXG4gICAgeTogT2JqZWN0KF91dGlsc19tYXRoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcInJvdW5kXFxcIl0pKE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJyb3VuZFxcXCJdKSh5ICogZHByKSAvIGRwcikgfHwgMFxcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcXG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XFxuXFxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cztcXG5cXG4gIHZhciBfcmVmMyA9IHJvdW5kT2Zmc2V0cyA9PT0gdHJ1ZSA/IHJvdW5kT2Zmc2V0c0J5RFBSKG9mZnNldHMpIDogdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHJvdW5kT2Zmc2V0cyhvZmZzZXRzKSA6IG9mZnNldHMsXFxuICAgICAgX3JlZjMkeCA9IF9yZWYzLngsXFxuICAgICAgeCA9IF9yZWYzJHggPT09IHZvaWQgMCA/IDAgOiBfcmVmMyR4LFxcbiAgICAgIF9yZWYzJHkgPSBfcmVmMy55LFxcbiAgICAgIHkgPSBfcmVmMyR5ID09PSB2b2lkIDAgPyAwIDogX3JlZjMkeTtcXG5cXG4gIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XFxuICB2YXIgc2lkZVggPSBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwibGVmdFxcXCJdO1xcbiAgdmFyIHNpZGVZID0gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInRvcFxcXCJdO1xcbiAgdmFyIHdpbiA9IHdpbmRvdztcXG5cXG4gIGlmIChhZGFwdGl2ZSkge1xcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gT2JqZWN0KF9kb21fdXRpbHNfZ2V0T2Zmc2V0UGFyZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkocG9wcGVyKTtcXG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcXG4gICAgdmFyIHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XFxuXFxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IE9iamVjdChfZG9tX3V0aWxzX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKHBvcHBlcikpIHtcXG4gICAgICBvZmZzZXRQYXJlbnQgPSBPYmplY3QoX2RvbV91dGlsc19nZXREb2N1bWVudEVsZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdKShwb3BwZXIpO1xcblxcbiAgICAgIGlmIChPYmplY3QoX2RvbV91dGlsc19nZXRDb21wdXRlZFN0eWxlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXSkob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycpIHtcXG4gICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcXG4gICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XFxuICAgICAgfVxcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxcblxcblxcbiAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XFxuXFxuICAgIGlmIChwbGFjZW1lbnQgPT09IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ0b3BcXFwiXSkge1xcbiAgICAgIHNpZGVZID0gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImJvdHRvbVxcXCJdOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cXG5cXG4gICAgICB5IC09IG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xcbiAgICB9XFxuXFxuICAgIGlmIChwbGFjZW1lbnQgPT09IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJsZWZ0XFxcIl0pIHtcXG4gICAgICBzaWRlWCA9IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJyaWdodFxcXCJdOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cXG5cXG4gICAgICB4IC09IG9mZnNldFBhcmVudFt3aWR0aFByb3BdIC0gcG9wcGVyUmVjdC53aWR0aDtcXG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cXG4gIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xcblxcbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XFxuXFxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDwgMiA/IFxcXCJ0cmFuc2xhdGUoXFxcIiArIHggKyBcXFwicHgsIFxcXCIgKyB5ICsgXFxcInB4KVxcXCIgOiBcXFwidHJhbnNsYXRlM2QoXFxcIiArIHggKyBcXFwicHgsIFxcXCIgKyB5ICsgXFxcInB4LCAwKVxcXCIsIF9PYmplY3QkYXNzaWduKSk7XFxuICB9XFxuXFxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFxcXCJweFxcXCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXFxcInB4XFxcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xcbn1cXG5cXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY0KSB7XFxuICB2YXIgc3RhdGUgPSBfcmVmNC5zdGF0ZSxcXG4gICAgICBvcHRpb25zID0gX3JlZjQub3B0aW9ucztcXG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXFxuICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcXG4gICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcXG4gICAgICByb3VuZE9mZnNldHMgPSBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyb3VuZE9mZnNldHM7XFxuXFxuICBpZiAodHJ1ZSkge1xcbiAgICB2YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gT2JqZWN0KF9kb21fdXRpbHNfZ2V0Q29tcHV0ZWRTdHlsZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl0pKHN0YXRlLmVsZW1lbnRzLnBvcHBlcikudHJhbnNpdGlvblByb3BlcnR5IHx8ICcnO1xcblxcbiAgICBpZiAoYWRhcHRpdmUgJiYgWyd0cmFuc2Zvcm0nLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uc29tZShmdW5jdGlvbiAocHJvcGVydHkpIHtcXG4gICAgICByZXR1cm4gdHJhbnNpdGlvblByb3BlcnR5LmluZGV4T2YocHJvcGVydHkpID49IDA7XFxuICAgIH0pKSB7XFxuICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcnLCAnQ1NTIHByb3BlcnRpZXM6IFxcXCJ0cmFuc2Zvcm1cXFwiLCBcXFwidG9wXFxcIiwgXFxcInJpZ2h0XFxcIiwgXFxcImJvdHRvbVxcXCIsIFxcXCJsZWZ0XFxcIi4nLCAnXFxcXG5cXFxcbicsICdEaXNhYmxlIHRoZSBcXFwiY29tcHV0ZVN0eWxlc1xcXCIgbW9kaWZpZXJcXFxcJ3MgYGFkYXB0aXZlYCBvcHRpb24gdG8gYWxsb3cnLCAnZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTJywgJ3RyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gdGhlIHBvcHBlciBlbGVtZW50IGlmIG9ubHkgdHJhbnNpdGlvbmluZycsICdvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuJywgJ1xcXFxuXFxcXG4nLCAnV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBwb3BwZXIgZWxlbWVudCBhcyBhIHdyYXBwZXIgYXJvdW5kIGFuIGlubmVyJywgJ2VsZW1lbnQgdGhhdCBjYW4gaGF2ZSBhbnkgQ1NTIHByb3BlcnR5IHRyYW5zaXRpb25lZCBmb3IgYW5pbWF0aW9ucy4nXS5qb2luKCcgJykpO1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgY29tbW9uU3R5bGVzID0ge1xcbiAgICBwbGFjZW1lbnQ6IE9iamVjdChfdXRpbHNfZ2V0QmFzZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJkZWZhdWx0XFxcIl0pKHN0YXRlLnBsYWNlbWVudCksXFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxcbiAgICBwb3BwZXJSZWN0OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uXFxuICB9O1xcblxcbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XFxuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcXG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXFxuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXFxuICAgICAgYWRhcHRpdmU6IGFkYXB0aXZlLFxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXFxuICAgIH0pKSk7XFxuICB9XFxuXFxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XFxuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XFxuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcXG4gICAgICBhZGFwdGl2ZTogZmFsc2UsXFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcXG4gICAgfSkpKTtcXG4gIH1cXG5cXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcXG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudFxcbiAgfSk7XFxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1xcXCJkZWZhdWx0XFxcIl0gPSAoe1xcbiAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxcbiAgZW5hYmxlZDogdHJ1ZSxcXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxcbiAgZm46IGNvbXB1dGVTdHlsZXMsXFxuICBkYXRhOiB7fVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzRXZlbnRMaXN0ZW5lcnNKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0V2luZG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qc1xcXCIpO1xcbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxudmFyIHBhc3NpdmUgPSB7XFxuICBwYXNzaXZlOiB0cnVlXFxufTtcXG5cXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcXG4gIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXFxuICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xcbiAgdmFyIHdpbmRvdyA9IE9iamVjdChfZG9tX3V0aWxzX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XFxuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xcblxcbiAgaWYgKHNjcm9sbCkge1xcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGlmIChyZXNpemUpIHtcXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XFxuICB9XFxuXFxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoc2Nyb2xsKSB7XFxuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcXG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGlmIChyZXNpemUpIHtcXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcXG4gICAgfVxcbiAgfTtcXG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9ICh7XFxuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxcbiAgZW5hYmxlZDogdHJ1ZSxcXG4gIHBoYXNlOiAnd3JpdGUnLFxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXFxuICBlZmZlY3Q6IGVmZmVjdCxcXG4gIGRhdGE6IHt9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJNb2RpZmllcnNGbGlwSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZ2V0T3Bwb3NpdGVQbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2dldEJhc2VQbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZGV0ZWN0T3ZlcmZsb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbXB1dGVBdXRvUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZW51bXMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZ2V0VmFyaWF0aW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9nZXRWYXJpYXRpb24uanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG4gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xcblxcbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xcbiAgaWYgKE9iamVjdChfdXRpbHNfZ2V0QmFzZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKHBsYWNlbWVudCkgPT09IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJhdXRvXFxcIl0pIHtcXG4gICAgcmV0dXJuIFtdO1xcbiAgfVxcblxcbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gT2JqZWN0KF91dGlsc19nZXRPcHBvc2l0ZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKHBsYWNlbWVudCk7XFxuICByZXR1cm4gW09iamVjdChfdXRpbHNfZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKShwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgT2JqZWN0KF91dGlsc19nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKG9wcG9zaXRlUGxhY2VtZW50KV07XFxufVxcblxcbmZ1bmN0aW9uIGZsaXAoX3JlZikge1xcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XFxuXFxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFsdEF4aXMsXFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxcbiAgICAgIF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9IG9wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XFxuICB2YXIgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XFxuICB2YXIgYmFzZVBsYWNlbWVudCA9IE9iamVjdChfdXRpbHNfZ2V0QmFzZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKHByZWZlcnJlZFBsYWNlbWVudCk7XFxuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtPYmplY3QoX3V0aWxzX2dldE9wcG9zaXRlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcXG4gIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xcbiAgICByZXR1cm4gYWNjLmNvbmNhdChPYmplY3QoX3V0aWxzX2dldEJhc2VQbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShwbGFjZW1lbnQpID09PSBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiYXV0b1xcXCJdID8gT2JqZWN0KF91dGlsc19jb21wdXRlQXV0b1BsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl0pKHN0YXRlLCB7XFxuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXFxuICAgIH0pIDogcGxhY2VtZW50KTtcXG4gIH0sIFtdKTtcXG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XFxuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xcbiAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XFxuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcXG5cXG4gICAgdmFyIF9iYXNlUGxhY2VtZW50ID0gT2JqZWN0KF91dGlsc19nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkocGxhY2VtZW50KTtcXG5cXG4gICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBPYmplY3QoX3V0aWxzX2dldFZhcmlhdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJkZWZhdWx0XFxcIl0pKHBsYWNlbWVudCkgPT09IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJzdGFydFxcXCJdO1xcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFtfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwidG9wXFxcIl0sIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJib3R0b21cXFwiXV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcXG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XFxuICAgIHZhciBvdmVyZmxvdyA9IE9iamVjdChfdXRpbHNfZGV0ZWN0T3ZlcmZsb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdKShzdGF0ZSwge1xcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcXG4gICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xcbiAgICB9KTtcXG4gICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwicmlnaHRcXFwiXSA6IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJsZWZ0XFxcIl0gOiBpc1N0YXJ0VmFyaWF0aW9uID8gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcImJvdHRvbVxcXCJdIDogX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcInRvcFxcXCJdO1xcblxcbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XFxuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBPYmplY3QoX3V0aWxzX2dldE9wcG9zaXRlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkobWFpblZhcmlhdGlvblNpZGUpO1xcbiAgICB9XFxuXFxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gT2JqZWN0KF91dGlsc19nZXRPcHBvc2l0ZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKG1haW5WYXJpYXRpb25TaWRlKTtcXG4gICAgdmFyIGNoZWNrcyA9IFtdO1xcblxcbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W19iYXNlUGxhY2VtZW50XSA8PSAwKTtcXG4gICAgfVxcblxcbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XFxuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xcbiAgICB9XFxuXFxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XFxuICAgICAgcmV0dXJuIGNoZWNrO1xcbiAgICB9KSkge1xcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcXG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcXG4gICAgICBicmVhaztcXG4gICAgfVxcblxcbiAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcXG4gIH1cXG5cXG4gIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcXG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXFxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XFxuXFxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XFxuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xcbiAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcXG5cXG4gICAgICAgIGlmIChjaGVja3MpIHtcXG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBfaSkuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcXG4gICAgICAgIHJldHVybiBcXFwiYnJlYWtcXFwiO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XFxuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XFxuXFxuICAgICAgaWYgKF9yZXQgPT09IFxcXCJicmVha1xcXCIpIGJyZWFrO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcXG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XFxuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcXG4gICAgc3RhdGUucmVzZXQgPSB0cnVlO1xcbiAgfVxcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xcblxcblxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcXFwiZGVmYXVsdFxcXCJdID0gKHtcXG4gIG5hbWU6ICdmbGlwJyxcXG4gIGVuYWJsZWQ6IHRydWUsXFxuICBwaGFzZTogJ21haW4nLFxcbiAgZm46IGZsaXAsXFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxcbiAgZGF0YToge1xcbiAgICBfc2tpcDogZmFsc2VcXG4gIH1cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzSGlkZUpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lbnVtcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19kZXRlY3RPdmVyZmxvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1xcXCIpO1xcblxcblxcblxcbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XFxuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XFxuICAgIHByZXZlbnRlZE9mZnNldHMgPSB7XFxuICAgICAgeDogMCxcXG4gICAgICB5OiAwXFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4ge1xcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XFxuICByZXR1cm4gW19lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ0b3BcXFwiXSwgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInJpZ2h0XFxcIl0sIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJib3R0b21cXFwiXSwgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImxlZnRcXFwiXV0uc29tZShmdW5jdGlvbiAoc2lkZSkge1xcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcXG4gIH0pO1xcbn1cXG5cXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcXG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XFxuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gT2JqZWN0KF91dGlsc19kZXRlY3RPdmVyZmxvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKHN0YXRlLCB7XFxuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xcbiAgfSk7XFxuICB2YXIgcG9wcGVyQWx0T3ZlcmZsb3cgPSBPYmplY3QoX3V0aWxzX2RldGVjdE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUsIHtcXG4gICAgYWx0Qm91bmRhcnk6IHRydWVcXG4gIH0pO1xcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcXG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xcbiAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XFxuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XFxuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcXG4gIH07XFxuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XFxuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxcbiAgfSk7XFxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1xcXCJkZWZhdWx0XFxcIl0gPSAoe1xcbiAgbmFtZTogJ2hpZGUnLFxcbiAgZW5hYmxlZDogdHJ1ZSxcXG4gIHBoYXNlOiAnbWFpbicsXFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxcbiAgZm46IGhpZGVcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9pbmRleC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2luZGV4LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogYXBwbHlTdHlsZXMsIGFycm93LCBjb21wdXRlU3R5bGVzLCBldmVudExpc3RlbmVycywgZmxpcCwgaGlkZSwgb2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCBwcmV2ZW50T3ZlcmZsb3cgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJNb2RpZmllcnNJbmRleEpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2FwcGx5U3R5bGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FwcGx5U3R5bGVzLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhcHBseVN0eWxlc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2FwcGx5U3R5bGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hcnJvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hcnJvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYXJyb3dcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9hcnJvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tcHV0ZVN0eWxlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb21wdXRlU3R5bGVzLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNvbXB1dGVTdHlsZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9jb21wdXRlU3R5bGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudExpc3RlbmVyc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldmVudExpc3RlbmVycy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZXZlbnRMaXN0ZW5lcnNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9ldmVudExpc3RlbmVyc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZmxpcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mbGlwLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImZsaXBcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9mbGlwX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9oaWRlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hpZGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaGlkZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2hpZGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiZGVmYXVsdFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX29mZnNldF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9vZmZzZXQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJvZmZzZXRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9vZmZzZXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiZGVmYXVsdFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BvcHBlck9mZnNldHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcG9wcGVyT2Zmc2V0cy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJwb3BwZXJPZmZzZXRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfcG9wcGVyT2Zmc2V0c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJkZWZhdWx0XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcHJldmVudE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ByZXZlbnRPdmVyZmxvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInByZXZlbnRPdmVyZmxvd1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3ByZXZlbnRPdmVyZmxvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1xcXCJkZWZhdWx0XFxcIl07IH0pO1xcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2luZGV4LmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZLCBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzT2Zmc2V0SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2VudW1zLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gT2JqZWN0KF91dGlsc19nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkocGxhY2VtZW50KTtcXG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwibGVmdFxcXCJdLCBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwidG9wXFxcIl1dLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcXG5cXG4gIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxcbiAgfSkpIDogb2Zmc2V0LFxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XFxuXFxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XFxuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xcbiAgcmV0dXJuIFtfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwibGVmdFxcXCJdLCBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwicmlnaHRcXFwiXV0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xcbiAgICB4OiBkaXN0YW5jZSxcXG4gICAgeTogc2tpZGRpbmdcXG4gIH0gOiB7XFxuICAgIHg6IHNraWRkaW5nLFxcbiAgICB5OiBkaXN0YW5jZVxcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XFxuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcXG4gIHZhciBfb3B0aW9ucyRvZmZzZXQgPSBvcHRpb25zLm9mZnNldCxcXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcXG4gIHZhciBkYXRhID0gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInBsYWNlbWVudHNcXFwiXS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XFxuICAgIGFjY1twbGFjZW1lbnRdID0gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCBzdGF0ZS5yZWN0cywgb2Zmc2V0KTtcXG4gICAgcmV0dXJuIGFjYztcXG4gIH0sIHt9KTtcXG4gIHZhciBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQgPSBkYXRhW3N0YXRlLnBsYWNlbWVudF0sXFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcXG5cXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xcbiAgfVxcblxcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XFxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1xcXCJkZWZhdWx0XFxcIl0gPSAoe1xcbiAgbmFtZTogJ29mZnNldCcsXFxuICBlbmFibGVkOiB0cnVlLFxcbiAgcGhhc2U6ICdtYWluJyxcXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcXG4gIGZuOiBvZmZzZXRcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJNb2RpZmllcnNQb3BwZXJPZmZzZXRzSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29tcHV0ZU9mZnNldHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcXFwiKTtcXG5cXG5cXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKF9yZWYpIHtcXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcXG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXFxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcXG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IE9iamVjdChfdXRpbHNfY29tcHV0ZU9mZnNldHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKSh7XFxuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxcbiAgfSk7XFxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1xcXCJkZWZhdWx0XFxcIl0gPSAoe1xcbiAgbmFtZTogJ3BvcHBlck9mZnNldHMnLFxcbiAgZW5hYmxlZDogdHJ1ZSxcXG4gIHBoYXNlOiAncmVhZCcsXFxuICBmbjogcG9wcGVyT2Zmc2V0cyxcXG4gIGRhdGE6IHt9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzUHJldmVudE92ZXJmbG93SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2VudW1zLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2dldEJhc2VQbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZ2V0QWx0QXhpc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZ2V0QWx0QXhpcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3dpdGhpbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvd2l0aGluLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0TGF5b3V0UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldE9mZnNldFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2RldGVjdE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19nZXRWYXJpYXRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2dldFZhcmlhdGlvbi5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZ2V0RnJlc2hTaWRlT2JqZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tYXRoLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qc1xcXCIpO1xcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XFxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxcbiAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XFxuICB2YXIgb3ZlcmZsb3cgPSBPYmplY3QoX3V0aWxzX2RldGVjdE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUsIHtcXG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxcbiAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcXG4gICAgcGFkZGluZzogcGFkZGluZyxcXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XFxuICB9KTtcXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gT2JqZWN0KF91dGlsc19nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUucGxhY2VtZW50KTtcXG4gIHZhciB2YXJpYXRpb24gPSBPYmplY3QoX3V0aWxzX2dldFZhcmlhdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1xcXCJkZWZhdWx0XFxcIl0pKHN0YXRlLnBsYWNlbWVudCk7XFxuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcXG4gIHZhciBtYWluQXhpcyA9IE9iamVjdChfdXRpbHNfZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoYmFzZVBsYWNlbWVudCk7XFxuICB2YXIgYWx0QXhpcyA9IE9iamVjdChfdXRpbHNfZ2V0QWx0QXhpc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl0pKG1haW5BeGlzKTtcXG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XFxuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcXG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcXG4gIH0pKSA6IHRldGhlck9mZnNldDtcXG4gIHZhciBkYXRhID0ge1xcbiAgICB4OiAwLFxcbiAgICB5OiAwXFxuICB9O1xcblxcbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmIChjaGVja01haW5BeGlzIHx8IGNoZWNrQWx0QXhpcykge1xcbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInRvcFxcXCJdIDogX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImxlZnRcXFwiXTtcXG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImJvdHRvbVxcXCJdIDogX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInJpZ2h0XFxcIl07XFxuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XFxuICAgIHZhciBtaW4gPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG92ZXJmbG93W21haW5TaWRlXTtcXG4gICAgdmFyIG1heCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdIC0gb3ZlcmZsb3dbYWx0U2lkZV07XFxuICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcXG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInN0YXJ0XFxcIl0gPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XFxuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJzdGFydFxcXCJdID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXFxuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcXG5cXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xcbiAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IE9iamVjdChfZG9tX3V0aWxzX2dldExheW91dFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiZGVmYXVsdFxcXCJdKShhcnJvd0VsZW1lbnQpIDoge1xcbiAgICAgIHdpZHRoOiAwLFxcbiAgICAgIGhlaWdodDogMFxcbiAgICB9O1xcbiAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBPYmplY3QoX3V0aWxzX2dldEZyZXNoU2lkZU9iamVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1xcXCJkZWZhdWx0XFxcIl0pKCk7XFxuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXFxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxcblxcbiAgICB2YXIgYXJyb3dMZW4gPSBPYmplY3QoX3V0aWxzX3dpdGhpbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl0pKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSB0ZXRoZXJPZmZzZXRWYWx1ZSA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gdGV0aGVyT2Zmc2V0VmFsdWU7XFxuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyB0ZXRoZXJPZmZzZXRWYWx1ZSA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgdGV0aGVyT2Zmc2V0VmFsdWU7XFxuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIE9iamVjdChfZG9tX3V0aWxzX2dldE9mZnNldFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJkZWZhdWx0XFxcIl0pKHN0YXRlLmVsZW1lbnRzLmFycm93KTtcXG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcXG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF1bbWFpbkF4aXNdIDogMDtcXG4gICAgdmFyIHRldGhlck1pbiA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcXG4gICAgdmFyIHRldGhlck1heCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcXG5cXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcXG4gICAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gT2JqZWN0KF91dGlsc193aXRoaW5fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVmYXVsdFxcXCJdKSh0ZXRoZXIgPyBPYmplY3QoX3V0aWxzX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXFxcIm1pblxcXCJdKShtaW4sIHRldGhlck1pbikgOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gT2JqZWN0KF91dGlsc19tYXRoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1xcXCJtYXhcXFwiXSkobWF4LCB0ZXRoZXJNYXgpIDogbWF4KTtcXG4gICAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcXG4gICAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcXG4gICAgfVxcblxcbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XFxuICAgICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwidG9wXFxcIl0gOiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwibGVmdFxcXCJdO1xcblxcbiAgICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiYm90dG9tXFxcIl0gOiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicmlnaHRcXFwiXTtcXG5cXG4gICAgICB2YXIgX29mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XFxuXFxuICAgICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcXG5cXG4gICAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XFxuXFxuICAgICAgdmFyIF9wcmV2ZW50ZWRPZmZzZXQgPSBPYmplY3QoX3V0aWxzX3dpdGhpbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl0pKHRldGhlciA/IE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcXFwibWluXFxcIl0pKF9taW4sIHRldGhlck1pbikgOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBPYmplY3QoX3V0aWxzX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXFxcIm1heFxcXCJdKShfbWF4LCB0ZXRoZXJNYXgpIDogX21heCk7XFxuXFxuICAgICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XFxuICAgICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xcbiAgICB9XFxuICB9XFxuXFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcXG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9ICh7XFxuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcXG4gIGVuYWJsZWQ6IHRydWUsXFxuICBwaGFzZTogJ21haW4nLFxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLWxpdGUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLWxpdGUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlBvcHBlckxpdGVKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY3JlYXRlUG9wcGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVQb3BwZXI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRNb2RpZmllcnNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlZmF1bHRNb2RpZmllcnM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY3JlYXRlUG9wcGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NyZWF0ZVBvcHBlci5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicG9wcGVyR2VuZXJhdG9yXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfY3JlYXRlUG9wcGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInBvcHBlckdlbmVyYXRvclxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRldGVjdE92ZXJmbG93XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfY3JlYXRlUG9wcGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRldGVjdE92ZXJmbG93XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX2V2ZW50TGlzdGVuZXJzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX3BvcHBlck9mZnNldHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX2NvbXB1dGVTdHlsZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX2FwcGx5U3R5bGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGlmaWVycy9hcHBseVN0eWxlcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1xcXCIpO1xcblxcblxcblxcblxcblxcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW19tb2RpZmllcnNfZXZlbnRMaXN0ZW5lcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdLCBfbW9kaWZpZXJzX3BvcHBlck9mZnNldHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdLCBfbW9kaWZpZXJzX2NvbXB1dGVTdHlsZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdLCBfbW9kaWZpZXJzX2FwcGx5U3R5bGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXV07XFxudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9PYmplY3QoX2NyZWF0ZVBvcHBlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJwb3BwZXJHZW5lcmF0b3JcXFwiXSkoe1xcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXItbGl0ZS5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdywgY3JlYXRlUG9wcGVyTGl0ZSwgYXBwbHlTdHlsZXMsIGFycm93LCBjb21wdXRlU3R5bGVzLCBldmVudExpc3RlbmVycywgZmxpcCwgaGlkZSwgb2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCBwcmV2ZW50T3ZlcmZsb3cgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJQb3BwZXJKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY3JlYXRlUG9wcGVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVQb3BwZXI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRNb2RpZmllcnNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlZmF1bHRNb2RpZmllcnM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY3JlYXRlUG9wcGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NyZWF0ZVBvcHBlci5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicG9wcGVyR2VuZXJhdG9yXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfY3JlYXRlUG9wcGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInBvcHBlckdlbmVyYXRvclxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRldGVjdE92ZXJmbG93XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfY3JlYXRlUG9wcGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRldGVjdE92ZXJmbG93XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX2V2ZW50TGlzdGVuZXJzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX3BvcHBlck9mZnNldHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX2NvbXB1dGVTdHlsZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX2FwcGx5U3R5bGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGlmaWVycy9hcHBseVN0eWxlcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX29mZnNldF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2RpZmllcnMvb2Zmc2V0LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL29mZnNldC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX2ZsaXBfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kaWZpZXJzL2ZsaXAuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZmxpcC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX3ByZXZlbnRPdmVyZmxvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX2Fycm93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGlmaWVycy9hcnJvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX2hpZGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kaWZpZXJzL2hpZGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcG9wcGVyX2xpdGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BvcHBlci1saXRlLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLWxpdGUuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNyZWF0ZVBvcHBlckxpdGVcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9wb3BwZXJfbGl0ZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcXFwiY3JlYXRlUG9wcGVyXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2RpZmllcnMvaW5kZXguanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFwcGx5U3R5bGVzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1xcXCJhcHBseVN0eWxlc1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFycm93XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1xcXCJhcnJvd1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNvbXB1dGVTdHlsZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tb2RpZmllcnNfaW5kZXhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXFxcImNvbXB1dGVTdHlsZXNcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJldmVudExpc3RlbmVyc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21vZGlmaWVyc19pbmRleF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcXFwiZXZlbnRMaXN0ZW5lcnNcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJmbGlwXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1xcXCJmbGlwXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaGlkZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21vZGlmaWVyc19pbmRleF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcXFwiaGlkZVxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm9mZnNldFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21vZGlmaWVyc19pbmRleF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcXFwib2Zmc2V0XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicG9wcGVyT2Zmc2V0c1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21vZGlmaWVyc19pbmRleF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcXFwicG9wcGVyT2Zmc2V0c1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInByZXZlbnRPdmVyZmxvd1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21vZGlmaWVyc19pbmRleF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcXFwicHJldmVudE92ZXJmbG93XFxcIl07IH0pO1xcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW19tb2RpZmllcnNfZXZlbnRMaXN0ZW5lcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdLCBfbW9kaWZpZXJzX3BvcHBlck9mZnNldHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdLCBfbW9kaWZpZXJzX2NvbXB1dGVTdHlsZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdLCBfbW9kaWZpZXJzX2FwcGx5U3R5bGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXSwgX21vZGlmaWVyc19vZmZzZXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiZGVmYXVsdFxcXCJdLCBfbW9kaWZpZXJzX2ZsaXBfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiZGVmYXVsdFxcXCJdLCBfbW9kaWZpZXJzX3ByZXZlbnRPdmVyZmxvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJkZWZhdWx0XFxcIl0sIF9tb2RpZmllcnNfYXJyb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcXFwiZGVmYXVsdFxcXCJdLCBfbW9kaWZpZXJzX2hpZGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcXFwiZGVmYXVsdFxcXCJdXTtcXG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL09iamVjdChfY3JlYXRlUG9wcGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInBvcHBlckdlbmVyYXRvclxcXCJdKSh7XFxuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXFxufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG4gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xcblxcbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0NvbXB1dGVBdXRvUGxhY2VtZW50SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXB1dGVBdXRvUGxhY2VtZW50OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFZhcmlhdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRWYXJpYXRpb24uanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lbnVtcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZXRlY3RPdmVyZmxvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kZXRlY3RPdmVyZmxvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldEJhc2VQbGFjZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcXG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcXG4gICAgb3B0aW9ucyA9IHt9O1xcbiAgfVxcblxcbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcXG4gICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwicGxhY2VtZW50c1xcXCJdIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xcbiAgdmFyIHZhcmlhdGlvbiA9IE9iamVjdChfZ2V0VmFyaWF0aW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkocGxhY2VtZW50KTtcXG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwidmFyaWF0aW9uUGxhY2VtZW50c1xcXCJdIDogX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInZhcmlhdGlvblBsYWNlbWVudHNcXFwiXS5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xcbiAgICByZXR1cm4gT2JqZWN0KF9nZXRWYXJpYXRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShwbGFjZW1lbnQpID09PSB2YXJpYXRpb247XFxuICB9KSA6IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJiYXNlUGxhY2VtZW50c1xcXCJdO1xcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xcbiAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xcbiAgfSk7XFxuXFxuICBpZiAoYWxsb3dlZFBsYWNlbWVudHMubGVuZ3RoID09PSAwKSB7XFxuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcXG5cXG4gICAgaWYgKHRydWUpIHtcXG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBUaGUgYGFsbG93ZWRBdXRvUGxhY2VtZW50c2Agb3B0aW9uIGRpZCBub3QgYWxsb3cgYW55JywgJ3BsYWNlbWVudHMuIEVuc3VyZSB0aGUgYHBsYWNlbWVudGAgb3B0aW9uIG1hdGNoZXMgdGhlIHZhcmlhdGlvbicsICdvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnRzLicsICdGb3IgZXhhbXBsZSwgXFxcImF1dG9cXFwiIGNhbm5vdCBiZSB1c2VkIHRvIGFsbG93IFxcXCJib3R0b20tc3RhcnRcXFwiLicsICdVc2UgXFxcImF1dG8tc3RhcnRcXFwiIGluc3RlYWQuJ10uam9pbignICcpKTtcXG4gICAgfVxcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxcblxcblxcbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcXG4gICAgYWNjW3BsYWNlbWVudF0gPSBPYmplY3QoX2RldGVjdE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUsIHtcXG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xcbiAgICB9KVtPYmplY3QoX2dldEJhc2VQbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdKShwbGFjZW1lbnQpXTtcXG4gICAgcmV0dXJuIGFjYztcXG4gIH0sIHt9KTtcXG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcXG4gIH0pO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNDb21wdXRlT2Zmc2V0c0pzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb21wdXRlT2Zmc2V0czsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldEJhc2VQbGFjZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRWYXJpYXRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0VmFyaWF0aW9uLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZW51bXMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qc1xcXCIpO1xcblxcblxcblxcblxcbmZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcXG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBPYmplY3QoX2dldEJhc2VQbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShwbGFjZW1lbnQpIDogbnVsbDtcXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBPYmplY3QoX2dldFZhcmlhdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKHBsYWNlbWVudCkgOiBudWxsO1xcbiAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcXG4gIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcXG4gIHZhciBvZmZzZXRzO1xcblxcbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XFxuICAgIGNhc2UgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcInRvcFxcXCJdOlxcbiAgICAgIG9mZnNldHMgPSB7XFxuICAgICAgICB4OiBjb21tb25YLFxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxcbiAgICAgIH07XFxuICAgICAgYnJlYWs7XFxuXFxuICAgIGNhc2UgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImJvdHRvbVxcXCJdOlxcbiAgICAgIG9mZnNldHMgPSB7XFxuICAgICAgICB4OiBjb21tb25YLFxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XFxuICAgICAgfTtcXG4gICAgICBicmVhaztcXG5cXG4gICAgY2FzZSBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwicmlnaHRcXFwiXTpcXG4gICAgICBvZmZzZXRzID0ge1xcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXFxuICAgICAgICB5OiBjb21tb25ZXFxuICAgICAgfTtcXG4gICAgICBicmVhaztcXG5cXG4gICAgY2FzZSBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwibGVmdFxcXCJdOlxcbiAgICAgIG9mZnNldHMgPSB7XFxuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXFxuICAgICAgICB5OiBjb21tb25ZXFxuICAgICAgfTtcXG4gICAgICBicmVhaztcXG5cXG4gICAgZGVmYXVsdDpcXG4gICAgICBvZmZzZXRzID0ge1xcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXFxuICAgICAgICB5OiByZWZlcmVuY2UueVxcbiAgICAgIH07XFxuICB9XFxuXFxuICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gT2JqZWN0KF9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKShiYXNlUGxhY2VtZW50KSA6IG51bGw7XFxuXFxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcXG5cXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcXG4gICAgICBjYXNlIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJzdGFydFxcXCJdOlxcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcXG4gICAgICAgIGJyZWFrO1xcblxcbiAgICAgIGNhc2UgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImVuZFxcXCJdOlxcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcXG4gICAgICAgIGJyZWFrO1xcblxcbiAgICAgIGRlZmF1bHQ6XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXRzO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNEZWJvdW5jZUpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZWJvdW5jZTsgfSk7XFxuZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcXG4gIHZhciBwZW5kaW5nO1xcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKCFwZW5kaW5nKSB7XFxuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XFxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBwZW5kaW5nO1xcbiAgfTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZWJvdW5jZS5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzRGV0ZWN0T3ZlcmZsb3dKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGV0ZWN0T3ZlcmZsb3c7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldEJvdW5kaW5nQ2xpZW50UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RvbV91dGlsc19nZXRDbGlwcGluZ1JlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0RG9jdW1lbnRFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tcHV0ZU9mZnNldHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29tcHV0ZU9mZnNldHMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmVjdFRvQ2xpZW50UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZWN0VG9DbGllbnRSZWN0LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2VudW1zLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RvbV91dGlsc19pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tZXJnZVBhZGRpbmdPYmplY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWVyZ2VQYWRkaW5nT2JqZWN0LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9leHBhbmRUb0hhc2hNYXBfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXhwYW5kVG9IYXNoTWFwLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5mdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xcbiAgICBvcHRpb25zID0ge307XFxuICB9XFxuXFxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxcbiAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJjbGlwcGluZ1BhcmVudHNcXFwiXSA6IF9vcHRpb25zJGJvdW5kYXJ5LFxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJ2aWV3cG9ydFxcXCJdIDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwicG9wcGVyXFxcIl0gOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gT2JqZWN0KF9tZXJnZVBhZGRpbmdPYmplY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcXFwiZGVmYXVsdFxcXCJdKSh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogT2JqZWN0KF9leHBhbmRUb0hhc2hNYXBfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcXFwiZGVmYXVsdFxcXCJdKShwYWRkaW5nLCBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiYmFzZVBsYWNlbWVudHNcXFwiXSkpO1xcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcInBvcHBlclxcXCJdID8gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcInJlZmVyZW5jZVxcXCJdIDogX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcInBvcHBlclxcXCJdO1xcbiAgdmFyIHJlZmVyZW5jZUVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2U7XFxuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcXG4gIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IE9iamVjdChfZG9tX3V0aWxzX2dldENsaXBwaW5nUmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKE9iamVjdChfZG9tX3V0aWxzX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiaXNFbGVtZW50XFxcIl0pKGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgT2JqZWN0KF9kb21fdXRpbHNfZ2V0RG9jdW1lbnRFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSk7XFxuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IE9iamVjdChfZG9tX3V0aWxzX2dldEJvdW5kaW5nQ2xpZW50UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKHJlZmVyZW5jZUVsZW1lbnQpO1xcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBPYmplY3QoX2NvbXB1dGVPZmZzZXRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImRlZmF1bHRcXFwiXSkoe1xcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxcbiAgfSk7XFxuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IE9iamVjdChfcmVjdFRvQ2xpZW50UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl0pKE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcXG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwicG9wcGVyXFxcIl0gPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxcblxcbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcXG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXFxuICAgIGJvdHRvbTogZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tLFxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcXG4gIH07XFxuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XFxuXFxuICBpZiAoZWxlbWVudENvbnRleHQgPT09IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJwb3BwZXJcXFwiXSAmJiBvZmZzZXREYXRhKSB7XFxuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XFxuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgdmFyIG11bHRpcGx5ID0gW19lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJyaWdodFxcXCJdLCBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiYm90dG9tXFxcIl1dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xcbiAgICAgIHZhciBheGlzID0gW19lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJ0b3BcXFwiXSwgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcImJvdHRvbVxcXCJdXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcXG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzRXhwYW5kVG9IYXNoTWFwSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGV4cGFuZFRvSGFzaE1hcDsgfSk7XFxuZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XFxuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xcbiAgICBoYXNoTWFwW2tleV0gPSB2YWx1ZTtcXG4gICAgcmV0dXJuIGhhc2hNYXA7XFxuICB9LCB7fSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2Zvcm1hdC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZm9ybWF0LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzRm9ybWF0SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZvcm1hdDsgfSk7XFxuZnVuY3Rpb24gZm9ybWF0KHN0cikge1xcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcXG4gIH1cXG5cXG4gIHJldHVybiBbXS5jb25jYXQoYXJncykucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XFxuICAgIHJldHVybiBwLnJlcGxhY2UoLyVzLywgYyk7XFxuICB9LCBzdHIpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2Zvcm1hdC5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRBbHRBeGlzLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNHZXRBbHRBeGlzSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEFsdEF4aXM7IH0pO1xcbmZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRBbHRBeGlzLmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0dldEJhc2VQbGFjZW1lbnRKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0QmFzZVBsYWNlbWVudDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZW51bXMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XFxuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0dldEZyZXNoU2lkZU9iamVjdEpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRGcmVzaFNpZGVPYmplY3Q7IH0pO1xcbmZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpIHtcXG4gIHJldHVybiB7XFxuICAgIHRvcDogMCxcXG4gICAgcmlnaHQ6IDAsXFxuICAgIGJvdHRvbTogMCxcXG4gICAgbGVmdDogMFxcbiAgfTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNHZXRNYWluQXhpc0Zyb21QbGFjZW1lbnRKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50OyB9KTtcXG5mdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XFxuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNHZXRPcHBvc2l0ZVBsYWNlbWVudEpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRPcHBvc2l0ZVBsYWNlbWVudDsgfSk7XFxudmFyIGhhc2ggPSB7XFxuICBsZWZ0OiAncmlnaHQnLFxcbiAgcmlnaHQ6ICdsZWZ0JyxcXG4gIGJvdHRvbTogJ3RvcCcsXFxuICB0b3A6ICdib3R0b20nXFxufTtcXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcXG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XFxuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xcbiAgfSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50OyB9KTtcXG52YXIgaGFzaCA9IHtcXG4gIHN0YXJ0OiAnZW5kJyxcXG4gIGVuZDogJ3N0YXJ0J1xcbn07XFxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XFxuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcXG4gIH0pO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzR2V0VmFyaWF0aW9uSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFZhcmlhdGlvbjsgfSk7XFxuZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tYXRoLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBtYXgsIG1pbiwgcm91bmQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc01hdGhKcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibWF4XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtYXg7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm1pblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWluOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyb3VuZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcm91bmQ7IH0pO1xcbnZhciBtYXggPSBNYXRoLm1heDtcXG52YXIgbWluID0gTWF0aC5taW47XFxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc01lcmdlQnlOYW1lSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1lcmdlQnlOYW1lOyB9KTtcXG5mdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcXG4gIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcXG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XFxuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxcbiAgICB9KSA6IGN1cnJlbnQ7XFxuICAgIHJldHVybiBtZXJnZWQ7XFxuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXFxuXFxuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XFxuICB9KTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc01lcmdlUGFkZGluZ09iamVjdEpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3Q7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0RnJlc2hTaWRlT2JqZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldEZyZXNoU2lkZU9iamVjdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XFxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgT2JqZWN0KF9nZXRGcmVzaFNpZGVPYmplY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKSgpLCBwYWRkaW5nT2JqZWN0KTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvb3JkZXJNb2RpZmllcnMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvb3JkZXJNb2RpZmllcnMuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc09yZGVyTW9kaWZpZXJzSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9yZGVyTW9kaWZpZXJzOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lbnVtcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzXFxcIik7XFxuIC8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcXG5cXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcXG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XFxuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcXG4gIHZhciByZXN1bHQgPSBbXTtcXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcXG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XFxuXFxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XFxuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xcbiAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcXG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcXG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcXG5cXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XFxuICB9XFxuXFxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcXG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiByZXN1bHQ7XFxufVxcblxcbmZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXFxuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXFxuXFxuICByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIm1vZGlmaWVyUGhhc2VzXFxcIl0ucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XFxuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xcbiAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XFxuICAgIH0pKTtcXG4gIH0sIFtdKTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9vcmRlck1vZGlmaWVycy5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNSZWN0VG9DbGllbnRSZWN0SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3Q7IH0pO1xcbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcXG4gICAgbGVmdDogcmVjdC54LFxcbiAgICB0b3A6IHJlY3QueSxcXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcXG4gIH0pO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdW5pcXVlQnkuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdW5pcXVlQnkuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc1VuaXF1ZUJ5SnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHVuaXF1ZUJ5OyB9KTtcXG5mdW5jdGlvbiB1bmlxdWVCeShhcnIsIGZuKSB7XFxuICB2YXIgaWRlbnRpZmllcnMgPSBuZXcgU2V0KCk7XFxuICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xcbiAgICB2YXIgaWRlbnRpZmllciA9IGZuKGl0ZW0pO1xcblxcbiAgICBpZiAoIWlkZW50aWZpZXJzLmhhcyhpZGVudGlmaWVyKSkge1xcbiAgICAgIGlkZW50aWZpZXJzLmFkZChpZGVudGlmaWVyKTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgfSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdW5pcXVlQnkuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdmFsaWRhdGVNb2RpZmllcnMuanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdmFsaWRhdGVNb2RpZmllcnMuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc1ZhbGlkYXRlTW9kaWZpZXJzSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHZhbGlkYXRlTW9kaWZpZXJzOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Zvcm1hdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3JtYXQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9mb3JtYXQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lbnVtcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzXFxcIik7XFxuXFxuXFxudmFyIElOVkFMSURfTU9ESUZJRVJfRVJST1IgPSAnUG9wcGVyOiBtb2RpZmllciBcXFwiJXNcXFwiIHByb3ZpZGVkIGFuIGludmFsaWQgJXMgcHJvcGVydHksIGV4cGVjdGVkICVzIGJ1dCBnb3QgJXMnO1xcbnZhciBNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IgPSAnUG9wcGVyOiBtb2RpZmllciBcXFwiJXNcXFwiIHJlcXVpcmVzIFxcXCIlc1xcXCIsIGJ1dCBcXFwiJXNcXFwiIG1vZGlmaWVyIGlzIG5vdCBhdmFpbGFibGUnO1xcbnZhciBWQUxJRF9QUk9QRVJUSUVTID0gWyduYW1lJywgJ2VuYWJsZWQnLCAncGhhc2UnLCAnZm4nLCAnZWZmZWN0JywgJ3JlcXVpcmVzJywgJ29wdGlvbnMnXTtcXG5mdW5jdGlvbiB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpIHtcXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xcbiAgICBPYmplY3Qua2V5cyhtb2RpZmllcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgc3dpdGNoIChrZXkpIHtcXG4gICAgICAgIGNhc2UgJ25hbWUnOlxcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLm5hbWUgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihPYmplY3QoX2Zvcm1hdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKElOVkFMSURfTU9ESUZJRVJfRVJST1IsIFN0cmluZyhtb2RpZmllci5uYW1lKSwgJ1xcXCJuYW1lXFxcIicsICdcXFwic3RyaW5nXFxcIicsIFxcXCJcXFxcXFxcIlxcXCIgKyBTdHJpbmcobW9kaWZpZXIubmFtZSkgKyBcXFwiXFxcXFxcXCJcXFwiKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdlbmFibGVkJzpcXG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5lbmFibGVkICE9PSAnYm9vbGVhbicpIHtcXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKE9iamVjdChfZm9ybWF0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1xcXCJlbmFibGVkXFxcIicsICdcXFwiYm9vbGVhblxcXCInLCBcXFwiXFxcXFxcXCJcXFwiICsgU3RyaW5nKG1vZGlmaWVyLmVuYWJsZWQpICsgXFxcIlxcXFxcXFwiXFxcIikpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICBjYXNlICdwaGFzZSc6XFxuICAgICAgICAgIGlmIChfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwibW9kaWZpZXJQaGFzZXNcXFwiXS5pbmRleE9mKG1vZGlmaWVyLnBoYXNlKSA8IDApIHtcXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKE9iamVjdChfZm9ybWF0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1xcXCJwaGFzZVxcXCInLCBcXFwiZWl0aGVyIFxcXCIgKyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwibW9kaWZpZXJQaGFzZXNcXFwiXS5qb2luKCcsICcpLCBcXFwiXFxcXFxcXCJcXFwiICsgU3RyaW5nKG1vZGlmaWVyLnBoYXNlKSArIFxcXCJcXFxcXFxcIlxcXCIpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgJ2ZuJzpcXG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5mbiAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoT2JqZWN0KF9mb3JtYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXFxcImZuXFxcIicsICdcXFwiZnVuY3Rpb25cXFwiJywgXFxcIlxcXFxcXFwiXFxcIiArIFN0cmluZyhtb2RpZmllci5mbikgKyBcXFwiXFxcXFxcXCJcXFwiKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdlZmZlY3QnOlxcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLmVmZmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoT2JqZWN0KF9mb3JtYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXFxcImVmZmVjdFxcXCInLCAnXFxcImZ1bmN0aW9uXFxcIicsIFxcXCJcXFxcXFxcIlxcXCIgKyBTdHJpbmcobW9kaWZpZXIuZm4pICsgXFxcIlxcXFxcXFwiXFxcIikpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSAncmVxdWlyZXMnOlxcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kaWZpZXIucmVxdWlyZXMpKSB7XFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihPYmplY3QoX2Zvcm1hdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcXFwicmVxdWlyZXNcXFwiJywgJ1xcXCJhcnJheVxcXCInLCBcXFwiXFxcXFxcXCJcXFwiICsgU3RyaW5nKG1vZGlmaWVyLnJlcXVpcmVzKSArIFxcXCJcXFxcXFxcIlxcXCIpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgJ3JlcXVpcmVzSWZFeGlzdHMnOlxcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cykpIHtcXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKE9iamVjdChfZm9ybWF0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1xcXCJyZXF1aXJlc0lmRXhpc3RzXFxcIicsICdcXFwiYXJyYXlcXFwiJywgXFxcIlxcXFxcXFwiXFxcIiArIFN0cmluZyhtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzKSArIFxcXCJcXFxcXFxcIlxcXCIpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgJ29wdGlvbnMnOlxcbiAgICAgICAgY2FzZSAnZGF0YSc6XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcXFwiUG9wcGVySlM6IGFuIGludmFsaWQgcHJvcGVydHkgaGFzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIFxcXFxcXFwiXFxcIiArIG1vZGlmaWVyLm5hbWUgKyBcXFwiXFxcXFxcXCIgbW9kaWZpZXIsIHZhbGlkIHByb3BlcnRpZXMgYXJlIFxcXCIgKyBWQUxJRF9QUk9QRVJUSUVTLm1hcChmdW5jdGlvbiAocykge1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiXFxcXFxcXCJcXFwiICsgcyArIFxcXCJcXFxcXFxcIlxcXCI7XFxuICAgICAgICAgIH0pLmpvaW4oJywgJykgKyBcXFwiOyBidXQgXFxcXFxcXCJcXFwiICsga2V5ICsgXFxcIlxcXFxcXFwiIHdhcyBwcm92aWRlZC5cXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgbW9kaWZpZXIucmVxdWlyZXMgJiYgbW9kaWZpZXIucmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWlyZW1lbnQpIHtcXG4gICAgICAgIGlmIChtb2RpZmllcnMuZmluZChmdW5jdGlvbiAobW9kKSB7XFxuICAgICAgICAgIHJldHVybiBtb2QubmFtZSA9PT0gcmVxdWlyZW1lbnQ7XFxuICAgICAgICB9KSA9PSBudWxsKSB7XFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoT2JqZWN0KF9mb3JtYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IsIFN0cmluZyhtb2RpZmllci5uYW1lKSwgcmVxdWlyZW1lbnQsIHJlcXVpcmVtZW50KSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0pO1xcbiAgfSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdmFsaWRhdGVNb2RpZmllcnMuanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy93aXRoaW4uanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNXaXRoaW5Kcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gd2l0aGluOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWF0aC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanNcXFwiKTtcXG5cXG5mdW5jdGlvbiB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KSB7XFxuICByZXR1cm4gT2JqZWN0KF9tYXRoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIm1heFxcXCJdKShtaW4sIE9iamVjdChfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJtaW5cXFwiXSkodmFsdWUsIG1heCkpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcC5lc20uanNcIjpcbiAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmVzbS5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEFsZXJ0LCBCdXR0b24sIENhcm91c2VsLCBDb2xsYXBzZSwgRHJvcGRvd24sIE1vZGFsLCBPZmZjYW52YXMsIFBvcG92ZXIsIFNjcm9sbFNweSwgVGFiLCBUb2FzdCwgVG9vbHRpcCAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc0Jvb3RzdHJhcERpc3RKc0Jvb3RzdHJhcEVzbUpzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJBbGVydFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQWxlcnQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkJ1dHRvblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQnV0dG9uOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJDYXJvdXNlbFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ2Fyb3VzZWw7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkNvbGxhcHNlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDb2xsYXBzZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiRHJvcGRvd25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERyb3Bkb3duOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJNb2RhbFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTW9kYWw7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIk9mZmNhbnZhc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gT2ZmY2FudmFzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJQb3BvdmVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQb3BvdmVyOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJTY3JvbGxTcHlcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNjcm9sbFNweTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiVGFiXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUYWI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRvYXN0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUb2FzdDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiVG9vbHRpcFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVG9vbHRpcDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wb3BwZXJqc19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAcG9wcGVyanMvY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2luZGV4LmpzXFxcIik7XFxuLyohXFxuICAqIEJvb3RzdHJhcCB2NS4wLjEgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS8pXFxuICAqIENvcHlyaWdodCAyMDExLTIwMjEgVGhlIEJvb3RzdHJhcCBBdXRob3JzIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvZ3JhcGhzL2NvbnRyaWJ1dG9ycylcXG4gICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAqL1xcblxcblxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQm9vdHN0cmFwICh2NS4wLjEpOiBkb20vc2VsZWN0b3ItZW5naW5lLmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5jb25zdCBOT0RFX1RFWFQgPSAzO1xcbmNvbnN0IFNlbGVjdG9yRW5naW5lID0ge1xcbiAgZmluZChzZWxlY3RvciwgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xcbiAgICByZXR1cm4gW10uY29uY2F0KC4uLkVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwuY2FsbChlbGVtZW50LCBzZWxlY3RvcikpO1xcbiAgfSxcXG5cXG4gIGZpbmRPbmUoc2VsZWN0b3IsIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcXG4gICAgcmV0dXJuIEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XFxuICB9LFxcblxcbiAgY2hpbGRyZW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcXG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5lbGVtZW50LmNoaWxkcmVuKS5maWx0ZXIoY2hpbGQgPT4gY2hpbGQubWF0Y2hlcyhzZWxlY3RvcikpO1xcbiAgfSxcXG5cXG4gIHBhcmVudHMoZWxlbWVudCwgc2VsZWN0b3IpIHtcXG4gICAgY29uc3QgcGFyZW50cyA9IFtdO1xcbiAgICBsZXQgYW5jZXN0b3IgPSBlbGVtZW50LnBhcmVudE5vZGU7XFxuXFxuICAgIHdoaWxlIChhbmNlc3RvciAmJiBhbmNlc3Rvci5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgYW5jZXN0b3Iubm9kZVR5cGUgIT09IE5PREVfVEVYVCkge1xcbiAgICAgIGlmIChhbmNlc3Rvci5tYXRjaGVzKHNlbGVjdG9yKSkge1xcbiAgICAgICAgcGFyZW50cy5wdXNoKGFuY2VzdG9yKTtcXG4gICAgICB9XFxuXFxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBwYXJlbnRzO1xcbiAgfSxcXG5cXG4gIHByZXYoZWxlbWVudCwgc2VsZWN0b3IpIHtcXG4gICAgbGV0IHByZXZpb3VzID0gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xcblxcbiAgICB3aGlsZSAocHJldmlvdXMpIHtcXG4gICAgICBpZiAocHJldmlvdXMubWF0Y2hlcyhzZWxlY3RvcikpIHtcXG4gICAgICAgIHJldHVybiBbcHJldmlvdXNdO1xcbiAgICAgIH1cXG5cXG4gICAgICBwcmV2aW91cyA9IHByZXZpb3VzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIFtdO1xcbiAgfSxcXG5cXG4gIG5leHQoZWxlbWVudCwgc2VsZWN0b3IpIHtcXG4gICAgbGV0IG5leHQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZztcXG5cXG4gICAgd2hpbGUgKG5leHQpIHtcXG4gICAgICBpZiAobmV4dC5tYXRjaGVzKHNlbGVjdG9yKSkge1xcbiAgICAgICAgcmV0dXJuIFtuZXh0XTtcXG4gICAgICB9XFxuXFxuICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBbXTtcXG4gIH1cXG5cXG59O1xcblxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQm9vdHN0cmFwICh2NS4wLjEpOiB1dGlsL2luZGV4LmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBNQVhfVUlEID0gMTAwMDAwMDtcXG5jb25zdCBNSUxMSVNFQ09ORFNfTVVMVElQTElFUiA9IDEwMDA7XFxuY29uc3QgVFJBTlNJVElPTl9FTkQgPSAndHJhbnNpdGlvbmVuZCc7IC8vIFNob3V0b3V0IEFuZ3VzQ3JvbGwgKGh0dHBzOi8vZ29vLmdsL3B4d1FHcClcXG5cXG5jb25zdCB0b1R5cGUgPSBvYmogPT4ge1xcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xcbiAgICByZXR1cm4gYCR7b2JqfWA7XFxuICB9XFxuXFxuICByZXR1cm4ge30udG9TdHJpbmcuY2FsbChvYmopLm1hdGNoKC9cXFxccyhbYS16XSspL2kpWzFdLnRvTG93ZXJDYXNlKCk7XFxufTtcXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIFB1YmxpYyBVdGlsIEFwaVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuXFxuY29uc3QgZ2V0VUlEID0gcHJlZml4ID0+IHtcXG4gIGRvIHtcXG4gICAgcHJlZml4ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1BWF9VSUQpO1xcbiAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSk7XFxuXFxuICByZXR1cm4gcHJlZml4O1xcbn07XFxuXFxuY29uc3QgZ2V0U2VsZWN0b3IgPSBlbGVtZW50ID0+IHtcXG4gIGxldCBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXRhcmdldCcpO1xcblxcbiAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gJyMnKSB7XFxuICAgIGxldCBocmVmQXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJyk7IC8vIFRoZSBvbmx5IHZhbGlkIGNvbnRlbnQgdGhhdCBjb3VsZCBkb3VibGUgYXMgYSBzZWxlY3RvciBhcmUgSURzIG9yIGNsYXNzZXMsXFxuICAgIC8vIHNvIGV2ZXJ5dGhpbmcgc3RhcnRpbmcgd2l0aCBgI2Agb3IgYC5gLiBJZiBhIFxcXCJyZWFsXFxcIiBVUkwgaXMgdXNlZCBhcyB0aGUgc2VsZWN0b3IsXFxuICAgIC8vIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yYCB3aWxsIHJpZ2h0ZnVsbHkgY29tcGxhaW4gaXQgaXMgaW52YWxpZC5cXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMzIyNzNcXG5cXG4gICAgaWYgKCFocmVmQXR0ciB8fCAhaHJlZkF0dHIuaW5jbHVkZXMoJyMnKSAmJiAhaHJlZkF0dHIuc3RhcnRzV2l0aCgnLicpKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH0gLy8gSnVzdCBpbiBjYXNlIHNvbWUgQ01TIHB1dHMgb3V0IGEgZnVsbCBVUkwgd2l0aCB0aGUgYW5jaG9yIGFwcGVuZGVkXFxuXFxuXFxuICAgIGlmIChocmVmQXR0ci5pbmNsdWRlcygnIycpICYmICFocmVmQXR0ci5zdGFydHNXaXRoKCcjJykpIHtcXG4gICAgICBocmVmQXR0ciA9IGAjJHtocmVmQXR0ci5zcGxpdCgnIycpWzFdfWA7XFxuICAgIH1cXG5cXG4gICAgc2VsZWN0b3IgPSBocmVmQXR0ciAmJiBocmVmQXR0ciAhPT0gJyMnID8gaHJlZkF0dHIudHJpbSgpIDogbnVsbDtcXG4gIH1cXG5cXG4gIHJldHVybiBzZWxlY3RvcjtcXG59O1xcblxcbmNvbnN0IGdldFNlbGVjdG9yRnJvbUVsZW1lbnQgPSBlbGVtZW50ID0+IHtcXG4gIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudCk7XFxuXFxuICBpZiAoc2VsZWN0b3IpIHtcXG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBudWxsO1xcbiAgfVxcblxcbiAgcmV0dXJuIG51bGw7XFxufTtcXG5cXG5jb25zdCBnZXRFbGVtZW50RnJvbVNlbGVjdG9yID0gZWxlbWVudCA9PiB7XFxuICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xcbiAgcmV0dXJuIHNlbGVjdG9yID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiBudWxsO1xcbn07XFxuXFxuY29uc3QgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQgPSBlbGVtZW50ID0+IHtcXG4gIGlmICghZWxlbWVudCkge1xcbiAgICByZXR1cm4gMDtcXG4gIH0gLy8gR2V0IHRyYW5zaXRpb24tZHVyYXRpb24gb2YgdGhlIGVsZW1lbnRcXG5cXG5cXG4gIGxldCB7XFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbixcXG4gICAgdHJhbnNpdGlvbkRlbGF5XFxuICB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XFxuICBjb25zdCBmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbik7XFxuICBjb25zdCBmbG9hdFRyYW5zaXRpb25EZWxheSA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSk7IC8vIFJldHVybiAwIGlmIGVsZW1lbnQgb3IgdHJhbnNpdGlvbiBkdXJhdGlvbiBpcyBub3QgZm91bmRcXG5cXG4gIGlmICghZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gJiYgIWZsb2F0VHJhbnNpdGlvbkRlbGF5KSB7XFxuICAgIHJldHVybiAwO1xcbiAgfSAvLyBJZiBtdWx0aXBsZSBkdXJhdGlvbnMgYXJlIGRlZmluZWQsIHRha2UgdGhlIGZpcnN0XFxuXFxuXFxuICB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb24uc3BsaXQoJywnKVswXTtcXG4gIHRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheS5zcGxpdCgnLCcpWzBdO1xcbiAgcmV0dXJuIChOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pICsgTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KSkgKiBNSUxMSVNFQ09ORFNfTVVMVElQTElFUjtcXG59O1xcblxcbmNvbnN0IHRyaWdnZXJUcmFuc2l0aW9uRW5kID0gZWxlbWVudCA9PiB7XFxuICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFRSQU5TSVRJT05fRU5EKSk7XFxufTtcXG5cXG5jb25zdCBpc0VsZW1lbnQgPSBvYmogPT4ge1xcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBvYmouanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xcbiAgICBvYmogPSBvYmpbMF07XFxuICB9XFxuXFxuICByZXR1cm4gdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCc7XFxufTtcXG5cXG5jb25zdCBnZXRFbGVtZW50ID0gb2JqID0+IHtcXG4gIGlmIChpc0VsZW1lbnQob2JqKSkge1xcbiAgICAvLyBpdCdzIGEgalF1ZXJ5IG9iamVjdCBvciBhIG5vZGUgZWxlbWVudFxcbiAgICByZXR1cm4gb2JqLmpxdWVyeSA/IG9ialswXSA6IG9iajtcXG4gIH1cXG5cXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyAmJiBvYmoubGVuZ3RoID4gMCkge1xcbiAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShvYmopO1xcbiAgfVxcblxcbiAgcmV0dXJuIG51bGw7XFxufTtcXG5cXG5jb25zdCBlbXVsYXRlVHJhbnNpdGlvbkVuZCA9IChlbGVtZW50LCBkdXJhdGlvbikgPT4ge1xcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xcbiAgY29uc3QgZHVyYXRpb25QYWRkaW5nID0gNTtcXG4gIGNvbnN0IGVtdWxhdGVkRHVyYXRpb24gPSBkdXJhdGlvbiArIGR1cmF0aW9uUGFkZGluZztcXG5cXG4gIGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xcbiAgICBjYWxsZWQgPSB0cnVlO1xcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTl9FTkQsIGxpc3RlbmVyKTtcXG4gIH1cXG5cXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgbGlzdGVuZXIpO1xcbiAgc2V0VGltZW91dCgoKSA9PiB7XFxuICAgIGlmICghY2FsbGVkKSB7XFxuICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQoZWxlbWVudCk7XFxuICAgIH1cXG4gIH0sIGVtdWxhdGVkRHVyYXRpb24pO1xcbn07XFxuXFxuY29uc3QgdHlwZUNoZWNrQ29uZmlnID0gKGNvbXBvbmVudE5hbWUsIGNvbmZpZywgY29uZmlnVHlwZXMpID0+IHtcXG4gIE9iamVjdC5rZXlzKGNvbmZpZ1R5cGVzKS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcXG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IGNvbmZpZ1R5cGVzW3Byb3BlcnR5XTtcXG4gICAgY29uc3QgdmFsdWUgPSBjb25maWdbcHJvcGVydHldO1xcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB2YWx1ZSAmJiBpc0VsZW1lbnQodmFsdWUpID8gJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKTtcXG5cXG4gICAgaWYgKCFuZXcgUmVnRXhwKGV4cGVjdGVkVHlwZXMpLnRlc3QodmFsdWVUeXBlKSkge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29tcG9uZW50TmFtZS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFxcXCIke3Byb3BlcnR5fVxcXCIgcHJvdmlkZWQgdHlwZSBcXFwiJHt2YWx1ZVR5cGV9XFxcIiBidXQgZXhwZWN0ZWQgdHlwZSBcXFwiJHtleHBlY3RlZFR5cGVzfVxcXCIuYCk7XFxuICAgIH1cXG4gIH0pO1xcbn07XFxuXFxuY29uc3QgaXNWaXNpYmxlID0gZWxlbWVudCA9PiB7XFxuICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgaWYgKGVsZW1lbnQuc3R5bGUgJiYgZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5zdHlsZSkge1xcbiAgICBjb25zdCBlbGVtZW50U3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xcbiAgICBjb25zdCBwYXJlbnROb2RlU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQucGFyZW50Tm9kZSk7XFxuICAgIHJldHVybiBlbGVtZW50U3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnICYmIHBhcmVudE5vZGVTdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScgJiYgZWxlbWVudFN0eWxlLnZpc2liaWxpdHkgIT09ICdoaWRkZW4nO1xcbiAgfVxcblxcbiAgcmV0dXJuIGZhbHNlO1xcbn07XFxuXFxuY29uc3QgaXNEaXNhYmxlZCA9IGVsZW1lbnQgPT4ge1xcbiAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBlbGVtZW50LmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xcbiAgICByZXR1cm4gZWxlbWVudC5kaXNhYmxlZDtcXG4gIH1cXG5cXG4gIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKSAhPT0gJ2ZhbHNlJztcXG59O1xcblxcbmNvbnN0IGZpbmRTaGFkb3dSb290ID0gZWxlbWVudCA9PiB7XFxuICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpIHtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9IC8vIENhbiBmaW5kIHRoZSBzaGFkb3cgcm9vdCBvdGhlcndpc2UgaXQnbGwgcmV0dXJuIHRoZSBkb2N1bWVudFxcblxcblxcbiAgaWYgKHR5cGVvZiBlbGVtZW50LmdldFJvb3ROb2RlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGNvbnN0IHJvb3QgPSBlbGVtZW50LmdldFJvb3ROb2RlKCk7XFxuICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsO1xcbiAgfVxcblxcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XFxuICAgIHJldHVybiBlbGVtZW50O1xcbiAgfSAvLyB3aGVuIHdlIGRvbid0IGZpbmQgYSBzaGFkb3cgcm9vdFxcblxcblxcbiAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuXFxuICByZXR1cm4gZmluZFNoYWRvd1Jvb3QoZWxlbWVudC5wYXJlbnROb2RlKTtcXG59O1xcblxcbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcXG5cXG5jb25zdCByZWZsb3cgPSBlbGVtZW50ID0+IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xcblxcbmNvbnN0IGdldGpRdWVyeSA9ICgpID0+IHtcXG4gIGNvbnN0IHtcXG4gICAgalF1ZXJ5XFxuICB9ID0gd2luZG93O1xcblxcbiAgaWYgKGpRdWVyeSAmJiAhZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoJ2RhdGEtYnMtbm8tanF1ZXJ5JykpIHtcXG4gICAgcmV0dXJuIGpRdWVyeTtcXG4gIH1cXG5cXG4gIHJldHVybiBudWxsO1xcbn07XFxuXFxuY29uc3Qgb25ET01Db250ZW50TG9hZGVkID0gY2FsbGJhY2sgPT4ge1xcbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2FsbGJhY2spO1xcbiAgfSBlbHNlIHtcXG4gICAgY2FsbGJhY2soKTtcXG4gIH1cXG59O1xcblxcbmNvbnN0IGlzUlRMID0gKCkgPT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpciA9PT0gJ3J0bCc7XFxuXFxuY29uc3QgZGVmaW5lSlF1ZXJ5UGx1Z2luID0gcGx1Z2luID0+IHtcXG4gIG9uRE9NQ29udGVudExvYWRlZCgoKSA9PiB7XFxuICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKTtcXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuXFxuICAgIGlmICgkKSB7XFxuICAgICAgY29uc3QgbmFtZSA9IHBsdWdpbi5OQU1FO1xcbiAgICAgIGNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bbmFtZV07XFxuICAgICAgJC5mbltuYW1lXSA9IHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XFxuICAgICAgJC5mbltuYW1lXS5Db25zdHJ1Y3RvciA9IHBsdWdpbjtcXG5cXG4gICAgICAkLmZuW25hbWVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XFxuICAgICAgICAkLmZuW25hbWVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xcbiAgICAgICAgcmV0dXJuIHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSk7XFxufTtcXG5cXG5jb25zdCBleGVjdXRlID0gY2FsbGJhY2sgPT4ge1xcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBjYWxsYmFjaygpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGRvbS9kYXRhLmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5jb25zdCBlbGVtZW50TWFwID0gbmV3IE1hcCgpO1xcbnZhciBEYXRhID0ge1xcbiAgc2V0KGVsZW1lbnQsIGtleSwgaW5zdGFuY2UpIHtcXG4gICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xcbiAgICAgIGVsZW1lbnRNYXAuc2V0KGVsZW1lbnQsIG5ldyBNYXAoKSk7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KTsgLy8gbWFrZSBpdCBjbGVhciB3ZSBvbmx5IHdhbnQgb25lIGluc3RhbmNlIHBlciBlbGVtZW50XFxuICAgIC8vIGNhbiBiZSByZW1vdmVkIGxhdGVyIHdoZW4gbXVsdGlwbGUga2V5L2luc3RhbmNlcyBhcmUgZmluZSB0byBiZSB1c2VkXFxuXFxuICAgIGlmICghaW5zdGFuY2VNYXAuaGFzKGtleSkgJiYgaW5zdGFuY2VNYXAuc2l6ZSAhPT0gMCkge1xcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXFxuICAgICAgY29uc29sZS5lcnJvcihgQm9vdHN0cmFwIGRvZXNuJ3QgYWxsb3cgbW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudC4gQm91bmQgaW5zdGFuY2U6ICR7QXJyYXkuZnJvbShpbnN0YW5jZU1hcC5rZXlzKCkpWzBdfS5gKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaW5zdGFuY2VNYXAuc2V0KGtleSwgaW5zdGFuY2UpO1xcbiAgfSxcXG5cXG4gIGdldChlbGVtZW50LCBrZXkpIHtcXG4gICAgaWYgKGVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XFxuICAgICAgcmV0dXJuIGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpLmdldChrZXkpIHx8IG51bGw7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG51bGw7XFxuICB9LFxcblxcbiAgcmVtb3ZlKGVsZW1lbnQsIGtleSkge1xcbiAgICBpZiAoIWVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudCk7XFxuICAgIGluc3RhbmNlTWFwLmRlbGV0ZShrZXkpOyAvLyBmcmVlIHVwIGVsZW1lbnQgcmVmZXJlbmNlcyBpZiB0aGVyZSBhcmUgbm8gaW5zdGFuY2VzIGxlZnQgZm9yIGFuIGVsZW1lbnRcXG5cXG4gICAgaWYgKGluc3RhbmNlTWFwLnNpemUgPT09IDApIHtcXG4gICAgICBlbGVtZW50TWFwLmRlbGV0ZShlbGVtZW50KTtcXG4gICAgfVxcbiAgfVxcblxcbn07XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGRvbS9ldmVudC1oYW5kbGVyLmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBuYW1lc3BhY2VSZWdleCA9IC9bXi5dKig/PVxcXFwuLiopXFxcXC58LiovO1xcbmNvbnN0IHN0cmlwTmFtZVJlZ2V4ID0gL1xcXFwuLiovO1xcbmNvbnN0IHN0cmlwVWlkUmVnZXggPSAvOjpcXFxcZCskLztcXG5jb25zdCBldmVudFJlZ2lzdHJ5ID0ge307IC8vIEV2ZW50cyBzdG9yYWdlXFxuXFxubGV0IHVpZEV2ZW50ID0gMTtcXG5jb25zdCBjdXN0b21FdmVudHMgPSB7XFxuICBtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcXG4gIG1vdXNlbGVhdmU6ICdtb3VzZW91dCdcXG59O1xcbmNvbnN0IGN1c3RvbUV2ZW50c1JlZ2V4ID0gL14obW91c2VlbnRlcnxtb3VzZWxlYXZlKS9pO1xcbmNvbnN0IG5hdGl2ZUV2ZW50cyA9IG5ldyBTZXQoWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdjb250ZXh0bWVudScsICdtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAnc2VsZWN0c3RhcnQnLCAnc2VsZWN0ZW5kJywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnb3JpZW50YXRpb25jaGFuZ2UnLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlcm1vdmUnLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJsZWF2ZScsICdwb2ludGVyY2FuY2VsJywgJ2dlc3R1cmVzdGFydCcsICdnZXN0dXJlY2hhbmdlJywgJ2dlc3R1cmVlbmQnLCAnZm9jdXMnLCAnYmx1cicsICdjaGFuZ2UnLCAncmVzZXQnLCAnc2VsZWN0JywgJ3N1Ym1pdCcsICdmb2N1c2luJywgJ2ZvY3Vzb3V0JywgJ2xvYWQnLCAndW5sb2FkJywgJ2JlZm9yZXVubG9hZCcsICdyZXNpemUnLCAnbW92ZScsICdET01Db250ZW50TG9hZGVkJywgJ3JlYWR5c3RhdGVjaGFuZ2UnLCAnZXJyb3InLCAnYWJvcnQnLCAnc2Nyb2xsJ10pO1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIFByaXZhdGUgbWV0aG9kc1xcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmZ1bmN0aW9uIGdldFVpZEV2ZW50KGVsZW1lbnQsIHVpZCkge1xcbiAgcmV0dXJuIHVpZCAmJiBgJHt1aWR9Ojoke3VpZEV2ZW50Kyt9YCB8fCBlbGVtZW50LnVpZEV2ZW50IHx8IHVpZEV2ZW50Kys7XFxufVxcblxcbmZ1bmN0aW9uIGdldEV2ZW50KGVsZW1lbnQpIHtcXG4gIGNvbnN0IHVpZCA9IGdldFVpZEV2ZW50KGVsZW1lbnQpO1xcbiAgZWxlbWVudC51aWRFdmVudCA9IHVpZDtcXG4gIGV2ZW50UmVnaXN0cnlbdWlkXSA9IGV2ZW50UmVnaXN0cnlbdWlkXSB8fCB7fTtcXG4gIHJldHVybiBldmVudFJlZ2lzdHJ5W3VpZF07XFxufVxcblxcbmZ1bmN0aW9uIGJvb3RzdHJhcEhhbmRsZXIoZWxlbWVudCwgZm4pIHtcXG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XFxuICAgIGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gZWxlbWVudDtcXG5cXG4gICAgaWYgKGhhbmRsZXIub25lT2ZmKSB7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCBldmVudC50eXBlLCBmbik7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGZuLmFwcGx5KGVsZW1lbnQsIFtldmVudF0pO1xcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgc2VsZWN0b3IsIGZuKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xcbiAgICBjb25zdCBkb21FbGVtZW50cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XFxuXFxuICAgIGZvciAobGV0IHtcXG4gICAgICB0YXJnZXRcXG4gICAgfSA9IGV2ZW50OyB0YXJnZXQgJiYgdGFyZ2V0ICE9PSB0aGlzOyB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZSkge1xcbiAgICAgIGZvciAobGV0IGkgPSBkb21FbGVtZW50cy5sZW5ndGg7IGktLTspIHtcXG4gICAgICAgIGlmIChkb21FbGVtZW50c1tpXSA9PT0gdGFyZ2V0KSB7XFxuICAgICAgICAgIGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGFyZ2V0O1xcblxcbiAgICAgICAgICBpZiAoaGFuZGxlci5vbmVPZmYpIHtcXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9jb25zaXN0ZW50LWRlc3RydWN0dXJpbmdcXG4gICAgICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsIGV2ZW50LnR5cGUsIHNlbGVjdG9yLCBmbik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRhcmdldCwgW2V2ZW50XSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IC8vIFRvIHBsZWFzZSBFU0xpbnRcXG5cXG5cXG4gICAgcmV0dXJuIG51bGw7XFxuICB9O1xcbn1cXG5cXG5mdW5jdGlvbiBmaW5kSGFuZGxlcihldmVudHMsIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3RvciA9IG51bGwpIHtcXG4gIGNvbnN0IHVpZEV2ZW50TGlzdCA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XFxuXFxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gdWlkRXZlbnRMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW3VpZEV2ZW50TGlzdFtpXV07XFxuXFxuICAgIGlmIChldmVudC5vcmlnaW5hbEhhbmRsZXIgPT09IGhhbmRsZXIgJiYgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yID09PSBkZWxlZ2F0aW9uU2VsZWN0b3IpIHtcXG4gICAgICByZXR1cm4gZXZlbnQ7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBudWxsO1xcbn1cXG5cXG5mdW5jdGlvbiBub3JtYWxpemVQYXJhbXMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25Gbikge1xcbiAgY29uc3QgZGVsZWdhdGlvbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJztcXG4gIGNvbnN0IG9yaWdpbmFsSGFuZGxlciA9IGRlbGVnYXRpb24gPyBkZWxlZ2F0aW9uRm4gOiBoYW5kbGVyO1xcbiAgbGV0IHR5cGVFdmVudCA9IGdldFR5cGVFdmVudChvcmlnaW5hbFR5cGVFdmVudCk7XFxuICBjb25zdCBpc05hdGl2ZSA9IG5hdGl2ZUV2ZW50cy5oYXModHlwZUV2ZW50KTtcXG5cXG4gIGlmICghaXNOYXRpdmUpIHtcXG4gICAgdHlwZUV2ZW50ID0gb3JpZ2luYWxUeXBlRXZlbnQ7XFxuICB9XFxuXFxuICByZXR1cm4gW2RlbGVnYXRpb24sIG9yaWdpbmFsSGFuZGxlciwgdHlwZUV2ZW50XTtcXG59XFxuXFxuZnVuY3Rpb24gYWRkSGFuZGxlcihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuLCBvbmVPZmYpIHtcXG4gIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmICghaGFuZGxlcikge1xcbiAgICBoYW5kbGVyID0gZGVsZWdhdGlvbkZuO1xcbiAgICBkZWxlZ2F0aW9uRm4gPSBudWxsO1xcbiAgfSAvLyBpbiBjYXNlIG9mIG1vdXNlZW50ZXIgb3IgbW91c2VsZWF2ZSB3cmFwIHRoZSBoYW5kbGVyIHdpdGhpbiBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGZvciBpdHMgRE9NIHBvc2l0aW9uXFxuICAvLyB0aGlzIHByZXZlbnRzIHRoZSBoYW5kbGVyIGZyb20gYmVpbmcgZGlzcGF0Y2hlZCB0aGUgc2FtZSB3YXkgYXMgbW91c2VvdmVyIG9yIG1vdXNlb3V0IGRvZXNcXG5cXG5cXG4gIGlmIChjdXN0b21FdmVudHNSZWdleC50ZXN0KG9yaWdpbmFsVHlwZUV2ZW50KSkge1xcbiAgICBjb25zdCB3cmFwRm4gPSBmbiA9PiB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgaWYgKCFldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQgIT09IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmICFldmVudC5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xcbiAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfTtcXG5cXG4gICAgaWYgKGRlbGVnYXRpb25Gbikge1xcbiAgICAgIGRlbGVnYXRpb25GbiA9IHdyYXBGbihkZWxlZ2F0aW9uRm4pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGhhbmRsZXIgPSB3cmFwRm4oaGFuZGxlcik7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGNvbnN0IFtkZWxlZ2F0aW9uLCBvcmlnaW5hbEhhbmRsZXIsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbXMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25Gbik7XFxuICBjb25zdCBldmVudHMgPSBnZXRFdmVudChlbGVtZW50KTtcXG4gIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzW3R5cGVFdmVudF0gfHwgKGV2ZW50c1t0eXBlRXZlbnRdID0ge30pO1xcbiAgY29uc3QgcHJldmlvdXNGbiA9IGZpbmRIYW5kbGVyKGhhbmRsZXJzLCBvcmlnaW5hbEhhbmRsZXIsIGRlbGVnYXRpb24gPyBoYW5kbGVyIDogbnVsbCk7XFxuXFxuICBpZiAocHJldmlvdXNGbikge1xcbiAgICBwcmV2aW91c0ZuLm9uZU9mZiA9IHByZXZpb3VzRm4ub25lT2ZmICYmIG9uZU9mZjtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgY29uc3QgdWlkID0gZ2V0VWlkRXZlbnQob3JpZ2luYWxIYW5kbGVyLCBvcmlnaW5hbFR5cGVFdmVudC5yZXBsYWNlKG5hbWVzcGFjZVJlZ2V4LCAnJykpO1xcbiAgY29uc3QgZm4gPSBkZWxlZ2F0aW9uID8gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuKSA6IGJvb3RzdHJhcEhhbmRsZXIoZWxlbWVudCwgaGFuZGxlcik7XFxuICBmbi5kZWxlZ2F0aW9uU2VsZWN0b3IgPSBkZWxlZ2F0aW9uID8gaGFuZGxlciA6IG51bGw7XFxuICBmbi5vcmlnaW5hbEhhbmRsZXIgPSBvcmlnaW5hbEhhbmRsZXI7XFxuICBmbi5vbmVPZmYgPSBvbmVPZmY7XFxuICBmbi51aWRFdmVudCA9IHVpZDtcXG4gIGhhbmRsZXJzW3VpZF0gPSBmbjtcXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBkZWxlZ2F0aW9uKTtcXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvblNlbGVjdG9yKSB7XFxuICBjb25zdCBmbiA9IGZpbmRIYW5kbGVyKGV2ZW50c1t0eXBlRXZlbnRdLCBoYW5kbGVyLCBkZWxlZ2F0aW9uU2VsZWN0b3IpO1xcblxcbiAgaWYgKCFmbikge1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZUV2ZW50LCBmbiwgQm9vbGVhbihkZWxlZ2F0aW9uU2VsZWN0b3IpKTtcXG4gIGRlbGV0ZSBldmVudHNbdHlwZUV2ZW50XVtmbi51aWRFdmVudF07XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZU5hbWVzcGFjZWRIYW5kbGVycyhlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgbmFtZXNwYWNlKSB7XFxuICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xcbiAgT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpLmZvckVhY2goaGFuZGxlcktleSA9PiB7XFxuICAgIGlmIChoYW5kbGVyS2V5LmluY2x1ZGVzKG5hbWVzcGFjZSkpIHtcXG4gICAgICBjb25zdCBldmVudCA9IHN0b3JlRWxlbWVudEV2ZW50W2hhbmRsZXJLZXldO1xcbiAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGV2ZW50Lm9yaWdpbmFsSGFuZGxlciwgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yKTtcXG4gICAgfVxcbiAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIGdldFR5cGVFdmVudChldmVudCkge1xcbiAgLy8gYWxsb3cgdG8gZ2V0IHRoZSBuYXRpdmUgZXZlbnRzIGZyb20gbmFtZXNwYWNlZCBldmVudHMgKCdjbGljay5icy5idXR0b24nIC0tPiAnY2xpY2snKVxcbiAgZXZlbnQgPSBldmVudC5yZXBsYWNlKHN0cmlwTmFtZVJlZ2V4LCAnJyk7XFxuICByZXR1cm4gY3VzdG9tRXZlbnRzW2V2ZW50XSB8fCBldmVudDtcXG59XFxuXFxuY29uc3QgRXZlbnRIYW5kbGVyID0ge1xcbiAgb24oZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25Gbikge1xcbiAgICBhZGRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4sIGZhbHNlKTtcXG4gIH0sXFxuXFxuICBvbmUoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25Gbikge1xcbiAgICBhZGRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4sIHRydWUpO1xcbiAgfSxcXG5cXG4gIG9mZihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuKSB7XFxuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IFtkZWxlZ2F0aW9uLCBvcmlnaW5hbEhhbmRsZXIsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbXMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25Gbik7XFxuICAgIGNvbnN0IGluTmFtZXNwYWNlID0gdHlwZUV2ZW50ICE9PSBvcmlnaW5hbFR5cGVFdmVudDtcXG4gICAgY29uc3QgZXZlbnRzID0gZ2V0RXZlbnQoZWxlbWVudCk7XFxuICAgIGNvbnN0IGlzTmFtZXNwYWNlID0gb3JpZ2luYWxUeXBlRXZlbnQuc3RhcnRzV2l0aCgnLicpO1xcblxcbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsSGFuZGxlciAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAvLyBTaW1wbGVzdCBjYXNlOiBoYW5kbGVyIGlzIHBhc3NlZCwgcmVtb3ZlIHRoYXQgbGlzdGVuZXIgT05MWS5cXG4gICAgICBpZiAoIWV2ZW50cyB8fCAhZXZlbnRzW3R5cGVFdmVudF0pIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgb3JpZ2luYWxIYW5kbGVyLCBkZWxlZ2F0aW9uID8gaGFuZGxlciA6IG51bGwpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAoaXNOYW1lc3BhY2UpIHtcXG4gICAgICBPYmplY3Qua2V5cyhldmVudHMpLmZvckVhY2goZWxlbWVudEV2ZW50ID0+IHtcXG4gICAgICAgIHJlbW92ZU5hbWVzcGFjZWRIYW5kbGVycyhlbGVtZW50LCBldmVudHMsIGVsZW1lbnRFdmVudCwgb3JpZ2luYWxUeXBlRXZlbnQuc2xpY2UoMSkpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHN0b3JlRWxlbWVudEV2ZW50ID0gZXZlbnRzW3R5cGVFdmVudF0gfHwge307XFxuICAgIE9iamVjdC5rZXlzKHN0b3JlRWxlbWVudEV2ZW50KS5mb3JFYWNoKGtleUhhbmRsZXJzID0+IHtcXG4gICAgICBjb25zdCBoYW5kbGVyS2V5ID0ga2V5SGFuZGxlcnMucmVwbGFjZShzdHJpcFVpZFJlZ2V4LCAnJyk7XFxuXFxuICAgICAgaWYgKCFpbk5hbWVzcGFjZSB8fCBvcmlnaW5hbFR5cGVFdmVudC5pbmNsdWRlcyhoYW5kbGVyS2V5KSkge1xcbiAgICAgICAgY29uc3QgZXZlbnQgPSBzdG9yZUVsZW1lbnRFdmVudFtrZXlIYW5kbGVyc107XFxuICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBldmVudC5vcmlnaW5hbEhhbmRsZXIsIGV2ZW50LmRlbGVnYXRpb25TZWxlY3Rvcik7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH0sXFxuXFxuICB0cmlnZ2VyKGVsZW1lbnQsIGV2ZW50LCBhcmdzKSB7XFxuICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgJCA9IGdldGpRdWVyeSgpO1xcbiAgICBjb25zdCB0eXBlRXZlbnQgPSBnZXRUeXBlRXZlbnQoZXZlbnQpO1xcbiAgICBjb25zdCBpbk5hbWVzcGFjZSA9IGV2ZW50ICE9PSB0eXBlRXZlbnQ7XFxuICAgIGNvbnN0IGlzTmF0aXZlID0gbmF0aXZlRXZlbnRzLmhhcyh0eXBlRXZlbnQpO1xcbiAgICBsZXQgalF1ZXJ5RXZlbnQ7XFxuICAgIGxldCBidWJibGVzID0gdHJ1ZTtcXG4gICAgbGV0IG5hdGl2ZURpc3BhdGNoID0gdHJ1ZTtcXG4gICAgbGV0IGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcXG4gICAgbGV0IGV2dCA9IG51bGw7XFxuXFxuICAgIGlmIChpbk5hbWVzcGFjZSAmJiAkKSB7XFxuICAgICAgalF1ZXJ5RXZlbnQgPSAkLkV2ZW50KGV2ZW50LCBhcmdzKTtcXG4gICAgICAkKGVsZW1lbnQpLnRyaWdnZXIoalF1ZXJ5RXZlbnQpO1xcbiAgICAgIGJ1YmJsZXMgPSAhalF1ZXJ5RXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcXG4gICAgICBuYXRpdmVEaXNwYXRjaCA9ICFqUXVlcnlFdmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpO1xcbiAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSBqUXVlcnlFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcXG4gICAgfVxcblxcbiAgICBpZiAoaXNOYXRpdmUpIHtcXG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xcbiAgICAgIGV2dC5pbml0RXZlbnQodHlwZUV2ZW50LCBidWJibGVzLCB0cnVlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHtcXG4gICAgICAgIGJ1YmJsZXMsXFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXFxuICAgICAgfSk7XFxuICAgIH0gLy8gbWVyZ2UgY3VzdG9tIGluZm9ybWF0aW9uIGluIG91ciBldmVudFxcblxcblxcbiAgICBpZiAodHlwZW9mIGFyZ3MgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgT2JqZWN0LmtleXMoYXJncykuZm9yRWFjaChrZXkgPT4ge1xcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2dCwga2V5LCB7XFxuICAgICAgICAgIGdldCgpIHtcXG4gICAgICAgICAgICByZXR1cm4gYXJnc1trZXldO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICB9XFxuXFxuICAgIGlmIChuYXRpdmVEaXNwYXRjaCkge1xcbiAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldnQpO1xcbiAgICB9XFxuXFxuICAgIGlmIChldnQuZGVmYXVsdFByZXZlbnRlZCAmJiB0eXBlb2YgalF1ZXJ5RXZlbnQgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgalF1ZXJ5RXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZXZ0O1xcbiAgfVxcblxcbn07XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGJhc2UtY29tcG9uZW50LmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBWRVJTSU9OID0gJzUuMC4xJztcXG5cXG5jbGFzcyBCYXNlQ29tcG9uZW50IHtcXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcXG4gICAgZWxlbWVudCA9IGdldEVsZW1lbnQoZWxlbWVudCk7XFxuXFxuICAgIGlmICghZWxlbWVudCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcXG4gICAgRGF0YS5zZXQodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcyk7XFxuICB9XFxuXFxuICBkaXNwb3NlKCkge1xcbiAgICBEYXRhLnJlbW92ZSh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKTtcXG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSk7XFxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLmZvckVhY2gocHJvcGVydHlOYW1lID0+IHtcXG4gICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBudWxsO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIF9xdWV1ZUNhbGxiYWNrKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkID0gdHJ1ZSkge1xcbiAgICBpZiAoIWlzQW5pbWF0ZWQpIHtcXG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQoZWxlbWVudCk7XFxuICAgIEV2ZW50SGFuZGxlci5vbmUoZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCAoKSA9PiBleGVjdXRlKGNhbGxiYWNrKSk7XFxuICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGVsZW1lbnQsIHRyYW5zaXRpb25EdXJhdGlvbik7XFxuICB9XFxuICAvKiogU3RhdGljICovXFxuXFxuXFxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudCkge1xcbiAgICByZXR1cm4gRGF0YS5nZXQoZWxlbWVudCwgdGhpcy5EQVRBX0tFWSk7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XFxuICAgIHJldHVybiBWRVJTSU9OO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIHRvIGltcGxlbWVudCB0aGUgc3RhdGljIG1ldGhvZCBcXFwiTkFNRVxcXCIsIGZvciBlYWNoIGNvbXBvbmVudCEnKTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XFxuICAgIHJldHVybiBgYnMuJHt0aGlzLk5BTUV9YDtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xcbiAgICByZXR1cm4gYC4ke3RoaXMuREFUQV9LRVl9YDtcXG4gIH1cXG5cXG59XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGFsZXJ0LmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBOQU1FJGMgPSAnYWxlcnQnO1xcbmNvbnN0IERBVEFfS0VZJGIgPSAnYnMuYWxlcnQnO1xcbmNvbnN0IEVWRU5UX0tFWSRiID0gYC4ke0RBVEFfS0VZJGJ9YDtcXG5jb25zdCBEQVRBX0FQSV9LRVkkOCA9ICcuZGF0YS1hcGknO1xcbmNvbnN0IFNFTEVDVE9SX0RJU01JU1MgPSAnW2RhdGEtYnMtZGlzbWlzcz1cXFwiYWxlcnRcXFwiXSc7XFxuY29uc3QgRVZFTlRfQ0xPU0UgPSBgY2xvc2Uke0VWRU5UX0tFWSRifWA7XFxuY29uc3QgRVZFTlRfQ0xPU0VEID0gYGNsb3NlZCR7RVZFTlRfS0VZJGJ9YDtcXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ3ID0gYGNsaWNrJHtFVkVOVF9LRVkkYn0ke0RBVEFfQVBJX0tFWSQ4fWA7XFxuY29uc3QgQ0xBU1NfTkFNRV9BTEVSVCA9ICdhbGVydCc7XFxuY29uc3QgQ0xBU1NfTkFNRV9GQURFJDYgPSAnZmFkZSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDkgPSAnc2hvdyc7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIEFsZXJ0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XFxuICAvLyBHZXR0ZXJzXFxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgIHJldHVybiBOQU1FJGM7XFxuICB9IC8vIFB1YmxpY1xcblxcblxcbiAgY2xvc2UoZWxlbWVudCkge1xcbiAgICBjb25zdCByb290RWxlbWVudCA9IGVsZW1lbnQgPyB0aGlzLl9nZXRSb290RWxlbWVudChlbGVtZW50KSA6IHRoaXMuX2VsZW1lbnQ7XFxuXFxuICAgIGNvbnN0IGN1c3RvbUV2ZW50ID0gdGhpcy5fdHJpZ2dlckNsb3NlRXZlbnQocm9vdEVsZW1lbnQpO1xcblxcbiAgICBpZiAoY3VzdG9tRXZlbnQgPT09IG51bGwgfHwgY3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9yZW1vdmVFbGVtZW50KHJvb3RFbGVtZW50KTtcXG4gIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgX2dldFJvb3RFbGVtZW50KGVsZW1lbnQpIHtcXG4gICAgcmV0dXJuIGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkgfHwgZWxlbWVudC5jbG9zZXN0KGAuJHtDTEFTU19OQU1FX0FMRVJUfWApO1xcbiAgfVxcblxcbiAgX3RyaWdnZXJDbG9zZUV2ZW50KGVsZW1lbnQpIHtcXG4gICAgcmV0dXJuIEV2ZW50SGFuZGxlci50cmlnZ2VyKGVsZW1lbnQsIEVWRU5UX0NMT1NFKTtcXG4gIH1cXG5cXG4gIF9yZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcXG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ5KTtcXG4gICAgY29uc3QgaXNBbmltYXRlZCA9IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQ2KTtcXG5cXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudChlbGVtZW50KSwgZWxlbWVudCwgaXNBbmltYXRlZCk7XFxuICB9XFxuXFxuICBfZGVzdHJveUVsZW1lbnQoZWxlbWVudCkge1xcbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XFxuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xcbiAgICB9XFxuXFxuICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKGVsZW1lbnQsIEVWRU5UX0NMT1NFRCk7XFxuICB9IC8vIFN0YXRpY1xcblxcblxcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgbGV0IGRhdGEgPSBEYXRhLmdldCh0aGlzLCBEQVRBX0tFWSRiKTtcXG5cXG4gICAgICBpZiAoIWRhdGEpIHtcXG4gICAgICAgIGRhdGEgPSBuZXcgQWxlcnQodGhpcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjb25maWcgPT09ICdjbG9zZScpIHtcXG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgc3RhdGljIGhhbmRsZURpc21pc3MoYWxlcnRJbnN0YW5jZSkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgaWYgKGV2ZW50KSB7XFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBhbGVydEluc3RhbmNlLmNsb3NlKHRoaXMpO1xcbiAgICB9O1xcbiAgfVxcblxcbn1cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcblxcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNywgU0VMRUNUT1JfRElTTUlTUywgQWxlcnQuaGFuZGxlRGlzbWlzcyhuZXcgQWxlcnQoKSkpO1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGpRdWVyeVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGFkZCAuQWxlcnQgdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcXG4gKi9cXG5cXG5kZWZpbmVKUXVlcnlQbHVnaW4oQWxlcnQpO1xcblxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQm9vdHN0cmFwICh2NS4wLjEpOiBidXR0b24uanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIENvbnN0YW50c1xcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNvbnN0IE5BTUUkYiA9ICdidXR0b24nO1xcbmNvbnN0IERBVEFfS0VZJGEgPSAnYnMuYnV0dG9uJztcXG5jb25zdCBFVkVOVF9LRVkkYSA9IGAuJHtEQVRBX0tFWSRhfWA7XFxuY29uc3QgREFUQV9BUElfS0VZJDcgPSAnLmRhdGEtYXBpJztcXG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSQzID0gJ2FjdGl2ZSc7XFxuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkNSA9ICdbZGF0YS1icy10b2dnbGU9XFxcImJ1dHRvblxcXCJdJztcXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ2ID0gYGNsaWNrJHtFVkVOVF9LRVkkYX0ke0RBVEFfQVBJX0tFWSQ3fWA7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIEJ1dHRvbiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgLy8gR2V0dGVyc1xcbiAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICByZXR1cm4gTkFNRSRiO1xcbiAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gIHRvZ2dsZSgpIHtcXG4gICAgLy8gVG9nZ2xlIGNsYXNzIGFuZCBzeW5jIHRoZSBgYXJpYS1wcmVzc2VkYCBhdHRyaWJ1dGUgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBgLnRvZ2dsZSgpYCBtZXRob2RcXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX0FDVElWRSQzKSk7XFxuICB9IC8vIFN0YXRpY1xcblxcblxcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgbGV0IGRhdGEgPSBEYXRhLmdldCh0aGlzLCBEQVRBX0tFWSRhKTtcXG5cXG4gICAgICBpZiAoIWRhdGEpIHtcXG4gICAgICAgIGRhdGEgPSBuZXcgQnV0dG9uKHRoaXMpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY29uZmlnID09PSAndG9nZ2xlJykge1xcbiAgICAgICAgZGF0YVtjb25maWddKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG5cXG59XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5cXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDYsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUsIGV2ZW50ID0+IHtcXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICBjb25zdCBidXR0b24gPSBldmVudC50YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1KTtcXG4gIGxldCBkYXRhID0gRGF0YS5nZXQoYnV0dG9uLCBEQVRBX0tFWSRhKTtcXG5cXG4gIGlmICghZGF0YSkge1xcbiAgICBkYXRhID0gbmV3IEJ1dHRvbihidXR0b24pO1xcbiAgfVxcblxcbiAgZGF0YS50b2dnbGUoKTtcXG59KTtcXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBqUXVlcnlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBhZGQgLkJ1dHRvbiB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxcbiAqL1xcblxcbmRlZmluZUpRdWVyeVBsdWdpbihCdXR0b24pO1xcblxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQm9vdHN0cmFwICh2NS4wLjEpOiBkb20vbWFuaXB1bGF0b3IuanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcbmZ1bmN0aW9uIG5vcm1hbGl6ZURhdGEodmFsKSB7XFxuICBpZiAodmFsID09PSAndHJ1ZScpIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICBpZiAodmFsID09PSAnZmFsc2UnKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIGlmICh2YWwgPT09IE51bWJlcih2YWwpLnRvU3RyaW5nKCkpIHtcXG4gICAgcmV0dXJuIE51bWJlcih2YWwpO1xcbiAgfVxcblxcbiAgaWYgKHZhbCA9PT0gJycgfHwgdmFsID09PSAnbnVsbCcpIHtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuXFxuICByZXR1cm4gdmFsO1xcbn1cXG5cXG5mdW5jdGlvbiBub3JtYWxpemVEYXRhS2V5KGtleSkge1xcbiAgcmV0dXJuIGtleS5yZXBsYWNlKC9bQS1aXS9nLCBjaHIgPT4gYC0ke2Noci50b0xvd2VyQ2FzZSgpfWApO1xcbn1cXG5cXG5jb25zdCBNYW5pcHVsYXRvciA9IHtcXG4gIHNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5LCB2YWx1ZSkge1xcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gLCB2YWx1ZSk7XFxuICB9LFxcblxcbiAgcmVtb3ZlRGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcXG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCk7XFxuICB9LFxcblxcbiAgZ2V0RGF0YUF0dHJpYnV0ZXMoZWxlbWVudCkge1xcbiAgICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgICByZXR1cm4ge307XFxuICAgIH1cXG5cXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xcbiAgICBPYmplY3Qua2V5cyhlbGVtZW50LmRhdGFzZXQpLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2JzJykpLmZvckVhY2goa2V5ID0+IHtcXG4gICAgICBsZXQgcHVyZUtleSA9IGtleS5yZXBsYWNlKC9eYnMvLCAnJyk7XFxuICAgICAgcHVyZUtleSA9IHB1cmVLZXkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBwdXJlS2V5LnNsaWNlKDEsIHB1cmVLZXkubGVuZ3RoKTtcXG4gICAgICBhdHRyaWJ1dGVzW3B1cmVLZXldID0gbm9ybWFsaXplRGF0YShlbGVtZW50LmRhdGFzZXRba2V5XSk7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gYXR0cmlidXRlcztcXG4gIH0sXFxuXFxuICBnZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSkge1xcbiAgICByZXR1cm4gbm9ybWFsaXplRGF0YShlbGVtZW50LmdldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gKSk7XFxuICB9LFxcblxcbiAgb2Zmc2V0KGVsZW1lbnQpIHtcXG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgIHJldHVybiB7XFxuICAgICAgdG9wOiByZWN0LnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLFxcbiAgICAgIGxlZnQ6IHJlY3QubGVmdCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdFxcbiAgICB9O1xcbiAgfSxcXG5cXG4gIHBvc2l0aW9uKGVsZW1lbnQpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICB0b3A6IGVsZW1lbnQub2Zmc2V0VG9wLFxcbiAgICAgIGxlZnQ6IGVsZW1lbnQub2Zmc2V0TGVmdFxcbiAgICB9O1xcbiAgfVxcblxcbn07XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGNhcm91c2VsLmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBOQU1FJGEgPSAnY2Fyb3VzZWwnO1xcbmNvbnN0IERBVEFfS0VZJDkgPSAnYnMuY2Fyb3VzZWwnO1xcbmNvbnN0IEVWRU5UX0tFWSQ5ID0gYC4ke0RBVEFfS0VZJDl9YDtcXG5jb25zdCBEQVRBX0FQSV9LRVkkNiA9ICcuZGF0YS1hcGknO1xcbmNvbnN0IEFSUk9XX0xFRlRfS0VZID0gJ0Fycm93TGVmdCc7XFxuY29uc3QgQVJST1dfUklHSFRfS0VZID0gJ0Fycm93UmlnaHQnO1xcbmNvbnN0IFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgPSA1MDA7IC8vIFRpbWUgZm9yIG1vdXNlIGNvbXBhdCBldmVudHMgdG8gZmlyZSBhZnRlciB0b3VjaFxcblxcbmNvbnN0IFNXSVBFX1RIUkVTSE9MRCA9IDQwO1xcbmNvbnN0IERlZmF1bHQkOSA9IHtcXG4gIGludGVydmFsOiA1MDAwLFxcbiAga2V5Ym9hcmQ6IHRydWUsXFxuICBzbGlkZTogZmFsc2UsXFxuICBwYXVzZTogJ2hvdmVyJyxcXG4gIHdyYXA6IHRydWUsXFxuICB0b3VjaDogdHJ1ZVxcbn07XFxuY29uc3QgRGVmYXVsdFR5cGUkOSA9IHtcXG4gIGludGVydmFsOiAnKG51bWJlcnxib29sZWFuKScsXFxuICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxcbiAgc2xpZGU6ICcoYm9vbGVhbnxzdHJpbmcpJyxcXG4gIHBhdXNlOiAnKHN0cmluZ3xib29sZWFuKScsXFxuICB3cmFwOiAnYm9vbGVhbicsXFxuICB0b3VjaDogJ2Jvb2xlYW4nXFxufTtcXG5jb25zdCBPUkRFUl9ORVhUID0gJ25leHQnO1xcbmNvbnN0IE9SREVSX1BSRVYgPSAncHJldic7XFxuY29uc3QgRElSRUNUSU9OX0xFRlQgPSAnbGVmdCc7XFxuY29uc3QgRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcXG5jb25zdCBFVkVOVF9TTElERSA9IGBzbGlkZSR7RVZFTlRfS0VZJDl9YDtcXG5jb25zdCBFVkVOVF9TTElEID0gYHNsaWQke0VWRU5UX0tFWSQ5fWA7XFxuY29uc3QgRVZFTlRfS0VZRE9XTiA9IGBrZXlkb3duJHtFVkVOVF9LRVkkOX1gO1xcbmNvbnN0IEVWRU5UX01PVVNFRU5URVIgPSBgbW91c2VlbnRlciR7RVZFTlRfS0VZJDl9YDtcXG5jb25zdCBFVkVOVF9NT1VTRUxFQVZFID0gYG1vdXNlbGVhdmUke0VWRU5UX0tFWSQ5fWA7XFxuY29uc3QgRVZFTlRfVE9VQ0hTVEFSVCA9IGB0b3VjaHN0YXJ0JHtFVkVOVF9LRVkkOX1gO1xcbmNvbnN0IEVWRU5UX1RPVUNITU9WRSA9IGB0b3VjaG1vdmUke0VWRU5UX0tFWSQ5fWA7XFxuY29uc3QgRVZFTlRfVE9VQ0hFTkQgPSBgdG91Y2hlbmQke0VWRU5UX0tFWSQ5fWA7XFxuY29uc3QgRVZFTlRfUE9JTlRFUkRPV04gPSBgcG9pbnRlcmRvd24ke0VWRU5UX0tFWSQ5fWA7XFxuY29uc3QgRVZFTlRfUE9JTlRFUlVQID0gYHBvaW50ZXJ1cCR7RVZFTlRfS0VZJDl9YDtcXG5jb25zdCBFVkVOVF9EUkFHX1NUQVJUID0gYGRyYWdzdGFydCR7RVZFTlRfS0VZJDl9YDtcXG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDIgPSBgbG9hZCR7RVZFTlRfS0VZJDl9JHtEQVRBX0FQSV9LRVkkNn1gO1xcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDUgPSBgY2xpY2ske0VWRU5UX0tFWSQ5fSR7REFUQV9BUElfS0VZJDZ9YDtcXG5jb25zdCBDTEFTU19OQU1FX0NBUk9VU0VMID0gJ2Nhcm91c2VsJztcXG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSQyID0gJ2FjdGl2ZSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9TTElERSA9ICdzbGlkZSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9FTkQgPSAnY2Fyb3VzZWwtaXRlbS1lbmQnO1xcbmNvbnN0IENMQVNTX05BTUVfU1RBUlQgPSAnY2Fyb3VzZWwtaXRlbS1zdGFydCc7XFxuY29uc3QgQ0xBU1NfTkFNRV9ORVhUID0gJ2Nhcm91c2VsLWl0ZW0tbmV4dCc7XFxuY29uc3QgQ0xBU1NfTkFNRV9QUkVWID0gJ2Nhcm91c2VsLWl0ZW0tcHJldic7XFxuY29uc3QgQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UID0gJ3BvaW50ZXItZXZlbnQnO1xcbmNvbnN0IFNFTEVDVE9SX0FDVElWRSQxID0gJy5hY3RpdmUnO1xcbmNvbnN0IFNFTEVDVE9SX0FDVElWRV9JVEVNID0gJy5hY3RpdmUuY2Fyb3VzZWwtaXRlbSc7XFxuY29uc3QgU0VMRUNUT1JfSVRFTSA9ICcuY2Fyb3VzZWwtaXRlbSc7XFxuY29uc3QgU0VMRUNUT1JfSVRFTV9JTUcgPSAnLmNhcm91c2VsLWl0ZW0gaW1nJztcXG5jb25zdCBTRUxFQ1RPUl9ORVhUX1BSRVYgPSAnLmNhcm91c2VsLWl0ZW0tbmV4dCwgLmNhcm91c2VsLWl0ZW0tcHJldic7XFxuY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SUyA9ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycyc7XFxuY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SID0gJ1tkYXRhLWJzLXRhcmdldF0nO1xcbmNvbnN0IFNFTEVDVE9SX0RBVEFfU0xJREUgPSAnW2RhdGEtYnMtc2xpZGVdLCBbZGF0YS1icy1zbGlkZS10b10nO1xcbmNvbnN0IFNFTEVDVE9SX0RBVEFfUklERSA9ICdbZGF0YS1icy1yaWRlPVxcXCJjYXJvdXNlbFxcXCJdJztcXG5jb25zdCBQT0lOVEVSX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xcbmNvbnN0IFBPSU5URVJfVFlQRV9QRU4gPSAncGVuJztcXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDbGFzcyBEZWZpbml0aW9uXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuY2xhc3MgQ2Fyb3VzZWwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xcbiAgICBzdXBlcihlbGVtZW50KTtcXG4gICAgdGhpcy5faXRlbXMgPSBudWxsO1xcbiAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XFxuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xcbiAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xcbiAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcXG4gICAgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsO1xcbiAgICB0aGlzLnRvdWNoU3RhcnRYID0gMDtcXG4gICAgdGhpcy50b3VjaERlbHRhWCA9IDA7XFxuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xcbiAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfSU5ESUNBVE9SUywgdGhpcy5fZWxlbWVudCk7XFxuICAgIHRoaXMuX3RvdWNoU3VwcG9ydGVkID0gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDA7XFxuICAgIHRoaXMuX3BvaW50ZXJFdmVudCA9IEJvb2xlYW4od2luZG93LlBvaW50ZXJFdmVudCk7XFxuXFxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XFxuICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgcmV0dXJuIERlZmF1bHQkOTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgcmV0dXJuIE5BTUUkYTtcXG4gIH0gLy8gUHVibGljXFxuXFxuXFxuICBuZXh0KCkge1xcbiAgICBpZiAoIXRoaXMuX2lzU2xpZGluZykge1xcbiAgICAgIHRoaXMuX3NsaWRlKE9SREVSX05FWFQpO1xcbiAgICB9XFxuICB9XFxuXFxuICBuZXh0V2hlblZpc2libGUoKSB7XFxuICAgIC8vIERvbid0IGNhbGwgbmV4dCB3aGVuIHRoZSBwYWdlIGlzbid0IHZpc2libGVcXG4gICAgLy8gb3IgdGhlIGNhcm91c2VsIG9yIGl0cyBwYXJlbnQgaXNuJ3QgdmlzaWJsZVxcbiAgICBpZiAoIWRvY3VtZW50LmhpZGRlbiAmJiBpc1Zpc2libGUodGhpcy5fZWxlbWVudCkpIHtcXG4gICAgICB0aGlzLm5leHQoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcHJldigpIHtcXG4gICAgaWYgKCF0aGlzLl9pc1NsaWRpbmcpIHtcXG4gICAgICB0aGlzLl9zbGlkZShPUkRFUl9QUkVWKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcGF1c2UoZXZlbnQpIHtcXG4gICAgaWYgKCFldmVudCkge1xcbiAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAoU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9ORVhUX1BSRVYsIHRoaXMuX2VsZW1lbnQpKSB7XFxuICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQodGhpcy5fZWxlbWVudCk7XFxuICAgICAgdGhpcy5jeWNsZSh0cnVlKTtcXG4gICAgfVxcblxcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xcbiAgfVxcblxcbiAgY3ljbGUoZXZlbnQpIHtcXG4gICAgaWYgKCFldmVudCkge1xcbiAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XFxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XFxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9jb25maWcgJiYgdGhpcy5fY29uZmlnLmludGVydmFsICYmICF0aGlzLl9pc1BhdXNlZCkge1xcbiAgICAgIHRoaXMuX3VwZGF0ZUludGVydmFsKCk7XFxuXFxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID8gdGhpcy5uZXh0V2hlblZpc2libGUgOiB0aGlzLm5leHQpLmJpbmQodGhpcyksIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRvKGluZGV4KSB7XFxuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRV9JVEVNLCB0aGlzLl9lbGVtZW50KTtcXG5cXG4gICAgY29uc3QgYWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgodGhpcy5fYWN0aXZlRWxlbWVudCk7XFxuXFxuICAgIGlmIChpbmRleCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcXG4gICAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NMSUQsICgpID0+IHRoaXMudG8oaW5kZXgpKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKGFjdGl2ZUluZGV4ID09PSBpbmRleCkge1xcbiAgICAgIHRoaXMucGF1c2UoKTtcXG4gICAgICB0aGlzLmN5Y2xlKCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IG9yZGVyID0gaW5kZXggPiBhY3RpdmVJbmRleCA/IE9SREVSX05FWFQgOiBPUkRFUl9QUkVWO1xcblxcbiAgICB0aGlzLl9zbGlkZShvcmRlciwgdGhpcy5faXRlbXNbaW5kZXhdKTtcXG4gIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgY29uZmlnID0geyAuLi5EZWZhdWx0JDksXFxuICAgICAgLi4uY29uZmlnXFxuICAgIH07XFxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FJGEsIGNvbmZpZywgRGVmYXVsdFR5cGUkOSk7XFxuICAgIHJldHVybiBjb25maWc7XFxuICB9XFxuXFxuICBfaGFuZGxlU3dpcGUoKSB7XFxuICAgIGNvbnN0IGFic0RlbHRheCA9IE1hdGguYWJzKHRoaXMudG91Y2hEZWx0YVgpO1xcblxcbiAgICBpZiAoYWJzRGVsdGF4IDw9IFNXSVBFX1RIUkVTSE9MRCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBhYnNEZWx0YXggLyB0aGlzLnRvdWNoRGVsdGFYO1xcbiAgICB0aGlzLnRvdWNoRGVsdGFYID0gMDtcXG5cXG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fc2xpZGUoZGlyZWN0aW9uID4gMCA/IERJUkVDVElPTl9SSUdIVCA6IERJUkVDVElPTl9MRUZUKTtcXG4gIH1cXG5cXG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRUVOVEVSLCBldmVudCA9PiB0aGlzLnBhdXNlKGV2ZW50KSk7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFTEVBVkUsIGV2ZW50ID0+IHRoaXMuY3ljbGUoZXZlbnQpKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5fY29uZmlnLnRvdWNoICYmIHRoaXMuX3RvdWNoU3VwcG9ydGVkKSB7XFxuICAgICAgdGhpcy5fYWRkVG91Y2hFdmVudExpc3RlbmVycygpO1xcbiAgICB9XFxuICB9XFxuXFxuICBfYWRkVG91Y2hFdmVudExpc3RlbmVycygpIHtcXG4gICAgY29uc3Qgc3RhcnQgPSBldmVudCA9PiB7XFxuICAgICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCAmJiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9QRU4gfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9UT1VDSCkpIHtcXG4gICAgICAgIHRoaXMudG91Y2hTdGFydFggPSBldmVudC5jbGllbnRYO1xcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3BvaW50ZXJFdmVudCkge1xcbiAgICAgICAgdGhpcy50b3VjaFN0YXJ0WCA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WDtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGNvbnN0IG1vdmUgPSBldmVudCA9PiB7XFxuICAgICAgLy8gZW5zdXJlIHN3aXBpbmcgd2l0aCBvbmUgdG91Y2ggYW5kIG5vdCBwaW5jaGluZ1xcbiAgICAgIHRoaXMudG91Y2hEZWx0YVggPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSA/IDAgOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYO1xcbiAgICB9O1xcblxcbiAgICBjb25zdCBlbmQgPSBldmVudCA9PiB7XFxuICAgICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCAmJiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9QRU4gfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9UT1VDSCkpIHtcXG4gICAgICAgIHRoaXMudG91Y2hEZWx0YVggPSBldmVudC5jbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0WDtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5faGFuZGxlU3dpcGUoKTtcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlID09PSAnaG92ZXInKSB7XFxuICAgICAgICAvLyBJZiBpdCdzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2UsIG1vdXNlZW50ZXIvbGVhdmUgYXJlIGZpcmVkIGFzXFxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSBtb3VzZSBjb21wYXRpYmlsaXR5IGV2ZW50cyBvbiBmaXJzdCB0YXAgLSB0aGUgY2Fyb3VzZWxcXG4gICAgICAgIC8vIHdvdWxkIHN0b3AgY3ljbGluZyB1bnRpbCB1c2VyIHRhcHBlZCBvdXQgb2YgaXQ7XFxuICAgICAgICAvLyBoZXJlLCB3ZSBsaXN0ZW4gZm9yIHRvdWNoZW5kLCBleHBsaWNpdGx5IHBhdXNlIHRoZSBjYXJvdXNlbFxcbiAgICAgICAgLy8gKGFzIGlmIGl0J3MgdGhlIHNlY29uZCB0aW1lIHdlIHRhcCBvbiBpdCwgbW91c2VlbnRlciBjb21wYXQgZXZlbnRcXG4gICAgICAgIC8vIGlzIE5PVCBmaXJlZCkgYW5kIGFmdGVyIGEgdGltZW91dCAodG8gYWxsb3cgZm9yIG1vdXNlIGNvbXBhdGliaWxpdHlcXG4gICAgICAgIC8vIGV2ZW50cyB0byBmaXJlKSB3ZSBleHBsaWNpdGx5IHJlc3RhcnQgY3ljbGluZ1xcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xcblxcbiAgICAgICAgaWYgKHRoaXMudG91Y2hUaW1lb3V0KSB7XFxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRvdWNoVGltZW91dCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoZXZlbnQgPT4gdGhpcy5jeWNsZShldmVudCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNX0lNRywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChpdGVtSW1nID0+IHtcXG4gICAgICBFdmVudEhhbmRsZXIub24oaXRlbUltZywgRVZFTlRfRFJBR19TVEFSVCwgZSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xcbiAgICB9KTtcXG5cXG4gICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCkge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9QT0lOVEVSRE9XTiwgZXZlbnQgPT4gc3RhcnQoZXZlbnQpKTtcXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfUE9JTlRFUlVQLCBldmVudCA9PiBlbmQoZXZlbnQpKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hTVEFSVCwgZXZlbnQgPT4gc3RhcnQoZXZlbnQpKTtcXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hNT1ZFLCBldmVudCA9PiBtb3ZlKGV2ZW50KSk7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIRU5ELCBldmVudCA9PiBlbmQoZXZlbnQpKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgX2tleWRvd24oZXZlbnQpIHtcXG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmIChldmVudC5rZXkgPT09IEFSUk9XX0xFRlRfS0VZKSB7XFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICB0aGlzLl9zbGlkZShESVJFQ1RJT05fUklHSFQpO1xcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfUklHSFRfS0VZKSB7XFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICB0aGlzLl9zbGlkZShESVJFQ1RJT05fTEVGVCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9nZXRJdGVtSW5kZXgoZWxlbWVudCkge1xcbiAgICB0aGlzLl9pdGVtcyA9IGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlID8gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNLCBlbGVtZW50LnBhcmVudE5vZGUpIDogW107XFxuICAgIHJldHVybiB0aGlzLl9pdGVtcy5pbmRleE9mKGVsZW1lbnQpO1xcbiAgfVxcblxcbiAgX2dldEl0ZW1CeU9yZGVyKG9yZGVyLCBhY3RpdmVFbGVtZW50KSB7XFxuICAgIGNvbnN0IGlzTmV4dCA9IG9yZGVyID09PSBPUkRFUl9ORVhUO1xcbiAgICBjb25zdCBpc1ByZXYgPSBvcmRlciA9PT0gT1JERVJfUFJFVjtcXG5cXG4gICAgY29uc3QgYWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCk7XFxuXFxuICAgIGNvbnN0IGxhc3RJdGVtSW5kZXggPSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxO1xcbiAgICBjb25zdCBpc0dvaW5nVG9XcmFwID0gaXNQcmV2ICYmIGFjdGl2ZUluZGV4ID09PSAwIHx8IGlzTmV4dCAmJiBhY3RpdmVJbmRleCA9PT0gbGFzdEl0ZW1JbmRleDtcXG5cXG4gICAgaWYgKGlzR29pbmdUb1dyYXAgJiYgIXRoaXMuX2NvbmZpZy53cmFwKSB7XFxuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZGVsdGEgPSBpc1ByZXYgPyAtMSA6IDE7XFxuICAgIGNvbnN0IGl0ZW1JbmRleCA9IChhY3RpdmVJbmRleCArIGRlbHRhKSAlIHRoaXMuX2l0ZW1zLmxlbmd0aDtcXG4gICAgcmV0dXJuIGl0ZW1JbmRleCA9PT0gLTEgPyB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXSA6IHRoaXMuX2l0ZW1zW2l0ZW1JbmRleF07XFxuICB9XFxuXFxuICBfdHJpZ2dlclNsaWRlRXZlbnQocmVsYXRlZFRhcmdldCwgZXZlbnREaXJlY3Rpb25OYW1lKSB7XFxuICAgIGNvbnN0IHRhcmdldEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHJlbGF0ZWRUYXJnZXQpO1xcblxcbiAgICBjb25zdCBmcm9tSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgoU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9BQ1RJVkVfSVRFTSwgdGhpcy5fZWxlbWVudCkpO1xcblxcbiAgICByZXR1cm4gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0xJREUsIHtcXG4gICAgICByZWxhdGVkVGFyZ2V0LFxcbiAgICAgIGRpcmVjdGlvbjogZXZlbnREaXJlY3Rpb25OYW1lLFxcbiAgICAgIGZyb206IGZyb21JbmRleCxcXG4gICAgICB0bzogdGFyZ2V0SW5kZXhcXG4gICAgfSk7XFxuICB9XFxuXFxuICBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChlbGVtZW50KSB7XFxuICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xcbiAgICAgIGNvbnN0IGFjdGl2ZUluZGljYXRvciA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFJDEsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcXG4gICAgICBhY3RpdmVJbmRpY2F0b3IuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQyKTtcXG4gICAgICBhY3RpdmVJbmRpY2F0b3IucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnKTtcXG4gICAgICBjb25zdCBpbmRpY2F0b3JzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JTkRJQ0FUT1IsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcXG5cXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljYXRvcnMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoaW5kaWNhdG9yc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtc2xpZGUtdG8nKSwgMTApID09PSB0aGlzLl9nZXRJdGVtSW5kZXgoZWxlbWVudCkpIHtcXG4gICAgICAgICAgaW5kaWNhdG9yc1tpXS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDIpO1xcbiAgICAgICAgICBpbmRpY2F0b3JzW2ldLnNldEF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50JywgJ3RydWUnKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBfdXBkYXRlSW50ZXJ2YWwoKSB7XFxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9hY3RpdmVFbGVtZW50IHx8IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFX0lURU0sIHRoaXMuX2VsZW1lbnQpO1xcblxcbiAgICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZWxlbWVudEludGVydmFsID0gTnVtYmVyLnBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLWludGVydmFsJyksIDEwKTtcXG5cXG4gICAgaWYgKGVsZW1lbnRJbnRlcnZhbCkge1xcbiAgICAgIHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgPSB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5pbnRlcnZhbDtcXG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBlbGVtZW50SW50ZXJ2YWw7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWw7XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9zbGlkZShkaXJlY3Rpb25Pck9yZGVyLCBlbGVtZW50KSB7XFxuICAgIGNvbnN0IG9yZGVyID0gdGhpcy5fZGlyZWN0aW9uVG9PcmRlcihkaXJlY3Rpb25Pck9yZGVyKTtcXG5cXG4gICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFX0lURU0sIHRoaXMuX2VsZW1lbnQpO1xcblxcbiAgICBjb25zdCBhY3RpdmVFbGVtZW50SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCk7XFxuXFxuICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCB0aGlzLl9nZXRJdGVtQnlPcmRlcihvcmRlciwgYWN0aXZlRWxlbWVudCk7XFxuXFxuICAgIGNvbnN0IG5leHRFbGVtZW50SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgobmV4dEVsZW1lbnQpO1xcblxcbiAgICBjb25zdCBpc0N5Y2xpbmcgPSBCb29sZWFuKHRoaXMuX2ludGVydmFsKTtcXG4gICAgY29uc3QgaXNOZXh0ID0gb3JkZXIgPT09IE9SREVSX05FWFQ7XFxuICAgIGNvbnN0IGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gaXNOZXh0ID8gQ0xBU1NfTkFNRV9TVEFSVCA6IENMQVNTX05BTUVfRU5EO1xcbiAgICBjb25zdCBvcmRlckNsYXNzTmFtZSA9IGlzTmV4dCA/IENMQVNTX05BTUVfTkVYVCA6IENMQVNTX05BTUVfUFJFVjtcXG5cXG4gICAgY29uc3QgZXZlbnREaXJlY3Rpb25OYW1lID0gdGhpcy5fb3JkZXJUb0RpcmVjdGlvbihvcmRlcik7XFxuXFxuICAgIGlmIChuZXh0RWxlbWVudCAmJiBuZXh0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUkMikpIHtcXG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3Qgc2xpZGVFdmVudCA9IHRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KG5leHRFbGVtZW50LCBldmVudERpcmVjdGlvbk5hbWUpO1xcblxcbiAgICBpZiAoc2xpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAhbmV4dEVsZW1lbnQpIHtcXG4gICAgICAvLyBTb21lIHdlaXJkbmVzcyBpcyBoYXBwZW5pbmcsIHNvIHdlIGJhaWxcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5faXNTbGlkaW5nID0gdHJ1ZTtcXG5cXG4gICAgaWYgKGlzQ3ljbGluZykge1xcbiAgICAgIHRoaXMucGF1c2UoKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50KTtcXG5cXG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG5leHRFbGVtZW50O1xcblxcbiAgICBjb25zdCB0cmlnZ2VyU2xpZEV2ZW50ID0gKCkgPT4ge1xcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NMSUQsIHtcXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG5leHRFbGVtZW50LFxcbiAgICAgICAgZGlyZWN0aW9uOiBldmVudERpcmVjdGlvbk5hbWUsXFxuICAgICAgICBmcm9tOiBhY3RpdmVFbGVtZW50SW5kZXgsXFxuICAgICAgICB0bzogbmV4dEVsZW1lbnRJbmRleFxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBpZiAodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TTElERSkpIHtcXG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKG9yZGVyQ2xhc3NOYW1lKTtcXG4gICAgICByZWZsb3cobmV4dEVsZW1lbnQpO1xcbiAgICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XFxuICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XFxuXFxuICAgICAgY29uc3QgY29tcGxldGVDYWxsQmFjayA9ICgpID0+IHtcXG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoZGlyZWN0aW9uYWxDbGFzc05hbWUsIG9yZGVyQ2xhc3NOYW1lKTtcXG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XFxuICAgICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMiwgb3JkZXJDbGFzc05hbWUsIGRpcmVjdGlvbmFsQ2xhc3NOYW1lKTtcXG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xcbiAgICAgICAgc2V0VGltZW91dCh0cmlnZ2VyU2xpZEV2ZW50LCAwKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsQmFjaywgYWN0aXZlRWxlbWVudCwgdHJ1ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDIpO1xcbiAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XFxuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XFxuICAgICAgdHJpZ2dlclNsaWRFdmVudCgpO1xcbiAgICB9XFxuXFxuICAgIGlmIChpc0N5Y2xpbmcpIHtcXG4gICAgICB0aGlzLmN5Y2xlKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9kaXJlY3Rpb25Ub09yZGVyKGRpcmVjdGlvbikge1xcbiAgICBpZiAoIVtESVJFQ1RJT05fUklHSFQsIERJUkVDVElPTl9MRUZUXS5pbmNsdWRlcyhkaXJlY3Rpb24pKSB7XFxuICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcXG4gICAgfVxcblxcbiAgICBpZiAoaXNSVEwoKSkge1xcbiAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUID8gT1JERVJfUFJFViA6IE9SREVSX05FWFQ7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVjtcXG4gIH1cXG5cXG4gIF9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSB7XFxuICAgIGlmICghW09SREVSX05FWFQsIE9SREVSX1BSRVZdLmluY2x1ZGVzKG9yZGVyKSkge1xcbiAgICAgIHJldHVybiBvcmRlcjtcXG4gICAgfVxcblxcbiAgICBpZiAoaXNSVEwoKSkge1xcbiAgICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9SSUdIVCA6IERJUkVDVElPTl9MRUZUO1xcbiAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gIHN0YXRpYyBjYXJvdXNlbEludGVyZmFjZShlbGVtZW50LCBjb25maWcpIHtcXG4gICAgbGV0IGRhdGEgPSBEYXRhLmdldChlbGVtZW50LCBEQVRBX0tFWSQ5KTtcXG4gICAgbGV0IF9jb25maWcgPSB7IC4uLkRlZmF1bHQkOSxcXG4gICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyhlbGVtZW50KVxcbiAgICB9O1xcblxcbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcpIHtcXG4gICAgICBfY29uZmlnID0geyAuLi5fY29uZmlnLFxcbiAgICAgICAgLi4uY29uZmlnXFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBhY3Rpb24gPSB0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyA/IGNvbmZpZyA6IF9jb25maWcuc2xpZGU7XFxuXFxuICAgIGlmICghZGF0YSkge1xcbiAgICAgIGRhdGEgPSBuZXcgQ2Fyb3VzZWwoZWxlbWVudCwgX2NvbmZpZyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XFxuICAgICAgZGF0YS50byhjb25maWcpO1xcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnKSB7XFxuICAgICAgaWYgKHR5cGVvZiBkYXRhW2FjdGlvbl0gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7YWN0aW9ufVxcXCJgKTtcXG4gICAgICB9XFxuXFxuICAgICAgZGF0YVthY3Rpb25dKCk7XFxuICAgIH0gZWxzZSBpZiAoX2NvbmZpZy5pbnRlcnZhbCAmJiBfY29uZmlnLnJpZGUpIHtcXG4gICAgICBkYXRhLnBhdXNlKCk7XFxuICAgICAgZGF0YS5jeWNsZSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICBDYXJvdXNlbC5jYXJvdXNlbEludGVyZmFjZSh0aGlzLCBjb25maWcpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBkYXRhQXBpQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XFxuICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XFxuXFxuICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQ0FST1VTRUwpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGNvbmZpZyA9IHsgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGFyZ2V0KSxcXG4gICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzKVxcbiAgICB9O1xcbiAgICBjb25zdCBzbGlkZUluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtc2xpZGUtdG8nKTtcXG5cXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcXG4gICAgICBjb25maWcuaW50ZXJ2YWwgPSBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBDYXJvdXNlbC5jYXJvdXNlbEludGVyZmFjZSh0YXJnZXQsIGNvbmZpZyk7XFxuXFxuICAgIGlmIChzbGlkZUluZGV4KSB7XFxuICAgICAgRGF0YS5nZXQodGFyZ2V0LCBEQVRBX0tFWSQ5KS50byhzbGlkZUluZGV4KTtcXG4gICAgfVxcblxcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgfVxcblxcbn1cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcblxcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSwgU0VMRUNUT1JfREFUQV9TTElERSwgQ2Fyb3VzZWwuZGF0YUFwaUNsaWNrSGFuZGxlcik7XFxuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQyLCAoKSA9PiB7XFxuICBjb25zdCBjYXJvdXNlbHMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfUklERSk7XFxuXFxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2Fyb3VzZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgIENhcm91c2VsLmNhcm91c2VsSW50ZXJmYWNlKGNhcm91c2Vsc1tpXSwgRGF0YS5nZXQoY2Fyb3VzZWxzW2ldLCBEQVRBX0tFWSQ5KSk7XFxuICB9XFxufSk7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogalF1ZXJ5XFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogYWRkIC5DYXJvdXNlbCB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxcbiAqL1xcblxcbmRlZmluZUpRdWVyeVBsdWdpbihDYXJvdXNlbCk7XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGNvbGxhcHNlLmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBOQU1FJDkgPSAnY29sbGFwc2UnO1xcbmNvbnN0IERBVEFfS0VZJDggPSAnYnMuY29sbGFwc2UnO1xcbmNvbnN0IEVWRU5UX0tFWSQ4ID0gYC4ke0RBVEFfS0VZJDh9YDtcXG5jb25zdCBEQVRBX0FQSV9LRVkkNSA9ICcuZGF0YS1hcGknO1xcbmNvbnN0IERlZmF1bHQkOCA9IHtcXG4gIHRvZ2dsZTogdHJ1ZSxcXG4gIHBhcmVudDogJydcXG59O1xcbmNvbnN0IERlZmF1bHRUeXBlJDggPSB7XFxuICB0b2dnbGU6ICdib29sZWFuJyxcXG4gIHBhcmVudDogJyhzdHJpbmd8ZWxlbWVudCknXFxufTtcXG5jb25zdCBFVkVOVF9TSE9XJDUgPSBgc2hvdyR7RVZFTlRfS0VZJDh9YDtcXG5jb25zdCBFVkVOVF9TSE9XTiQ1ID0gYHNob3duJHtFVkVOVF9LRVkkOH1gO1xcbmNvbnN0IEVWRU5UX0hJREUkNSA9IGBoaWRlJHtFVkVOVF9LRVkkOH1gO1xcbmNvbnN0IEVWRU5UX0hJRERFTiQ1ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDh9YDtcXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ0ID0gYGNsaWNrJHtFVkVOVF9LRVkkOH0ke0RBVEFfQVBJX0tFWSQ1fWA7XFxuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDggPSAnc2hvdyc7XFxuY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRSA9ICdjb2xsYXBzZSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTSU5HID0gJ2NvbGxhcHNpbmcnO1xcbmNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0VEID0gJ2NvbGxhcHNlZCc7XFxuY29uc3QgV0lEVEggPSAnd2lkdGgnO1xcbmNvbnN0IEhFSUdIVCA9ICdoZWlnaHQnO1xcbmNvbnN0IFNFTEVDVE9SX0FDVElWRVMgPSAnLnNob3csIC5jb2xsYXBzaW5nJztcXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0ID0gJ1tkYXRhLWJzLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiXSc7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIENvbGxhcHNlIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XFxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgc3VwZXIoZWxlbWVudCk7XFxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgdGhpcy5fdHJpZ2dlckFycmF5ID0gU2VsZWN0b3JFbmdpbmUuZmluZChgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0fVtocmVmPVxcXCIjJHt0aGlzLl9lbGVtZW50LmlkfVxcXCJdLGAgKyBgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0fVtkYXRhLWJzLXRhcmdldD1cXFwiIyR7dGhpcy5fZWxlbWVudC5pZH1cXFwiXWApO1xcbiAgICBjb25zdCB0b2dnbGVMaXN0ID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0KTtcXG5cXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRvZ2dsZUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICBjb25zdCBlbGVtID0gdG9nZ2xlTGlzdFtpXTtcXG4gICAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbSk7XFxuICAgICAgY29uc3QgZmlsdGVyRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpLmZpbHRlcihmb3VuZEVsZW0gPT4gZm91bmRFbGVtID09PSB0aGlzLl9lbGVtZW50KTtcXG5cXG4gICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwgJiYgZmlsdGVyRWxlbWVudC5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7XFxuXFxuICAgICAgICB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChlbGVtKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fY29uZmlnLnBhcmVudCA/IHRoaXMuX2dldFBhcmVudCgpIDogbnVsbDtcXG5cXG4gICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XFxuICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3RyaWdnZXJBcnJheSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcXG4gICAgICB0aGlzLnRvZ2dsZSgpO1xcbiAgICB9XFxuICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgcmV0dXJuIERlZmF1bHQkODtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgcmV0dXJuIE5BTUUkOTtcXG4gIH0gLy8gUHVibGljXFxuXFxuXFxuICB0b2dnbGUoKSB7XFxuICAgIGlmICh0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckOCkpIHtcXG4gICAgICB0aGlzLmhpZGUoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLnNob3coKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgc2hvdygpIHtcXG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckOCkpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgbGV0IGFjdGl2ZXM7XFxuICAgIGxldCBhY3RpdmVzRGF0YTtcXG5cXG4gICAgaWYgKHRoaXMuX3BhcmVudCkge1xcbiAgICAgIGFjdGl2ZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0FDVElWRVMsIHRoaXMuX3BhcmVudCkuZmlsdGVyKGVsZW0gPT4ge1xcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucGFyZW50ID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtcGFyZW50JykgPT09IHRoaXMuX2NvbmZpZy5wYXJlbnQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9DT0xMQVBTRSk7XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICBhY3RpdmVzID0gbnVsbDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgY29uc3QgY29udGFpbmVyID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZSh0aGlzLl9zZWxlY3Rvcik7XFxuXFxuICAgIGlmIChhY3RpdmVzKSB7XFxuICAgICAgY29uc3QgdGVtcEFjdGl2ZURhdGEgPSBhY3RpdmVzLmZpbmQoZWxlbSA9PiBjb250YWluZXIgIT09IGVsZW0pO1xcbiAgICAgIGFjdGl2ZXNEYXRhID0gdGVtcEFjdGl2ZURhdGEgPyBEYXRhLmdldCh0ZW1wQWN0aXZlRGF0YSwgREFUQV9LRVkkOCkgOiBudWxsO1xcblxcbiAgICAgIGlmIChhY3RpdmVzRGF0YSAmJiBhY3RpdmVzRGF0YS5faXNUcmFuc2l0aW9uaW5nKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDUpO1xcblxcbiAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmIChhY3RpdmVzKSB7XFxuICAgICAgYWN0aXZlcy5mb3JFYWNoKGVsZW1BY3RpdmUgPT4ge1xcbiAgICAgICAgaWYgKGNvbnRhaW5lciAhPT0gZWxlbUFjdGl2ZSkge1xcbiAgICAgICAgICBDb2xsYXBzZS5jb2xsYXBzZUludGVyZmFjZShlbGVtQWN0aXZlLCAnaGlkZScpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFhY3RpdmVzRGF0YSkge1xcbiAgICAgICAgICBEYXRhLnNldChlbGVtQWN0aXZlLCBEQVRBX0tFWSQ4LCBudWxsKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcXG5cXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcXG5cXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gMDtcXG5cXG4gICAgaWYgKHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGgpIHtcXG4gICAgICB0aGlzLl90cmlnZ2VyQXJyYXkuZm9yRWFjaChlbGVtZW50ID0+IHtcXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNFRCk7XFxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKTtcXG5cXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0UsIENMQVNTX05BTUVfU0hPVyQ4KTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJztcXG4gICAgICB0aGlzLnNldFRyYW5zaXRpb25pbmcoZmFsc2UpO1xcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDUpO1xcbiAgICB9O1xcblxcbiAgICBjb25zdCBjYXBpdGFsaXplZERpbWVuc2lvbiA9IGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpO1xcbiAgICBjb25zdCBzY3JvbGxTaXplID0gYHNjcm9sbCR7Y2FwaXRhbGl6ZWREaW1lbnNpb259YDtcXG5cXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IGAke3RoaXMuX2VsZW1lbnRbc2Nyb2xsU2l6ZV19cHhgO1xcbiAgfVxcblxcbiAgaGlkZSgpIHtcXG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAhdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDgpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDUpO1xcblxcbiAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbWVuc2lvbl19cHhgO1xcbiAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XJDgpO1xcblxcbiAgICBjb25zdCB0cmlnZ2VyQXJyYXlMZW5ndGggPSB0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoO1xcblxcbiAgICBpZiAodHJpZ2dlckFycmF5TGVuZ3RoID4gMCkge1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpZ2dlckFycmF5TGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGNvbnN0IHRyaWdnZXIgPSB0aGlzLl90cmlnZ2VyQXJyYXlbaV07XFxuICAgICAgICBjb25zdCBlbGVtID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0cmlnZ2VyKTtcXG5cXG4gICAgICAgIGlmIChlbGVtICYmICFlbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckOCkpIHtcXG4gICAgICAgICAgdHJpZ2dlci5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0VEKTtcXG4gICAgICAgICAgdHJpZ2dlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKTtcXG5cXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XFxuICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKGZhbHNlKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRSk7XFxuXFxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDUpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJztcXG5cXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XFxuICB9XFxuXFxuICBzZXRUcmFuc2l0aW9uaW5nKGlzVHJhbnNpdGlvbmluZykge1xcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBpc1RyYW5zaXRpb25pbmc7XFxuICB9IC8vIFByaXZhdGVcXG5cXG5cXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XFxuICAgIGNvbmZpZyA9IHsgLi4uRGVmYXVsdCQ4LFxcbiAgICAgIC4uLmNvbmZpZ1xcbiAgICB9O1xcbiAgICBjb25maWcudG9nZ2xlID0gQm9vbGVhbihjb25maWcudG9nZ2xlKTsgLy8gQ29lcmNlIHN0cmluZyB2YWx1ZXNcXG5cXG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUkOSwgY29uZmlnLCBEZWZhdWx0VHlwZSQ4KTtcXG4gICAgcmV0dXJuIGNvbmZpZztcXG4gIH1cXG5cXG4gIF9nZXREaW1lbnNpb24oKSB7XFxuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhXSURUSCkgPyBXSURUSCA6IEhFSUdIVDtcXG4gIH1cXG5cXG4gIF9nZXRQYXJlbnQoKSB7XFxuICAgIGxldCB7XFxuICAgICAgcGFyZW50XFxuICAgIH0gPSB0aGlzLl9jb25maWc7XFxuICAgIHBhcmVudCA9IGdldEVsZW1lbnQocGFyZW50KTtcXG4gICAgY29uc3Qgc2VsZWN0b3IgPSBgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0fVtkYXRhLWJzLXBhcmVudD1cXFwiJHtwYXJlbnR9XFxcIl1gO1xcbiAgICBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yLCBwYXJlbnQpLmZvckVhY2goZWxlbWVudCA9PiB7XFxuICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpO1xcblxcbiAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhzZWxlY3RlZCwgW2VsZW1lbnRdKTtcXG4gICAgfSk7XFxuICAgIHJldHVybiBwYXJlbnQ7XFxuICB9XFxuXFxuICBfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKGVsZW1lbnQsIHRyaWdnZXJBcnJheSkge1xcbiAgICBpZiAoIWVsZW1lbnQgfHwgIXRyaWdnZXJBcnJheS5sZW5ndGgpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgaXNPcGVuID0gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDgpO1xcbiAgICB0cmlnZ2VyQXJyYXkuZm9yRWFjaChlbGVtID0+IHtcXG4gICAgICBpZiAoaXNPcGVuKSB7XFxuICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRUQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBlbGVtLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRUQpO1xcbiAgICAgIH1cXG5cXG4gICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGlzT3Blbik7XFxuICAgIH0pO1xcbiAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gIHN0YXRpYyBjb2xsYXBzZUludGVyZmFjZShlbGVtZW50LCBjb25maWcpIHtcXG4gICAgbGV0IGRhdGEgPSBEYXRhLmdldChlbGVtZW50LCBEQVRBX0tFWSQ4KTtcXG4gICAgY29uc3QgX2NvbmZpZyA9IHsgLi4uRGVmYXVsdCQ4LFxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpLFxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcXG4gICAgfTtcXG5cXG4gICAgaWYgKCFkYXRhICYmIF9jb25maWcudG9nZ2xlICYmIHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xcbiAgICAgIF9jb25maWcudG9nZ2xlID0gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgaWYgKCFkYXRhKSB7XFxuICAgICAgZGF0YSA9IG5ldyBDb2xsYXBzZShlbGVtZW50LCBfY29uZmlnKTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcXFwiJHtjb25maWd9XFxcImApO1xcbiAgICAgIH1cXG5cXG4gICAgICBkYXRhW2NvbmZpZ10oKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgQ29sbGFwc2UuY29sbGFwc2VJbnRlcmZhY2UodGhpcywgY29uZmlnKTtcXG4gICAgfSk7XFxuICB9XFxuXFxufVxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuXFxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ0LCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0LCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gIC8vIHByZXZlbnREZWZhdWx0IG9ubHkgZm9yIDxhPiBlbGVtZW50cyAod2hpY2ggY2hhbmdlIHRoZSBVUkwpIG5vdCBpbnNpZGUgdGhlIGNvbGxhcHNpYmxlIGVsZW1lbnRcXG4gIGlmIChldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0EnIHx8IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmIGV2ZW50LmRlbGVnYXRlVGFyZ2V0LnRhZ05hbWUgPT09ICdBJykge1xcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgfVxcblxcbiAgY29uc3QgdHJpZ2dlckRhdGEgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzKTtcXG4gIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtcXG4gIGNvbnN0IHNlbGVjdG9yRWxlbWVudHMgPSBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yKTtcXG4gIHNlbGVjdG9yRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcXG4gICAgY29uc3QgZGF0YSA9IERhdGEuZ2V0KGVsZW1lbnQsIERBVEFfS0VZJDgpO1xcbiAgICBsZXQgY29uZmlnO1xcblxcbiAgICBpZiAoZGF0YSkge1xcbiAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgYXR0cmlidXRlXFxuICAgICAgaWYgKGRhdGEuX3BhcmVudCA9PT0gbnVsbCAmJiB0eXBlb2YgdHJpZ2dlckRhdGEucGFyZW50ID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgZGF0YS5fY29uZmlnLnBhcmVudCA9IHRyaWdnZXJEYXRhLnBhcmVudDtcXG4gICAgICAgIGRhdGEuX3BhcmVudCA9IGRhdGEuX2dldFBhcmVudCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25maWcgPSAndG9nZ2xlJztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjb25maWcgPSB0cmlnZ2VyRGF0YTtcXG4gICAgfVxcblxcbiAgICBDb2xsYXBzZS5jb2xsYXBzZUludGVyZmFjZShlbGVtZW50LCBjb25maWcpO1xcbiAgfSk7XFxufSk7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogalF1ZXJ5XFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogYWRkIC5Db2xsYXBzZSB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxcbiAqL1xcblxcbmRlZmluZUpRdWVyeVBsdWdpbihDb2xsYXBzZSk7XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGRyb3Bkb3duLmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBOQU1FJDggPSAnZHJvcGRvd24nO1xcbmNvbnN0IERBVEFfS0VZJDcgPSAnYnMuZHJvcGRvd24nO1xcbmNvbnN0IEVWRU5UX0tFWSQ3ID0gYC4ke0RBVEFfS0VZJDd9YDtcXG5jb25zdCBEQVRBX0FQSV9LRVkkNCA9ICcuZGF0YS1hcGknO1xcbmNvbnN0IEVTQ0FQRV9LRVkkMiA9ICdFc2NhcGUnO1xcbmNvbnN0IFNQQUNFX0tFWSA9ICdTcGFjZSc7XFxuY29uc3QgVEFCX0tFWSA9ICdUYWInO1xcbmNvbnN0IEFSUk9XX1VQX0tFWSA9ICdBcnJvd1VwJztcXG5jb25zdCBBUlJPV19ET1dOX0tFWSA9ICdBcnJvd0Rvd24nO1xcbmNvbnN0IFJJR0hUX01PVVNFX0JVVFRPTiA9IDI7IC8vIE1vdXNlRXZlbnQuYnV0dG9uIHZhbHVlIGZvciB0aGUgc2Vjb25kYXJ5IGJ1dHRvbiwgdXN1YWxseSB0aGUgcmlnaHQgYnV0dG9uXFxuXFxuY29uc3QgUkVHRVhQX0tFWURPV04gPSBuZXcgUmVnRXhwKGAke0FSUk9XX1VQX0tFWX18JHtBUlJPV19ET1dOX0tFWX18JHtFU0NBUEVfS0VZJDJ9YCk7XFxuY29uc3QgRVZFTlRfSElERSQ0ID0gYGhpZGUke0VWRU5UX0tFWSQ3fWA7XFxuY29uc3QgRVZFTlRfSElEREVOJDQgPSBgaGlkZGVuJHtFVkVOVF9LRVkkN31gO1xcbmNvbnN0IEVWRU5UX1NIT1ckNCA9IGBzaG93JHtFVkVOVF9LRVkkN31gO1xcbmNvbnN0IEVWRU5UX1NIT1dOJDQgPSBgc2hvd24ke0VWRU5UX0tFWSQ3fWA7XFxuY29uc3QgRVZFTlRfQ0xJQ0sgPSBgY2xpY2ske0VWRU5UX0tFWSQ3fWA7XFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMyA9IGBjbGljayR7RVZFTlRfS0VZJDd9JHtEQVRBX0FQSV9LRVkkNH1gO1xcbmNvbnN0IEVWRU5UX0tFWURPV05fREFUQV9BUEkgPSBga2V5ZG93biR7RVZFTlRfS0VZJDd9JHtEQVRBX0FQSV9LRVkkNH1gO1xcbmNvbnN0IEVWRU5UX0tFWVVQX0RBVEFfQVBJID0gYGtleXVwJHtFVkVOVF9LRVkkN30ke0RBVEFfQVBJX0tFWSQ0fWA7XFxuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDcgPSAnc2hvdyc7XFxuY29uc3QgQ0xBU1NfTkFNRV9EUk9QVVAgPSAnZHJvcHVwJztcXG5jb25zdCBDTEFTU19OQU1FX0RST1BFTkQgPSAnZHJvcGVuZCc7XFxuY29uc3QgQ0xBU1NfTkFNRV9EUk9QU1RBUlQgPSAnZHJvcHN0YXJ0JztcXG5jb25zdCBDTEFTU19OQU1FX05BVkJBUiA9ICduYXZiYXInO1xcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMgPSAnW2RhdGEtYnMtdG9nZ2xlPVxcXCJkcm9wZG93blxcXCJdJztcXG5jb25zdCBTRUxFQ1RPUl9NRU5VID0gJy5kcm9wZG93bi1tZW51JztcXG5jb25zdCBTRUxFQ1RPUl9OQVZCQVJfTkFWID0gJy5uYXZiYXItbmF2JztcXG5jb25zdCBTRUxFQ1RPUl9WSVNJQkxFX0lURU1TID0gJy5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJztcXG5jb25zdCBQTEFDRU1FTlRfVE9QID0gaXNSVEwoKSA/ICd0b3AtZW5kJyA6ICd0b3Atc3RhcnQnO1xcbmNvbnN0IFBMQUNFTUVOVF9UT1BFTkQgPSBpc1JUTCgpID8gJ3RvcC1zdGFydCcgOiAndG9wLWVuZCc7XFxuY29uc3QgUExBQ0VNRU5UX0JPVFRPTSA9IGlzUlRMKCkgPyAnYm90dG9tLWVuZCcgOiAnYm90dG9tLXN0YXJ0JztcXG5jb25zdCBQTEFDRU1FTlRfQk9UVE9NRU5EID0gaXNSVEwoKSA/ICdib3R0b20tc3RhcnQnIDogJ2JvdHRvbS1lbmQnO1xcbmNvbnN0IFBMQUNFTUVOVF9SSUdIVCA9IGlzUlRMKCkgPyAnbGVmdC1zdGFydCcgOiAncmlnaHQtc3RhcnQnO1xcbmNvbnN0IFBMQUNFTUVOVF9MRUZUID0gaXNSVEwoKSA/ICdyaWdodC1zdGFydCcgOiAnbGVmdC1zdGFydCc7XFxuY29uc3QgRGVmYXVsdCQ3ID0ge1xcbiAgb2Zmc2V0OiBbMCwgMl0sXFxuICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXFxuICByZWZlcmVuY2U6ICd0b2dnbGUnLFxcbiAgZGlzcGxheTogJ2R5bmFtaWMnLFxcbiAgcG9wcGVyQ29uZmlnOiBudWxsLFxcbiAgYXV0b0Nsb3NlOiB0cnVlXFxufTtcXG5jb25zdCBEZWZhdWx0VHlwZSQ3ID0ge1xcbiAgb2Zmc2V0OiAnKGFycmF5fHN0cmluZ3xmdW5jdGlvbiknLFxcbiAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcXG4gIHJlZmVyZW5jZTogJyhzdHJpbmd8ZWxlbWVudHxvYmplY3QpJyxcXG4gIGRpc3BsYXk6ICdzdHJpbmcnLFxcbiAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0fGZ1bmN0aW9uKScsXFxuICBhdXRvQ2xvc2U6ICcoYm9vbGVhbnxzdHJpbmcpJ1xcbn07XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIERyb3Bkb3duIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XFxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgc3VwZXIoZWxlbWVudCk7XFxuICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XFxuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xcbiAgICB0aGlzLl9tZW51ID0gdGhpcy5fZ2V0TWVudUVsZW1lbnQoKTtcXG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcXG5cXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcXG4gIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xcbiAgICByZXR1cm4gRGVmYXVsdCQ3O1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcXG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDc7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgIHJldHVybiBOQU1FJDg7XFxuICB9IC8vIFB1YmxpY1xcblxcblxcbiAgdG9nZ2xlKCkge1xcbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzLl9lbGVtZW50KSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ3KTtcXG5cXG4gICAgaWYgKGlzQWN0aXZlKSB7XFxuICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuc2hvdygpO1xcbiAgfVxcblxcbiAgc2hvdygpIHtcXG4gICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgdGhpcy5fbWVudS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDcpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHBhcmVudCA9IERyb3Bkb3duLmdldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xcbiAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcXG4gICAgfTtcXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ0LCByZWxhdGVkVGFyZ2V0KTtcXG5cXG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9IC8vIFRvdGFsbHkgZGlzYWJsZSBQb3BwZXIgZm9yIERyb3Bkb3ducyBpbiBOYXZiYXJcXG5cXG5cXG4gICAgaWYgKHRoaXMuX2luTmF2YmFyKSB7XFxuICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJywgJ25vbmUnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAodHlwZW9mIF9wb3BwZXJqc19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXFxcJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGxldCByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ3BhcmVudCcpIHtcXG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBwYXJlbnQ7XFxuICAgICAgfSBlbHNlIGlmIChpc0VsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkpIHtcXG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBnZXRFbGVtZW50KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpO1xcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZTtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgcG9wcGVyQ29uZmlnID0gdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCk7XFxuXFxuICAgICAgY29uc3QgaXNEaXNwbGF5U3RhdGljID0gcG9wcGVyQ29uZmlnLm1vZGlmaWVycy5maW5kKG1vZGlmaWVyID0+IG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlcycgJiYgbW9kaWZpZXIuZW5hYmxlZCA9PT0gZmFsc2UpO1xcbiAgICAgIHRoaXMuX3BvcHBlciA9IF9wb3BwZXJqc19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImNyZWF0ZVBvcHBlclxcXCJdKHJlZmVyZW5jZUVsZW1lbnQsIHRoaXMuX21lbnUsIHBvcHBlckNvbmZpZyk7XFxuXFxuICAgICAgaWYgKGlzRGlzcGxheVN0YXRpYykge1xcbiAgICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJywgJ3N0YXRpYycpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXFxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XFxuICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXFxuICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxcblxcblxcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICFwYXJlbnQuY2xvc2VzdChTRUxFQ1RPUl9OQVZCQVJfTkFWKSkge1xcbiAgICAgIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKGVsZW0gPT4gRXZlbnRIYW5kbGVyLm9uKGVsZW0sICdtb3VzZW92ZXInLCBub29wKSk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xcblxcbiAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfTkFNRV9TSE9XJDcpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfTkFNRV9TSE9XJDcpO1xcblxcbiAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQ0LCByZWxhdGVkVGFyZ2V0KTtcXG4gIH1cXG5cXG4gIGhpZGUoKSB7XFxuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8ICF0aGlzLl9tZW51LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckNykpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcXG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KTtcXG4gIH1cXG5cXG4gIGRpc3Bvc2UoKSB7XFxuICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcXG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xcbiAgICB9XFxuXFxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcXG4gIH1cXG5cXG4gIHVwZGF0ZSgpIHtcXG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcXG5cXG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xcbiAgICAgIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcXG4gICAgfVxcbiAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XFxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDSywgZXZlbnQgPT4ge1xcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgdGhpcy50b2dnbGUoKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBfY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ0LCByZWxhdGVkVGFyZ2V0KTtcXG5cXG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXFxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XFxuXFxuXFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcXG4gICAgICBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaChlbGVtID0+IEV2ZW50SGFuZGxlci5vZmYoZWxlbSwgJ21vdXNlb3ZlcicsIG5vb3ApKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XFxuICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDcpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDcpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xcblxcbiAgICBNYW5pcHVsYXRvci5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInKTtcXG4gICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDQsIHJlbGF0ZWRUYXJnZXQpO1xcbiAgfVxcblxcbiAgX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgY29uZmlnID0geyAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXFxuICAgICAgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXFxuICAgICAgLi4uY29uZmlnXFxuICAgIH07XFxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FJDgsIGNvbmZpZywgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSk7XFxuXFxuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgIWlzRWxlbWVudChjb25maWcucmVmZXJlbmNlKSAmJiB0eXBlb2YgY29uZmlnLnJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAvLyBQb3BwZXIgdmlydHVhbCBlbGVtZW50cyByZXF1aXJlIGEgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG1ldGhvZFxcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7TkFNRSQ4LnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXFxcInJlZmVyZW5jZVxcXCIgcHJvdmlkZWQgdHlwZSBcXFwib2JqZWN0XFxcIiB3aXRob3V0IGEgcmVxdWlyZWQgXFxcImdldEJvdW5kaW5nQ2xpZW50UmVjdFxcXCIgbWV0aG9kLmApO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBjb25maWc7XFxuICB9XFxuXFxuICBfZ2V0TWVudUVsZW1lbnQoKSB7XFxuICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5uZXh0KHRoaXMuX2VsZW1lbnQsIFNFTEVDVE9SX01FTlUpWzBdO1xcbiAgfVxcblxcbiAgX2dldFBsYWNlbWVudCgpIHtcXG4gICAgY29uc3QgcGFyZW50RHJvcGRvd24gPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7XFxuXFxuICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRU5EKSkge1xcbiAgICAgIHJldHVybiBQTEFDRU1FTlRfUklHSFQ7XFxuICAgIH1cXG5cXG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BTVEFSVCkpIHtcXG4gICAgICByZXR1cm4gUExBQ0VNRU5UX0xFRlQ7XFxuICAgIH0gLy8gV2UgbmVlZCB0byB0cmltIHRoZSB2YWx1ZSBiZWNhdXNlIGN1c3RvbSBwcm9wZXJ0aWVzIGNhbiBhbHNvIGluY2x1ZGUgc3BhY2VzXFxuXFxuXFxuICAgIGNvbnN0IGlzRW5kID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZW51KS5nZXRQcm9wZXJ0eVZhbHVlKCctLWJzLXBvc2l0aW9uJykudHJpbSgpID09PSAnZW5kJztcXG5cXG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BVUCkpIHtcXG4gICAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfVE9QRU5EIDogUExBQ0VNRU5UX1RPUDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfQk9UVE9NRU5EIDogUExBQ0VNRU5UX0JPVFRPTTtcXG4gIH1cXG5cXG4gIF9kZXRlY3ROYXZiYXIoKSB7XFxuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoYC4ke0NMQVNTX05BTUVfTkFWQkFSfWApICE9PSBudWxsO1xcbiAgfVxcblxcbiAgX2dldE9mZnNldCgpIHtcXG4gICAgY29uc3Qge1xcbiAgICAgIG9mZnNldFxcbiAgICB9ID0gdGhpcy5fY29uZmlnO1xcblxcbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICByZXR1cm4gb2Zmc2V0LnNwbGl0KCcsJykubWFwKHZhbCA9PiBOdW1iZXIucGFyc2VJbnQodmFsLCAxMCkpO1xcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgcmV0dXJuIHBvcHBlckRhdGEgPT4gb2Zmc2V0KHBvcHBlckRhdGEsIHRoaXMuX2VsZW1lbnQpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBvZmZzZXQ7XFxuICB9XFxuXFxuICBfZ2V0UG9wcGVyQ29uZmlnKCkge1xcbiAgICBjb25zdCBkZWZhdWx0QnNQb3BwZXJDb25maWcgPSB7XFxuICAgICAgcGxhY2VtZW50OiB0aGlzLl9nZXRQbGFjZW1lbnQoKSxcXG4gICAgICBtb2RpZmllcnM6IFt7XFxuICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcXG4gICAgICAgIG9wdGlvbnM6IHtcXG4gICAgICAgICAgYm91bmRhcnk6IHRoaXMuX2NvbmZpZy5ib3VuZGFyeVxcbiAgICAgICAgfVxcbiAgICAgIH0sIHtcXG4gICAgICAgIG5hbWU6ICdvZmZzZXQnLFxcbiAgICAgICAgb3B0aW9uczoge1xcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXFxuICAgICAgICB9XFxuICAgICAgfV1cXG4gICAgfTsgLy8gRGlzYWJsZSBQb3BwZXIgaWYgd2UgaGF2ZSBhIHN0YXRpYyBkaXNwbGF5XFxuXFxuICAgIGlmICh0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcXG4gICAgICBkZWZhdWx0QnNQb3BwZXJDb25maWcubW9kaWZpZXJzID0gW3tcXG4gICAgICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXFxuICAgICAgICBlbmFibGVkOiBmYWxzZVxcbiAgICAgIH1dO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB7IC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcXG4gICAgICAuLi4odHlwZW9mIHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGRlZmF1bHRCc1BvcHBlckNvbmZpZykgOiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKVxcbiAgICB9O1xcbiAgfVxcblxcbiAgX3NlbGVjdE1lbnVJdGVtKGV2ZW50KSB7XFxuICAgIGNvbnN0IGl0ZW1zID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9WSVNJQkxFX0lURU1TLCB0aGlzLl9tZW51KS5maWx0ZXIoaXNWaXNpYmxlKTtcXG5cXG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgbGV0IGluZGV4ID0gaXRlbXMuaW5kZXhPZihldmVudC50YXJnZXQpOyAvLyBVcFxcblxcbiAgICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19VUF9LRVkgJiYgaW5kZXggPiAwKSB7XFxuICAgICAgaW5kZXgtLTtcXG4gICAgfSAvLyBEb3duXFxuXFxuXFxuICAgIGlmIChldmVudC5rZXkgPT09IEFSUk9XX0RPV05fS0VZICYmIGluZGV4IDwgaXRlbXMubGVuZ3RoIC0gMSkge1xcbiAgICAgIGluZGV4Kys7XFxuICAgIH0gLy8gaW5kZXggaXMgLTEgaWYgdGhlIGZpcnN0IGtleWRvd24gaXMgYW4gQXJyb3dVcFxcblxcblxcbiAgICBpbmRleCA9IGluZGV4ID09PSAtMSA/IDAgOiBpbmRleDtcXG4gICAgaXRlbXNbaW5kZXhdLmZvY3VzKCk7XFxuICB9IC8vIFN0YXRpY1xcblxcblxcbiAgc3RhdGljIGRyb3Bkb3duSW50ZXJmYWNlKGVsZW1lbnQsIGNvbmZpZykge1xcbiAgICBsZXQgZGF0YSA9IERhdGEuZ2V0KGVsZW1lbnQsIERBVEFfS0VZJDcpO1xcblxcbiAgICBjb25zdCBfY29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsO1xcblxcbiAgICBpZiAoIWRhdGEpIHtcXG4gICAgICBkYXRhID0gbmV3IERyb3Bkb3duKGVsZW1lbnQsIF9jb25maWcpO1xcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xcbiAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFxcXCIke2NvbmZpZ31cXFwiYCk7XFxuICAgICAgfVxcblxcbiAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICBEcm9wZG93bi5kcm9wZG93bkludGVyZmFjZSh0aGlzLCBjb25maWcpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBjbGVhck1lbnVzKGV2ZW50KSB7XFxuICAgIGlmIChldmVudCAmJiAoZXZlbnQuYnV0dG9uID09PSBSSUdIVF9NT1VTRV9CVVRUT04gfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC5rZXkgIT09IFRBQl9LRVkpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHRvZ2dsZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpO1xcblxcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdG9nZ2xlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBEYXRhLmdldCh0b2dnbGVzW2ldLCBEQVRBX0tFWSQ3KTtcXG5cXG4gICAgICBpZiAoIWNvbnRleHQgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gZmFsc2UpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWNvbnRleHQuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ3KSkge1xcbiAgICAgICAgY29udGludWU7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiBjb250ZXh0Ll9lbGVtZW50XFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAoZXZlbnQpIHtcXG4gICAgICAgIGNvbnN0IGNvbXBvc2VkUGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xcbiAgICAgICAgY29uc3QgaXNNZW51VGFyZ2V0ID0gY29tcG9zZWRQYXRoLmluY2x1ZGVzKGNvbnRleHQuX21lbnUpO1xcblxcbiAgICAgICAgaWYgKGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9lbGVtZW50KSB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnaW5zaWRlJyAmJiAhaXNNZW51VGFyZ2V0IHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09ICdvdXRzaWRlJyAmJiBpc01lbnVUYXJnZXQpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9IC8vIFRhYiBuYXZpZ2F0aW9uIHRocm91Z2ggdGhlIGRyb3Bkb3duIG1lbnUgb3IgZXZlbnRzIGZyb20gY29udGFpbmVkIGlucHV0cyBzaG91bGRuJ3QgY2xvc2UgdGhlIG1lbnVcXG5cXG5cXG4gICAgICAgIGlmIChjb250ZXh0Ll9tZW51LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgJiYgKGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ID09PSBUQUJfS0VZIHx8IC9pbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGZvcm0vaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0LmNsaWNrRXZlbnQgPSBldmVudDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgY29udGV4dC5fY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpO1xcbiAgICB9XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0UGFyZW50RnJvbUVsZW1lbnQoZWxlbWVudCkge1xcbiAgICByZXR1cm4gZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSB8fCBlbGVtZW50LnBhcmVudE5vZGU7XFxuICB9XFxuXFxuICBzdGF0aWMgZGF0YUFwaUtleWRvd25IYW5kbGVyKGV2ZW50KSB7XFxuICAgIC8vIElmIG5vdCBpbnB1dC90ZXh0YXJlYTpcXG4gICAgLy8gIC0gQW5kIG5vdCBhIGtleSBpbiBSRUdFWFBfS0VZRE9XTiA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXFxuICAgIC8vIElmIGlucHV0L3RleHRhcmVhOlxcbiAgICAvLyAgLSBJZiBzcGFjZSBrZXkgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxcbiAgICAvLyAgLSBJZiBrZXkgaXMgb3RoZXIgdGhhbiBlc2NhcGVcXG4gICAgLy8gICAgLSBJZiBrZXkgaXMgbm90IHVwIG9yIGRvd24gPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxcbiAgICAvLyAgICAtIElmIHRyaWdnZXIgaW5zaWRlIHRoZSBtZW51ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcXG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpID8gZXZlbnQua2V5ID09PSBTUEFDRV9LRVkgfHwgZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZJDIgJiYgKGV2ZW50LmtleSAhPT0gQVJST1dfRE9XTl9LRVkgJiYgZXZlbnQua2V5ICE9PSBBUlJPV19VUF9LRVkgfHwgZXZlbnQudGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1JfTUVOVSkpIDogIVJFR0VYUF9LRVlET1dOLnRlc3QoZXZlbnQua2V5KSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ3KTtcXG5cXG4gICAgaWYgKCFpc0FjdGl2ZSAmJiBldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkkMikge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXG4gICAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZ2V0VG9nZ2xlQnV0dG9uID0gKCkgPT4gdGhpcy5tYXRjaGVzKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpID8gdGhpcyA6IFNlbGVjdG9yRW5naW5lLnByZXYodGhpcywgU0VMRUNUT1JfREFUQV9UT0dHTEUkMylbMF07XFxuXFxuICAgIGlmIChldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkkMikge1xcbiAgICAgIGdldFRvZ2dsZUJ1dHRvbigpLmZvY3VzKCk7XFxuICAgICAgRHJvcGRvd24uY2xlYXJNZW51cygpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAoIWlzQWN0aXZlICYmIChldmVudC5rZXkgPT09IEFSUk9XX1VQX0tFWSB8fCBldmVudC5rZXkgPT09IEFSUk9XX0RPV05fS0VZKSkge1xcbiAgICAgIGdldFRvZ2dsZUJ1dHRvbigpLmNsaWNrKCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICghaXNBY3RpdmUgfHwgZXZlbnQua2V5ID09PSBTUEFDRV9LRVkpIHtcXG4gICAgICBEcm9wZG93bi5jbGVhck1lbnVzKCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIERyb3Bkb3duLmdldEluc3RhbmNlKGdldFRvZ2dsZUJ1dHRvbigpKS5fc2VsZWN0TWVudUl0ZW0oZXZlbnQpO1xcbiAgfVxcblxcbn1cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcblxcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKTtcXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX01FTlUsIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcik7XFxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQzLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWVVQX0RBVEFfQVBJLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gIERyb3Bkb3duLmRyb3Bkb3duSW50ZXJmYWNlKHRoaXMpO1xcbn0pO1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGpRdWVyeVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGFkZCAuRHJvcGRvd24gdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcXG4gKi9cXG5cXG5kZWZpbmVKUXVlcnlQbHVnaW4oRHJvcGRvd24pO1xcblxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQm9vdHN0cmFwICh2NS4wLjEpOiB1dGlsL3Njcm9sbEJhci5qc1xcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuY29uc3QgU0VMRUNUT1JfRklYRURfQ09OVEVOVCA9ICcuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wJztcXG5jb25zdCBTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCA9ICcuc3RpY2t5LXRvcCc7XFxuXFxuY29uc3QgZ2V0V2lkdGggPSAoKSA9PiB7XFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2lubmVyV2lkdGgjdXNhZ2Vfbm90ZXNcXG4gIGNvbnN0IGRvY3VtZW50V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XFxuICByZXR1cm4gTWF0aC5hYnMod2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudFdpZHRoKTtcXG59O1xcblxcbmNvbnN0IGhpZGUgPSAod2lkdGggPSBnZXRXaWR0aCgpKSA9PiB7XFxuICBfZGlzYWJsZU92ZXJGbG93KCk7IC8vIGdpdmUgcGFkZGluZyB0byBlbGVtZW50IHRvIGJhbGFuY2VzIHRoZSBoaWRkZW4gc2Nyb2xsYmFyIHdpZHRoXFxuXFxuXFxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoJ2JvZHknLCAncGFkZGluZ1JpZ2h0JywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKTsgLy8gdHJpY2s6IFdlIGFkanVzdCBwb3NpdGl2ZSBwYWRkaW5nUmlnaHQgYW5kIG5lZ2F0aXZlIG1hcmdpblJpZ2h0IHRvIHN0aWNreS10b3AgZWxlbWVudHMsIHRvIGtlZXAgc2hvd24gZnVsbHdpZHRoXFxuXFxuXFxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfRklYRURfQ09OVEVOVCwgJ3BhZGRpbmdSaWdodCcsIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgKyB3aWR0aCk7XFxuXFxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsICdtYXJnaW5SaWdodCcsIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgLSB3aWR0aCk7XFxufTtcXG5cXG5jb25zdCBfZGlzYWJsZU92ZXJGbG93ID0gKCkgPT4ge1xcbiAgY29uc3QgYWN0dWFsVmFsdWUgPSBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93O1xcblxcbiAgaWYgKGFjdHVhbFZhbHVlKSB7XFxuICAgIE1hbmlwdWxhdG9yLnNldERhdGFBdHRyaWJ1dGUoZG9jdW1lbnQuYm9keSwgJ292ZXJmbG93JywgYWN0dWFsVmFsdWUpO1xcbiAgfVxcblxcbiAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xcbn07XFxuXFxuY29uc3QgX3NldEVsZW1lbnRBdHRyaWJ1dGVzID0gKHNlbGVjdG9yLCBzdHlsZVByb3AsIGNhbGxiYWNrKSA9PiB7XFxuICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IGdldFdpZHRoKCk7XFxuICBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xcbiAgICBpZiAoZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+IGVsZW1lbnQuY2xpZW50V2lkdGggKyBzY3JvbGxiYXJXaWR0aCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBhY3R1YWxWYWx1ZSA9IGVsZW1lbnQuc3R5bGVbc3R5bGVQcm9wXTtcXG4gICAgY29uc3QgY2FsY3VsYXRlZFZhbHVlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbc3R5bGVQcm9wXTtcXG4gICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3AsIGFjdHVhbFZhbHVlKTtcXG4gICAgZWxlbWVudC5zdHlsZVtzdHlsZVByb3BdID0gYCR7Y2FsbGJhY2soTnVtYmVyLnBhcnNlRmxvYXQoY2FsY3VsYXRlZFZhbHVlKSl9cHhgO1xcbiAgfSk7XFxufTtcXG5cXG5jb25zdCByZXNldCA9ICgpID0+IHtcXG4gIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKCdib2R5JywgJ292ZXJmbG93Jyk7XFxuXFxuICBfcmVzZXRFbGVtZW50QXR0cmlidXRlcygnYm9keScsICdwYWRkaW5nUmlnaHQnKTtcXG5cXG4gIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsICdwYWRkaW5nUmlnaHQnKTtcXG5cXG4gIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX1NUSUNLWV9DT05URU5ULCAnbWFyZ2luUmlnaHQnKTtcXG59O1xcblxcbmNvbnN0IF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzID0gKHNlbGVjdG9yLCBzdHlsZVByb3ApID0+IHtcXG4gIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpLmZvckVhY2goZWxlbWVudCA9PiB7XFxuICAgIGNvbnN0IHZhbHVlID0gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3ApO1xcblxcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoc3R5bGVQcm9wKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBNYW5pcHVsYXRvci5yZW1vdmVEYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcCk7XFxuICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZVByb3BdID0gdmFsdWU7XFxuICAgIH1cXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IHV0aWwvYmFja2Ryb3AuanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuY29uc3QgRGVmYXVsdCQ2ID0ge1xcbiAgaXNWaXNpYmxlOiB0cnVlLFxcbiAgLy8gaWYgZmFsc2UsIHdlIHVzZSB0aGUgYmFja2Ryb3AgaGVscGVyIHdpdGhvdXQgYWRkaW5nIGFueSBlbGVtZW50IHRvIHRoZSBkb21cXG4gIGlzQW5pbWF0ZWQ6IGZhbHNlLFxcbiAgcm9vdEVsZW1lbnQ6IGRvY3VtZW50LmJvZHksXFxuICAvLyBnaXZlIHRoZSBjaG9pY2UgdG8gcGxhY2UgYmFja2Ryb3AgdW5kZXIgZGlmZmVyZW50IGVsZW1lbnRzXFxuICBjbGlja0NhbGxiYWNrOiBudWxsXFxufTtcXG5jb25zdCBEZWZhdWx0VHlwZSQ2ID0ge1xcbiAgaXNWaXNpYmxlOiAnYm9vbGVhbicsXFxuICBpc0FuaW1hdGVkOiAnYm9vbGVhbicsXFxuICByb290RWxlbWVudDogJ2VsZW1lbnQnLFxcbiAgY2xpY2tDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKSdcXG59O1xcbmNvbnN0IE5BTUUkNyA9ICdiYWNrZHJvcCc7XFxuY29uc3QgQ0xBU1NfTkFNRV9CQUNLRFJPUCA9ICdtb2RhbC1iYWNrZHJvcCc7XFxuY29uc3QgQ0xBU1NfTkFNRV9GQURFJDUgPSAnZmFkZSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDYgPSAnc2hvdyc7XFxuY29uc3QgRVZFTlRfTU9VU0VET1dOID0gYG1vdXNlZG93bi5icy4ke05BTUUkN31gO1xcblxcbmNsYXNzIEJhY2tkcm9wIHtcXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgdGhpcy5faXNBcHBlbmRlZCA9IGZhbHNlO1xcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcXG4gIH1cXG5cXG4gIHNob3coY2FsbGJhY2spIHtcXG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XFxuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2FwcGVuZCgpO1xcblxcbiAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcXG4gICAgICByZWZsb3codGhpcy5fZ2V0RWxlbWVudCgpKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9nZXRFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNik7XFxuXFxuICAgIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xcbiAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGhpZGUoY2FsbGJhY2spIHtcXG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XFxuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ2KTtcXG5cXG4gICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XFxuICAgICAgdGhpcy5kaXNwb3NlKCk7XFxuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XFxuICAgIH0pO1xcbiAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICBfZ2V0RWxlbWVudCgpIHtcXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50KSB7XFxuICAgICAgY29uc3QgYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICBiYWNrZHJvcC5jbGFzc05hbWUgPSBDTEFTU19OQU1FX0JBQ0tEUk9QO1xcblxcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaXNBbmltYXRlZCkge1xcbiAgICAgICAgYmFja2Ryb3AuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUkNSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBiYWNrZHJvcDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcXG4gIH1cXG5cXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XFxuICAgIGNvbmZpZyA9IHsgLi4uRGVmYXVsdCQ2LFxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KVxcbiAgICB9O1xcbiAgICBjb25maWcucm9vdEVsZW1lbnQgPSBjb25maWcucm9vdEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcXG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUkNywgY29uZmlnLCBEZWZhdWx0VHlwZSQ2KTtcXG4gICAgcmV0dXJuIGNvbmZpZztcXG4gIH1cXG5cXG4gIF9hcHBlbmQoKSB7XFxuICAgIGlmICh0aGlzLl9pc0FwcGVuZGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2NvbmZpZy5yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9nZXRFbGVtZW50KCkpO1xcblxcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZ2V0RWxlbWVudCgpLCBFVkVOVF9NT1VTRURPV04sICgpID0+IHtcXG4gICAgICBleGVjdXRlKHRoaXMuX2NvbmZpZy5jbGlja0NhbGxiYWNrKTtcXG4gICAgfSk7XFxuICAgIHRoaXMuX2lzQXBwZW5kZWQgPSB0cnVlO1xcbiAgfVxcblxcbiAgZGlzcG9zZSgpIHtcXG4gICAgaWYgKCF0aGlzLl9pc0FwcGVuZGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOKTtcXG5cXG4gICAgdGhpcy5fZ2V0RWxlbWVudCgpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZWxlbWVudCk7XFxuXFxuICAgIHRoaXMuX2lzQXBwZW5kZWQgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIF9lbXVsYXRlQW5pbWF0aW9uKGNhbGxiYWNrKSB7XFxuICAgIGlmICghdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcXG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24gPSBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9nZXRFbGVtZW50KCkpO1xcbiAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2dldEVsZW1lbnQoKSwgJ3RyYW5zaXRpb25lbmQnLCAoKSA9PiBleGVjdXRlKGNhbGxiYWNrKSk7XFxuICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRoaXMuX2dldEVsZW1lbnQoKSwgYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24pO1xcbiAgfVxcblxcbn1cXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIEJvb3RzdHJhcCAodjUuMC4xKTogbW9kYWwuanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIENvbnN0YW50c1xcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNvbnN0IE5BTUUkNiA9ICdtb2RhbCc7XFxuY29uc3QgREFUQV9LRVkkNiA9ICdicy5tb2RhbCc7XFxuY29uc3QgRVZFTlRfS0VZJDYgPSBgLiR7REFUQV9LRVkkNn1gO1xcbmNvbnN0IERBVEFfQVBJX0tFWSQzID0gJy5kYXRhLWFwaSc7XFxuY29uc3QgRVNDQVBFX0tFWSQxID0gJ0VzY2FwZSc7XFxuY29uc3QgRGVmYXVsdCQ1ID0ge1xcbiAgYmFja2Ryb3A6IHRydWUsXFxuICBrZXlib2FyZDogdHJ1ZSxcXG4gIGZvY3VzOiB0cnVlXFxufTtcXG5jb25zdCBEZWZhdWx0VHlwZSQ1ID0ge1xcbiAgYmFja2Ryb3A6ICcoYm9vbGVhbnxzdHJpbmcpJyxcXG4gIGtleWJvYXJkOiAnYm9vbGVhbicsXFxuICBmb2N1czogJ2Jvb2xlYW4nXFxufTtcXG5jb25zdCBFVkVOVF9ISURFJDMgPSBgaGlkZSR7RVZFTlRfS0VZJDZ9YDtcXG5jb25zdCBFVkVOVF9ISURFX1BSRVZFTlRFRCA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkNn1gO1xcbmNvbnN0IEVWRU5UX0hJRERFTiQzID0gYGhpZGRlbiR7RVZFTlRfS0VZJDZ9YDtcXG5jb25zdCBFVkVOVF9TSE9XJDMgPSBgc2hvdyR7RVZFTlRfS0VZJDZ9YDtcXG5jb25zdCBFVkVOVF9TSE9XTiQzID0gYHNob3duJHtFVkVOVF9LRVkkNn1gO1xcbmNvbnN0IEVWRU5UX0ZPQ1VTSU4kMiA9IGBmb2N1c2luJHtFVkVOVF9LRVkkNn1gO1xcbmNvbnN0IEVWRU5UX1JFU0laRSA9IGByZXNpemUke0VWRU5UX0tFWSQ2fWA7XFxuY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyQyID0gYGNsaWNrLmRpc21pc3Mke0VWRU5UX0tFWSQ2fWA7XFxuY29uc3QgRVZFTlRfS0VZRE9XTl9ESVNNSVNTJDEgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkNn1gO1xcbmNvbnN0IEVWRU5UX01PVVNFVVBfRElTTUlTUyA9IGBtb3VzZXVwLmRpc21pc3Mke0VWRU5UX0tFWSQ2fWA7XFxuY29uc3QgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MgPSBgbW91c2Vkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQ2fWA7XFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiA9IGBjbGljayR7RVZFTlRfS0VZJDZ9JHtEQVRBX0FQSV9LRVkkM31gO1xcbmNvbnN0IENMQVNTX05BTUVfT1BFTiA9ICdtb2RhbC1vcGVuJztcXG5jb25zdCBDTEFTU19OQU1FX0ZBREUkNCA9ICdmYWRlJztcXG5jb25zdCBDTEFTU19OQU1FX1NIT1ckNSA9ICdzaG93JztcXG5jb25zdCBDTEFTU19OQU1FX1NUQVRJQyA9ICdtb2RhbC1zdGF0aWMnO1xcbmNvbnN0IFNFTEVDVE9SX0RJQUxPRyA9ICcubW9kYWwtZGlhbG9nJztcXG5jb25zdCBTRUxFQ1RPUl9NT0RBTF9CT0RZID0gJy5tb2RhbC1ib2R5JztcXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyID0gJ1tkYXRhLWJzLXRvZ2dsZT1cXFwibW9kYWxcXFwiXSc7XFxuY29uc3QgU0VMRUNUT1JfREFUQV9ESVNNSVNTJDIgPSAnW2RhdGEtYnMtZGlzbWlzcz1cXFwibW9kYWxcXFwiXSc7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIE1vZGFsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XFxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgc3VwZXIoZWxlbWVudCk7XFxuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xcbiAgICB0aGlzLl9kaWFsb2cgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RJQUxPRywgdGhpcy5fZWxlbWVudCk7XFxuICAgIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCk7XFxuICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcXG4gICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlO1xcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcXG4gIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xcbiAgICByZXR1cm4gRGVmYXVsdCQ1O1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICByZXR1cm4gTkFNRSQ2O1xcbiAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XFxuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldCk7XFxuICB9XFxuXFxuICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9pc0FuaW1hdGVkKCkpIHtcXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckMywge1xcbiAgICAgIHJlbGF0ZWRUYXJnZXRcXG4gICAgfSk7XFxuXFxuICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xcbiAgICBoaWRlKCk7XFxuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX09QRU4pO1xcblxcbiAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcXG5cXG4gICAgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKTtcXG5cXG4gICAgdGhpcy5fc2V0UmVzaXplRXZlbnQoKTtcXG5cXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLX0RJU01JU1MkMiwgU0VMRUNUT1JfREFUQV9ESVNNSVNTJDIsIGV2ZW50ID0+IHRoaXMuaGlkZShldmVudCkpO1xcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZGlhbG9nLCBFVkVOVF9NT1VTRURPV05fRElTTUlTUywgKCkgPT4ge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VVUF9ESVNNSVNTLCBldmVudCA9PiB7XFxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLl9lbGVtZW50KSB7XFxuICAgICAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5fc2hvd0JhY2tkcm9wKCgpID0+IHRoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpKTtcXG4gIH1cXG5cXG4gIGhpZGUoZXZlbnQpIHtcXG4gICAgaWYgKGV2ZW50KSB7XFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgfVxcblxcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkMyk7XFxuXFxuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XFxuXFxuICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSB0aGlzLl9pc0FuaW1hdGVkKCk7XFxuXFxuICAgIGlmIChpc0FuaW1hdGVkKSB7XFxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9zZXRFc2NhcGVFdmVudCgpO1xcblxcbiAgICB0aGlzLl9zZXRSZXNpemVFdmVudCgpO1xcblxcbiAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOJDIpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDUpO1xcblxcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLX0RJU01JU1MkMik7XFxuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZGlhbG9nLCBFVkVOVF9NT1VTRURPV05fRElTTUlTUyk7XFxuXFxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5faGlkZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQsIGlzQW5pbWF0ZWQpO1xcbiAgfVxcblxcbiAgZGlzcG9zZSgpIHtcXG4gICAgW3dpbmRvdywgdGhpcy5fZGlhbG9nXS5mb3JFYWNoKGh0bWxFbGVtZW50ID0+IEV2ZW50SGFuZGxlci5vZmYoaHRtbEVsZW1lbnQsIEVWRU5UX0tFWSQ2KSk7XFxuXFxuICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKTtcXG5cXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xcbiAgICAvKipcXG4gICAgICogYGRvY3VtZW50YCBoYXMgMiBldmVudHMgYEVWRU5UX0ZPQ1VTSU5gIGFuZCBgRVZFTlRfQ0xJQ0tfREFUQV9BUElgXFxuICAgICAqIERvIG5vdCBtb3ZlIGBkb2N1bWVudGAgaW4gYGh0bWxFbGVtZW50c2AgYXJyYXlcXG4gICAgICogSXQgd2lsbCByZW1vdmUgYEVWRU5UX0NMSUNLX0RBVEFfQVBJYCBldmVudCB0aGF0IHNob3VsZCByZW1haW5cXG4gICAgICovXFxuXFxuICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0ZPQ1VTSU4kMik7XFxuICB9XFxuXFxuICBoYW5kbGVVcGRhdGUoKSB7XFxuICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xcbiAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xcbiAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcXG4gICAgICBpc1Zpc2libGU6IEJvb2xlYW4odGhpcy5fY29uZmlnLmJhY2tkcm9wKSxcXG4gICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWVcXG4gICAgICBpc0FuaW1hdGVkOiB0aGlzLl9pc0FuaW1hdGVkKClcXG4gICAgfSk7XFxuICB9XFxuXFxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xcbiAgICBjb25maWcgPSB7IC4uLkRlZmF1bHQkNSxcXG4gICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcXG4gICAgICAuLi5jb25maWdcXG4gICAgfTtcXG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUkNiwgY29uZmlnLCBEZWZhdWx0VHlwZSQ1KTtcXG4gICAgcmV0dXJuIGNvbmZpZztcXG4gIH1cXG5cXG4gIF9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSB7XFxuICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSB0aGlzLl9pc0FuaW1hdGVkKCk7XFxuXFxuICAgIGNvbnN0IG1vZGFsQm9keSA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTU9EQUxfQk9EWSwgdGhpcy5fZGlhbG9nKTtcXG5cXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgfHwgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xcbiAgICAgIC8vIERvbid0IG1vdmUgbW9kYWwncyBET00gcG9zaXRpb25cXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcXG5cXG4gICAgdGhpcy5fZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xcblxcbiAgICBpZiAobW9kYWxCb2R5KSB7XFxuICAgICAgbW9kYWxCb2R5LnNjcm9sbFRvcCA9IDA7XFxuICAgIH1cXG5cXG4gICAgaWYgKGlzQW5pbWF0ZWQpIHtcXG4gICAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ1KTtcXG5cXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5mb2N1cykge1xcbiAgICAgIHRoaXMuX2VuZm9yY2VGb2N1cygpO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHRyYW5zaXRpb25Db21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XFxuICAgICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDMsIHtcXG4gICAgICAgIHJlbGF0ZWRUYXJnZXRcXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayh0cmFuc2l0aW9uQ29tcGxldGUsIHRoaXMuX2RpYWxvZywgaXNBbmltYXRlZCk7XFxuICB9XFxuXFxuICBfZW5mb3JjZUZvY3VzKCkge1xcbiAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOJDIpOyAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcXG5cXG4gICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOJDIsIGV2ZW50ID0+IHtcXG4gICAgICBpZiAoZG9jdW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJiB0aGlzLl9lbGVtZW50ICE9PSBldmVudC50YXJnZXQgJiYgIXRoaXMuX2VsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xcbiAgICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICBfc2V0RXNjYXBlRXZlbnQoKSB7XFxuICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUyQxLCBldmVudCA9PiB7XFxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkICYmIGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSQxKSB7XFxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSQxKSB7XFxuICAgICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUyQxKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgX3NldFJlc2l6ZUV2ZW50KCkge1xcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX1JFU0laRSwgKCkgPT4gdGhpcy5fYWRqdXN0RGlhbG9nKCkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYod2luZG93LCBFVkVOVF9SRVNJWkUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBfaGlkZU1vZGFsKCkge1xcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xcblxcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcXG5cXG4gICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgoKSA9PiB7XFxuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfT1BFTik7XFxuXFxuICAgICAgdGhpcy5fcmVzZXRBZGp1c3RtZW50cygpO1xcblxcbiAgICAgIHJlc2V0KCk7XFxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDMpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIF9zaG93QmFja2Ryb3AoY2FsbGJhY2spIHtcXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLX0RJU01JU1MkMiwgZXZlbnQgPT4ge1xcbiAgICAgIGlmICh0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XFxuICAgICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2U7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XFxuICAgICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5fYmFja2Ryb3Auc2hvdyhjYWxsYmFjayk7XFxuICB9XFxuXFxuICBfaXNBbmltYXRlZCgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQ0KTtcXG4gIH1cXG5cXG4gIF90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkge1xcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCk7XFxuXFxuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XFxuXFxuICAgIGlmICghaXNNb2RhbE92ZXJmbG93aW5nKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcXG4gICAgfVxcblxcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TVEFUSUMpO1xcblxcbiAgICBjb25zdCBtb2RhbFRyYW5zaXRpb25EdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2RpYWxvZyk7XFxuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnKTtcXG4gICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsICgpID0+IHtcXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TVEFUSUMpO1xcblxcbiAgICAgIGlmICghaXNNb2RhbE92ZXJmbG93aW5nKSB7XFxuICAgICAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2VsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgKCkgPT4ge1xcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9ICcnO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50LCBtb2RhbFRyYW5zaXRpb25EdXJhdGlvbik7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgZW11bGF0ZVRyYW5zaXRpb25FbmQodGhpcy5fZWxlbWVudCwgbW9kYWxUcmFuc2l0aW9uRHVyYXRpb24pO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XFxuICB9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gIC8vIHRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuXFxuICBfYWRqdXN0RGlhbG9nKCkge1xcbiAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XFxuICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gZ2V0V2lkdGgoKTtcXG4gICAgY29uc3QgaXNCb2R5T3ZlcmZsb3dpbmcgPSBzY3JvbGxiYXJXaWR0aCA+IDA7XFxuXFxuICAgIGlmICghaXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nICYmICFpc1JUTCgpIHx8IGlzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcgJiYgaXNSVEwoKSkge1xcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBgJHtzY3JvbGxiYXJXaWR0aH1weGA7XFxuICAgIH1cXG5cXG4gICAgaWYgKGlzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcgJiYgIWlzUlRMKCkgfHwgIWlzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZyAmJiBpc1JUTCgpKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtzY3JvbGxiYXJXaWR0aH1weGA7XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9yZXNldEFkanVzdG1lbnRzKCkge1xcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gJyc7XFxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XFxuICB9IC8vIFN0YXRpY1xcblxcblxcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcsIHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgY29uc3QgZGF0YSA9IE1vZGFsLmdldEluc3RhbmNlKHRoaXMpIHx8IG5ldyBNb2RhbCh0aGlzLCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KTtcXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICB9XFxuXFxuICAgICAgZGF0YVtjb25maWddKHJlbGF0ZWRUYXJnZXQpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG59XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5cXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcXG5cXG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gIH1cXG5cXG4gIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9TSE9XJDMsIHNob3dFdmVudCA9PiB7XFxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiQzLCAoKSA9PiB7XFxuICAgICAgaWYgKGlzVmlzaWJsZSh0aGlzKSkge1xcbiAgICAgICAgdGhpcy5mb2N1cygpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9KTtcXG4gIGNvbnN0IGRhdGEgPSBNb2RhbC5nZXRJbnN0YW5jZSh0YXJnZXQpIHx8IG5ldyBNb2RhbCh0YXJnZXQpO1xcbiAgZGF0YS50b2dnbGUodGhpcyk7XFxufSk7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogalF1ZXJ5XFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogYWRkIC5Nb2RhbCB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxcbiAqL1xcblxcbmRlZmluZUpRdWVyeVBsdWdpbihNb2RhbCk7XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IG9mZmNhbnZhcy5qc1xcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBOQU1FJDUgPSAnb2ZmY2FudmFzJztcXG5jb25zdCBEQVRBX0tFWSQ1ID0gJ2JzLm9mZmNhbnZhcyc7XFxuY29uc3QgRVZFTlRfS0VZJDUgPSBgLiR7REFUQV9LRVkkNX1gO1xcbmNvbnN0IERBVEFfQVBJX0tFWSQyID0gJy5kYXRhLWFwaSc7XFxuY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQxID0gYGxvYWQke0VWRU5UX0tFWSQ1fSR7REFUQV9BUElfS0VZJDJ9YDtcXG5jb25zdCBFU0NBUEVfS0VZID0gJ0VzY2FwZSc7XFxuY29uc3QgRGVmYXVsdCQ0ID0ge1xcbiAgYmFja2Ryb3A6IHRydWUsXFxuICBrZXlib2FyZDogdHJ1ZSxcXG4gIHNjcm9sbDogZmFsc2VcXG59O1xcbmNvbnN0IERlZmF1bHRUeXBlJDQgPSB7XFxuICBiYWNrZHJvcDogJ2Jvb2xlYW4nLFxcbiAga2V5Ym9hcmQ6ICdib29sZWFuJyxcXG4gIHNjcm9sbDogJ2Jvb2xlYW4nXFxufTtcXG5jb25zdCBDTEFTU19OQU1FX1NIT1ckNCA9ICdzaG93JztcXG5jb25zdCBPUEVOX1NFTEVDVE9SID0gJy5vZmZjYW52YXMuc2hvdyc7XFxuY29uc3QgRVZFTlRfU0hPVyQyID0gYHNob3cke0VWRU5UX0tFWSQ1fWA7XFxuY29uc3QgRVZFTlRfU0hPV04kMiA9IGBzaG93biR7RVZFTlRfS0VZJDV9YDtcXG5jb25zdCBFVkVOVF9ISURFJDIgPSBgaGlkZSR7RVZFTlRfS0VZJDV9YDtcXG5jb25zdCBFVkVOVF9ISURERU4kMiA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ1fWA7XFxuY29uc3QgRVZFTlRfRk9DVVNJTiQxID0gYGZvY3VzaW4ke0VWRU5UX0tFWSQ1fWA7XFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMSA9IGBjbGljayR7RVZFTlRfS0VZJDV9JHtEQVRBX0FQSV9LRVkkMn1gO1xcbmNvbnN0IEVWRU5UX0NMSUNLX0RJU01JU1MkMSA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVkkNX1gO1xcbmNvbnN0IEVWRU5UX0tFWURPV05fRElTTUlTUyA9IGBrZXlkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQ1fWA7XFxuY29uc3QgU0VMRUNUT1JfREFUQV9ESVNNSVNTJDEgPSAnW2RhdGEtYnMtZGlzbWlzcz1cXFwib2ZmY2FudmFzXFxcIl0nO1xcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEgPSAnW2RhdGEtYnMtdG9nZ2xlPVxcXCJvZmZjYW52YXNcXFwiXSc7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIE9mZmNhbnZhcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgIHN1cGVyKGVsZW1lbnQpO1xcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xcbiAgICB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpO1xcblxcbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xcbiAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgIHJldHVybiBOQU1FJDU7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgIHJldHVybiBEZWZhdWx0JDQ7XFxuICB9IC8vIFB1YmxpY1xcblxcblxcbiAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcXG4gIH1cXG5cXG4gIHNob3cocmVsYXRlZFRhcmdldCkge1xcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDIsIHtcXG4gICAgICByZWxhdGVkVGFyZ2V0XFxuICAgIH0pO1xcblxcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5faXNTaG93biA9IHRydWU7XFxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcXG5cXG4gICAgdGhpcy5fYmFja2Ryb3Auc2hvdygpO1xcblxcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwpIHtcXG4gICAgICBoaWRlKCk7XFxuXFxuICAgICAgdGhpcy5fZW5mb3JjZUZvY3VzT25FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcXG5cXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ0KTtcXG5cXG4gICAgY29uc3QgY29tcGxldGVDYWxsQmFjayA9ICgpID0+IHtcXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQyLCB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsQmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XFxuICB9XFxuXFxuICBoaWRlKCkge1xcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24pIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQyKTtcXG5cXG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0ZPQ1VTSU4kMSk7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuYmx1cigpO1xcblxcbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNCk7XFxuXFxuICAgIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcXG5cXG4gICAgY29uc3QgY29tcGxldGVDYWxsYmFjayA9ICgpID0+IHtcXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XFxuXFxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XFxuICAgICAgICByZXNldCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kMik7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsYmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XFxuICB9XFxuXFxuICBkaXNwb3NlKCkge1xcbiAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCk7XFxuXFxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcXG4gICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiQxKTtcXG4gIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgY29uZmlnID0geyAuLi5EZWZhdWx0JDQsXFxuICAgICAgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDoge30pXFxuICAgIH07XFxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FJDUsIGNvbmZpZywgRGVmYXVsdFR5cGUkNCk7XFxuICAgIHJldHVybiBjb25maWc7XFxuICB9XFxuXFxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xcbiAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcXG4gICAgICBpc1Zpc2libGU6IHRoaXMuX2NvbmZpZy5iYWNrZHJvcCxcXG4gICAgICBpc0FuaW1hdGVkOiB0cnVlLFxcbiAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXFxuICAgICAgY2xpY2tDYWxsYmFjazogKCkgPT4gdGhpcy5oaWRlKClcXG4gICAgfSk7XFxuICB9XFxuXFxuICBfZW5mb3JjZUZvY3VzT25FbGVtZW50KGVsZW1lbnQpIHtcXG4gICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiQxKTsgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXFxuXFxuICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiQxLCBldmVudCA9PiB7XFxuICAgICAgaWYgKGRvY3VtZW50ICE9PSBldmVudC50YXJnZXQgJiYgZWxlbWVudCAhPT0gZXZlbnQudGFyZ2V0ICYmICFlbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcXG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICBlbGVtZW50LmZvY3VzKCk7XFxuICB9XFxuXFxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XFxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTJDEsIFNFTEVDVE9SX0RBVEFfRElTTUlTUyQxLCAoKSA9PiB0aGlzLmhpZGUoKSk7XFxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOX0RJU01JU1MsIGV2ZW50ID0+IHtcXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkICYmIGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSkge1xcbiAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH0gLy8gU3RhdGljXFxuXFxuXFxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICBjb25zdCBkYXRhID0gRGF0YS5nZXQodGhpcywgREFUQV9LRVkkNSkgfHwgbmV3IE9mZmNhbnZhcyh0aGlzLCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KTtcXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICB9XFxuXFxuICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG59XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5cXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDEsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcXG5cXG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gIH1cXG5cXG4gIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9ISURERU4kMiwgKCkgPT4ge1xcbiAgICAvLyBmb2N1cyBvbiB0cmlnZ2VyIHdoZW4gaXQgaXMgY2xvc2VkXFxuICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcXG4gICAgICB0aGlzLmZvY3VzKCk7XFxuICAgIH1cXG4gIH0pOyAvLyBhdm9pZCBjb25mbGljdCB3aGVuIGNsaWNraW5nIGEgdG9nZ2xlciBvZiBhbiBvZmZjYW52YXMsIHdoaWxlIGFub3RoZXIgaXMgb3BlblxcblxcbiAgY29uc3QgYWxsUmVhZHlPcGVuID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShPUEVOX1NFTEVDVE9SKTtcXG5cXG4gIGlmIChhbGxSZWFkeU9wZW4gJiYgYWxsUmVhZHlPcGVuICE9PSB0YXJnZXQpIHtcXG4gICAgT2ZmY2FudmFzLmdldEluc3RhbmNlKGFsbFJlYWR5T3BlbikuaGlkZSgpO1xcbiAgfVxcblxcbiAgY29uc3QgZGF0YSA9IERhdGEuZ2V0KHRhcmdldCwgREFUQV9LRVkkNSkgfHwgbmV3IE9mZmNhbnZhcyh0YXJnZXQpO1xcbiAgZGF0YS50b2dnbGUodGhpcyk7XFxufSk7XFxuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQxLCAoKSA9PiB7XFxuICBTZWxlY3RvckVuZ2luZS5maW5kKE9QRU5fU0VMRUNUT1IpLmZvckVhY2goZWwgPT4gKERhdGEuZ2V0KGVsLCBEQVRBX0tFWSQ1KSB8fCBuZXcgT2ZmY2FudmFzKGVsKSkuc2hvdygpKTtcXG59KTtcXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBqUXVlcnlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5kZWZpbmVKUXVlcnlQbHVnaW4oT2ZmY2FudmFzKTtcXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIEJvb3RzdHJhcCAodjUuMC4xKTogdXRpbC9zYW5pdGl6ZXIuanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcbmNvbnN0IHVyaUF0dHJzID0gbmV3IFNldChbJ2JhY2tncm91bmQnLCAnY2l0ZScsICdocmVmJywgJ2l0ZW10eXBlJywgJ2xvbmdkZXNjJywgJ3Bvc3RlcicsICdzcmMnLCAneGxpbms6aHJlZiddKTtcXG5jb25zdCBBUklBX0FUVFJJQlVURV9QQVRURVJOID0gL15hcmlhLVtcXFxcdy1dKiQvaTtcXG4vKipcXG4gKiBBIHBhdHRlcm4gdGhhdCByZWNvZ25pemVzIGEgY29tbW9ubHkgdXNlZnVsIHN1YnNldCBvZiBVUkxzIHRoYXQgYXJlIHNhZmUuXFxuICpcXG4gKiBTaG91dG91dCB0byBBbmd1bGFyIDcgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzcuMi40L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXFxuICovXFxuXFxuY29uc3QgU0FGRV9VUkxfUEFUVEVSTiA9IC9eKD86KD86aHR0cHM/fG1haWx0b3xmdHB8dGVsfGZpbGUpOnxbXiMmLzo/XSooPzpbIy8/XXwkKSkvaTtcXG4vKipcXG4gKiBBIHBhdHRlcm4gdGhhdCBtYXRjaGVzIHNhZmUgZGF0YSBVUkxzLiBPbmx5IG1hdGNoZXMgaW1hZ2UsIHZpZGVvIGFuZCBhdWRpbyB0eXBlcy5cXG4gKlxcbiAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgNyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvNy4yLjQvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcXG4gKi9cXG5cXG5jb25zdCBEQVRBX1VSTF9QQVRURVJOID0gL15kYXRhOig/OmltYWdlXFxcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFxcXC8oPzptcGVnfG1wNHxvZ2d8d2VibSl8YXVkaW9cXFxcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW1xcXFxkKy9hLXpdKz0qJC9pO1xcblxcbmNvbnN0IGFsbG93ZWRBdHRyaWJ1dGUgPSAoYXR0ciwgYWxsb3dlZEF0dHJpYnV0ZUxpc3QpID0+IHtcXG4gIGNvbnN0IGF0dHJOYW1lID0gYXR0ci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcbiAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmluY2x1ZGVzKGF0dHJOYW1lKSkge1xcbiAgICBpZiAodXJpQXR0cnMuaGFzKGF0dHJOYW1lKSkge1xcbiAgICAgIHJldHVybiBCb29sZWFuKFNBRkVfVVJMX1BBVFRFUk4udGVzdChhdHRyLm5vZGVWYWx1ZSkgfHwgREFUQV9VUkxfUEFUVEVSTi50ZXN0KGF0dHIubm9kZVZhbHVlKSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICBjb25zdCByZWdFeHAgPSBhbGxvd2VkQXR0cmlidXRlTGlzdC5maWx0ZXIoYXR0clJlZ2V4ID0+IGF0dHJSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCk7IC8vIENoZWNrIGlmIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlcyB0aGUgYXR0cmlidXRlLlxcblxcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJlZ0V4cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICBpZiAocmVnRXhwW2ldLnRlc3QoYXR0ck5hbWUpKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBmYWxzZTtcXG59O1xcblxcbmNvbnN0IERlZmF1bHRBbGxvd2xpc3QgPSB7XFxuICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxcbiAgJyonOiBbJ2NsYXNzJywgJ2RpcicsICdpZCcsICdsYW5nJywgJ3JvbGUnLCBBUklBX0FUVFJJQlVURV9QQVRURVJOXSxcXG4gIGE6IFsndGFyZ2V0JywgJ2hyZWYnLCAndGl0bGUnLCAncmVsJ10sXFxuICBhcmVhOiBbXSxcXG4gIGI6IFtdLFxcbiAgYnI6IFtdLFxcbiAgY29sOiBbXSxcXG4gIGNvZGU6IFtdLFxcbiAgZGl2OiBbXSxcXG4gIGVtOiBbXSxcXG4gIGhyOiBbXSxcXG4gIGgxOiBbXSxcXG4gIGgyOiBbXSxcXG4gIGgzOiBbXSxcXG4gIGg0OiBbXSxcXG4gIGg1OiBbXSxcXG4gIGg2OiBbXSxcXG4gIGk6IFtdLFxcbiAgaW1nOiBbJ3NyYycsICdzcmNzZXQnLCAnYWx0JywgJ3RpdGxlJywgJ3dpZHRoJywgJ2hlaWdodCddLFxcbiAgbGk6IFtdLFxcbiAgb2w6IFtdLFxcbiAgcDogW10sXFxuICBwcmU6IFtdLFxcbiAgczogW10sXFxuICBzbWFsbDogW10sXFxuICBzcGFuOiBbXSxcXG4gIHN1YjogW10sXFxuICBzdXA6IFtdLFxcbiAgc3Ryb25nOiBbXSxcXG4gIHU6IFtdLFxcbiAgdWw6IFtdXFxufTtcXG5mdW5jdGlvbiBzYW5pdGl6ZUh0bWwodW5zYWZlSHRtbCwgYWxsb3dMaXN0LCBzYW5pdGl6ZUZuKSB7XFxuICBpZiAoIXVuc2FmZUh0bWwubGVuZ3RoKSB7XFxuICAgIHJldHVybiB1bnNhZmVIdG1sO1xcbiAgfVxcblxcbiAgaWYgKHNhbml0aXplRm4gJiYgdHlwZW9mIHNhbml0aXplRm4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgcmV0dXJuIHNhbml0aXplRm4odW5zYWZlSHRtbCk7XFxuICB9XFxuXFxuICBjb25zdCBkb21QYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xcbiAgY29uc3QgY3JlYXRlZERvY3VtZW50ID0gZG9tUGFyc2VyLnBhcnNlRnJvbVN0cmluZyh1bnNhZmVIdG1sLCAndGV4dC9odG1sJyk7XFxuICBjb25zdCBhbGxvd2xpc3RLZXlzID0gT2JqZWN0LmtleXMoYWxsb3dMaXN0KTtcXG4gIGNvbnN0IGVsZW1lbnRzID0gW10uY29uY2F0KC4uLmNyZWF0ZWREb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSk7XFxuXFxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgY29uc3QgZWwgPSBlbGVtZW50c1tpXTtcXG4gICAgY29uc3QgZWxOYW1lID0gZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXG4gICAgaWYgKCFhbGxvd2xpc3RLZXlzLmluY2x1ZGVzKGVsTmFtZSkpIHtcXG4gICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcXG4gICAgICBjb250aW51ZTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBhdHRyaWJ1dGVMaXN0ID0gW10uY29uY2F0KC4uLmVsLmF0dHJpYnV0ZXMpO1xcbiAgICBjb25zdCBhbGxvd2VkQXR0cmlidXRlcyA9IFtdLmNvbmNhdChhbGxvd0xpc3RbJyonXSB8fCBbXSwgYWxsb3dMaXN0W2VsTmFtZV0gfHwgW10pO1xcbiAgICBhdHRyaWJ1dGVMaXN0LmZvckVhY2goYXR0ciA9PiB7XFxuICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlKGF0dHIsIGFsbG93ZWRBdHRyaWJ1dGVzKSkge1xcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIubm9kZU5hbWUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICByZXR1cm4gY3JlYXRlZERvY3VtZW50LmJvZHkuaW5uZXJIVE1MO1xcbn1cXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIEJvb3RzdHJhcCAodjUuMC4xKTogdG9vbHRpcC5qc1xcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ29uc3RhbnRzXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuY29uc3QgTkFNRSQ0ID0gJ3Rvb2x0aXAnO1xcbmNvbnN0IERBVEFfS0VZJDQgPSAnYnMudG9vbHRpcCc7XFxuY29uc3QgRVZFTlRfS0VZJDQgPSBgLiR7REFUQV9LRVkkNH1gO1xcbmNvbnN0IENMQVNTX1BSRUZJWCQxID0gJ2JzLXRvb2x0aXAnO1xcbmNvbnN0IEJTQ0xTX1BSRUZJWF9SRUdFWCQxID0gbmV3IFJlZ0V4cChgKF58XFxcXFxcXFxzKSR7Q0xBU1NfUFJFRklYJDF9XFxcXFxcXFxTK2AsICdnJyk7XFxuY29uc3QgRElTQUxMT1dFRF9BVFRSSUJVVEVTID0gbmV3IFNldChbJ3Nhbml0aXplJywgJ2FsbG93TGlzdCcsICdzYW5pdGl6ZUZuJ10pO1xcbmNvbnN0IERlZmF1bHRUeXBlJDMgPSB7XFxuICBhbmltYXRpb246ICdib29sZWFuJyxcXG4gIHRlbXBsYXRlOiAnc3RyaW5nJyxcXG4gIHRpdGxlOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKScsXFxuICB0cmlnZ2VyOiAnc3RyaW5nJyxcXG4gIGRlbGF5OiAnKG51bWJlcnxvYmplY3QpJyxcXG4gIGh0bWw6ICdib29sZWFuJyxcXG4gIHNlbGVjdG9yOiAnKHN0cmluZ3xib29sZWFuKScsXFxuICBwbGFjZW1lbnQ6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXFxuICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXFxuICBjb250YWluZXI6ICcoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbiknLFxcbiAgZmFsbGJhY2tQbGFjZW1lbnRzOiAnYXJyYXknLFxcbiAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcXG4gIGN1c3RvbUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxcbiAgc2FuaXRpemU6ICdib29sZWFuJyxcXG4gIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxcbiAgYWxsb3dMaXN0OiAnb2JqZWN0JyxcXG4gIHBvcHBlckNvbmZpZzogJyhudWxsfG9iamVjdHxmdW5jdGlvbiknXFxufTtcXG5jb25zdCBBdHRhY2htZW50TWFwID0ge1xcbiAgQVVUTzogJ2F1dG8nLFxcbiAgVE9QOiAndG9wJyxcXG4gIFJJR0hUOiBpc1JUTCgpID8gJ2xlZnQnIDogJ3JpZ2h0JyxcXG4gIEJPVFRPTTogJ2JvdHRvbScsXFxuICBMRUZUOiBpc1JUTCgpID8gJ3JpZ2h0JyA6ICdsZWZ0J1xcbn07XFxuY29uc3QgRGVmYXVsdCQzID0ge1xcbiAgYW5pbWF0aW9uOiB0cnVlLFxcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwXFxcIiByb2xlPVxcXCJ0b29sdGlwXFxcIj4nICsgJzxkaXYgY2xhc3M9XFxcInRvb2x0aXAtYXJyb3dcXFwiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1pbm5lclxcXCI+PC9kaXY+JyArICc8L2Rpdj4nLFxcbiAgdHJpZ2dlcjogJ2hvdmVyIGZvY3VzJyxcXG4gIHRpdGxlOiAnJyxcXG4gIGRlbGF5OiAwLFxcbiAgaHRtbDogZmFsc2UsXFxuICBzZWxlY3RvcjogZmFsc2UsXFxuICBwbGFjZW1lbnQ6ICd0b3AnLFxcbiAgb2Zmc2V0OiBbMCwgMF0sXFxuICBjb250YWluZXI6IGZhbHNlLFxcbiAgZmFsbGJhY2tQbGFjZW1lbnRzOiBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLFxcbiAgYm91bmRhcnk6ICdjbGlwcGluZ1BhcmVudHMnLFxcbiAgY3VzdG9tQ2xhc3M6ICcnLFxcbiAgc2FuaXRpemU6IHRydWUsXFxuICBzYW5pdGl6ZUZuOiBudWxsLFxcbiAgYWxsb3dMaXN0OiBEZWZhdWx0QWxsb3dsaXN0LFxcbiAgcG9wcGVyQ29uZmlnOiBudWxsXFxufTtcXG5jb25zdCBFdmVudCQyID0ge1xcbiAgSElERTogYGhpZGUke0VWRU5UX0tFWSQ0fWAsXFxuICBISURERU46IGBoaWRkZW4ke0VWRU5UX0tFWSQ0fWAsXFxuICBTSE9XOiBgc2hvdyR7RVZFTlRfS0VZJDR9YCxcXG4gIFNIT1dOOiBgc2hvd24ke0VWRU5UX0tFWSQ0fWAsXFxuICBJTlNFUlRFRDogYGluc2VydGVkJHtFVkVOVF9LRVkkNH1gLFxcbiAgQ0xJQ0s6IGBjbGljayR7RVZFTlRfS0VZJDR9YCxcXG4gIEZPQ1VTSU46IGBmb2N1c2luJHtFVkVOVF9LRVkkNH1gLFxcbiAgRk9DVVNPVVQ6IGBmb2N1c291dCR7RVZFTlRfS0VZJDR9YCxcXG4gIE1PVVNFRU5URVI6IGBtb3VzZWVudGVyJHtFVkVOVF9LRVkkNH1gLFxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke0VWRU5UX0tFWSQ0fWBcXG59O1xcbmNvbnN0IENMQVNTX05BTUVfRkFERSQzID0gJ2ZhZGUnO1xcbmNvbnN0IENMQVNTX05BTUVfTU9EQUwgPSAnbW9kYWwnO1xcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQzID0gJ3Nob3cnO1xcbmNvbnN0IEhPVkVSX1NUQVRFX1NIT1cgPSAnc2hvdyc7XFxuY29uc3QgSE9WRVJfU1RBVEVfT1VUID0gJ291dCc7XFxuY29uc3QgU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiA9ICcudG9vbHRpcC1pbm5lcic7XFxuY29uc3QgVFJJR0dFUl9IT1ZFUiA9ICdob3Zlcic7XFxuY29uc3QgVFJJR0dFUl9GT0NVUyA9ICdmb2N1cyc7XFxuY29uc3QgVFJJR0dFUl9DTElDSyA9ICdjbGljayc7XFxuY29uc3QgVFJJR0dFUl9NQU5VQUwgPSAnbWFudWFsJztcXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDbGFzcyBEZWZpbml0aW9uXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuY2xhc3MgVG9vbHRpcCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgIGlmICh0eXBlb2YgX3BvcHBlcmpzX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXFxcJ3MgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZyknKTtcXG4gICAgfVxcblxcbiAgICBzdXBlcihlbGVtZW50KTsgLy8gcHJpdmF0ZVxcblxcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xcbiAgICB0aGlzLl90aW1lb3V0ID0gMDtcXG4gICAgdGhpcy5faG92ZXJTdGF0ZSA9ICcnO1xcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge307XFxuICAgIHRoaXMuX3BvcHBlciA9IG51bGw7IC8vIFByb3RlY3RlZFxcblxcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgdGhpcy50aXAgPSBudWxsO1xcblxcbiAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcXG4gIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xcbiAgICByZXR1cm4gRGVmYXVsdCQzO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICByZXR1cm4gTkFNRSQ0O1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBFdmVudCgpIHtcXG4gICAgcmV0dXJuIEV2ZW50JDI7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkMztcXG4gIH0gLy8gUHVibGljXFxuXFxuXFxuICBlbmFibGUoKSB7XFxuICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XFxuICB9XFxuXFxuICBkaXNhYmxlKCkge1xcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIHRvZ2dsZUVuYWJsZWQoKSB7XFxuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICF0aGlzLl9pc0VuYWJsZWQ7XFxuICB9XFxuXFxuICB0b2dnbGUoZXZlbnQpIHtcXG4gICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKGV2ZW50KSB7XFxuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCk7XFxuXFxuICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrO1xcblxcbiAgICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcXG4gICAgICAgIGNvbnRleHQuX2VudGVyKG51bGwsIGNvbnRleHQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb250ZXh0Ll9sZWF2ZShudWxsLCBjb250ZXh0KTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKHRoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckMykpIHtcXG4gICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xcblxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9lbnRlcihudWxsLCB0aGlzKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZGlzcG9zZSgpIHtcXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChgLiR7Q0xBU1NfTkFNRV9NT0RBTH1gKSwgJ2hpZGUuYnMubW9kYWwnLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKTtcXG5cXG4gICAgaWYgKHRoaXMudGlwICYmIHRoaXMudGlwLnBhcmVudE5vZGUpIHtcXG4gICAgICB0aGlzLnRpcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudGlwKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XFxuICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcXG4gICAgfVxcblxcbiAgICBzdXBlci5kaXNwb3NlKCk7XFxuICB9XFxuXFxuICBzaG93KCkge1xcbiAgICBpZiAodGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2Ugc2hvdyBvbiB2aXNpYmxlIGVsZW1lbnRzJyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKCEodGhpcy5pc1dpdGhDb250ZW50KCkgJiYgdGhpcy5faXNFbmFibGVkKSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1cpO1xcbiAgICBjb25zdCBzaGFkb3dSb290ID0gZmluZFNoYWRvd1Jvb3QodGhpcy5fZWxlbWVudCk7XFxuICAgIGNvbnN0IGlzSW5UaGVEb20gPSBzaGFkb3dSb290ID09PSBudWxsID8gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0aGlzLl9lbGVtZW50KSA6IHNoYWRvd1Jvb3QuY29udGFpbnModGhpcy5fZWxlbWVudCk7XFxuXFxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCAhaXNJblRoZURvbSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTtcXG4gICAgY29uc3QgdGlwSWQgPSBnZXRVSUQodGhpcy5jb25zdHJ1Y3Rvci5OQU1FKTtcXG4gICAgdGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aXBJZCk7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwSWQpO1xcblxcbiAgICB0aGlzLnNldENvbnRlbnQoKTtcXG5cXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcXG4gICAgICB0aXAuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUkMyk7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgcGxhY2VtZW50ID0gdHlwZW9mIHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgdGlwLCB0aGlzLl9lbGVtZW50KSA6IHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQ7XFxuXFxuICAgIGNvbnN0IGF0dGFjaG1lbnQgPSB0aGlzLl9nZXRBdHRhY2htZW50KHBsYWNlbWVudCk7XFxuXFxuICAgIHRoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KTtcXG5cXG4gICAgY29uc3Qge1xcbiAgICAgIGNvbnRhaW5lclxcbiAgICB9ID0gdGhpcy5fY29uZmlnO1xcbiAgICBEYXRhLnNldCh0aXAsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpO1xcblxcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy50aXApKSB7XFxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRpcCk7XFxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5JTlNFUlRFRCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xcbiAgICAgIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLl9wb3BwZXIgPSBfcG9wcGVyanNfY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJjcmVhdGVQb3BwZXJcXFwiXSh0aGlzLl9lbGVtZW50LCB0aXAsIHRoaXMuX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSk7XFxuICAgIH1cXG5cXG4gICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDMpO1xcbiAgICBjb25zdCBjdXN0b21DbGFzcyA9IHR5cGVvZiB0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MoKSA6IHRoaXMuX2NvbmZpZy5jdXN0b21DbGFzcztcXG5cXG4gICAgaWYgKGN1c3RvbUNsYXNzKSB7XFxuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoLi4uY3VzdG9tQ2xhc3Muc3BsaXQoJyAnKSk7XFxuICAgIH0gLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xcbiAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xcbiAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcXG5cXG5cXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xcbiAgICAgIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICBjb25zdCBwcmV2SG92ZXJTdGF0ZSA9IHRoaXMuX2hvdmVyU3RhdGU7XFxuICAgICAgdGhpcy5faG92ZXJTdGF0ZSA9IG51bGw7XFxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTik7XFxuXFxuICAgICAgaWYgKHByZXZIb3ZlclN0YXRlID09PSBIT1ZFUl9TVEFURV9PVVQpIHtcXG4gICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMyk7XFxuXFxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCBpc0FuaW1hdGVkKTtcXG4gIH1cXG5cXG4gIGhpZGUoKSB7XFxuICAgIGlmICghdGhpcy5fcG9wcGVyKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xcblxcbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICBpZiAodGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9ob3ZlclN0YXRlICE9PSBIT1ZFUl9TVEFURV9TSE9XICYmIHRpcC5wYXJlbnROb2RlKSB7XFxuICAgICAgICB0aXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aXApO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9jbGVhblRpcENsYXNzKCk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcXG5cXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJRERFTik7XFxuXFxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcXG5cXG4gICAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJREUpO1xcblxcbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDMpOyAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxcblxcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XFxuICAgICAgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goZWxlbWVudCA9PiBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKSk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0NMSUNLXSA9IGZhbHNlO1xcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfRk9DVVNdID0gZmFsc2U7XFxuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9IT1ZFUl0gPSBmYWxzZTtcXG4gICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMyk7XFxuXFxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCBpc0FuaW1hdGVkKTtcXG5cXG4gICAgdGhpcy5faG92ZXJTdGF0ZSA9ICcnO1xcbiAgfVxcblxcbiAgdXBkYXRlKCkge1xcbiAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XFxuICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xcbiAgICB9XFxuICB9IC8vIFByb3RlY3RlZFxcblxcblxcbiAgaXNXaXRoQ29udGVudCgpIHtcXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRUaXRsZSgpKTtcXG4gIH1cXG5cXG4gIGdldFRpcEVsZW1lbnQoKSB7XFxuICAgIGlmICh0aGlzLnRpcCkge1xcbiAgICAgIHJldHVybiB0aGlzLnRpcDtcXG4gICAgfVxcblxcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fY29uZmlnLnRlbXBsYXRlO1xcbiAgICB0aGlzLnRpcCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XFxuICAgIHJldHVybiB0aGlzLnRpcDtcXG4gIH1cXG5cXG4gIHNldENvbnRlbnQoKSB7XFxuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xcbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiwgdGlwKSwgdGhpcy5nZXRUaXRsZSgpKTtcXG4gICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9GQURFJDMsIENMQVNTX05BTUVfU0hPVyQzKTtcXG4gIH1cXG5cXG4gIHNldEVsZW1lbnRDb250ZW50KGVsZW1lbnQsIGNvbnRlbnQpIHtcXG4gICAgaWYgKGVsZW1lbnQgPT09IG51bGwpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKGlzRWxlbWVudChjb250ZW50KSkge1xcbiAgICAgIGNvbnRlbnQgPSBnZXRFbGVtZW50KGNvbnRlbnQpOyAvLyBjb250ZW50IGlzIGEgRE9NIG5vZGUgb3IgYSBqUXVlcnlcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmh0bWwpIHtcXG4gICAgICAgIGlmIChjb250ZW50LnBhcmVudE5vZGUgIT09IGVsZW1lbnQpIHtcXG4gICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnJztcXG4gICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjb250ZW50KTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGNvbnRlbnQudGV4dENvbnRlbnQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5fY29uZmlnLmh0bWwpIHtcXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnNhbml0aXplKSB7XFxuICAgICAgICBjb250ZW50ID0gc2FuaXRpemVIdG1sKGNvbnRlbnQsIHRoaXMuX2NvbmZpZy5hbGxvd0xpc3QsIHRoaXMuX2NvbmZpZy5zYW5pdGl6ZUZuKTtcXG4gICAgICB9XFxuXFxuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBjb250ZW50O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBjb250ZW50O1xcbiAgICB9XFxuICB9XFxuXFxuICBnZXRUaXRsZSgpIHtcXG4gICAgbGV0IHRpdGxlID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnKTtcXG5cXG4gICAgaWYgKCF0aXRsZSkge1xcbiAgICAgIHRpdGxlID0gdHlwZW9mIHRoaXMuX2NvbmZpZy50aXRsZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuX2NvbmZpZy50aXRsZS5jYWxsKHRoaXMuX2VsZW1lbnQpIDogdGhpcy5fY29uZmlnLnRpdGxlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aXRsZTtcXG4gIH1cXG5cXG4gIHVwZGF0ZUF0dGFjaG1lbnQoYXR0YWNobWVudCkge1xcbiAgICBpZiAoYXR0YWNobWVudCA9PT0gJ3JpZ2h0Jykge1xcbiAgICAgIHJldHVybiAnZW5kJztcXG4gICAgfVxcblxcbiAgICBpZiAoYXR0YWNobWVudCA9PT0gJ2xlZnQnKSB7XFxuICAgICAgcmV0dXJuICdzdGFydCc7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGF0dGFjaG1lbnQ7XFxuICB9IC8vIFByaXZhdGVcXG5cXG5cXG4gIF9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQsIGNvbnRleHQpIHtcXG4gICAgY29uc3QgZGF0YUtleSA9IHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVk7XFxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IERhdGEuZ2V0KGV2ZW50LmRlbGVnYXRlVGFyZ2V0LCBkYXRhS2V5KTtcXG5cXG4gICAgaWYgKCFjb250ZXh0KSB7XFxuICAgICAgY29udGV4dCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGV2ZW50LmRlbGVnYXRlVGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcXG4gICAgICBEYXRhLnNldChldmVudC5kZWxlZ2F0ZVRhcmdldCwgZGF0YUtleSwgY29udGV4dCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGNvbnRleHQ7XFxuICB9XFxuXFxuICBfZ2V0T2Zmc2V0KCkge1xcbiAgICBjb25zdCB7XFxuICAgICAgb2Zmc2V0XFxuICAgIH0gPSB0aGlzLl9jb25maWc7XFxuXFxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xcbiAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsID0+IE51bWJlci5wYXJzZUludCh2YWwsIDEwKSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICByZXR1cm4gcG9wcGVyRGF0YSA9PiBvZmZzZXQocG9wcGVyRGF0YSwgdGhpcy5fZWxlbWVudCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG9mZnNldDtcXG4gIH1cXG5cXG4gIF9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkge1xcbiAgICBjb25zdCBkZWZhdWx0QnNQb3BwZXJDb25maWcgPSB7XFxuICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxcbiAgICAgIG1vZGlmaWVyczogW3tcXG4gICAgICAgIG5hbWU6ICdmbGlwJyxcXG4gICAgICAgIG9wdGlvbnM6IHtcXG4gICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiB0aGlzLl9jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRzXFxuICAgICAgICB9XFxuICAgICAgfSwge1xcbiAgICAgICAgbmFtZTogJ29mZnNldCcsXFxuICAgICAgICBvcHRpb25zOiB7XFxuICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcXG4gICAgICAgIH1cXG4gICAgICB9LCB7XFxuICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcXG4gICAgICAgIG9wdGlvbnM6IHtcXG4gICAgICAgICAgYm91bmRhcnk6IHRoaXMuX2NvbmZpZy5ib3VuZGFyeVxcbiAgICAgICAgfVxcbiAgICAgIH0sIHtcXG4gICAgICAgIG5hbWU6ICdhcnJvdycsXFxuICAgICAgICBvcHRpb25zOiB7XFxuICAgICAgICAgIGVsZW1lbnQ6IGAuJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9LWFycm93YFxcbiAgICAgICAgfVxcbiAgICAgIH0sIHtcXG4gICAgICAgIG5hbWU6ICdvbkNoYW5nZScsXFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxcbiAgICAgICAgcGhhc2U6ICdhZnRlcldyaXRlJyxcXG4gICAgICAgIGZuOiBkYXRhID0+IHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKVxcbiAgICAgIH1dLFxcbiAgICAgIG9uRmlyc3RVcGRhdGU6IGRhdGEgPT4ge1xcbiAgICAgICAgaWYgKGRhdGEub3B0aW9ucy5wbGFjZW1lbnQgIT09IGRhdGEucGxhY2VtZW50KSB7XFxuICAgICAgICAgIHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuICAgIHJldHVybiB7IC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcXG4gICAgICAuLi4odHlwZW9mIHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGRlZmF1bHRCc1BvcHBlckNvbmZpZykgOiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKVxcbiAgICB9O1xcbiAgfVxcblxcbiAgX2FkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KSB7XFxuICAgIHRoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoYCR7Q0xBU1NfUFJFRklYJDF9LSR7dGhpcy51cGRhdGVBdHRhY2htZW50KGF0dGFjaG1lbnQpfWApO1xcbiAgfVxcblxcbiAgX2dldEF0dGFjaG1lbnQocGxhY2VtZW50KSB7XFxuICAgIHJldHVybiBBdHRhY2htZW50TWFwW3BsYWNlbWVudC50b1VwcGVyQ2FzZSgpXTtcXG4gIH1cXG5cXG4gIF9zZXRMaXN0ZW5lcnMoKSB7XFxuICAgIGNvbnN0IHRyaWdnZXJzID0gdGhpcy5fY29uZmlnLnRyaWdnZXIuc3BsaXQoJyAnKTtcXG5cXG4gICAgdHJpZ2dlcnMuZm9yRWFjaCh0cmlnZ2VyID0+IHtcXG4gICAgICBpZiAodHJpZ2dlciA9PT0gJ2NsaWNrJykge1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuQ0xJQ0ssIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4gdGhpcy50b2dnbGUoZXZlbnQpKTtcXG4gICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgIT09IFRSSUdHRVJfTUFOVUFMKSB7XFxuICAgICAgICBjb25zdCBldmVudEluID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUiA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTjtcXG4gICAgICAgIGNvbnN0IGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VMRUFWRSA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNPVVQ7XFxuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgZXZlbnRJbiwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB0aGlzLl9lbnRlcihldmVudCkpO1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50T3V0LCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHRoaXMuX2xlYXZlKGV2ZW50KSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9ICgpID0+IHtcXG4gICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xcbiAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudC5jbG9zZXN0KGAuJHtDTEFTU19OQU1FX01PREFMfWApLCAnaGlkZS5icy5tb2RhbCcsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xcblxcbiAgICBpZiAodGhpcy5fY29uZmlnLnNlbGVjdG9yKSB7XFxuICAgICAgdGhpcy5fY29uZmlnID0geyAuLi50aGlzLl9jb25maWcsXFxuICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcXG4gICAgICAgIHNlbGVjdG9yOiAnJ1xcbiAgICAgIH07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5fZml4VGl0bGUoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgX2ZpeFRpdGxlKCkge1xcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpO1xcblxcbiAgICBjb25zdCBvcmlnaW5hbFRpdGxlVHlwZSA9IHR5cGVvZiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpO1xcblxcbiAgICBpZiAodGl0bGUgfHwgb3JpZ2luYWxUaXRsZVR5cGUgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnLCB0aXRsZSB8fCAnJyk7XFxuXFxuICAgICAgaWYgKHRpdGxlICYmICF0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpICYmICF0aGlzLl9lbGVtZW50LnRleHRDb250ZW50KSB7XFxuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRpdGxlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJycpO1xcbiAgICB9XFxuICB9XFxuXFxuICBfZW50ZXIoZXZlbnQsIGNvbnRleHQpIHtcXG4gICAgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCwgY29udGV4dCk7XFxuXFxuICAgIGlmIChldmVudCkge1xcbiAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAoY29udGV4dC5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQzKSB8fCBjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIT1ZFUl9TVEFURV9TSE9XKSB7XFxuICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX1NIT1c7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNsZWFyVGltZW91dChjb250ZXh0Ll90aW1lb3V0KTtcXG4gICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX1NIT1c7XFxuXFxuICAgIGlmICghY29udGV4dC5fY29uZmlnLmRlbGF5IHx8ICFjb250ZXh0Ll9jb25maWcuZGVsYXkuc2hvdykge1xcbiAgICAgIGNvbnRleHQuc2hvdygpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb250ZXh0Ll90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XFxuICAgICAgaWYgKGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX1NIT1cpIHtcXG4gICAgICAgIGNvbnRleHQuc2hvdygpO1xcbiAgICAgIH1cXG4gICAgfSwgY29udGV4dC5fY29uZmlnLmRlbGF5LnNob3cpO1xcbiAgfVxcblxcbiAgX2xlYXZlKGV2ZW50LCBjb250ZXh0KSB7XFxuICAgIGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQsIGNvbnRleHQpO1xcblxcbiAgICBpZiAoZXZlbnQpIHtcXG4gICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW2V2ZW50LnR5cGUgPT09ICdmb2N1c291dCcgPyBUUklHR0VSX0ZPQ1VTIDogVFJJR0dFUl9IT1ZFUl0gPSBjb250ZXh0Ll9lbGVtZW50LmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xcbiAgICB9XFxuXFxuICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpO1xcbiAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSE9WRVJfU1RBVEVfT1VUO1xcblxcbiAgICBpZiAoIWNvbnRleHQuX2NvbmZpZy5kZWxheSB8fCAhY29udGV4dC5fY29uZmlnLmRlbGF5LmhpZGUpIHtcXG4gICAgICBjb250ZXh0LmhpZGUoKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29udGV4dC5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgIGlmIChjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIT1ZFUl9TVEFURV9PVVQpIHtcXG4gICAgICAgIGNvbnRleHQuaGlkZSgpO1xcbiAgICAgIH1cXG4gICAgfSwgY29udGV4dC5fY29uZmlnLmRlbGF5LmhpZGUpO1xcbiAgfVxcblxcbiAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XFxuICAgIGZvciAoY29uc3QgdHJpZ2dlciBpbiB0aGlzLl9hY3RpdmVUcmlnZ2VyKSB7XFxuICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRyaWdnZXJbdHJpZ2dlcl0pIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xcbiAgICBjb25zdCBkYXRhQXR0cmlidXRlcyA9IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xcbiAgICBPYmplY3Qua2V5cyhkYXRhQXR0cmlidXRlcykuZm9yRWFjaChkYXRhQXR0ciA9PiB7XFxuICAgICAgaWYgKERJU0FMTE9XRURfQVRUUklCVVRFUy5oYXMoZGF0YUF0dHIpKSB7XFxuICAgICAgICBkZWxldGUgZGF0YUF0dHJpYnV0ZXNbZGF0YUF0dHJdO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIGNvbmZpZyA9IHsgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxcbiAgICAgIC4uLmRhdGFBdHRyaWJ1dGVzLFxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcXG4gICAgfTtcXG4gICAgY29uZmlnLmNvbnRhaW5lciA9IGNvbmZpZy5jb250YWluZXIgPT09IGZhbHNlID8gZG9jdW1lbnQuYm9keSA6IGdldEVsZW1lbnQoY29uZmlnLmNvbnRhaW5lcik7XFxuXFxuICAgIGlmICh0eXBlb2YgY29uZmlnLmRlbGF5ID09PSAnbnVtYmVyJykge1xcbiAgICAgIGNvbmZpZy5kZWxheSA9IHtcXG4gICAgICAgIHNob3c6IGNvbmZpZy5kZWxheSxcXG4gICAgICAgIGhpZGU6IGNvbmZpZy5kZWxheVxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGl0bGUgPT09ICdudW1iZXInKSB7XFxuICAgICAgY29uZmlnLnRpdGxlID0gY29uZmlnLnRpdGxlLnRvU3RyaW5nKCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBjb25maWcuY29udGVudCA9PT0gJ251bWJlcicpIHtcXG4gICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKCk7XFxuICAgIH1cXG5cXG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUkNCwgY29uZmlnLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKTtcXG5cXG4gICAgaWYgKGNvbmZpZy5zYW5pdGl6ZSkge1xcbiAgICAgIGNvbmZpZy50ZW1wbGF0ZSA9IHNhbml0aXplSHRtbChjb25maWcudGVtcGxhdGUsIGNvbmZpZy5hbGxvd0xpc3QsIGNvbmZpZy5zYW5pdGl6ZUZuKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gY29uZmlnO1xcbiAgfVxcblxcbiAgX2dldERlbGVnYXRlQ29uZmlnKCkge1xcbiAgICBjb25zdCBjb25maWcgPSB7fTtcXG5cXG4gICAgaWYgKHRoaXMuX2NvbmZpZykge1xcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuX2NvbmZpZykge1xcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtrZXldICE9PSB0aGlzLl9jb25maWdba2V5XSkge1xcbiAgICAgICAgICBjb25maWdba2V5XSA9IHRoaXMuX2NvbmZpZ1trZXldO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gY29uZmlnO1xcbiAgfVxcblxcbiAgX2NsZWFuVGlwQ2xhc3MoKSB7XFxuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xcbiAgICBjb25zdCB0YWJDbGFzcyA9IHRpcC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYJDEpO1xcblxcbiAgICBpZiAodGFiQ2xhc3MgIT09IG51bGwgJiYgdGFiQ2xhc3MubGVuZ3RoID4gMCkge1xcbiAgICAgIHRhYkNsYXNzLm1hcCh0b2tlbiA9PiB0b2tlbi50cmltKCkpLmZvckVhY2godENsYXNzID0+IHRpcC5jbGFzc0xpc3QucmVtb3ZlKHRDbGFzcykpO1xcbiAgICB9XFxuICB9XFxuXFxuICBfaGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHBvcHBlckRhdGEpIHtcXG4gICAgY29uc3Qge1xcbiAgICAgIHN0YXRlXFxuICAgIH0gPSBwb3BwZXJEYXRhO1xcblxcbiAgICBpZiAoIXN0YXRlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMudGlwID0gc3RhdGUuZWxlbWVudHMucG9wcGVyO1xcblxcbiAgICB0aGlzLl9jbGVhblRpcENsYXNzKCk7XFxuXFxuICAgIHRoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyh0aGlzLl9nZXRBdHRhY2htZW50KHN0YXRlLnBsYWNlbWVudCkpO1xcbiAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgIGxldCBkYXRhID0gRGF0YS5nZXQodGhpcywgREFUQV9LRVkkNCk7XFxuXFxuICAgICAgY29uc3QgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZztcXG5cXG4gICAgICBpZiAoIWRhdGEgJiYgL2Rpc3Bvc2V8aGlkZS8udGVzdChjb25maWcpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghZGF0YSkge1xcbiAgICAgICAgZGF0YSA9IG5ldyBUb29sdGlwKHRoaXMsIF9jb25maWcpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxufVxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGpRdWVyeVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGFkZCAuVG9vbHRpcCB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxcbiAqL1xcblxcblxcbmRlZmluZUpRdWVyeVBsdWdpbihUb29sdGlwKTtcXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIEJvb3RzdHJhcCAodjUuMC4xKTogcG9wb3Zlci5qc1xcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ29uc3RhbnRzXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuY29uc3QgTkFNRSQzID0gJ3BvcG92ZXInO1xcbmNvbnN0IERBVEFfS0VZJDMgPSAnYnMucG9wb3Zlcic7XFxuY29uc3QgRVZFTlRfS0VZJDMgPSBgLiR7REFUQV9LRVkkM31gO1xcbmNvbnN0IENMQVNTX1BSRUZJWCA9ICdicy1wb3BvdmVyJztcXG5jb25zdCBCU0NMU19QUkVGSVhfUkVHRVggPSBuZXcgUmVnRXhwKGAoXnxcXFxcXFxcXHMpJHtDTEFTU19QUkVGSVh9XFxcXFxcXFxTK2AsICdnJyk7XFxuY29uc3QgRGVmYXVsdCQyID0geyAuLi5Ub29sdGlwLkRlZmF1bHQsXFxuICBwbGFjZW1lbnQ6ICdyaWdodCcsXFxuICBvZmZzZXQ6IFswLCA4XSxcXG4gIHRyaWdnZXI6ICdjbGljaycsXFxuICBjb250ZW50OiAnJyxcXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cXFwicG9wb3ZlclxcXCIgcm9sZT1cXFwidG9vbHRpcFxcXCI+JyArICc8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWFycm93XFxcIj48L2Rpdj4nICsgJzxoMyBjbGFzcz1cXFwicG9wb3Zlci1oZWFkZXJcXFwiPjwvaDM+JyArICc8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWJvZHlcXFwiPjwvZGl2PicgKyAnPC9kaXY+J1xcbn07XFxuY29uc3QgRGVmYXVsdFR5cGUkMiA9IHsgLi4uVG9vbHRpcC5EZWZhdWx0VHlwZSxcXG4gIGNvbnRlbnQ6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJ1xcbn07XFxuY29uc3QgRXZlbnQkMSA9IHtcXG4gIEhJREU6IGBoaWRlJHtFVkVOVF9LRVkkM31gLFxcbiAgSElEREVOOiBgaGlkZGVuJHtFVkVOVF9LRVkkM31gLFxcbiAgU0hPVzogYHNob3cke0VWRU5UX0tFWSQzfWAsXFxuICBTSE9XTjogYHNob3duJHtFVkVOVF9LRVkkM31gLFxcbiAgSU5TRVJURUQ6IGBpbnNlcnRlZCR7RVZFTlRfS0VZJDN9YCxcXG4gIENMSUNLOiBgY2xpY2ske0VWRU5UX0tFWSQzfWAsXFxuICBGT0NVU0lOOiBgZm9jdXNpbiR7RVZFTlRfS0VZJDN9YCxcXG4gIEZPQ1VTT1VUOiBgZm9jdXNvdXQke0VWRU5UX0tFWSQzfWAsXFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7RVZFTlRfS0VZJDN9YCxcXG4gIE1PVVNFTEVBVkU6IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVkkM31gXFxufTtcXG5jb25zdCBDTEFTU19OQU1FX0ZBREUkMiA9ICdmYWRlJztcXG5jb25zdCBDTEFTU19OQU1FX1NIT1ckMiA9ICdzaG93JztcXG5jb25zdCBTRUxFQ1RPUl9USVRMRSA9ICcucG9wb3Zlci1oZWFkZXInO1xcbmNvbnN0IFNFTEVDVE9SX0NPTlRFTlQgPSAnLnBvcG92ZXItYm9keSc7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBUb29sdGlwIHtcXG4gIC8vIEdldHRlcnNcXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgcmV0dXJuIERlZmF1bHQkMjtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgcmV0dXJuIE5BTUUkMztcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgRXZlbnQoKSB7XFxuICAgIHJldHVybiBFdmVudCQxO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcXG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDI7XFxuICB9IC8vIE92ZXJyaWRlc1xcblxcblxcbiAgaXNXaXRoQ29udGVudCgpIHtcXG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XFxuICB9XFxuXFxuICBzZXRDb250ZW50KCkge1xcbiAgICBjb25zdCB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTsgLy8gd2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xcblxcbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfVElUTEUsIHRpcCksIHRoaXMuZ2V0VGl0bGUoKSk7XFxuXFxuICAgIGxldCBjb250ZW50ID0gdGhpcy5fZ2V0Q29udGVudCgpO1xcblxcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBjb250ZW50ID0gY29udGVudC5jYWxsKHRoaXMuX2VsZW1lbnQpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQoU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9DT05URU5ULCB0aXApLCBjb250ZW50KTtcXG4gICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9GQURFJDIsIENMQVNTX05BTUVfU0hPVyQyKTtcXG4gIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgX2FkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KSB7XFxuICAgIHRoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoYCR7Q0xBU1NfUFJFRklYfS0ke3RoaXMudXBkYXRlQXR0YWNobWVudChhdHRhY2htZW50KX1gKTtcXG4gIH1cXG5cXG4gIF9nZXRDb250ZW50KCkge1xcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtY29udGVudCcpIHx8IHRoaXMuX2NvbmZpZy5jb250ZW50O1xcbiAgfVxcblxcbiAgX2NsZWFuVGlwQ2xhc3MoKSB7XFxuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xcbiAgICBjb25zdCB0YWJDbGFzcyA9IHRpcC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYKTtcXG5cXG4gICAgaWYgKHRhYkNsYXNzICE9PSBudWxsICYmIHRhYkNsYXNzLmxlbmd0aCA+IDApIHtcXG4gICAgICB0YWJDbGFzcy5tYXAodG9rZW4gPT4gdG9rZW4udHJpbSgpKS5mb3JFYWNoKHRDbGFzcyA9PiB0aXAuY2xhc3NMaXN0LnJlbW92ZSh0Q2xhc3MpKTtcXG4gICAgfVxcbiAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgIGxldCBkYXRhID0gRGF0YS5nZXQodGhpcywgREFUQV9LRVkkMyk7XFxuXFxuICAgICAgY29uc3QgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDogbnVsbDtcXG5cXG4gICAgICBpZiAoIWRhdGEgJiYgL2Rpc3Bvc2V8aGlkZS8udGVzdChjb25maWcpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghZGF0YSkge1xcbiAgICAgICAgZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIF9jb25maWcpO1xcbiAgICAgICAgRGF0YS5zZXQodGhpcywgREFUQV9LRVkkMywgZGF0YSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcXFwiJHtjb25maWd9XFxcImApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGF0YVtjb25maWddKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG5cXG59XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogalF1ZXJ5XFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogYWRkIC5Qb3BvdmVyIHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XFxuICovXFxuXFxuXFxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFBvcG92ZXIpO1xcblxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQm9vdHN0cmFwICh2NS4wLjEpOiBzY3JvbGxzcHkuanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIENvbnN0YW50c1xcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNvbnN0IE5BTUUkMiA9ICdzY3JvbGxzcHknO1xcbmNvbnN0IERBVEFfS0VZJDIgPSAnYnMuc2Nyb2xsc3B5JztcXG5jb25zdCBFVkVOVF9LRVkkMiA9IGAuJHtEQVRBX0tFWSQyfWA7XFxuY29uc3QgREFUQV9BUElfS0VZJDEgPSAnLmRhdGEtYXBpJztcXG5jb25zdCBEZWZhdWx0JDEgPSB7XFxuICBvZmZzZXQ6IDEwLFxcbiAgbWV0aG9kOiAnYXV0bycsXFxuICB0YXJnZXQ6ICcnXFxufTtcXG5jb25zdCBEZWZhdWx0VHlwZSQxID0ge1xcbiAgb2Zmc2V0OiAnbnVtYmVyJyxcXG4gIG1ldGhvZDogJ3N0cmluZycsXFxuICB0YXJnZXQ6ICcoc3RyaW5nfGVsZW1lbnQpJ1xcbn07XFxuY29uc3QgRVZFTlRfQUNUSVZBVEUgPSBgYWN0aXZhdGUke0VWRU5UX0tFWSQyfWA7XFxuY29uc3QgRVZFTlRfU0NST0xMID0gYHNjcm9sbCR7RVZFTlRfS0VZJDJ9YDtcXG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJID0gYGxvYWQke0VWRU5UX0tFWSQyfSR7REFUQV9BUElfS0VZJDF9YDtcXG5jb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0lURU0gPSAnZHJvcGRvd24taXRlbSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMSA9ICdhY3RpdmUnO1xcbmNvbnN0IFNFTEVDVE9SX0RBVEFfU1BZID0gJ1tkYXRhLWJzLXNweT1cXFwic2Nyb2xsXFxcIl0nO1xcbmNvbnN0IFNFTEVDVE9SX05BVl9MSVNUX0dST1VQJDEgPSAnLm5hdiwgLmxpc3QtZ3JvdXAnO1xcbmNvbnN0IFNFTEVDVE9SX05BVl9MSU5LUyA9ICcubmF2LWxpbmsnO1xcbmNvbnN0IFNFTEVDVE9SX05BVl9JVEVNUyA9ICcubmF2LWl0ZW0nO1xcbmNvbnN0IFNFTEVDVE9SX0xJU1RfSVRFTVMgPSAnLmxpc3QtZ3JvdXAtaXRlbSc7XFxuY29uc3QgU0VMRUNUT1JfRFJPUERPV04kMSA9ICcuZHJvcGRvd24nO1xcbmNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxID0gJy5kcm9wZG93bi10b2dnbGUnO1xcbmNvbnN0IE1FVEhPRF9PRkZTRVQgPSAnb2Zmc2V0JztcXG5jb25zdCBNRVRIT0RfUE9TSVRJT04gPSAncG9zaXRpb24nO1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIENsYXNzIERlZmluaXRpb25cXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jbGFzcyBTY3JvbGxTcHkgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xcbiAgICBzdXBlcihlbGVtZW50KTtcXG4gICAgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQudGFnTmFtZSA9PT0gJ0JPRFknID8gd2luZG93IDogdGhpcy5fZWxlbWVudDtcXG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XFxuICAgIHRoaXMuX3NlbGVjdG9yID0gYCR7dGhpcy5fY29uZmlnLnRhcmdldH0gJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke3RoaXMuX2NvbmZpZy50YXJnZXR9ICR7U0VMRUNUT1JfTElTVF9JVEVNU30sICR7dGhpcy5fY29uZmlnLnRhcmdldH0gLiR7Q0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNfWA7XFxuICAgIHRoaXMuX29mZnNldHMgPSBbXTtcXG4gICAgdGhpcy5fdGFyZ2V0cyA9IFtdO1xcbiAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xcbiAgICB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwO1xcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fc2Nyb2xsRWxlbWVudCwgRVZFTlRfU0NST0xMLCAoKSA9PiB0aGlzLl9wcm9jZXNzKCkpO1xcbiAgICB0aGlzLnJlZnJlc2goKTtcXG5cXG4gICAgdGhpcy5fcHJvY2VzcygpO1xcbiAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgIHJldHVybiBEZWZhdWx0JDE7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgIHJldHVybiBOQU1FJDI7XFxuICB9IC8vIFB1YmxpY1xcblxcblxcbiAgcmVmcmVzaCgpIHtcXG4gICAgY29uc3QgYXV0b01ldGhvZCA9IHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHRoaXMuX3Njcm9sbEVsZW1lbnQud2luZG93ID8gTUVUSE9EX09GRlNFVCA6IE1FVEhPRF9QT1NJVElPTjtcXG4gICAgY29uc3Qgb2Zmc2V0TWV0aG9kID0gdGhpcy5fY29uZmlnLm1ldGhvZCA9PT0gJ2F1dG8nID8gYXV0b01ldGhvZCA6IHRoaXMuX2NvbmZpZy5tZXRob2Q7XFxuICAgIGNvbnN0IG9mZnNldEJhc2UgPSBvZmZzZXRNZXRob2QgPT09IE1FVEhPRF9QT1NJVElPTiA/IHRoaXMuX2dldFNjcm9sbFRvcCgpIDogMDtcXG4gICAgdGhpcy5fb2Zmc2V0cyA9IFtdO1xcbiAgICB0aGlzLl90YXJnZXRzID0gW107XFxuICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpO1xcbiAgICBjb25zdCB0YXJnZXRzID0gU2VsZWN0b3JFbmdpbmUuZmluZCh0aGlzLl9zZWxlY3Rvcik7XFxuICAgIHRhcmdldHMubWFwKGVsZW1lbnQgPT4ge1xcbiAgICAgIGNvbnN0IHRhcmdldFNlbGVjdG9yID0gZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KTtcXG4gICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTZWxlY3RvciA/IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUodGFyZ2V0U2VsZWN0b3IpIDogbnVsbDtcXG5cXG4gICAgICBpZiAodGFyZ2V0KSB7XFxuICAgICAgICBjb25zdCB0YXJnZXRCQ1IgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFxuICAgICAgICBpZiAodGFyZ2V0QkNSLndpZHRoIHx8IHRhcmdldEJDUi5oZWlnaHQpIHtcXG4gICAgICAgICAgcmV0dXJuIFtNYW5pcHVsYXRvcltvZmZzZXRNZXRob2RdKHRhcmdldCkudG9wICsgb2Zmc2V0QmFzZSwgdGFyZ2V0U2VsZWN0b3JdO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfSkuZmlsdGVyKGl0ZW0gPT4gaXRlbSkuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pLmZvckVhY2goaXRlbSA9PiB7XFxuICAgICAgdGhpcy5fb2Zmc2V0cy5wdXNoKGl0ZW1bMF0pO1xcblxcbiAgICAgIHRoaXMuX3RhcmdldHMucHVzaChpdGVtWzFdKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBkaXNwb3NlKCkge1xcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX3Njcm9sbEVsZW1lbnQsIEVWRU5UX0tFWSQyKTtcXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xcbiAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xcbiAgICBjb25maWcgPSB7IC4uLkRlZmF1bHQkMSxcXG4gICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcXG4gICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pXFxuICAgIH07XFxuXFxuICAgIGlmICh0eXBlb2YgY29uZmlnLnRhcmdldCAhPT0gJ3N0cmluZycgJiYgaXNFbGVtZW50KGNvbmZpZy50YXJnZXQpKSB7XFxuICAgICAgbGV0IHtcXG4gICAgICAgIGlkXFxuICAgICAgfSA9IGNvbmZpZy50YXJnZXQ7XFxuXFxuICAgICAgaWYgKCFpZCkge1xcbiAgICAgICAgaWQgPSBnZXRVSUQoTkFNRSQyKTtcXG4gICAgICAgIGNvbmZpZy50YXJnZXQuaWQgPSBpZDtcXG4gICAgICB9XFxuXFxuICAgICAgY29uZmlnLnRhcmdldCA9IGAjJHtpZH1gO1xcbiAgICB9XFxuXFxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FJDIsIGNvbmZpZywgRGVmYXVsdFR5cGUkMSk7XFxuICAgIHJldHVybiBjb25maWc7XFxuICB9XFxuXFxuICBfZ2V0U2Nyb2xsVG9wKCkge1xcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gdGhpcy5fc2Nyb2xsRWxlbWVudC5wYWdlWU9mZnNldCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsVG9wO1xcbiAgfVxcblxcbiAgX2dldFNjcm9sbEhlaWdodCgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IHx8IE1hdGgubWF4KGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0KTtcXG4gIH1cXG5cXG4gIF9nZXRPZmZzZXRIZWlnaHQoKSB7XFxuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcXG4gIH1cXG5cXG4gIF9wcm9jZXNzKCkge1xcbiAgICBjb25zdCBzY3JvbGxUb3AgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKSArIHRoaXMuX2NvbmZpZy5vZmZzZXQ7XFxuXFxuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpO1xcblxcbiAgICBjb25zdCBtYXhTY3JvbGwgPSB0aGlzLl9jb25maWcub2Zmc2V0ICsgc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fZ2V0T2Zmc2V0SGVpZ2h0KCk7XFxuXFxuICAgIGlmICh0aGlzLl9zY3JvbGxIZWlnaHQgIT09IHNjcm9sbEhlaWdodCkge1xcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xcbiAgICB9XFxuXFxuICAgIGlmIChzY3JvbGxUb3AgPj0gbWF4U2Nyb2xsKSB7XFxuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1t0aGlzLl90YXJnZXRzLmxlbmd0aCAtIDFdO1xcblxcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRhcmdldCkge1xcbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgJiYgc2Nyb2xsVG9wIDwgdGhpcy5fb2Zmc2V0c1swXSAmJiB0aGlzLl9vZmZzZXRzWzBdID4gMCkge1xcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XFxuXFxuICAgICAgdGhpcy5fY2xlYXIoKTtcXG5cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuX29mZnNldHMubGVuZ3RoOyBpLS07KSB7XFxuICAgICAgY29uc3QgaXNBY3RpdmVUYXJnZXQgPSB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbaV0gJiYgc2Nyb2xsVG9wID49IHRoaXMuX29mZnNldHNbaV0gJiYgKHR5cGVvZiB0aGlzLl9vZmZzZXRzW2kgKyAxXSA9PT0gJ3VuZGVmaW5lZCcgfHwgc2Nyb2xsVG9wIDwgdGhpcy5fb2Zmc2V0c1tpICsgMV0pO1xcblxcbiAgICAgIGlmIChpc0FjdGl2ZVRhcmdldCkge1xcbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fdGFyZ2V0c1tpXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBfYWN0aXZhdGUodGFyZ2V0KSB7XFxuICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldDtcXG5cXG4gICAgdGhpcy5fY2xlYXIoKTtcXG5cXG4gICAgY29uc3QgcXVlcmllcyA9IHRoaXMuX3NlbGVjdG9yLnNwbGl0KCcsJykubWFwKHNlbGVjdG9yID0+IGAke3NlbGVjdG9yfVtkYXRhLWJzLXRhcmdldD1cXFwiJHt0YXJnZXR9XFxcIl0sJHtzZWxlY3Rvcn1baHJlZj1cXFwiJHt0YXJnZXR9XFxcIl1gKTtcXG5cXG4gICAgY29uc3QgbGluayA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUocXVlcmllcy5qb2luKCcsJykpO1xcblxcbiAgICBpZiAobGluay5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNKSkge1xcbiAgICAgIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEsIGxpbmsuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTiQxKSkuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcXG4gICAgICBsaW5rLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rIGFzIGFjdGl2ZVxcbiAgICAgIGxpbmsuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcXG4gICAgICBTZWxlY3RvckVuZ2luZS5wYXJlbnRzKGxpbmssIFNFTEVDVE9SX05BVl9MSVNUX0dST1VQJDEpLmZvckVhY2gobGlzdEdyb3VwID0+IHtcXG4gICAgICAgIC8vIFNldCB0cmlnZ2VyZWQgbGlua3MgcGFyZW50cyBhcyBhY3RpdmVcXG4gICAgICAgIC8vIFdpdGggYm90aCA8dWw+IGFuZCA8bmF2PiBtYXJrdXAgYSBwYXJlbnQgaXMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYW55IG5hdiBhbmNlc3RvclxcbiAgICAgICAgU2VsZWN0b3JFbmdpbmUucHJldihsaXN0R3JvdXAsIGAke1NFTEVDVE9SX05BVl9MSU5LU30sICR7U0VMRUNUT1JfTElTVF9JVEVNU31gKS5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpKTsgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSB3aGVuIC5uYXYtbGluayBpcyBpbnNpZGUgLm5hdi1pdGVtXFxuXFxuICAgICAgICBTZWxlY3RvckVuZ2luZS5wcmV2KGxpc3RHcm91cCwgU0VMRUNUT1JfTkFWX0lURU1TKS5mb3JFYWNoKG5hdkl0ZW0gPT4ge1xcbiAgICAgICAgICBTZWxlY3RvckVuZ2luZS5jaGlsZHJlbihuYXZJdGVtLCBTRUxFQ1RPUl9OQVZfTElOS1MpLmZvckVhY2goaXRlbSA9PiBpdGVtLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fc2Nyb2xsRWxlbWVudCwgRVZFTlRfQUNUSVZBVEUsIHtcXG4gICAgICByZWxhdGVkVGFyZ2V0OiB0YXJnZXRcXG4gICAgfSk7XFxuICB9XFxuXFxuICBfY2xlYXIoKSB7XFxuICAgIFNlbGVjdG9yRW5naW5lLmZpbmQodGhpcy5fc2VsZWN0b3IpLmZpbHRlcihub2RlID0+IG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFJDEpKS5mb3JFYWNoKG5vZGUgPT4gbm9kZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpKTtcXG4gIH0gLy8gU3RhdGljXFxuXFxuXFxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICBjb25zdCBkYXRhID0gU2Nyb2xsU3B5LmdldEluc3RhbmNlKHRoaXMpIHx8IG5ldyBTY3JvbGxTcHkodGhpcywgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiB7fSk7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFxcXCIke2NvbmZpZ31cXFwiYCk7XFxuICAgICAgfVxcblxcbiAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG59XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5cXG5FdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJLCAoKSA9PiB7XFxuICBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfU1BZKS5mb3JFYWNoKHNweSA9PiBuZXcgU2Nyb2xsU3B5KHNweSkpO1xcbn0pO1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGpRdWVyeVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGFkZCAuU2Nyb2xsU3B5IHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XFxuICovXFxuXFxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFNjcm9sbFNweSk7XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IHRhYi5qc1xcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ29uc3RhbnRzXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuY29uc3QgTkFNRSQxID0gJ3RhYic7XFxuY29uc3QgREFUQV9LRVkkMSA9ICdicy50YWInO1xcbmNvbnN0IEVWRU5UX0tFWSQxID0gYC4ke0RBVEFfS0VZJDF9YDtcXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcXG5jb25zdCBFVkVOVF9ISURFJDEgPSBgaGlkZSR7RVZFTlRfS0VZJDF9YDtcXG5jb25zdCBFVkVOVF9ISURERU4kMSA9IGBoaWRkZW4ke0VWRU5UX0tFWSQxfWA7XFxuY29uc3QgRVZFTlRfU0hPVyQxID0gYHNob3cke0VWRU5UX0tFWSQxfWA7XFxuY29uc3QgRVZFTlRfU0hPV04kMSA9IGBzaG93biR7RVZFTlRfS0VZJDF9YDtcXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSA9IGBjbGljayR7RVZFTlRfS0VZJDF9JHtEQVRBX0FQSV9LRVl9YDtcXG5jb25zdCBDTEFTU19OQU1FX0RST1BET1dOX01FTlUgPSAnZHJvcGRvd24tbWVudSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUgPSAnYWN0aXZlJztcXG5jb25zdCBDTEFTU19OQU1FX0ZBREUkMSA9ICdmYWRlJztcXG5jb25zdCBDTEFTU19OQU1FX1NIT1ckMSA9ICdzaG93JztcXG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTiA9ICcuZHJvcGRvd24nO1xcbmNvbnN0IFNFTEVDVE9SX05BVl9MSVNUX0dST1VQID0gJy5uYXYsIC5saXN0LWdyb3VwJztcXG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkUgPSAnLmFjdGl2ZSc7XFxuY29uc3QgU0VMRUNUT1JfQUNUSVZFX1VMID0gJzpzY29wZSA+IGxpID4gLmFjdGl2ZSc7XFxuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtYnMtdG9nZ2xlPVxcXCJ0YWJcXFwiXSwgW2RhdGEtYnMtdG9nZ2xlPVxcXCJwaWxsXFxcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cXFwibGlzdFxcXCJdJztcXG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUgPSAnLmRyb3Bkb3duLXRvZ2dsZSc7XFxuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fQUNUSVZFX0NISUxEID0gJzpzY29wZSA+IC5kcm9wZG93bi1tZW51IC5hY3RpdmUnO1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIENsYXNzIERlZmluaXRpb25cXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jbGFzcyBUYWIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gIC8vIEdldHRlcnNcXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgcmV0dXJuIE5BTUUkMTtcXG4gIH0gLy8gUHVibGljXFxuXFxuXFxuICBzaG93KCkge1xcbiAgICBpZiAodGhpcy5fZWxlbWVudC5wYXJlbnROb2RlICYmIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGxldCBwcmV2aW91cztcXG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzLl9lbGVtZW50KTtcXG5cXG4gICAgY29uc3QgbGlzdEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVApO1xcblxcbiAgICBpZiAobGlzdEVsZW1lbnQpIHtcXG4gICAgICBjb25zdCBpdGVtU2VsZWN0b3IgPSBsaXN0RWxlbWVudC5ub2RlTmFtZSA9PT0gJ1VMJyB8fCBsaXN0RWxlbWVudC5ub2RlTmFtZSA9PT0gJ09MJyA/IFNFTEVDVE9SX0FDVElWRV9VTCA6IFNFTEVDVE9SX0FDVElWRTtcXG4gICAgICBwcmV2aW91cyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoaXRlbVNlbGVjdG9yLCBsaXN0RWxlbWVudCk7XFxuICAgICAgcHJldmlvdXMgPSBwcmV2aW91c1twcmV2aW91cy5sZW5ndGggLSAxXTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBwcmV2aW91cyA/IEV2ZW50SGFuZGxlci50cmlnZ2VyKHByZXZpb3VzLCBFVkVOVF9ISURFJDEsIHtcXG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XFxuICAgIH0pIDogbnVsbDtcXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQxLCB7XFxuICAgICAgcmVsYXRlZFRhcmdldDogcHJldmlvdXNcXG4gICAgfSk7XFxuXFxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCBoaWRlRXZlbnQgIT09IG51bGwgJiYgaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fZWxlbWVudCwgbGlzdEVsZW1lbnQpO1xcblxcbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcihwcmV2aW91cywgRVZFTlRfSElEREVOJDEsIHtcXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcXG4gICAgICB9KTtcXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQxLCB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBpZiAodGFyZ2V0KSB7XFxuICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0LCB0YXJnZXQucGFyZW50Tm9kZSwgY29tcGxldGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNvbXBsZXRlKCk7XFxuICAgIH1cXG4gIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgX2FjdGl2YXRlKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcXG4gICAgY29uc3QgYWN0aXZlRWxlbWVudHMgPSBjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlTmFtZSA9PT0gJ1VMJyB8fCBjb250YWluZXIubm9kZU5hbWUgPT09ICdPTCcpID8gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9BQ1RJVkVfVUwsIGNvbnRhaW5lcikgOiBTZWxlY3RvckVuZ2luZS5jaGlsZHJlbihjb250YWluZXIsIFNFTEVDVE9SX0FDVElWRSk7XFxuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzWzBdO1xcbiAgICBjb25zdCBpc1RyYW5zaXRpb25pbmcgPSBjYWxsYmFjayAmJiBhY3RpdmUgJiYgYWN0aXZlLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMSk7XFxuXFxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4gdGhpcy5fdHJhbnNpdGlvbkNvbXBsZXRlKGVsZW1lbnQsIGFjdGl2ZSwgY2FsbGJhY2spO1xcblxcbiAgICBpZiAoYWN0aXZlICYmIGlzVHJhbnNpdGlvbmluZykge1xcbiAgICAgIGFjdGl2ZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQxKTtcXG5cXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCBlbGVtZW50LCB0cnVlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjb21wbGV0ZSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBfdHJhbnNpdGlvbkNvbXBsZXRlKGVsZW1lbnQsIGFjdGl2ZSwgY2FsbGJhY2spIHtcXG4gICAgaWYgKGFjdGl2ZSkge1xcbiAgICAgIGFjdGl2ZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKTtcXG4gICAgICBjb25zdCBkcm9wZG93bkNoaWxkID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9EUk9QRE9XTl9BQ1RJVkVfQ0hJTEQsIGFjdGl2ZS5wYXJlbnROb2RlKTtcXG5cXG4gICAgICBpZiAoZHJvcGRvd25DaGlsZCkge1xcbiAgICAgICAgZHJvcGRvd25DaGlsZC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGFjdGl2ZS5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ3RhYicpIHtcXG4gICAgICAgIGFjdGl2ZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSk7XFxuXFxuICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAndGFiJykge1xcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XFxuICAgIH1cXG5cXG4gICAgcmVmbG93KGVsZW1lbnQpO1xcblxcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDEpKSB7XFxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQxKTtcXG4gICAgfVxcblxcbiAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xcblxcbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlTmFtZSA9PT0gJ0xJJykge1xcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xcbiAgICB9XFxuXFxuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX01FTlUpKSB7XFxuICAgICAgY29uc3QgZHJvcGRvd25FbGVtZW50ID0gZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX0RST1BET1dOKTtcXG5cXG4gICAgICBpZiAoZHJvcGRvd25FbGVtZW50KSB7XFxuICAgICAgICBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSwgZHJvcGRvd25FbGVtZW50KS5mb3JFYWNoKGRyb3Bkb3duID0+IGRyb3Bkb3duLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpKTtcXG4gICAgICB9XFxuXFxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcXG4gICAgfVxcblxcbiAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICBjYWxsYmFjaygpO1xcbiAgICB9XFxuICB9IC8vIFN0YXRpY1xcblxcblxcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgY29uc3QgZGF0YSA9IERhdGEuZ2V0KHRoaXMsIERBVEFfS0VZJDEpIHx8IG5ldyBUYWIodGhpcyk7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFxcXCIke2NvbmZpZ31cXFwiYCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcblxcbn1cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcblxcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gIH1cXG5cXG4gIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGNvbnN0IGRhdGEgPSBEYXRhLmdldCh0aGlzLCBEQVRBX0tFWSQxKSB8fCBuZXcgVGFiKHRoaXMpO1xcbiAgZGF0YS5zaG93KCk7XFxufSk7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogalF1ZXJ5XFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogYWRkIC5UYWIgdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcXG4gKi9cXG5cXG5kZWZpbmVKUXVlcnlQbHVnaW4oVGFiKTtcXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIEJvb3RzdHJhcCAodjUuMC4xKTogdG9hc3QuanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIENvbnN0YW50c1xcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNvbnN0IE5BTUUgPSAndG9hc3QnO1xcbmNvbnN0IERBVEFfS0VZID0gJ2JzLnRvYXN0JztcXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YDtcXG5jb25zdCBFVkVOVF9DTElDS19ESVNNSVNTID0gYGNsaWNrLmRpc21pc3Mke0VWRU5UX0tFWX1gO1xcbmNvbnN0IEVWRU5UX01PVVNFT1ZFUiA9IGBtb3VzZW92ZXIke0VWRU5UX0tFWX1gO1xcbmNvbnN0IEVWRU5UX01PVVNFT1VUID0gYG1vdXNlb3V0JHtFVkVOVF9LRVl9YDtcXG5jb25zdCBFVkVOVF9GT0NVU0lOID0gYGZvY3VzaW4ke0VWRU5UX0tFWX1gO1xcbmNvbnN0IEVWRU5UX0ZPQ1VTT1VUID0gYGZvY3Vzb3V0JHtFVkVOVF9LRVl9YDtcXG5jb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gO1xcbmNvbnN0IEVWRU5UX0hJRERFTiA9IGBoaWRkZW4ke0VWRU5UX0tFWX1gO1xcbmNvbnN0IEVWRU5UX1NIT1cgPSBgc2hvdyR7RVZFTlRfS0VZfWA7XFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gO1xcbmNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJztcXG5jb25zdCBDTEFTU19OQU1FX0hJREUgPSAnaGlkZSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnO1xcbmNvbnN0IENMQVNTX05BTUVfU0hPV0lORyA9ICdzaG93aW5nJztcXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcXG4gIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxcbiAgYXV0b2hpZGU6ICdib29sZWFuJyxcXG4gIGRlbGF5OiAnbnVtYmVyJ1xcbn07XFxuY29uc3QgRGVmYXVsdCA9IHtcXG4gIGFuaW1hdGlvbjogdHJ1ZSxcXG4gIGF1dG9oaWRlOiB0cnVlLFxcbiAgZGVsYXk6IDUwMDBcXG59O1xcbmNvbnN0IFNFTEVDVE9SX0RBVEFfRElTTUlTUyA9ICdbZGF0YS1icy1kaXNtaXNzPVxcXCJ0b2FzdFxcXCJdJztcXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDbGFzcyBEZWZpbml0aW9uXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuY2xhc3MgVG9hc3QgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xcbiAgICBzdXBlcihlbGVtZW50KTtcXG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XFxuICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xcbiAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gZmFsc2U7XFxuICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBmYWxzZTtcXG5cXG4gICAgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XFxuICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgIHJldHVybiBEZWZhdWx0VHlwZTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgcmV0dXJuIERlZmF1bHQ7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgIHJldHVybiBOQU1FO1xcbiAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gIHNob3coKSB7XFxuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1cpO1xcblxcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XFxuXFxuICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSk7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORyk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyk7XFxuXFxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04pO1xcblxcbiAgICAgIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0hJREUpO1xcblxcbiAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1dJTkcpO1xcblxcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcXG4gIH1cXG5cXG4gIGhpZGUoKSB7XFxuICAgIGlmICghdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFKTtcXG5cXG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJREUpO1xcblxcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTik7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpO1xcblxcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcXG4gIH1cXG5cXG4gIGRpc3Bvc2UoKSB7XFxuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xcblxcbiAgICBpZiAodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpO1xcbiAgICB9XFxuXFxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcXG4gIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgY29uZmlnID0geyAuLi5EZWZhdWx0LFxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcXG4gICAgfTtcXG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSk7XFxuICAgIHJldHVybiBjb25maWc7XFxuICB9XFxuXFxuICBfbWF5YmVTY2hlZHVsZUhpZGUoKSB7XFxuICAgIGlmICghdGhpcy5fY29uZmlnLmF1dG9oaWRlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uIHx8IHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24pIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpO1xcbiAgfVxcblxcbiAgX29uSW50ZXJhY3Rpb24oZXZlbnQsIGlzSW50ZXJhY3RpbmcpIHtcXG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XFxuICAgICAgY2FzZSAnbW91c2VvdmVyJzpcXG4gICAgICBjYXNlICdtb3VzZW91dCc6XFxuICAgICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gaXNJbnRlcmFjdGluZztcXG4gICAgICAgIGJyZWFrO1xcblxcbiAgICAgIGNhc2UgJ2ZvY3VzaW4nOlxcbiAgICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcXG4gICAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nO1xcbiAgICAgICAgYnJlYWs7XFxuICAgIH1cXG5cXG4gICAgaWYgKGlzSW50ZXJhY3RpbmcpIHtcXG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcXG5cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgbmV4dEVsZW1lbnQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xcblxcbiAgICBpZiAodGhpcy5fZWxlbWVudCA9PT0gbmV4dEVsZW1lbnQgfHwgdGhpcy5fZWxlbWVudC5jb250YWlucyhuZXh0RWxlbWVudCkpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcXG4gIH1cXG5cXG4gIF9zZXRMaXN0ZW5lcnMoKSB7XFxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTLCBTRUxFQ1RPUl9EQVRBX0RJU01JU1MsICgpID0+IHRoaXMuaGlkZSgpKTtcXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1ZFUiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpO1xcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VPVVQsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIGZhbHNlKSk7XFxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU0lOLCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCB0cnVlKSk7XFxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU09VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKTtcXG4gIH1cXG5cXG4gIF9jbGVhclRpbWVvdXQoKSB7XFxuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcXG4gICAgdGhpcy5fdGltZW91dCA9IG51bGw7XFxuICB9IC8vIFN0YXRpY1xcblxcblxcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgbGV0IGRhdGEgPSBEYXRhLmdldCh0aGlzLCBEQVRBX0tFWSk7XFxuXFxuICAgICAgY29uc3QgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZztcXG5cXG4gICAgICBpZiAoIWRhdGEpIHtcXG4gICAgICAgIGRhdGEgPSBuZXcgVG9hc3QodGhpcywgX2NvbmZpZyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcXFwiJHtjb25maWd9XFxcImApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxufVxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGpRdWVyeVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGFkZCAuVG9hc3QgdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcXG4gKi9cXG5cXG5cXG5kZWZpbmVKUXVlcnlQbHVnaW4oVG9hc3QpO1xcblxcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb3RzdHJhcC5lc20uanMubWFwXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcC5lc20uanM/XCIpO1xuICAgIC8qKiovXG4gIH0sXG5cbiAgLyoqKi9cbiAgXCIuL25vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3QvZmVhdGhlci5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9ub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L2ZlYXRoZXIuanMgKioqIVxuICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAvKioqL1xuICBmdW5jdGlvbiBub2RlX21vZHVsZXNGZWF0aGVySWNvbnNEaXN0RmVhdGhlckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgIGV2YWwoXCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xcblxcdGlmKHRydWUpXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XFxuXFx0ZWxzZSB7fVxcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcXG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxcbi8qKioqKiovIFxcdC8vIFRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cXG4vKioqKioqLyBcXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHRcXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcXG4vKioqKioqLyBcXHRcXHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xcbi8qKioqKiovIFxcdFxcdFxcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xcbi8qKioqKiovIFxcdFxcdH1cXG4vKioqKioqLyBcXHRcXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxcbi8qKioqKiovIFxcdFxcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcXG4vKioqKioqLyBcXHRcXHRcXHRpOiBtb2R1bGVJZCxcXG4vKioqKioqLyBcXHRcXHRcXHRsOiBmYWxzZSxcXG4vKioqKioqLyBcXHRcXHRcXHRleHBvcnRzOiB7fVxcbi8qKioqKiovIFxcdFxcdH07XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHRcXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cXG4vKioqKioqLyBcXHRcXHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcXG4vKioqKioqLyBcXHRcXHRtb2R1bGUubCA9IHRydWU7XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHRcXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxcbi8qKioqKiovIFxcdFxcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcXG4vKioqKioqLyBcXHR9XFxuLyoqKioqKi9cXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xcbi8qKioqKiovIFxcdFxcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcXG4vKioqKioqLyBcXHRcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xcbi8qKioqKiovIFxcdFxcdFxcdFxcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXFxuLyoqKioqKi8gXFx0XFx0XFx0XFx0ZW51bWVyYWJsZTogdHJ1ZSxcXG4vKioqKioqLyBcXHRcXHRcXHRcXHRnZXQ6IGdldHRlclxcbi8qKioqKiovIFxcdFxcdFxcdH0pO1xcbi8qKioqKiovIFxcdFxcdH1cXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcXG4vKioqKioqLyBcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xcbi8qKioqKiovIFxcdH07XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xcbi8qKioqKiovIFxcdFxcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xcbi8qKioqKiovIFxcdFxcdFxcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XFxuLyoqKioqKi8gXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcXG4vKioqKioqLyBcXHRcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XFxuLyoqKioqKi8gXFx0XFx0cmV0dXJuIGdldHRlcjtcXG4vKioqKioqLyBcXHR9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcXFwiXFxcIjtcXG4vKioqKioqL1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXFxuLyoqKioqKi8gXFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XFxuLyoqKioqKi8gfSlcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiovICh7XFxuXFxuLyoqKi8gXFxcIi4vZGlzdC9pY29ucy5qc29uXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vZGlzdC9pY29ucy5qc29uICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBleHBvcnRzIHByb3ZpZGVkOiBhY3Rpdml0eSwgYWlycGxheSwgYWxlcnQtY2lyY2xlLCBhbGVydC1vY3RhZ29uLCBhbGVydC10cmlhbmdsZSwgYWxpZ24tY2VudGVyLCBhbGlnbi1qdXN0aWZ5LCBhbGlnbi1sZWZ0LCBhbGlnbi1yaWdodCwgYW5jaG9yLCBhcGVydHVyZSwgYXJjaGl2ZSwgYXJyb3ctZG93bi1jaXJjbGUsIGFycm93LWRvd24tbGVmdCwgYXJyb3ctZG93bi1yaWdodCwgYXJyb3ctZG93biwgYXJyb3ctbGVmdC1jaXJjbGUsIGFycm93LWxlZnQsIGFycm93LXJpZ2h0LWNpcmNsZSwgYXJyb3ctcmlnaHQsIGFycm93LXVwLWNpcmNsZSwgYXJyb3ctdXAtbGVmdCwgYXJyb3ctdXAtcmlnaHQsIGFycm93LXVwLCBhdC1zaWduLCBhd2FyZCwgYmFyLWNoYXJ0LTIsIGJhci1jaGFydCwgYmF0dGVyeS1jaGFyZ2luZywgYmF0dGVyeSwgYmVsbC1vZmYsIGJlbGwsIGJsdWV0b290aCwgYm9sZCwgYm9vay1vcGVuLCBib29rLCBib29rbWFyaywgYm94LCBicmllZmNhc2UsIGNhbGVuZGFyLCBjYW1lcmEtb2ZmLCBjYW1lcmEsIGNhc3QsIGNoZWNrLWNpcmNsZSwgY2hlY2stc3F1YXJlLCBjaGVjaywgY2hldnJvbi1kb3duLCBjaGV2cm9uLWxlZnQsIGNoZXZyb24tcmlnaHQsIGNoZXZyb24tdXAsIGNoZXZyb25zLWRvd24sIGNoZXZyb25zLWxlZnQsIGNoZXZyb25zLXJpZ2h0LCBjaGV2cm9ucy11cCwgY2hyb21lLCBjaXJjbGUsIGNsaXBib2FyZCwgY2xvY2ssIGNsb3VkLWRyaXp6bGUsIGNsb3VkLWxpZ2h0bmluZywgY2xvdWQtb2ZmLCBjbG91ZC1yYWluLCBjbG91ZC1zbm93LCBjbG91ZCwgY29kZSwgY29kZXBlbiwgY29kZXNhbmRib3gsIGNvZmZlZSwgY29sdW1ucywgY29tbWFuZCwgY29tcGFzcywgY29weSwgY29ybmVyLWRvd24tbGVmdCwgY29ybmVyLWRvd24tcmlnaHQsIGNvcm5lci1sZWZ0LWRvd24sIGNvcm5lci1sZWZ0LXVwLCBjb3JuZXItcmlnaHQtZG93biwgY29ybmVyLXJpZ2h0LXVwLCBjb3JuZXItdXAtbGVmdCwgY29ybmVyLXVwLXJpZ2h0LCBjcHUsIGNyZWRpdC1jYXJkLCBjcm9wLCBjcm9zc2hhaXIsIGRhdGFiYXNlLCBkZWxldGUsIGRpc2MsIGRpdmlkZS1jaXJjbGUsIGRpdmlkZS1zcXVhcmUsIGRpdmlkZSwgZG9sbGFyLXNpZ24sIGRvd25sb2FkLWNsb3VkLCBkb3dubG9hZCwgZHJpYmJibGUsIGRyb3BsZXQsIGVkaXQtMiwgZWRpdC0zLCBlZGl0LCBleHRlcm5hbC1saW5rLCBleWUtb2ZmLCBleWUsIGZhY2Vib29rLCBmYXN0LWZvcndhcmQsIGZlYXRoZXIsIGZpZ21hLCBmaWxlLW1pbnVzLCBmaWxlLXBsdXMsIGZpbGUtdGV4dCwgZmlsZSwgZmlsbSwgZmlsdGVyLCBmbGFnLCBmb2xkZXItbWludXMsIGZvbGRlci1wbHVzLCBmb2xkZXIsIGZyYW1lciwgZnJvd24sIGdpZnQsIGdpdC1icmFuY2gsIGdpdC1jb21taXQsIGdpdC1tZXJnZSwgZ2l0LXB1bGwtcmVxdWVzdCwgZ2l0aHViLCBnaXRsYWIsIGdsb2JlLCBncmlkLCBoYXJkLWRyaXZlLCBoYXNoLCBoZWFkcGhvbmVzLCBoZWFydCwgaGVscC1jaXJjbGUsIGhleGFnb24sIGhvbWUsIGltYWdlLCBpbmJveCwgaW5mbywgaW5zdGFncmFtLCBpdGFsaWMsIGtleSwgbGF5ZXJzLCBsYXlvdXQsIGxpZmUtYnVveSwgbGluay0yLCBsaW5rLCBsaW5rZWRpbiwgbGlzdCwgbG9hZGVyLCBsb2NrLCBsb2ctaW4sIGxvZy1vdXQsIG1haWwsIG1hcC1waW4sIG1hcCwgbWF4aW1pemUtMiwgbWF4aW1pemUsIG1laCwgbWVudSwgbWVzc2FnZS1jaXJjbGUsIG1lc3NhZ2Utc3F1YXJlLCBtaWMtb2ZmLCBtaWMsIG1pbmltaXplLTIsIG1pbmltaXplLCBtaW51cy1jaXJjbGUsIG1pbnVzLXNxdWFyZSwgbWludXMsIG1vbml0b3IsIG1vb24sIG1vcmUtaG9yaXpvbnRhbCwgbW9yZS12ZXJ0aWNhbCwgbW91c2UtcG9pbnRlciwgbW92ZSwgbXVzaWMsIG5hdmlnYXRpb24tMiwgbmF2aWdhdGlvbiwgb2N0YWdvbiwgcGFja2FnZSwgcGFwZXJjbGlwLCBwYXVzZS1jaXJjbGUsIHBhdXNlLCBwZW4tdG9vbCwgcGVyY2VudCwgcGhvbmUtY2FsbCwgcGhvbmUtZm9yd2FyZGVkLCBwaG9uZS1pbmNvbWluZywgcGhvbmUtbWlzc2VkLCBwaG9uZS1vZmYsIHBob25lLW91dGdvaW5nLCBwaG9uZSwgcGllLWNoYXJ0LCBwbGF5LWNpcmNsZSwgcGxheSwgcGx1cy1jaXJjbGUsIHBsdXMtc3F1YXJlLCBwbHVzLCBwb2NrZXQsIHBvd2VyLCBwcmludGVyLCByYWRpbywgcmVmcmVzaC1jY3csIHJlZnJlc2gtY3csIHJlcGVhdCwgcmV3aW5kLCByb3RhdGUtY2N3LCByb3RhdGUtY3csIHJzcywgc2F2ZSwgc2Npc3NvcnMsIHNlYXJjaCwgc2VuZCwgc2VydmVyLCBzZXR0aW5ncywgc2hhcmUtMiwgc2hhcmUsIHNoaWVsZC1vZmYsIHNoaWVsZCwgc2hvcHBpbmctYmFnLCBzaG9wcGluZy1jYXJ0LCBzaHVmZmxlLCBzaWRlYmFyLCBza2lwLWJhY2ssIHNraXAtZm9yd2FyZCwgc2xhY2ssIHNsYXNoLCBzbGlkZXJzLCBzbWFydHBob25lLCBzbWlsZSwgc3BlYWtlciwgc3F1YXJlLCBzdGFyLCBzdG9wLWNpcmNsZSwgc3VuLCBzdW5yaXNlLCBzdW5zZXQsIHRhYmxldCwgdGFnLCB0YXJnZXQsIHRlcm1pbmFsLCB0aGVybW9tZXRlciwgdGh1bWJzLWRvd24sIHRodW1icy11cCwgdG9nZ2xlLWxlZnQsIHRvZ2dsZS1yaWdodCwgdG9vbCwgdHJhc2gtMiwgdHJhc2gsIHRyZWxsbywgdHJlbmRpbmctZG93biwgdHJlbmRpbmctdXAsIHRyaWFuZ2xlLCB0cnVjaywgdHYsIHR3aXRjaCwgdHdpdHRlciwgdHlwZSwgdW1icmVsbGEsIHVuZGVybGluZSwgdW5sb2NrLCB1cGxvYWQtY2xvdWQsIHVwbG9hZCwgdXNlci1jaGVjaywgdXNlci1taW51cywgdXNlci1wbHVzLCB1c2VyLXgsIHVzZXIsIHVzZXJzLCB2aWRlby1vZmYsIHZpZGVvLCB2b2ljZW1haWwsIHZvbHVtZS0xLCB2b2x1bWUtMiwgdm9sdW1lLXgsIHZvbHVtZSwgd2F0Y2gsIHdpZmktb2ZmLCB3aWZpLCB3aW5kLCB4LWNpcmNsZSwgeC1vY3RhZ29uLCB4LXNxdWFyZSwgeCwgeW91dHViZSwgemFwLW9mZiwgemFwLCB6b29tLWluLCB6b29tLW91dCwgZGVmYXVsdCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXFwiYWN0aXZpdHlcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMjIgMTIgMTggMTIgMTUgMjEgOSAzIDYgMTIgMiAxMlxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiYWlycGxheVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNNSAxN0g0YTIgMiAwIDAgMS0yLTJWNWEyIDIgMCAwIDEgMi0yaDE2YTIgMiAwIDAgMSAyIDJ2MTBhMiAyIDAgMCAxLTIgMmgtMVxcXFxcXFwiPjwvcGF0aD48cG9seWdvbiBwb2ludHM9XFxcXFxcXCIxMiAxNSAxNyAyMSA3IDIxIDEyIDE1XFxcXFxcXCI+PC9wb2x5Z29uPlxcXCIsXFxcImFsZXJ0LWNpcmNsZVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCI4XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTZcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyLjAxXFxcXFxcXCIgeTI9XFxcXFxcXCIxNlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJhbGVydC1vY3RhZ29uXFxcIjpcXFwiPHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiNy44NiAyIDE2LjE0IDIgMjIgNy44NiAyMiAxNi4xNCAxNi4xNCAyMiA3Ljg2IDIyIDIgMTYuMTQgMiA3Ljg2IDcuODYgMlxcXFxcXFwiPjwvcG9seWdvbj48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCI4XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTZcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyLjAxXFxcXFxcXCIgeTI9XFxcXFxcXCIxNlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJhbGVydC10cmlhbmdsZVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTAuMjkgMy44NkwxLjgyIDE4YTIgMiAwIDAgMCAxLjcxIDNoMTYuOTRhMiAyIDAgMCAwIDEuNzEtM0wxMy43MSAzLjg2YTIgMiAwIDAgMC0zLjQyIDB6XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxM1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxN1xcXFxcXFwiIHgyPVxcXFxcXFwiMTIuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjE3XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImFsaWduLWNlbnRlclxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMThcXFxcXFxcIiB5MT1cXFxcXFxcIjEwXFxcXFxcXCIgeDI9XFxcXFxcXCI2XFxcXFxcXCIgeTI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCI2XFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCI2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjE0XFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxNFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE4XFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiNlxcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiYWxpZ24tanVzdGlmeVxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjEwXFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCI2XFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCI2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjE0XFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxNFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiM1xcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiYWxpZ24tbGVmdFxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMTdcXFxcXFxcIiB5MT1cXFxcXFxcIjEwXFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCI2XFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCI2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjE0XFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxNFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE3XFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiM1xcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiYWxpZ24tcmlnaHRcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxMFxcXFxcXFwiIHgyPVxcXFxcXFwiN1xcXFxcXFwiIHkyPVxcXFxcXFwiMTBcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyMVxcXFxcXFwiIHkxPVxcXFxcXFwiNlxcXFxcXFwiIHgyPVxcXFxcXFwiM1xcXFxcXFwiIHkyPVxcXFxcXFwiNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxNFxcXFxcXFwiIHgyPVxcXFxcXFwiM1xcXFxcXFwiIHkyPVxcXFxcXFwiMTRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyMVxcXFxcXFwiIHkxPVxcXFxcXFwiMThcXFxcXFxcIiB4Mj1cXFxcXFxcIjdcXFxcXFxcIiB5Mj1cXFxcXFxcIjE4XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImFuY2hvclxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiNVxcXFxcXFwiIHI9XFxcXFxcXCIzXFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMjJcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCI4XFxcXFxcXCI+PC9saW5lPjxwYXRoIGQ9XFxcXFxcXCJNNSAxMkgyYTEwIDEwIDAgMCAwIDIwIDBoLTNcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiYXBlcnR1cmVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIxNC4zMVxcXFxcXFwiIHkxPVxcXFxcXFwiOFxcXFxcXFwiIHgyPVxcXFxcXFwiMjAuMDVcXFxcXFxcIiB5Mj1cXFxcXFxcIjE3Ljk0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOS42OVxcXFxcXFwiIHkxPVxcXFxcXFwiOFxcXFxcXFwiIHgyPVxcXFxcXFwiMjEuMTdcXFxcXFxcIiB5Mj1cXFxcXFxcIjhcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI3LjM4XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTMuMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjIuMDZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI5LjY5XFxcXFxcXCIgeTE9XFxcXFxcXCIxNlxcXFxcXFwiIHgyPVxcXFxcXFwiMy45NVxcXFxcXFwiIHkyPVxcXFxcXFwiNi4wNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE0LjMxXFxcXFxcXCIgeTE9XFxcXFxcXCIxNlxcXFxcXFwiIHgyPVxcXFxcXFwiMi44M1xcXFxcXFwiIHkyPVxcXFxcXFwiMTZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNi42MlxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjEwLjg4XFxcXFxcXCIgeTI9XFxcXFxcXCIyMS45NFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJhcmNoaXZlXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIxIDggMjEgMjEgMyAyMSAzIDhcXFxcXFxcIj48L3BvbHlsaW5lPjxyZWN0IHg9XFxcXFxcXCIxXFxcXFxcXCIgeT1cXFxcXFxcIjNcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjIyXFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiNVxcXFxcXFwiPjwvcmVjdD48bGluZSB4MT1cXFxcXFxcIjEwXFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTRcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImFycm93LWRvd24tY2lyY2xlXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI4IDEyIDEyIDE2IDE2IDEyXFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCI4XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTZcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiYXJyb3ctZG93bi1sZWZ0XFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxN1xcXFxcXFwiIHkxPVxcXFxcXFwiN1xcXFxcXFwiIHgyPVxcXFxcXFwiN1xcXFxcXFwiIHkyPVxcXFxcXFwiMTdcXFxcXFxcIj48L2xpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE3IDE3IDcgMTcgNyA3XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJhcnJvdy1kb3duLXJpZ2h0XFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCI3XFxcXFxcXCIgeTE9XFxcXFxcXCI3XFxcXFxcXCIgeDI9XFxcXFxcXCIxN1xcXFxcXFwiIHkyPVxcXFxcXFwiMTdcXFxcXFxcIj48L2xpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE3IDcgMTcgMTcgNyAxN1xcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiYXJyb3ctZG93blxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjVcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxOVxcXFxcXFwiPjwvbGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTkgMTIgMTIgMTkgNSAxMlxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiYXJyb3ctbGVmdC1jaXJjbGVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjEyIDggOCAxMiAxMiAxNlxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNlxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjhcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImFycm93LWxlZnRcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjE5XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiNVxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjEyIDE5IDUgMTIgMTIgNVxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiYXJyb3ctcmlnaHQtY2lyY2xlXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxMiAxNiAxNiAxMiAxMiA4XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIxNlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiYXJyb3ctcmlnaHRcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjVcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIxOVxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjEyIDUgMTkgMTIgMTIgMTlcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImFycm93LXVwLWNpcmNsZVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTYgMTIgMTIgOCA4IDEyXFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxNlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjhcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiYXJyb3ctdXAtbGVmdFxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMTdcXFxcXFxcIiB5MT1cXFxcXFxcIjE3XFxcXFxcXCIgeDI9XFxcXFxcXCI3XFxcXFxcXCIgeTI9XFxcXFxcXCI3XFxcXFxcXCI+PC9saW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI3IDE3IDcgNyAxNyA3XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJhcnJvdy11cC1yaWdodFxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiN1xcXFxcXFwiIHkxPVxcXFxcXFwiMTdcXFxcXFxcIiB4Mj1cXFxcXFxcIjE3XFxcXFxcXCIgeTI9XFxcXFxcXCI3XFxcXFxcXCI+PC9saW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI3IDcgMTcgNyAxNyAxN1xcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiYXJyb3ctdXBcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxOVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjVcXFxcXFxcIj48L2xpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjUgMTIgMTIgNSAxOSAxMlxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiYXQtc2lnblxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiNFxcXFxcXFwiPjwvY2lyY2xlPjxwYXRoIGQ9XFxcXFxcXCJNMTYgOHY1YTMgMyAwIDAgMCA2IDB2LTFhMTAgMTAgMCAxIDAtMy45MiA3Ljk0XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImF3YXJkXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCI4XFxcXFxcXCIgcj1cXFxcXFxcIjdcXFxcXFxcIj48L2NpcmNsZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiOC4yMSAxMy44OSA3IDIzIDEyIDIwIDE3IDIzIDE1Ljc5IDEzLjg4XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJiYXItY2hhcnQtMlxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMThcXFxcXFxcIiB5MT1cXFxcXFxcIjIwXFxcXFxcXCIgeDI9XFxcXFxcXCIxOFxcXFxcXFwiIHkyPVxcXFxcXFwiMTBcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMjBcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCI0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiNlxcXFxcXFwiIHkxPVxcXFxcXFwiMjBcXFxcXFxcIiB4Mj1cXFxcXFxcIjZcXFxcXFxcIiB5Mj1cXFxcXFxcIjE0XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImJhci1jaGFydFxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjIwXFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTBcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxOFxcXFxcXFwiIHkxPVxcXFxcXFwiMjBcXFxcXFxcIiB4Mj1cXFxcXFxcIjE4XFxcXFxcXCIgeTI9XFxcXFxcXCI0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiNlxcXFxcXFwiIHkxPVxcXFxcXFwiMjBcXFxcXFxcIiB4Mj1cXFxcXFxcIjZcXFxcXFxcIiB5Mj1cXFxcXFxcIjE2XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImJhdHRlcnktY2hhcmdpbmdcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTUgMThIM2EyIDIgMCAwIDEtMi0yVjhhMiAyIDAgMCAxIDItMmgzLjE5TTE1IDZoMmEyIDIgMCAwIDEgMiAydjhhMiAyIDAgMCAxLTIgMmgtMy4xOVxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjIzXFxcXFxcXCIgeTE9XFxcXFxcXCIxM1xcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjExXFxcXFxcXCI+PC9saW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxMSA2IDcgMTIgMTMgMTIgOSAxOFxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiYmF0dGVyeVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIxXFxcXFxcXCIgeT1cXFxcXFxcIjZcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMTJcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PGxpbmUgeDE9XFxcXFxcXCIyM1xcXFxcXFwiIHkxPVxcXFxcXFwiMTNcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxMVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJiZWxsLW9mZlxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTMuNzMgMjFhMiAyIDAgMCAxLTMuNDYgMFxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTE4LjYzIDEzQTE3Ljg5IDE3Ljg5IDAgMCAxIDE4IDhcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk02LjI2IDYuMjZBNS44NiA1Ljg2IDAgMCAwIDYgOGMwIDctMyA5LTMgOWgxNFxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTE4IDhhNiA2IDAgMCAwLTkuMzMtNVxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjFcXFxcXFxcIiB5MT1cXFxcXFxcIjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIyM1xcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJiZWxsXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xOCA4QTYgNiAwIDAgMCA2IDhjMCA3LTMgOS0zIDloMThzLTMtMi0zLTlcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xMy43MyAyMWEyIDIgMCAwIDEtMy40NiAwXFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImJsdWV0b290aFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI2LjUgNi41IDE3LjUgMTcuNSAxMiAyMyAxMiAxIDE3LjUgNi41IDYuNSAxNy41XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJib2xkXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk02IDRoOGE0IDQgMCAwIDEgNCA0IDQgNCAwIDAgMS00IDRINnpcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk02IDEyaDlhNCA0IDAgMCAxIDQgNCA0IDQgMCAwIDEtNCA0SDZ6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImJvb2stb3BlblxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMiAzaDZhNCA0IDAgMCAxIDQgNHYxNGEzIDMgMCAwIDAtMy0zSDJ6XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMjIgM2gtNmE0IDQgMCAwIDAtNCA0djE0YTMgMyAwIDAgMSAzLTNoN3pcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiYm9va1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNNCAxOS41QTIuNSAyLjUgMCAwIDEgNi41IDE3SDIwXFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNNi41IDJIMjB2MjBINi41QTIuNSAyLjUgMCAwIDEgNCAxOS41di0xNUEyLjUgMi41IDAgMCAxIDYuNSAyelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJib29rbWFya1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTkgMjFsLTctNS03IDVWNWEyIDIgMCAwIDEgMi0yaDEwYTIgMiAwIDAgMSAyIDJ6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImJveFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjEgMTZWOGEyIDIgMCAwIDAtMS0xLjczbC03LTRhMiAyIDAgMCAwLTIgMGwtNyA0QTIgMiAwIDAgMCAzIDh2OGEyIDIgMCAwIDAgMSAxLjczbDcgNGEyIDIgMCAwIDAgMiAwbDctNEEyIDIgMCAwIDAgMjEgMTZ6XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIzLjI3IDYuOTYgMTIgMTIuMDEgMjAuNzMgNi45NlxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMjIuMDhcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJicmllZmNhc2VcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiMlxcXFxcXFwiIHk9XFxcXFxcXCI3XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIyMFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjE0XFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxwYXRoIGQ9XFxcXFxcXCJNMTYgMjFWNWEyIDIgMCAwIDAtMi0yaC00YTIgMiAwIDAgMC0yIDJ2MTZcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiY2FsZW5kYXJcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiM1xcXFxcXFwiIHk9XFxcXFxcXCI0XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIxOFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjE4XFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxsaW5lIHgxPVxcXFxcXFwiMTZcXFxcXFxcIiB5MT1cXFxcXFxcIjJcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCI2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMlxcXFxcXFwiIHgyPVxcXFxcXFwiOFxcXFxcXFwiIHkyPVxcXFxcXFwiNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjNcXFxcXFxcIiB5MT1cXFxcXFxcIjEwXFxcXFxcXCIgeDI9XFxcXFxcXCIyMVxcXFxcXFwiIHkyPVxcXFxcXFwiMTBcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiY2FtZXJhLW9mZlxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMVxcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjEgMjFIM2EyIDIgMCAwIDEtMi0yVjhhMiAyIDAgMCAxIDItMmgzbTMtM2g2bDIgM2g0YTIgMiAwIDAgMSAyIDJ2OS4zNG0tNy43Mi0yLjA2YTQgNCAwIDEgMS01LjU2LTUuNTZcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiY2FtZXJhXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMyAxOWEyIDIgMCAwIDEtMiAySDNhMiAyIDAgMCAxLTItMlY4YTIgMiAwIDAgMSAyLTJoNGwyLTNoNmwyIDNoNGEyIDIgMCAwIDEgMiAyelxcXFxcXFwiPjwvcGF0aD48Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEzXFxcXFxcXCIgcj1cXFxcXFxcIjRcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJjYXN0XFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yIDE2LjFBNSA1IDAgMCAxIDUuOSAyME0yIDEyLjA1QTkgOSAwIDAgMSA5Ljk1IDIwTTIgOFY2YTIgMiAwIDAgMSAyLTJoMTZhMiAyIDAgMCAxIDIgMnYxMmEyIDIgMCAwIDEtMiAyaC02XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMlxcXFxcXFwiIHkxPVxcXFxcXFwiMjBcXFxcXFxcIiB4Mj1cXFxcXFxcIjIuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjIwXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImNoZWNrLWNpcmNsZVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjIgMTEuMDhWMTJhMTAgMTAgMCAxIDEtNS45My05LjE0XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIyMiA0IDEyIDE0LjAxIDkgMTEuMDFcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImNoZWNrLXNxdWFyZVxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI5IDExIDEyIDE0IDIyIDRcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjEgMTJ2N2EyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMlY1YTIgMiAwIDAgMSAyLTJoMTFcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiY2hlY2tcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMjAgNiA5IDE3IDQgMTJcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImNoZXZyb24tZG93blxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI2IDkgMTIgMTUgMTggOVxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiY2hldnJvbi1sZWZ0XFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE1IDE4IDkgMTIgMTUgNlxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiY2hldnJvbi1yaWdodFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI5IDE4IDE1IDEyIDkgNlxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiY2hldnJvbi11cFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxOCAxNSAxMiA5IDYgMTVcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImNoZXZyb25zLWRvd25cXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiNyAxMyAxMiAxOCAxNyAxM1xcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjcgNiAxMiAxMSAxNyA2XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJjaGV2cm9ucy1sZWZ0XFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjExIDE3IDYgMTIgMTEgN1xcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE4IDE3IDEzIDEyIDE4IDdcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImNoZXZyb25zLXJpZ2h0XFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjEzIDE3IDE4IDEyIDEzIDdcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI2IDE3IDExIDEyIDYgN1xcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiY2hldnJvbnMtdXBcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTcgMTEgMTIgNiA3IDExXFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTcgMTggMTIgMTMgNyAxOFxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiY2hyb21lXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiNFxcXFxcXFwiPjwvY2lyY2xlPjxsaW5lIHgxPVxcXFxcXFwiMjEuMTdcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCI4XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMy45NVxcXFxcXFwiIHkxPVxcXFxcXFwiNi4wNlxcXFxcXFwiIHgyPVxcXFxcXFwiOC41NFxcXFxcXFwiIHkyPVxcXFxcXFwiMTRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMC44OFxcXFxcXFwiIHkxPVxcXFxcXFwiMjEuOTRcXFxcXFxcIiB4Mj1cXFxcXFxcIjE1LjQ2XFxcXFxcXCIgeTI9XFxcXFxcXCIxNFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJjaXJjbGVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+XFxcIixcXFwiY2xpcGJvYXJkXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNiA0aDJhMiAyIDAgMCAxIDIgMnYxNGEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2YTIgMiAwIDAgMSAyLTJoMlxcXFxcXFwiPjwvcGF0aD48cmVjdCB4PVxcXFxcXFwiOFxcXFxcXFwiIHk9XFxcXFxcXCIyXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCI4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiNFxcXFxcXFwiIHJ4PVxcXFxcXFwiMVxcXFxcXFwiIHJ5PVxcXFxcXFwiMVxcXFxcXFwiPjwvcmVjdD5cXFwiLFxcXCJjbG9ja1xcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTIgNiAxMiAxMiAxNiAxNFxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiY2xvdWQtZHJpenpsZVxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMTlcXFxcXFxcIiB4Mj1cXFxcXFxcIjhcXFxcXFxcIiB5Mj1cXFxcXFxcIjIxXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMTNcXFxcXFxcIiB4Mj1cXFxcXFxcIjhcXFxcXFxcIiB5Mj1cXFxcXFxcIjE1XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTZcXFxcXFxcIiB5MT1cXFxcXFxcIjE5XFxcXFxcXCIgeDI9XFxcXFxcXCIxNlxcXFxcXFwiIHkyPVxcXFxcXFwiMjFcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNlxcXFxcXFwiIHkxPVxcXFxcXFwiMTNcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjE1XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTdcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk0yMCAxNi41OEE1IDUgMCAwIDAgMTggN2gtMS4yNkE4IDggMCAxIDAgNCAxNS4yNVxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjbG91ZC1saWdodG5pbmdcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE5IDE2LjlBNSA1IDAgMCAwIDE4IDdoLTEuMjZhOCA4IDAgMSAwLTExLjYyIDlcXFxcXFxcIj48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjEzIDExIDkgMTcgMTUgMTcgMTEgMjNcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImNsb3VkLW9mZlxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjIuNjEgMTYuOTVBNSA1IDAgMCAwIDE4IDEwaC0xLjI2YTggOCAwIDAgMC03LjA1LTZNNSA1YTggOCAwIDAgMCA0IDE1aDlhNSA1IDAgMCAwIDEuNy0uM1xcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjFcXFxcXFxcIiB5MT1cXFxcXFxcIjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIyM1xcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJjbG91ZC1yYWluXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxNlxcXFxcXFwiIHkxPVxcXFxcXFwiMTNcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIyMVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjEzXFxcXFxcXCIgeDI9XFxcXFxcXCI4XFxcXFxcXCIgeTI9XFxcXFxcXCIyMVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxNVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjAgMTYuNThBNSA1IDAgMCAwIDE4IDdoLTEuMjZBOCA4IDAgMSAwIDQgMTUuMjVcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiY2xvdWQtc25vd1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjAgMTcuNThBNSA1IDAgMCAwIDE4IDhoLTEuMjZBOCA4IDAgMSAwIDQgMTYuMjVcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIxNlxcXFxcXFwiIHgyPVxcXFxcXFwiOC4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMTZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIyMFxcXFxcXFwiIHgyPVxcXFxcXFwiOC4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMjBcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMThcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyLjAxXFxcXFxcXCIgeTI9XFxcXFxcXCIxOFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTIuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjIyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTZcXFxcXFxcIiB5MT1cXFxcXFxcIjE2XFxcXFxcXCIgeDI9XFxcXFxcXCIxNi4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMTZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNlxcXFxcXFwiIHkxPVxcXFxcXFwiMjBcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2LjAxXFxcXFxcXCIgeTI9XFxcXFxcXCIyMFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJjbG91ZFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTggMTBoLTEuMjZBOCA4IDAgMSAwIDkgMjBoOWE1IDUgMCAwIDAgMC0xMHpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiY29kZVxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNiAxOCAyMiAxMiAxNiA2XFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiOCA2IDIgMTIgOCAxOFxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiY29kZXBlblxcXCI6XFxcIjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjEyIDIgMjIgOC41IDIyIDE1LjUgMTIgMjIgMiAxNS41IDIgOC41IDEyIDJcXFxcXFxcIj48L3BvbHlnb24+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMjJcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxNS41XFxcXFxcXCI+PC9saW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIyMiA4LjUgMTIgMTUuNSAyIDguNVxcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIgMTUuNSAxMiA4LjUgMjIgMTUuNVxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjguNVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJjb2Rlc2FuZGJveFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjEgMTZWOGEyIDIgMCAwIDAtMS0xLjczbC03LTRhMiAyIDAgMCAwLTIgMGwtNyA0QTIgMiAwIDAgMCAzIDh2OGEyIDIgMCAwIDAgMSAxLjczbDcgNGEyIDIgMCAwIDAgMiAwbDctNEEyIDIgMCAwIDAgMjEgMTZ6XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI3LjUgNC4yMSAxMiA2LjgxIDE2LjUgNC4yMVxcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjcuNSAxOS43OSA3LjUgMTQuNiAzIDEyXFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMjEgMTIgMTYuNSAxNC42IDE2LjUgMTkuNzlcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIzLjI3IDYuOTYgMTIgMTIuMDEgMjAuNzMgNi45NlxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMjIuMDhcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJjb2ZmZWVcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE4IDhoMWE0IDQgMCAwIDEgMCA4aC0xXFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMiA4aDE2djlhNCA0IDAgMCAxLTQgNEg2YTQgNCAwIDAgMS00LTRWOHpcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCI2XFxcXFxcXCIgeTE9XFxcXFxcXCIxXFxcXFxcXCIgeDI9XFxcXFxcXCI2XFxcXFxcXCIgeTI9XFxcXFxcXCI0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTBcXFxcXFxcIiB5MT1cXFxcXFxcIjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjEwXFxcXFxcXCIgeTI9XFxcXFxcXCI0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTRcXFxcXFxcIiB5MT1cXFxcXFxcIjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjE0XFxcXFxcXCIgeTI9XFxcXFxcXCI0XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImNvbHVtbnNcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTEyIDNoN2EyIDIgMCAwIDEgMiAydjE0YTIgMiAwIDAgMS0yIDJoLTdtMC0xOEg1YTIgMiAwIDAgMC0yIDJ2MTRhMiAyIDAgMCAwIDIgMmg3bTAtMTh2MThcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiY29tbWFuZFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTggM2EzIDMgMCAwIDAtMyAzdjEyYTMgMyAwIDAgMCAzIDMgMyAzIDAgMCAwIDMtMyAzIDMgMCAwIDAtMy0zSDZhMyAzIDAgMCAwLTMgMyAzIDMgMCAwIDAgMyAzIDMgMyAwIDAgMCAzLTNWNmEzIDMgMCAwIDAtMy0zIDMgMyAwIDAgMC0zIDMgMyAzIDAgMCAwIDMgM2gxMmEzIDMgMCAwIDAgMy0zIDMgMyAwIDAgMC0zLTN6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImNvbXBhc3NcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMTYuMjQgNy43NiAxNC4xMiAxNC4xMiA3Ljc2IDE2LjI0IDkuODggOS44OCAxNi4yNCA3Ljc2XFxcXFxcXCI+PC9wb2x5Z29uPlxcXCIsXFxcImNvcHlcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiOVxcXFxcXFwiIHk9XFxcXFxcXCI5XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIxM1xcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjEzXFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxwYXRoIGQ9XFxcXFxcXCJNNSAxNUg0YTIgMiAwIDAgMS0yLTJWNGEyIDIgMCAwIDEgMi0yaDlhMiAyIDAgMCAxIDIgMnYxXFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImNvcm5lci1kb3duLWxlZnRcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiOSAxMCA0IDE1IDkgMjBcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjAgNHY3YTQgNCAwIDAgMS00IDRINFxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjb3JuZXItZG93bi1yaWdodFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNSAxMCAyMCAxNSAxNSAyMFxcXFxcXFwiPjwvcG9seWxpbmU+PHBhdGggZD1cXFxcXFxcIk00IDR2N2E0IDQgMCAwIDAgNCA0aDEyXFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImNvcm5lci1sZWZ0LWRvd25cXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTQgMTUgOSAyMCA0IDE1XFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTIwIDRoLTdhNCA0IDAgMCAwLTQgNHYxMlxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjb3JuZXItbGVmdC11cFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNCA5IDkgNCA0IDlcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjAgMjBoLTdhNCA0IDAgMCAxLTQtNFY0XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImNvcm5lci1yaWdodC1kb3duXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjEwIDE1IDE1IDIwIDIwIDE1XFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTQgNGg3YTQgNCAwIDAgMSA0IDR2MTJcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiY29ybmVyLXJpZ2h0LXVwXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjEwIDkgMTUgNCAyMCA5XFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTQgMjBoN2E0IDQgMCAwIDAgNC00VjRcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiY29ybmVyLXVwLWxlZnRcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiOSAxNCA0IDkgOSA0XFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTIwIDIwdi03YTQgNCAwIDAgMC00LTRINFxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjb3JuZXItdXAtcmlnaHRcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTUgMTQgMjAgOSAxNSA0XFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTQgMjB2LTdhNCA0IDAgMCAxIDQtNGgxMlxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjcHVcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiNFxcXFxcXFwiIHk9XFxcXFxcXCI0XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIxNlxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjE2XFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxyZWN0IHg9XFxcXFxcXCI5XFxcXFxcXCIgeT1cXFxcXFxcIjlcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjZcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCI2XFxcXFxcXCI+PC9yZWN0PjxsaW5lIHgxPVxcXFxcXFwiOVxcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiOVxcXFxcXFwiIHkyPVxcXFxcXFwiNFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE1XFxcXFxcXCIgeTE9XFxcXFxcXCIxXFxcXFxcXCIgeDI9XFxcXFxcXCIxNVxcXFxcXFwiIHkyPVxcXFxcXFwiNFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjIwXFxcXFxcXCIgeDI9XFxcXFxcXCI5XFxcXFxcXCIgeTI9XFxcXFxcXCIyM1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE1XFxcXFxcXCIgeTE9XFxcXFxcXCIyMFxcXFxcXFwiIHgyPVxcXFxcXFwiMTVcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjBcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCI5XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjBcXFxcXFxcIiB5MT1cXFxcXFxcIjE0XFxcXFxcXCIgeDI9XFxcXFxcXCIyM1xcXFxcXFwiIHkyPVxcXFxcXFwiMTRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxXFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCI0XFxcXFxcXCIgeTI9XFxcXFxcXCI5XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMVxcXFxcXFwiIHkxPVxcXFxcXFwiMTRcXFxcXFxcIiB4Mj1cXFxcXFxcIjRcXFxcXFxcIiB5Mj1cXFxcXFxcIjE0XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImNyZWRpdC1jYXJkXFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjFcXFxcXFxcIiB5PVxcXFxcXFwiNFxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMjJcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxNlxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD48bGluZSB4MT1cXFxcXFxcIjFcXFxcXFxcIiB5MT1cXFxcXFxcIjEwXFxcXFxcXCIgeDI9XFxcXFxcXCIyM1xcXFxcXFwiIHkyPVxcXFxcXFwiMTBcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiY3JvcFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNNi4xMyAxTDYgMTZhMiAyIDAgMCAwIDIgMmgxNVxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTEgNi4xM0wxNiA2YTIgMiAwIDAgMSAyIDJ2MTVcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiY3Jvc3NoYWlyXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxsaW5lIHgxPVxcXFxcXFwiMjJcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIxOFxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI2XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiNlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMjJcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxOFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJkYXRhYmFzZVxcXCI6XFxcIjxlbGxpcHNlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjVcXFxcXFxcIiByeD1cXFxcXFxcIjlcXFxcXFxcIiByeT1cXFxcXFxcIjNcXFxcXFxcIj48L2VsbGlwc2U+PHBhdGggZD1cXFxcXFxcIk0yMSAxMmMwIDEuNjYtNCAzLTkgM3MtOS0xLjM0LTktM1xcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTMgNXYxNGMwIDEuNjYgNCAzIDkgM3M5LTEuMzQgOS0zVjVcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiZGVsZXRlXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMSA0SDhsLTcgOCA3IDhoMTNhMiAyIDAgMCAwIDItMlY2YTIgMiAwIDAgMC0yLTJ6XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMThcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCIxOFxcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiZGlzY1xcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJkaXZpZGUtY2lyY2xlXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTZcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjE2XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjhcXFxcXFxcIj48L2xpbmU+PGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPlxcXCIsXFxcImRpdmlkZS1zcXVhcmVcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiM1xcXFxcXFwiIHk9XFxcXFxcXCIzXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIxOFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjE4XFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxNlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjE2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCI4XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImRpdmlkZVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiNlxcXFxcXFwiIHI9XFxcXFxcXCIyXFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCI1XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTlcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMThcXFxcXFxcIiByPVxcXFxcXFwiMlxcXFxcXFwiPjwvY2lyY2xlPlxcXCIsXFxcImRvbGxhci1zaWduXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPjxwYXRoIGQ9XFxcXFxcXCJNMTcgNUg5LjVhMy41IDMuNSAwIDAgMCAwIDdoNWEzLjUgMy41IDAgMCAxIDAgN0g2XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImRvd25sb2FkLWNsb3VkXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjggMTcgMTIgMjEgMTYgMTdcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMjFcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk0yMC44OCAxOC4wOUE1IDUgMCAwIDAgMTggOWgtMS4yNkE4IDggMCAxIDAgMyAxNi4yOVxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJkb3dubG9hZFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjEgMTV2NGEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMnYtNFxcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiNyAxMCAxMiAxNSAxNyAxMFxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTVcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIzXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImRyaWJiYmxlXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxwYXRoIGQ9XFxcXFxcXCJNOC41NiAyLjc1YzQuMzcgNi4wMyA2LjAyIDkuNDIgOC4wMyAxNy43Mm0yLjU0LTE1LjM4Yy0zLjcyIDQuMzUtOC45NCA1LjY2LTE2Ljg4IDUuODVtMTkuNSAxLjljLTMuNS0uOTMtNi42My0uODItOC45NCAwLTIuNTguOTItNS4wMSAyLjg2LTcuNDQgNi4zMlxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJkcm9wbGV0XFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xMiAyLjY5bDUuNjYgNS42NmE4IDggMCAxIDEtMTEuMzEgMHpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiZWRpdC0yXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNyAzYTIuODI4IDIuODI4IDAgMSAxIDQgNEw3LjUgMjAuNSAyIDIybDEuNS01LjVMMTcgM3pcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiZWRpdC0zXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xMiAyMGg5XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMTYuNSAzLjVhMi4xMjEgMi4xMjEgMCAwIDEgMyAzTDcgMTlsLTQgMSAxLTRMMTYuNSAzLjV6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImVkaXRcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTExIDRINGEyIDIgMCAwIDAtMiAydjE0YTIgMiAwIDAgMCAyIDJoMTRhMiAyIDAgMCAwIDItMnYtN1xcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTE4LjUgMi41YTIuMTIxIDIuMTIxIDAgMCAxIDMgM0wxMiAxNWwtNCAxIDEtNCA5LjUtOS41elxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJleHRlcm5hbC1saW5rXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xOCAxM3Y2YTIgMiAwIDAgMS0yIDJINWEyIDIgMCAwIDEtMi0yVjhhMiAyIDAgMCAxIDItMmg2XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNSAzIDIxIDMgMjEgOVxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMFxcXFxcXFwiIHkxPVxcXFxcXFwiMTRcXFxcXFxcIiB4Mj1cXFxcXFxcIjIxXFxcXFxcXCIgeTI9XFxcXFxcXCIzXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImV5ZS1vZmZcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE3Ljk0IDE3Ljk0QTEwLjA3IDEwLjA3IDAgMCAxIDEyIDIwYy03IDAtMTEtOC0xMS04YTE4LjQ1IDE4LjQ1IDAgMCAxIDUuMDYtNS45NE05LjkgNC4yNEE5LjEyIDkuMTIgMCAwIDEgMTIgNGM3IDAgMTEgOCAxMSA4YTE4LjUgMTguNSAwIDAgMS0yLjE2IDMuMTltLTYuNzItMS4wN2EzIDMgMCAxIDEtNC4yNC00LjI0XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMVxcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImV5ZVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMSAxMnM0LTggMTEtOCAxMSA4IDExIDgtNCA4LTExIDgtMTEtOC0xMS04elxcXFxcXFwiPjwvcGF0aD48Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJmYWNlYm9va1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTggMmgtM2E1IDUgMCAwIDAtNSA1djNIN3Y0aDN2OGg0di04aDNsMS00aC00VjdhMSAxIDAgMCAxIDEtMWgzelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJmYXN0LWZvcndhcmRcXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCIxMyAxOSAyMiAxMiAxMyA1IDEzIDE5XFxcXFxcXCI+PC9wb2x5Z29uPjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjIgMTkgMTEgMTIgMiA1IDIgMTlcXFxcXFxcIj48L3BvbHlnb24+XFxcIixcXFwiZmVhdGhlclxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjAuMjQgMTIuMjRhNiA2IDAgMCAwLTguNDktOC40OUw1IDEwLjVWMTloOC41elxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjE2XFxcXFxcXCIgeTE9XFxcXFxcXCI4XFxcXFxcXCIgeDI9XFxcXFxcXCIyXFxcXFxcXCIgeTI9XFxcXFxcXCIyMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE3LjVcXFxcXFxcIiB5MT1cXFxcXFxcIjE1XFxcXFxcXCIgeDI9XFxcXFxcXCI5XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJmaWdtYVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNNSA1LjVBMy41IDMuNSAwIDAgMSA4LjUgMkgxMnY3SDguNUEzLjUgMy41IDAgMCAxIDUgNS41elxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTEyIDJoMy41YTMuNSAzLjUgMCAxIDEgMCA3SDEyVjJ6XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMTIgMTIuNWEzLjUgMy41IDAgMSAxIDcgMCAzLjUgMy41IDAgMSAxLTcgMHpcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk01IDE5LjVBMy41IDMuNSAwIDAgMSA4LjUgMTZIMTJ2My41YTMuNSAzLjUgMCAxIDEtNyAwelxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTUgMTIuNUEzLjUgMy41IDAgMCAxIDguNSA5SDEydjdIOC41QTMuNSAzLjUgMCAwIDEgNSAxMi41elxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJmaWxlLW1pbnVzXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNCAySDZhMiAyIDAgMCAwLTIgMnYxNmEyIDIgMCAwIDAgMiAyaDEyYTIgMiAwIDAgMCAyLTJWOHpcXFxcXFxcIj48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE0IDIgMTQgOCAyMCA4XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjE1XFxcXFxcXCIgeDI9XFxcXFxcXCIxNVxcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiZmlsZS1wbHVzXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNCAySDZhMiAyIDAgMCAwLTIgMnYxNmEyIDIgMCAwIDAgMiAyaDEyYTIgMiAwIDAgMCAyLTJWOHpcXFxcXFxcIj48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE0IDIgMTQgOCAyMCA4XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOVxcXFxcXFwiIHkxPVxcXFxcXFwiMTVcXFxcXFxcIiB4Mj1cXFxcXFxcIjE1XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJmaWxlLXRleHRcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE0IDJINmEyIDIgMCAwIDAtMiAydjE2YTIgMiAwIDAgMCAyIDJoMTJhMiAyIDAgMCAwIDItMlY4elxcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTQgMiAxNCA4IDIwIDhcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiMTZcXFxcXFxcIiB5MT1cXFxcXFxcIjEzXFxcXFxcXCIgeDI9XFxcXFxcXCI4XFxcXFxcXCIgeTI9XFxcXFxcXCIxM1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE2XFxcXFxcXCIgeTE9XFxcXFxcXCIxN1xcXFxcXFwiIHgyPVxcXFxcXFwiOFxcXFxcXFwiIHkyPVxcXFxcXFwiMTdcXFxcXFxcIj48L2xpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjEwIDkgOSA5IDggOVxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiZmlsZVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTMgMkg2YTIgMiAwIDAgMC0yIDJ2MTZhMiAyIDAgMCAwIDIgMmgxMmEyIDIgMCAwIDAgMi0yVjl6XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxMyAyIDEzIDkgMjAgOVxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiZmlsbVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIyXFxcXFxcXCIgeT1cXFxcXFxcIjJcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjIwXFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMjBcXFxcXFxcIiByeD1cXFxcXFxcIjIuMThcXFxcXFxcIiByeT1cXFxcXFxcIjIuMThcXFxcXFxcIj48L3JlY3Q+PGxpbmUgeDE9XFxcXFxcXCI3XFxcXFxcXCIgeTE9XFxcXFxcXCIyXFxcXFxcXCIgeDI9XFxcXFxcXCI3XFxcXFxcXCIgeTI9XFxcXFxcXCIyMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE3XFxcXFxcXCIgeTE9XFxcXFxcXCIyXFxcXFxcXCIgeDI9XFxcXFxcXCIxN1xcXFxcXFwiIHkyPVxcXFxcXFwiMjJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyXFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMjJcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMlxcXFxcXFwiIHkxPVxcXFxcXFwiN1xcXFxcXFwiIHgyPVxcXFxcXFwiN1xcXFxcXFwiIHkyPVxcXFxcXFwiN1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjJcXFxcXFxcIiB5MT1cXFxcXFxcIjE3XFxcXFxcXCIgeDI9XFxcXFxcXCI3XFxcXFxcXCIgeTI9XFxcXFxcXCIxN1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE3XFxcXFxcXCIgeTE9XFxcXFxcXCIxN1xcXFxcXFwiIHgyPVxcXFxcXFwiMjJcXFxcXFxcIiB5Mj1cXFxcXFxcIjE3XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTdcXFxcXFxcIiB5MT1cXFxcXFxcIjdcXFxcXFxcIiB4Mj1cXFxcXFxcIjIyXFxcXFxcXCIgeTI9XFxcXFxcXCI3XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImZpbHRlclxcXCI6XFxcIjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjIyIDMgMiAzIDEwIDEyLjQ2IDEwIDE5IDE0IDIxIDE0IDEyLjQ2IDIyIDNcXFxcXFxcIj48L3BvbHlnb24+XFxcIixcXFwiZmxhZ1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNNCAxNXMxLTEgNC0xIDUgMiA4IDIgNC0xIDQtMVYzcy0xIDEtNCAxLTUtMi04LTItNCAxLTQgMXpcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCI0XFxcXFxcXCIgeTE9XFxcXFxcXCIyMlxcXFxcXFwiIHgyPVxcXFxcXFwiNFxcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiZm9sZGVyLW1pbnVzXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMiAxOWEyIDIgMCAwIDEtMiAySDRhMiAyIDAgMCAxLTItMlY1YTIgMiAwIDAgMSAyLTJoNWwyIDNoOWEyIDIgMCAwIDEgMiAyelxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjE0XFxcXFxcXCIgeDI9XFxcXFxcXCIxNVxcXFxcXFwiIHkyPVxcXFxcXFwiMTRcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiZm9sZGVyLXBsdXNcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIyIDE5YTIgMiAwIDAgMS0yIDJINGEyIDIgMCAwIDEtMi0yVjVhMiAyIDAgMCAxIDItMmg1bDIgM2g5YTIgMiAwIDAgMSAyIDJ6XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjExXFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTdcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI5XFxcXFxcXCIgeTE9XFxcXFxcXCIxNFxcXFxcXFwiIHgyPVxcXFxcXFwiMTVcXFxcXFxcIiB5Mj1cXFxcXFxcIjE0XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImZvbGRlclxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjIgMTlhMiAyIDAgMCAxLTIgMkg0YTIgMiAwIDAgMS0yLTJWNWEyIDIgMCAwIDEgMi0yaDVsMiAzaDlhMiAyIDAgMCAxIDIgMnpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiZnJhbWVyXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk01IDE2VjloMTRWMkg1bDE0IDE0aC03bS03IDBsNyA3di03bS03IDBoN1xcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJmcm93blxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48cGF0aCBkPVxcXFxcXFwiTTE2IDE2cy0xLjUtMi00LTItNCAyLTQgMlxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjkuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjlcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNVxcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiMTUuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjlcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiZ2lmdFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIyMCAxMiAyMCAyMiA0IDIyIDQgMTJcXFxcXFxcIj48L3BvbHlsaW5lPjxyZWN0IHg9XFxcXFxcXCIyXFxcXFxcXCIgeT1cXFxcXFxcIjdcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjIwXFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiNVxcXFxcXFwiPjwvcmVjdD48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjdcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk0xMiA3SDcuNWEyLjUgMi41IDAgMCAxIDAtNUMxMSAyIDEyIDcgMTIgN3pcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xMiA3aDQuNWEyLjUgMi41IDAgMCAwIDAtNUMxMyAyIDEyIDcgMTIgN3pcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiZ2l0LWJyYW5jaFxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiNlxcXFxcXFwiIHkxPVxcXFxcXFwiM1xcXFxcXFwiIHgyPVxcXFxcXFwiNlxcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+PGNpcmNsZSBjeD1cXFxcXFxcIjE4XFxcXFxcXCIgY3k9XFxcXFxcXCI2XFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXFxcXFwiNlxcXFxcXFwiIGN5PVxcXFxcXFwiMThcXFxcXFxcIiByPVxcXFxcXFwiM1xcXFxcXFwiPjwvY2lyY2xlPjxwYXRoIGQ9XFxcXFxcXCJNMTggOWE5IDkgMCAwIDEtOSA5XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImdpdC1jb21taXRcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjRcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjEuMDVcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCI3XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE3LjAxXFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMjIuOTZcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImdpdC1tZXJnZVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxOFxcXFxcXFwiIGN5PVxcXFxcXFwiMThcXFxcXFxcIiByPVxcXFxcXFwiM1xcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCI2XFxcXFxcXCIgY3k9XFxcXFxcXCI2XFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT48cGF0aCBkPVxcXFxcXFwiTTYgMjFWOWE5IDkgMCAwIDAgOSA5XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImdpdC1wdWxsLXJlcXVlc3RcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMThcXFxcXFxcIiBjeT1cXFxcXFxcIjE4XFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXFxcXFwiNlxcXFxcXFwiIGN5PVxcXFxcXFwiNlxcXFxcXFwiIHI9XFxcXFxcXCIzXFxcXFxcXCI+PC9jaXJjbGU+PHBhdGggZD1cXFxcXFxcIk0xMyA2aDNhMiAyIDAgMCAxIDIgMnY3XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiNlxcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiNlxcXFxcXFwiIHkyPVxcXFxcXFwiMjFcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiZ2l0aHViXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk05IDE5Yy01IDEuNS01LTIuNS03LTNtMTQgNnYtMy44N2EzLjM3IDMuMzcgMCAwIDAtLjk0LTIuNjFjMy4xNC0uMzUgNi40NC0xLjU0IDYuNDQtN0E1LjQ0IDUuNDQgMCAwIDAgMjAgNC43NyA1LjA3IDUuMDcgMCAwIDAgMTkuOTEgMVMxOC43My42NSAxNiAyLjQ4YTEzLjM4IDEzLjM4IDAgMCAwLTcgMEM2LjI3LjY1IDUuMDkgMSA1LjA5IDFBNS4wNyA1LjA3IDAgMCAwIDUgNC43N2E1LjQ0IDUuNDQgMCAwIDAtMS41IDMuNzhjMCA1LjQyIDMuMyA2LjYxIDYuNDQgN0EzLjM3IDMuMzcgMCAwIDAgOSAxOC4xM1YyMlxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJnaXRsYWJcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIyLjY1IDE0LjM5TDEyIDIyLjEzIDEuMzUgMTQuMzlhLjg0Ljg0IDAgMCAxLS4zLS45NGwxLjIyLTMuNzggMi40NC03LjUxQS40Mi40MiAwIDAgMSA0LjgyIDJhLjQzLjQzIDAgMCAxIC41OCAwIC40Mi40MiAwIDAgMSAuMTEuMThsMi40NCA3LjQ5aDguMWwyLjQ0LTcuNTFBLjQyLjQyIDAgMCAxIDE4LjYgMmEuNDMuNDMgMCAwIDEgLjU4IDAgLjQyLjQyIDAgMCAxIC4xMS4xOGwyLjQ0IDcuNTFMMjMgMTMuNDVhLjg0Ljg0IDAgMCAxLS4zNS45NHpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiZ2xvYmVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIyXFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMjJcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxwYXRoIGQ9XFxcXFxcXCJNMTIgMmExNS4zIDE1LjMgMCAwIDEgNCAxMCAxNS4zIDE1LjMgMCAwIDEtNCAxMCAxNS4zIDE1LjMgMCAwIDEtNC0xMCAxNS4zIDE1LjMgMCAwIDEgNC0xMHpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiZ3JpZFxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjNcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjdcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCI3XFxcXFxcXCI+PC9yZWN0PjxyZWN0IHg9XFxcXFxcXCIxNFxcXFxcXFwiIHk9XFxcXFxcXCIzXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCI3XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiN1xcXFxcXFwiPjwvcmVjdD48cmVjdCB4PVxcXFxcXFwiMTRcXFxcXFxcIiB5PVxcXFxcXFwiMTRcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjdcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCI3XFxcXFxcXCI+PC9yZWN0PjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjE0XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCI3XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiN1xcXFxcXFwiPjwvcmVjdD5cXFwiLFxcXCJoYXJkLWRyaXZlXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIyMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjJcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxwYXRoIGQ9XFxcXFxcXCJNNS40NSA1LjExTDIgMTJ2NmEyIDIgMCAwIDAgMiAyaDE2YTIgMiAwIDAgMCAyLTJ2LTZsLTMuNDUtNi44OUEyIDIgMCAwIDAgMTYuNzYgNEg3LjI0YTIgMiAwIDAgMC0xLjc5IDEuMTF6XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiNlxcXFxcXFwiIHkxPVxcXFxcXFwiMTZcXFxcXFxcIiB4Mj1cXFxcXFxcIjYuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjE2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTBcXFxcXFxcIiB5MT1cXFxcXFxcIjE2XFxcXFxcXCIgeDI9XFxcXFxcXCIxMC4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMTZcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiaGFzaFxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiNFxcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiMjBcXFxcXFxcIiB5Mj1cXFxcXFxcIjlcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI0XFxcXFxcXCIgeTE9XFxcXFxcXCIxNVxcXFxcXFwiIHgyPVxcXFxcXFwiMjBcXFxcXFxcIiB5Mj1cXFxcXFxcIjE1XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTBcXFxcXFxcIiB5MT1cXFxcXFxcIjNcXFxcXFxcIiB4Mj1cXFxcXFxcIjhcXFxcXFxcIiB5Mj1cXFxcXFxcIjIxXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTZcXFxcXFxcIiB5MT1cXFxcXFxcIjNcXFxcXFxcIiB4Mj1cXFxcXFxcIjE0XFxcXFxcXCIgeTI9XFxcXFxcXCIyMVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJoZWFkcGhvbmVzXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0zIDE4di02YTkgOSAwIDAgMSAxOCAwdjZcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0yMSAxOWEyIDIgMCAwIDEtMiAyaC0xYTIgMiAwIDAgMS0yLTJ2LTNhMiAyIDAgMCAxIDItMmgzek0zIDE5YTIgMiAwIDAgMCAyIDJoMWEyIDIgMCAwIDAgMi0ydi0zYTIgMiAwIDAgMC0yLTJIM3pcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiaGVhcnRcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIwLjg0IDQuNjFhNS41IDUuNSAwIDAgMC03Ljc4IDBMMTIgNS42N2wtMS4wNi0xLjA2YTUuNSA1LjUgMCAwIDAtNy43OCA3Ljc4bDEuMDYgMS4wNkwxMiAyMS4yM2w3Ljc4LTcuNzggMS4wNi0xLjA2YTUuNSA1LjUgMCAwIDAgMC03Ljc4elxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJoZWxwLWNpcmNsZVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48cGF0aCBkPVxcXFxcXFwiTTkuMDkgOWEzIDMgMCAwIDEgNS44MyAxYzAgMi0zIDMtMyAzXFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjE3XFxcXFxcXCIgeDI9XFxcXFxcXCIxMi4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMTdcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiaGV4YWdvblxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjEgMTZWOGEyIDIgMCAwIDAtMS0xLjczbC03LTRhMiAyIDAgMCAwLTIgMGwtNyA0QTIgMiAwIDAgMCAzIDh2OGEyIDIgMCAwIDAgMSAxLjczbDcgNGEyIDIgMCAwIDAgMiAwbDctNEEyIDIgMCAwIDAgMjEgMTZ6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImhvbWVcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTMgOWw5LTcgOSA3djExYTIgMiAwIDAgMS0yIDJINWEyIDIgMCAwIDEtMi0yelxcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiOSAyMiA5IDEyIDE1IDEyIDE1IDIyXFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJpbWFnZVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjNcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMThcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PGNpcmNsZSBjeD1cXFxcXFxcIjguNVxcXFxcXFwiIGN5PVxcXFxcXFwiOC41XFxcXFxcXCIgcj1cXFxcXFxcIjEuNVxcXFxcXFwiPjwvY2lyY2xlPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIyMSAxNSAxNiAxMCA1IDIxXFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJpbmJveFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIyMiAxMiAxNiAxMiAxNCAxNSAxMCAxNSA4IDEyIDIgMTJcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNNS40NSA1LjExTDIgMTJ2NmEyIDIgMCAwIDAgMiAyaDE2YTIgMiAwIDAgMCAyLTJ2LTZsLTMuNDUtNi44OUEyIDIgMCAwIDAgMTYuNzYgNEg3LjI0YTIgMiAwIDAgMC0xLjc5IDEuMTF6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImluZm9cXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTZcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCI4XFxcXFxcXCIgeDI9XFxcXFxcXCIxMi4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiOFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJpbnN0YWdyYW1cXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiMlxcXFxcXFwiIHk9XFxcXFxcXCIyXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIyMFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjIwXFxcXFxcXCIgcng9XFxcXFxcXCI1XFxcXFxcXCIgcnk9XFxcXFxcXCI1XFxcXFxcXCI+PC9yZWN0PjxwYXRoIGQ9XFxcXFxcXCJNMTYgMTEuMzdBNCA0IDAgMSAxIDEyLjYzIDggNCA0IDAgMCAxIDE2IDExLjM3elxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjE3LjVcXFxcXFxcIiB5MT1cXFxcXFxcIjYuNVxcXFxcXFwiIHgyPVxcXFxcXFwiMTcuNTFcXFxcXFxcIiB5Mj1cXFxcXFxcIjYuNVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJpdGFsaWNcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjE5XFxcXFxcXCIgeTE9XFxcXFxcXCI0XFxcXFxcXCIgeDI9XFxcXFxcXCIxMFxcXFxcXFwiIHkyPVxcXFxcXFwiNFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE0XFxcXFxcXCIgeTE9XFxcXFxcXCIyMFxcXFxcXFwiIHgyPVxcXFxcXFwiNVxcXFxcXFwiIHkyPVxcXFxcXFwiMjBcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNVxcXFxcXFwiIHkxPVxcXFxcXFwiNFxcXFxcXFwiIHgyPVxcXFxcXFwiOVxcXFxcXFwiIHkyPVxcXFxcXFwiMjBcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwia2V5XFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMSAybC0yIDJtLTcuNjEgNy42MWE1LjUgNS41IDAgMSAxLTcuNzc4IDcuNzc4IDUuNSA1LjUgMCAwIDEgNy43NzctNy43Nzd6bTAgMEwxNS41IDcuNW0wIDBsMyAzTDIyIDdsLTMtM20tMy41IDMuNUwxOSA0XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImxheWVyc1xcXCI6XFxcIjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjEyIDIgMiA3IDEyIDEyIDIyIDcgMTIgMlxcXFxcXFwiPjwvcG9seWdvbj48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMiAxNyAxMiAyMiAyMiAxN1xcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIgMTIgMTIgMTcgMjIgMTJcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImxheW91dFxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjNcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMThcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PGxpbmUgeDE9XFxcXFxcXCIzXFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCIyMVxcXFxcXFwiIHkyPVxcXFxcXFwiOVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjIxXFxcXFxcXCIgeDI9XFxcXFxcXCI5XFxcXFxcXCIgeTI9XFxcXFxcXCI5XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImxpZmUtYnVveVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjRcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjQuOTNcXFxcXFxcIiB5MT1cXFxcXFxcIjQuOTNcXFxcXFxcIiB4Mj1cXFxcXFxcIjkuMTdcXFxcXFxcIiB5Mj1cXFxcXFxcIjkuMTdcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNC44M1xcXFxcXFwiIHkxPVxcXFxcXFwiMTQuODNcXFxcXFxcIiB4Mj1cXFxcXFxcIjE5LjA3XFxcXFxcXCIgeTI9XFxcXFxcXCIxOS4wN1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE0LjgzXFxcXFxcXCIgeTE9XFxcXFxcXCI5LjE3XFxcXFxcXCIgeDI9XFxcXFxcXCIxOS4wN1xcXFxcXFwiIHkyPVxcXFxcXFwiNC45M1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE0LjgzXFxcXFxcXCIgeTE9XFxcXFxcXCI5LjE3XFxcXFxcXCIgeDI9XFxcXFxcXCIxOC4zNlxcXFxcXFwiIHkyPVxcXFxcXFwiNS42NFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjQuOTNcXFxcXFxcIiB5MT1cXFxcXFxcIjE5LjA3XFxcXFxcXCIgeDI9XFxcXFxcXCI5LjE3XFxcXFxcXCIgeTI9XFxcXFxcXCIxNC44M1xcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJsaW5rLTJcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE1IDdoM2E1IDUgMCAwIDEgNSA1IDUgNSAwIDAgMS01IDVoLTNtLTYgMEg2YTUgNSAwIDAgMS01LTUgNSA1IDAgMCAxIDUtNWgzXFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJsaW5rXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xMCAxM2E1IDUgMCAwIDAgNy41NC41NGwzLTNhNSA1IDAgMCAwLTcuMDctNy4wN2wtMS43MiAxLjcxXFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMTQgMTFhNSA1IDAgMCAwLTcuNTQtLjU0bC0zIDNhNSA1IDAgMCAwIDcuMDcgNy4wN2wxLjcxLTEuNzFcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwibGlua2VkaW5cXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE2IDhhNiA2IDAgMCAxIDYgNnY3aC00di03YTIgMiAwIDAgMC0yLTIgMiAyIDAgMCAwLTIgMnY3aC00di03YTYgNiAwIDAgMSA2LTZ6XFxcXFxcXCI+PC9wYXRoPjxyZWN0IHg9XFxcXFxcXCIyXFxcXFxcXCIgeT1cXFxcXFxcIjlcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjRcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxMlxcXFxcXFwiPjwvcmVjdD48Y2lyY2xlIGN4PVxcXFxcXFwiNFxcXFxcXFwiIGN5PVxcXFxcXFwiNFxcXFxcXFwiIHI9XFxcXFxcXCIyXFxcXFxcXCI+PC9jaXJjbGU+XFxcIixcXFwibGlzdFxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiNlxcXFxcXFwiIHgyPVxcXFxcXFwiMjFcXFxcXFxcIiB5Mj1cXFxcXFxcIjZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMjFcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMThcXFxcXFxcIiB4Mj1cXFxcXFxcIjIxXFxcXFxcXCIgeTI9XFxcXFxcXCIxOFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjNcXFxcXFxcIiB5MT1cXFxcXFxcIjZcXFxcXFxcIiB4Mj1cXFxcXFxcIjMuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIzXFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMy4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIzXFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiMy4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwibG9hZGVyXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMThcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIyMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjQuOTNcXFxcXFxcIiB5MT1cXFxcXFxcIjQuOTNcXFxcXFxcIiB4Mj1cXFxcXFxcIjcuNzZcXFxcXFxcIiB5Mj1cXFxcXFxcIjcuNzZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNi4yNFxcXFxcXFwiIHkxPVxcXFxcXFwiMTYuMjRcXFxcXFxcIiB4Mj1cXFxcXFxcIjE5LjA3XFxcXFxcXCIgeTI9XFxcXFxcXCIxOS4wN1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjJcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCI2XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE4XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMjJcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiNC45M1xcXFxcXFwiIHkxPVxcXFxcXFwiMTkuMDdcXFxcXFxcIiB4Mj1cXFxcXFxcIjcuNzZcXFxcXFxcIiB5Mj1cXFxcXFxcIjE2LjI0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTYuMjRcXFxcXFxcIiB5MT1cXFxcXFxcIjcuNzZcXFxcXFxcIiB4Mj1cXFxcXFxcIjE5LjA3XFxcXFxcXCIgeTI9XFxcXFxcXCI0LjkzXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImxvY2tcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiM1xcXFxcXFwiIHk9XFxcXFxcXCIxMVxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMThcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxMVxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD48cGF0aCBkPVxcXFxcXFwiTTcgMTFWN2E1IDUgMCAwIDEgMTAgMHY0XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImxvZy1pblxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTUgM2g0YTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMmgtNFxcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTAgMTcgMTUgMTIgMTAgN1xcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNVxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImxvZy1vdXRcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTkgMjFINWEyIDIgMCAwIDEtMi0yVjVhMiAyIDAgMCAxIDItMmg0XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNiAxNyAyMSAxMiAxNiA3XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiOVxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwibWFpbFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNNCA0aDE2YzEuMSAwIDIgLjkgMiAydjEyYzAgMS4xLS45IDItMiAySDRjLTEuMSAwLTItLjktMi0yVjZjMC0xLjEuOS0yIDItMnpcXFxcXFxcIj48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIyLDYgMTIsMTMgMiw2XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJtYXAtcGluXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMSAxMGMwIDctOSAxMy05IDEzcy05LTYtOS0xM2E5IDkgMCAwIDEgMTggMHpcXFxcXFxcIj48L3BhdGg+PGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMFxcXFxcXFwiIHI9XFxcXFxcXCIzXFxcXFxcXCI+PC9jaXJjbGU+XFxcIixcXFwibWFwXFxcIjpcXFwiPHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMSA2IDEgMjIgOCAxOCAxNiAyMiAyMyAxOCAyMyAyIDE2IDYgOCAyIDEgNlxcXFxcXFwiPjwvcG9seWdvbj48bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjJcXFxcXFxcIiB4Mj1cXFxcXFxcIjhcXFxcXFxcIiB5Mj1cXFxcXFxcIjE4XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTZcXFxcXFxcIiB5MT1cXFxcXFxcIjZcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIyMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJtYXhpbWl6ZS0yXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE1IDMgMjEgMyAyMSA5XFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiOSAyMSAzIDIxIDMgMTVcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjNcXFxcXFxcIiB4Mj1cXFxcXFxcIjE0XFxcXFxcXCIgeTI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjNcXFxcXFxcIiB5MT1cXFxcXFxcIjIxXFxcXFxcXCIgeDI9XFxcXFxcXCIxMFxcXFxcXFwiIHkyPVxcXFxcXFwiMTRcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwibWF4aW1pemVcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTggM0g1YTIgMiAwIDAgMC0yIDJ2M20xOCAwVjVhMiAyIDAgMCAwLTItMmgtM20wIDE4aDNhMiAyIDAgMCAwIDItMnYtM00zIDE2djNhMiAyIDAgMCAwIDIgMmgzXFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcIm1laFxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjE1XFxcXFxcXCIgeDI9XFxcXFxcXCIxNlxcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI5XFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCI5LjAxXFxcXFxcXCIgeTI9XFxcXFxcXCI5XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTVcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjE1LjAxXFxcXFxcXCIgeTI9XFxcXFxcXCI5XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcIm1lbnVcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjNcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIyMVxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIzXFxcXFxcXCIgeTE9XFxcXFxcXCI2XFxcXFxcXCIgeDI9XFxcXFxcXCIyMVxcXFxcXFwiIHkyPVxcXFxcXFwiNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjNcXFxcXFxcIiB5MT1cXFxcXFxcIjE4XFxcXFxcXCIgeDI9XFxcXFxcXCIyMVxcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwibWVzc2FnZS1jaXJjbGVcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIxIDExLjVhOC4zOCA4LjM4IDAgMCAxLS45IDMuOCA4LjUgOC41IDAgMCAxLTcuNiA0LjcgOC4zOCA4LjM4IDAgMCAxLTMuOC0uOUwzIDIxbDEuOS01LjdhOC4zOCA4LjM4IDAgMCAxLS45LTMuOCA4LjUgOC41IDAgMCAxIDQuNy03LjYgOC4zOCA4LjM4IDAgMCAxIDMuOC0uOWguNWE4LjQ4IDguNDggMCAwIDEgOCA4di41elxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJtZXNzYWdlLXNxdWFyZVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjEgMTVhMiAyIDAgMCAxLTIgMkg3bC00IDRWNWEyIDIgMCAwIDEgMi0yaDE0YTIgMiAwIDAgMSAyIDJ6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcIm1pYy1vZmZcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjFcXFxcXFxcIiB5MT1cXFxcXFxcIjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIyM1xcXFxcXFwiPjwvbGluZT48cGF0aCBkPVxcXFxcXFwiTTkgOXYzYTMgMyAwIDAgMCA1LjEyIDIuMTJNMTUgOS4zNFY0YTMgMyAwIDAgMC01Ljk0LS42XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMTcgMTYuOTVBNyA3IDAgMCAxIDUgMTJ2LTJtMTQgMHYyYTcgNyAwIDAgMS0uMTEgMS4yM1xcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxOVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMjNcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIyM1xcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJtaWNcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTEyIDFhMyAzIDAgMCAwLTMgM3Y4YTMgMyAwIDAgMCA2IDBWNGEzIDMgMCAwIDAtMy0zelxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTE5IDEwdjJhNyA3IDAgMCAxLTE0IDB2LTJcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTlcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIyM1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjIzXFxcXFxcXCIgeDI9XFxcXFxcXCIxNlxcXFxcXFwiIHkyPVxcXFxcXFwiMjNcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwibWluaW1pemUtMlxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI0IDE0IDEwIDE0IDEwIDIwXFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMjAgMTAgMTQgMTAgMTQgNFxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNFxcXFxcXFwiIHkxPVxcXFxcXFwiMTBcXFxcXFxcIiB4Mj1cXFxcXFxcIjIxXFxcXFxcXCIgeTI9XFxcXFxcXCIzXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiM1xcXFxcXFwiIHkxPVxcXFxcXFwiMjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjEwXFxcXFxcXCIgeTI9XFxcXFxcXCIxNFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJtaW5pbWl6ZVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNOCAzdjNhMiAyIDAgMCAxLTIgMkgzbTE4IDBoLTNhMiAyIDAgMCAxLTItMlYzbTAgMTh2LTNhMiAyIDAgMCAxIDItMmgzTTMgMTZoM2EyIDIgMCAwIDEgMiAydjNcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwibWludXMtY2lyY2xlXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJtaW51cy1zcXVhcmVcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiM1xcXFxcXFwiIHk9XFxcXFxcXCIzXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIxOFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjE4XFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJtaW51c1xcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiNVxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjE5XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJtb25pdG9yXFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjJcXFxcXFxcIiB5PVxcXFxcXFwiM1xcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMjBcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxNFxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD48bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjIxXFxcXFxcXCIgeDI9XFxcXFxcXCIxNlxcXFxcXFwiIHkyPVxcXFxcXFwiMjFcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTdcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIyMVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJtb29uXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMSAxMi43OUE5IDkgMCAxIDEgMTEuMjEgMyA3IDcgMCAwIDAgMjEgMTIuNzl6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcIm1vcmUtaG9yaXpvbnRhbFxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMVxcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCIxOVxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMVxcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCI1XFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxXFxcXFxcXCI+PC9jaXJjbGU+XFxcIixcXFwibW9yZS12ZXJ0aWNhbFxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMVxcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiNVxcXFxcXFwiIHI9XFxcXFxcXCIxXFxcXFxcXCI+PC9jaXJjbGU+PGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxOVxcXFxcXFwiIHI9XFxcXFxcXCIxXFxcXFxcXCI+PC9jaXJjbGU+XFxcIixcXFwibW91c2UtcG9pbnRlclxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMyAzbDcuMDcgMTYuOTcgMi41MS03LjM5IDcuMzktMi41MUwzIDN6XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMTMgMTNsNiA2XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcIm1vdmVcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiNSA5IDIgMTIgNSAxNVxcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjkgNSAxMiAyIDE1IDVcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNSAxOSAxMiAyMiA5IDE5XFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTkgOSAyMiAxMiAxOSAxNVxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIyXFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMjJcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjJcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIyMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJtdXNpY1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNOSAxOFY1bDEyLTJ2MTNcXFxcXFxcIj48L3BhdGg+PGNpcmNsZSBjeD1cXFxcXFxcIjZcXFxcXFxcIiBjeT1cXFxcXFxcIjE4XFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXFxcXFwiMThcXFxcXFxcIiBjeT1cXFxcXFxcIjE2XFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJuYXZpZ2F0aW9uLTJcXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCIxMiAyIDE5IDIxIDEyIDE3IDUgMjEgMTIgMlxcXFxcXFwiPjwvcG9seWdvbj5cXFwiLFxcXCJuYXZpZ2F0aW9uXFxcIjpcXFwiPHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMyAxMSAyMiAyIDEzIDIxIDExIDEzIDMgMTFcXFxcXFxcIj48L3BvbHlnb24+XFxcIixcXFwib2N0YWdvblxcXCI6XFxcIjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjcuODYgMiAxNi4xNCAyIDIyIDcuODYgMjIgMTYuMTQgMTYuMTQgMjIgNy44NiAyMiAyIDE2LjE0IDIgNy44NiA3Ljg2IDJcXFxcXFxcIj48L3BvbHlnb24+XFxcIixcXFwicGFja2FnZVxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMTYuNVxcXFxcXFwiIHkxPVxcXFxcXFwiOS40XFxcXFxcXCIgeDI9XFxcXFxcXCI3LjVcXFxcXFxcIiB5Mj1cXFxcXFxcIjQuMjFcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk0yMSAxNlY4YTIgMiAwIDAgMC0xLTEuNzNsLTctNGEyIDIgMCAwIDAtMiAwbC03IDRBMiAyIDAgMCAwIDMgOHY4YTIgMiAwIDAgMCAxIDEuNzNsNyA0YTIgMiAwIDAgMCAyIDBsNy00QTIgMiAwIDAgMCAyMSAxNnpcXFxcXFxcIj48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjMuMjcgNi45NiAxMiAxMi4wMSAyMC43MyA2Ljk2XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMi4wOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInBhcGVyY2xpcFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjEuNDQgMTEuMDVsLTkuMTkgOS4xOWE2IDYgMCAwIDEtOC40OS04LjQ5bDkuMTktOS4xOWE0IDQgMCAwIDEgNS42NiA1LjY2bC05LjIgOS4xOWEyIDIgMCAwIDEtMi44My0yLjgzbDguNDktOC40OFxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJwYXVzZS1jaXJjbGVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIxMFxcXFxcXFwiIHkxPVxcXFxcXFwiMTVcXFxcXFxcIiB4Mj1cXFxcXFxcIjEwXFxcXFxcXCIgeTI9XFxcXFxcXCI5XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTRcXFxcXFxcIiB5MT1cXFxcXFxcIjE1XFxcXFxcXCIgeDI9XFxcXFxcXCIxNFxcXFxcXFwiIHkyPVxcXFxcXFwiOVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJwYXVzZVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCI2XFxcXFxcXCIgeT1cXFxcXFxcIjRcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjRcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxNlxcXFxcXFwiPjwvcmVjdD48cmVjdCB4PVxcXFxcXFwiMTRcXFxcXFxcIiB5PVxcXFxcXFwiNFxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiNFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjE2XFxcXFxcXCI+PC9yZWN0PlxcXCIsXFxcInBlbi10b29sXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xMiAxOWw3LTcgMyAzLTcgNy0zLTN6XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMTggMTNsLTEuNS03LjVMMiAybDMuNSAxNC41TDEzIDE4bDUtNXpcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0yIDJsNy41ODYgNy41ODZcXFxcXFxcIj48L3BhdGg+PGNpcmNsZSBjeD1cXFxcXFxcIjExXFxcXFxcXCIgY3k9XFxcXFxcXCIxMVxcXFxcXFwiIHI9XFxcXFxcXCIyXFxcXFxcXCI+PC9jaXJjbGU+XFxcIixcXFwicGVyY2VudFxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMTlcXFxcXFxcIiB5MT1cXFxcXFxcIjVcXFxcXFxcIiB4Mj1cXFxcXFxcIjVcXFxcXFxcIiB5Mj1cXFxcXFxcIjE5XFxcXFxcXCI+PC9saW5lPjxjaXJjbGUgY3g9XFxcXFxcXCI2LjVcXFxcXFxcIiBjeT1cXFxcXFxcIjYuNVxcXFxcXFwiIHI9XFxcXFxcXCIyLjVcXFxcXFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXFxcXFwiMTcuNVxcXFxcXFwiIGN5PVxcXFxcXFwiMTcuNVxcXFxcXFwiIHI9XFxcXFxcXCIyLjVcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJwaG9uZS1jYWxsXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNS4wNSA1QTUgNSAwIDAgMSAxOSA4Ljk1TTE1LjA1IDFBOSA5IDAgMCAxIDIzIDguOTRtLTEgNy45OHYzYTIgMiAwIDAgMS0yLjE4IDIgMTkuNzkgMTkuNzkgMCAwIDEtOC42My0zLjA3IDE5LjUgMTkuNSAwIDAgMS02LTYgMTkuNzkgMTkuNzkgMCAwIDEtMy4wNy04LjY3QTIgMiAwIDAgMSA0LjExIDJoM2EyIDIgMCAwIDEgMiAxLjcyIDEyLjg0IDEyLjg0IDAgMCAwIC43IDIuODEgMiAyIDAgMCAxLS40NSAyLjExTDguMDkgOS45MWExNiAxNiAwIDAgMCA2IDZsMS4yNy0xLjI3YTIgMiAwIDAgMSAyLjExLS40NSAxMi44NCAxMi44NCAwIDAgMCAyLjgxLjdBMiAyIDAgMCAxIDIyIDE2LjkyelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJwaG9uZS1mb3J3YXJkZWRcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTkgMSAyMyA1IDE5IDlcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiMTVcXFxcXFxcIiB5MT1cXFxcXFxcIjVcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCI1XFxcXFxcXCI+PC9saW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjIgMTYuOTJ2M2EyIDIgMCAwIDEtMi4xOCAyIDE5Ljc5IDE5Ljc5IDAgMCAxLTguNjMtMy4wNyAxOS41IDE5LjUgMCAwIDEtNi02IDE5Ljc5IDE5Ljc5IDAgMCAxLTMuMDctOC42N0EyIDIgMCAwIDEgNC4xMSAyaDNhMiAyIDAgMCAxIDIgMS43MiAxMi44NCAxMi44NCAwIDAgMCAuNyAyLjgxIDIgMiAwIDAgMS0uNDUgMi4xMUw4LjA5IDkuOTFhMTYgMTYgMCAwIDAgNiA2bDEuMjctMS4yN2EyIDIgMCAwIDEgMi4xMS0uNDUgMTIuODQgMTIuODQgMCAwIDAgMi44MS43QTIgMiAwIDAgMSAyMiAxNi45MnpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwicGhvbmUtaW5jb21pbmdcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTYgMiAxNiA4IDIyIDhcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiMjNcXFxcXFxcIiB5MT1cXFxcXFxcIjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCI4XFxcXFxcXCI+PC9saW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjIgMTYuOTJ2M2EyIDIgMCAwIDEtMi4xOCAyIDE5Ljc5IDE5Ljc5IDAgMCAxLTguNjMtMy4wNyAxOS41IDE5LjUgMCAwIDEtNi02IDE5Ljc5IDE5Ljc5IDAgMCAxLTMuMDctOC42N0EyIDIgMCAwIDEgNC4xMSAyaDNhMiAyIDAgMCAxIDIgMS43MiAxMi44NCAxMi44NCAwIDAgMCAuNyAyLjgxIDIgMiAwIDAgMS0uNDUgMi4xMUw4LjA5IDkuOTFhMTYgMTYgMCAwIDAgNiA2bDEuMjctMS4yN2EyIDIgMCAwIDEgMi4xMS0uNDUgMTIuODQgMTIuODQgMCAwIDAgMi44MS43QTIgMiAwIDAgMSAyMiAxNi45MnpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwicGhvbmUtbWlzc2VkXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIyM1xcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTdcXFxcXFxcIiB5Mj1cXFxcXFxcIjdcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxN1xcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjdcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk0yMiAxNi45MnYzYTIgMiAwIDAgMS0yLjE4IDIgMTkuNzkgMTkuNzkgMCAwIDEtOC42My0zLjA3IDE5LjUgMTkuNSAwIDAgMS02LTYgMTkuNzkgMTkuNzkgMCAwIDEtMy4wNy04LjY3QTIgMiAwIDAgMSA0LjExIDJoM2EyIDIgMCAwIDEgMiAxLjcyIDEyLjg0IDEyLjg0IDAgMCAwIC43IDIuODEgMiAyIDAgMCAxLS40NSAyLjExTDguMDkgOS45MWExNiAxNiAwIDAgMCA2IDZsMS4yNy0xLjI3YTIgMiAwIDAgMSAyLjExLS40NSAxMi44NCAxMi44NCAwIDAgMCAyLjgxLjdBMiAyIDAgMCAxIDIyIDE2LjkyelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJwaG9uZS1vZmZcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTEwLjY4IDEzLjMxYTE2IDE2IDAgMCAwIDMuNDEgMi42bDEuMjctMS4yN2EyIDIgMCAwIDEgMi4xMS0uNDUgMTIuODQgMTIuODQgMCAwIDAgMi44MS43IDIgMiAwIDAgMSAxLjcyIDJ2M2EyIDIgMCAwIDEtMi4xOCAyIDE5Ljc5IDE5Ljc5IDAgMCAxLTguNjMtMy4wNyAxOS40MiAxOS40MiAwIDAgMS0zLjMzLTIuNjdtLTIuNjctMy4zNGExOS43OSAxOS43OSAwIDAgMS0zLjA3LTguNjNBMiAyIDAgMCAxIDQuMTEgMmgzYTIgMiAwIDAgMSAyIDEuNzIgMTIuODQgMTIuODQgMCAwIDAgLjcgMi44MSAyIDIgMCAwIDEtLjQ1IDIuMTFMOC4wOSA5LjkxXFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMjNcXFxcXFxcIiB5MT1cXFxcXFxcIjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjFcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInBob25lLW91dGdvaW5nXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIzIDcgMjMgMSAxNyAxXFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjE2XFxcXFxcXCIgeTE9XFxcXFxcXCI4XFxcXFxcXCIgeDI9XFxcXFxcXCIyM1xcXFxcXFwiIHkyPVxcXFxcXFwiMVxcXFxcXFwiPjwvbGluZT48cGF0aCBkPVxcXFxcXFwiTTIyIDE2LjkydjNhMiAyIDAgMCAxLTIuMTggMiAxOS43OSAxOS43OSAwIDAgMS04LjYzLTMuMDcgMTkuNSAxOS41IDAgMCAxLTYtNiAxOS43OSAxOS43OSAwIDAgMS0zLjA3LTguNjdBMiAyIDAgMCAxIDQuMTEgMmgzYTIgMiAwIDAgMSAyIDEuNzIgMTIuODQgMTIuODQgMCAwIDAgLjcgMi44MSAyIDIgMCAwIDEtLjQ1IDIuMTFMOC4wOSA5LjkxYTE2IDE2IDAgMCAwIDYgNmwxLjI3LTEuMjdhMiAyIDAgMCAxIDIuMTEtLjQ1IDEyLjg0IDEyLjg0IDAgMCAwIDIuODEuN0EyIDIgMCAwIDEgMjIgMTYuOTJ6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInBob25lXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMiAxNi45MnYzYTIgMiAwIDAgMS0yLjE4IDIgMTkuNzkgMTkuNzkgMCAwIDEtOC42My0zLjA3IDE5LjUgMTkuNSAwIDAgMS02LTYgMTkuNzkgMTkuNzkgMCAwIDEtMy4wNy04LjY3QTIgMiAwIDAgMSA0LjExIDJoM2EyIDIgMCAwIDEgMiAxLjcyIDEyLjg0IDEyLjg0IDAgMCAwIC43IDIuODEgMiAyIDAgMCAxLS40NSAyLjExTDguMDkgOS45MWExNiAxNiAwIDAgMCA2IDZsMS4yNy0xLjI3YTIgMiAwIDAgMSAyLjExLS40NSAxMi44NCAxMi44NCAwIDAgMCAyLjgxLjdBMiAyIDAgMCAxIDIyIDE2LjkyelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJwaWUtY2hhcnRcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIxLjIxIDE1Ljg5QTEwIDEwIDAgMSAxIDggMi44M1xcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTIyIDEyQTEwIDEwIDAgMCAwIDEyIDJ2MTB6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInBsYXktY2lyY2xlXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjEwIDggMTYgMTIgMTAgMTYgMTAgOFxcXFxcXFwiPjwvcG9seWdvbj5cXFwiLFxcXCJwbGF5XFxcIjpcXFwiPHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiNSAzIDE5IDEyIDUgMjEgNSAzXFxcXFxcXCI+PC9wb2x5Z29uPlxcXCIsXFxcInBsdXMtY2lyY2xlXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIxNlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwicGx1cy1zcXVhcmVcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiM1xcXFxcXFwiIHk9XFxcXFxcXCIzXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIxOFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjE4XFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIxNlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwicGx1c1xcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjVcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxOVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjVcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIxOVxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwicG9ja2V0XFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk00IDNoMTZhMiAyIDAgMCAxIDIgMnY2YTEwIDEwIDAgMCAxLTEwIDEwQTEwIDEwIDAgMCAxIDIgMTFWNWEyIDIgMCAwIDEgMi0yelxcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiOCAxMCAxMiAxNCAxNiAxMFxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwicG93ZXJcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE4LjM2IDYuNjRhOSA5IDAgMSAxLTEyLjczIDBcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInByaW50ZXJcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiNiA5IDYgMiAxOCAyIDE4IDlcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNNiAxOEg0YTIgMiAwIDAgMS0yLTJ2LTVhMiAyIDAgMCAxIDItMmgxNmEyIDIgMCAwIDEgMiAydjVhMiAyIDAgMCAxLTIgMmgtMlxcXFxcXFwiPjwvcGF0aD48cmVjdCB4PVxcXFxcXFwiNlxcXFxcXFwiIHk9XFxcXFxcXCIxNFxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMTJcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCI4XFxcXFxcXCI+PC9yZWN0PlxcXCIsXFxcInJhZGlvXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIyXFxcXFxcXCI+PC9jaXJjbGU+PHBhdGggZD1cXFxcXFxcIk0xNi4yNCA3Ljc2YTYgNiAwIDAgMSAwIDguNDltLTguNDgtLjAxYTYgNiAwIDAgMSAwLTguNDltMTEuMzEtMi44MmExMCAxMCAwIDAgMSAwIDE0LjE0bS0xNC4xNCAwYTEwIDEwIDAgMCAxIDAtMTQuMTRcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwicmVmcmVzaC1jY3dcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMSA0IDEgMTAgNyAxMFxcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIzIDIwIDIzIDE0IDE3IDE0XFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTIwLjQ5IDlBOSA5IDAgMCAwIDUuNjQgNS42NEwxIDEwbTIyIDRsLTQuNjQgNC4zNkE5IDkgMCAwIDEgMy41MSAxNVxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJyZWZyZXNoLWN3XFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIzIDQgMjMgMTAgMTcgMTBcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxIDIwIDEgMTQgNyAxNFxcXFxcXFwiPjwvcG9seWxpbmU+PHBhdGggZD1cXFxcXFxcIk0zLjUxIDlhOSA5IDAgMCAxIDE0Ljg1LTMuMzZMMjMgMTBNMSAxNGw0LjY0IDQuMzZBOSA5IDAgMCAwIDIwLjQ5IDE1XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInJlcGVhdFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNyAxIDIxIDUgMTcgOVxcXFxcXFwiPjwvcG9seWxpbmU+PHBhdGggZD1cXFxcXFxcIk0zIDExVjlhNCA0IDAgMCAxIDQtNGgxNFxcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiNyAyMyAzIDE5IDcgMTVcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjEgMTN2MmE0IDQgMCAwIDEtNCA0SDNcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwicmV3aW5kXFxcIjpcXFwiPHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMTEgMTkgMiAxMiAxMSA1IDExIDE5XFxcXFxcXCI+PC9wb2x5Z29uPjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjIyIDE5IDEzIDEyIDIyIDUgMjIgMTlcXFxcXFxcIj48L3BvbHlnb24+XFxcIixcXFwicm90YXRlLWNjd1xcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxIDQgMSAxMCA3IDEwXFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTMuNTEgMTVhOSA5IDAgMSAwIDIuMTMtOS4zNkwxIDEwXFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInJvdGF0ZS1jd1xcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIyMyA0IDIzIDEwIDE3IDEwXFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTIwLjQ5IDE1YTkgOSAwIDEgMS0yLjEyLTkuMzZMMjMgMTBcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwicnNzXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk00IDExYTkgOSAwIDAgMSA5IDlcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk00IDRhMTYgMTYgMCAwIDEgMTYgMTZcXFxcXFxcIj48L3BhdGg+PGNpcmNsZSBjeD1cXFxcXFxcIjVcXFxcXFxcIiBjeT1cXFxcXFxcIjE5XFxcXFxcXCIgcj1cXFxcXFxcIjFcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJzYXZlXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xOSAyMUg1YTIgMiAwIDAgMS0yLTJWNWEyIDIgMCAwIDEgMi0yaDExbDUgNXYxMWEyIDIgMCAwIDEtMiAyelxcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTcgMjEgMTcgMTMgNyAxMyA3IDIxXFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiNyAzIDcgOCAxNSA4XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJzY2lzc29yc1xcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCI2XFxcXFxcXCIgY3k9XFxcXFxcXCI2XFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXFxcXFwiNlxcXFxcXFwiIGN5PVxcXFxcXFwiMThcXFxcXFxcIiByPVxcXFxcXFwiM1xcXFxcXFwiPjwvY2lyY2xlPjxsaW5lIHgxPVxcXFxcXFwiMjBcXFxcXFxcIiB5MT1cXFxcXFxcIjRcXFxcXFxcIiB4Mj1cXFxcXFxcIjguMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjE1Ljg4XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTQuNDdcXFxcXFxcIiB5MT1cXFxcXFxcIjE0LjQ4XFxcXFxcXCIgeDI9XFxcXFxcXCIyMFxcXFxcXFwiIHkyPVxcXFxcXFwiMjBcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI4LjEyXFxcXFxcXCIgeTE9XFxcXFxcXCI4LjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwic2VhcmNoXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjExXFxcXFxcXCIgY3k9XFxcXFxcXCIxMVxcXFxcXFwiIHI9XFxcXFxcXCI4XFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIyMVxcXFxcXFwiIHkxPVxcXFxcXFwiMjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2LjY1XFxcXFxcXCIgeTI9XFxcXFxcXCIxNi42NVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJzZW5kXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIyMlxcXFxcXFwiIHkxPVxcXFxcXFwiMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTFcXFxcXFxcIiB5Mj1cXFxcXFxcIjEzXFxcXFxcXCI+PC9saW5lPjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjIyIDIgMTUgMjIgMTEgMTMgMiA5IDIyIDJcXFxcXFxcIj48L3BvbHlnb24+XFxcIixcXFwic2VydmVyXFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjJcXFxcXFxcIiB5PVxcXFxcXFwiMlxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMjBcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCI4XFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxyZWN0IHg9XFxcXFxcXCIyXFxcXFxcXCIgeT1cXFxcXFxcIjE0XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIyMFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjhcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PGxpbmUgeDE9XFxcXFxcXCI2XFxcXFxcXCIgeTE9XFxcXFxcXCI2XFxcXFxcXCIgeDI9XFxcXFxcXCI2LjAxXFxcXFxcXCIgeTI9XFxcXFxcXCI2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiNlxcXFxcXFwiIHkxPVxcXFxcXFwiMThcXFxcXFxcIiB4Mj1cXFxcXFxcIjYuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjE4XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInNldHRpbmdzXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIzXFxcXFxcXCI+PC9jaXJjbGU+PHBhdGggZD1cXFxcXFxcIk0xOS40IDE1YTEuNjUgMS42NSAwIDAgMCAuMzMgMS44MmwuMDYuMDZhMiAyIDAgMCAxIDAgMi44MyAyIDIgMCAwIDEtMi44MyAwbC0uMDYtLjA2YTEuNjUgMS42NSAwIDAgMC0xLjgyLS4zMyAxLjY1IDEuNjUgMCAwIDAtMSAxLjUxVjIxYTIgMiAwIDAgMS0yIDIgMiAyIDAgMCAxLTItMnYtLjA5QTEuNjUgMS42NSAwIDAgMCA5IDE5LjRhMS42NSAxLjY1IDAgMCAwLTEuODIuMzNsLS4wNi4wNmEyIDIgMCAwIDEtMi44MyAwIDIgMiAwIDAgMSAwLTIuODNsLjA2LS4wNmExLjY1IDEuNjUgMCAwIDAgLjMzLTEuODIgMS42NSAxLjY1IDAgMCAwLTEuNTEtMUgzYTIgMiAwIDAgMS0yLTIgMiAyIDAgMCAxIDItMmguMDlBMS42NSAxLjY1IDAgMCAwIDQuNiA5YTEuNjUgMS42NSAwIDAgMC0uMzMtMS44MmwtLjA2LS4wNmEyIDIgMCAwIDEgMC0yLjgzIDIgMiAwIDAgMSAyLjgzIDBsLjA2LjA2YTEuNjUgMS42NSAwIDAgMCAxLjgyLjMzSDlhMS42NSAxLjY1IDAgMCAwIDEtMS41MVYzYTIgMiAwIDAgMSAyLTIgMiAyIDAgMCAxIDIgMnYuMDlhMS42NSAxLjY1IDAgMCAwIDEgMS41MSAxLjY1IDEuNjUgMCAwIDAgMS44Mi0uMzNsLjA2LS4wNmEyIDIgMCAwIDEgMi44MyAwIDIgMiAwIDAgMSAwIDIuODNsLS4wNi4wNmExLjY1IDEuNjUgMCAwIDAtLjMzIDEuODJWOWExLjY1IDEuNjUgMCAwIDAgMS41MSAxSDIxYTIgMiAwIDAgMSAyIDIgMiAyIDAgMCAxLTIgMmgtLjA5YTEuNjUgMS42NSAwIDAgMC0xLjUxIDF6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInNoYXJlLTJcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMThcXFxcXFxcIiBjeT1cXFxcXFxcIjVcXFxcXFxcIiByPVxcXFxcXFwiM1xcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCI2XFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIzXFxcXFxcXCI+PC9jaXJjbGU+PGNpcmNsZSBjeD1cXFxcXFxcIjE4XFxcXFxcXCIgY3k9XFxcXFxcXCIxOVxcXFxcXFwiIHI9XFxcXFxcXCIzXFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCI4LjU5XFxcXFxcXCIgeTE9XFxcXFxcXCIxMy41MVxcXFxcXFwiIHgyPVxcXFxcXFwiMTUuNDJcXFxcXFxcIiB5Mj1cXFxcXFxcIjE3LjQ5XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTUuNDFcXFxcXFxcIiB5MT1cXFxcXFxcIjYuNTFcXFxcXFxcIiB4Mj1cXFxcXFxcIjguNTlcXFxcXFxcIiB5Mj1cXFxcXFxcIjEwLjQ5XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInNoYXJlXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk00IDEydjhhMiAyIDAgMCAwIDIgMmgxMmEyIDIgMCAwIDAgMi0ydi04XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNiA2IDEyIDIgOCA2XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyXFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwic2hpZWxkLW9mZlxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTkuNjkgMTRhNi45IDYuOSAwIDAgMCAuMzEtMlY1bC04LTMtMy4xNiAxLjE4XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNNC43MyA0LjczTDQgNXY3YzAgNiA4IDEwIDggMTBhMjAuMjkgMjAuMjkgMCAwIDAgNS42Mi00LjM4XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMVxcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInNoaWVsZFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTIgMjJzOC00IDgtMTBWNWwtOC0zLTggM3Y3YzAgNiA4IDEwIDggMTB6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInNob3BwaW5nLWJhZ1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNNiAyTDMgNnYxNGEyIDIgMCAwIDAgMiAyaDE0YTIgMiAwIDAgMCAyLTJWNmwtMy00elxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjNcXFxcXFxcIiB5MT1cXFxcXFxcIjZcXFxcXFxcIiB4Mj1cXFxcXFxcIjIxXFxcXFxcXCIgeTI9XFxcXFxcXCI2XFxcXFxcXCI+PC9saW5lPjxwYXRoIGQ9XFxcXFxcXCJNMTYgMTBhNCA0IDAgMCAxLTggMFxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJzaG9wcGluZy1jYXJ0XFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjlcXFxcXFxcIiBjeT1cXFxcXFxcIjIxXFxcXFxcXCIgcj1cXFxcXFxcIjFcXFxcXFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXFxcXFwiMjBcXFxcXFxcIiBjeT1cXFxcXFxcIjIxXFxcXFxcXCIgcj1cXFxcXFxcIjFcXFxcXFxcIj48L2NpcmNsZT48cGF0aCBkPVxcXFxcXFwiTTEgMWg0bDIuNjggMTMuMzlhMiAyIDAgMCAwIDIgMS42MWg5LjcyYTIgMiAwIDAgMCAyLTEuNjFMMjMgNkg2XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInNodWZmbGVcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTYgMyAyMSAzIDIxIDhcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiNFxcXFxcXFwiIHkxPVxcXFxcXFwiMjBcXFxcXFxcIiB4Mj1cXFxcXFxcIjIxXFxcXFxcXCIgeTI9XFxcXFxcXCIzXFxcXFxcXCI+PC9saW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIyMSAxNiAyMSAyMSAxNiAyMVxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNVxcXFxcXFwiIHkxPVxcXFxcXFwiMTVcXFxcXFxcIiB4Mj1cXFxcXFxcIjIxXFxcXFxcXCIgeTI9XFxcXFxcXCIyMVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjRcXFxcXFxcIiB5MT1cXFxcXFxcIjRcXFxcXFxcIiB4Mj1cXFxcXFxcIjlcXFxcXFxcIiB5Mj1cXFxcXFxcIjlcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwic2lkZWJhclxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjNcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMThcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PGxpbmUgeDE9XFxcXFxcXCI5XFxcXFxcXCIgeTE9XFxcXFxcXCIzXFxcXFxcXCIgeDI9XFxcXFxcXCI5XFxcXFxcXCIgeTI9XFxcXFxcXCIyMVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJza2lwLWJhY2tcXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCIxOSAyMCA5IDEyIDE5IDQgMTkgMjBcXFxcXFxcIj48L3BvbHlnb24+PGxpbmUgeDE9XFxcXFxcXCI1XFxcXFxcXCIgeTE9XFxcXFxcXCIxOVxcXFxcXFwiIHgyPVxcXFxcXFwiNVxcXFxcXFwiIHkyPVxcXFxcXFwiNVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJza2lwLWZvcndhcmRcXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCI1IDQgMTUgMTIgNSAyMCA1IDRcXFxcXFxcIj48L3BvbHlnb24+PGxpbmUgeDE9XFxcXFxcXCIxOVxcXFxcXFwiIHkxPVxcXFxcXFwiNVxcXFxcXFwiIHgyPVxcXFxcXFwiMTlcXFxcXFxcIiB5Mj1cXFxcXFxcIjE5XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInNsYWNrXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNC41IDEwYy0uODMgMC0xLjUtLjY3LTEuNS0xLjV2LTVjMC0uODMuNjctMS41IDEuNS0xLjVzMS41LjY3IDEuNSAxLjV2NWMwIC44My0uNjcgMS41LTEuNSAxLjV6XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMjAuNSAxMEgxOVY4LjVjMC0uODMuNjctMS41IDEuNS0xLjVzMS41LjY3IDEuNSAxLjUtLjY3IDEuNS0xLjUgMS41elxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTkuNSAxNGMuODMgMCAxLjUuNjcgMS41IDEuNXY1YzAgLjgzLS42NyAxLjUtMS41IDEuNVM4IDIxLjMzIDggMjAuNXYtNWMwLS44My42Ny0xLjUgMS41LTEuNXpcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0zLjUgMTRINXYxLjVjMCAuODMtLjY3IDEuNS0xLjUgMS41UzIgMTYuMzMgMiAxNS41IDIuNjcgMTQgMy41IDE0elxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTE0IDE0LjVjMC0uODMuNjctMS41IDEuNS0xLjVoNWMuODMgMCAxLjUuNjcgMS41IDEuNXMtLjY3IDEuNS0xLjUgMS41aC01Yy0uODMgMC0xLjUtLjY3LTEuNS0xLjV6XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMTUuNSAxOUgxNHYxLjVjMCAuODMuNjcgMS41IDEuNSAxLjVzMS41LS42NyAxLjUtMS41LS42Ny0xLjUtMS41LTEuNXpcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xMCA5LjVDMTAgOC42NyA5LjMzIDggOC41IDhoLTVDMi42NyA4IDIgOC42NyAyIDkuNVMyLjY3IDExIDMuNSAxMWg1Yy44MyAwIDEuNS0uNjcgMS41LTEuNXpcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk04LjUgNUgxMFYzLjVDMTAgMi42NyA5LjMzIDIgOC41IDJTNyAyLjY3IDcgMy41IDcuNjcgNSA4LjUgNXpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwic2xhc2hcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCI0LjkzXFxcXFxcXCIgeTE9XFxcXFxcXCI0LjkzXFxcXFxcXCIgeDI9XFxcXFxcXCIxOS4wN1xcXFxcXFwiIHkyPVxcXFxcXFwiMTkuMDdcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwic2xpZGVyc1xcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiNFxcXFxcXFwiIHkxPVxcXFxcXFwiMjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjRcXFxcXFxcIiB5Mj1cXFxcXFxcIjE0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiNFxcXFxcXFwiIHkxPVxcXFxcXFwiMTBcXFxcXFxcIiB4Mj1cXFxcXFxcIjRcXFxcXFxcIiB5Mj1cXFxcXFxcIjNcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCI4XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiM1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjIwXFxcXFxcXCIgeTE9XFxcXFxcXCIyMVxcXFxcXFwiIHgyPVxcXFxcXFwiMjBcXFxcXFxcIiB5Mj1cXFxcXFxcIjE2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjBcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIyMFxcXFxcXFwiIHkyPVxcXFxcXFwiM1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjFcXFxcXFxcIiB5MT1cXFxcXFxcIjE0XFxcXFxcXCIgeDI9XFxcXFxcXCI3XFxcXFxcXCIgeTI9XFxcXFxcXCIxNFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjE1XFxcXFxcXCIgeTI9XFxcXFxcXCI4XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTdcXFxcXFxcIiB5MT1cXFxcXFxcIjE2XFxcXFxcXCIgeDI9XFxcXFxcXCIyM1xcXFxcXFwiIHkyPVxcXFxcXFwiMTZcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwic21hcnRwaG9uZVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCI1XFxcXFxcXCIgeT1cXFxcXFxcIjJcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE0XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMjBcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMThcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyLjAxXFxcXFxcXCIgeTI9XFxcXFxcXCIxOFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJzbWlsZVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48cGF0aCBkPVxcXFxcXFwiTTggMTRzMS41IDIgNCAyIDQtMiA0LTJcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCI5XFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCI5LjAxXFxcXFxcXCIgeTI9XFxcXFxcXCI5XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTVcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjE1LjAxXFxcXFxcXCIgeTI9XFxcXFxcXCI5XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInNwZWFrZXJcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiNFxcXFxcXFwiIHk9XFxcXFxcXCIyXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIxNlxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjIwXFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTRcXFxcXFxcIiByPVxcXFxcXFwiNFxcXFxcXFwiPjwvY2lyY2xlPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjZcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyLjAxXFxcXFxcXCIgeTI9XFxcXFxcXCI2XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInNxdWFyZVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjNcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMThcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+XFxcIixcXFwic3RhclxcXCI6XFxcIjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjEyIDIgMTUuMDkgOC4yNiAyMiA5LjI3IDE3IDE0LjE0IDE4LjE4IDIxLjAyIDEyIDE3Ljc3IDUuODIgMjEuMDIgNyAxNC4xNCAyIDkuMjcgOC45MSA4LjI2IDEyIDJcXFxcXFxcIj48L3BvbHlnb24+XFxcIixcXFwic3RvcC1jaXJjbGVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PHJlY3QgeD1cXFxcXFxcIjlcXFxcXFxcIiB5PVxcXFxcXFwiOVxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiNlxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjZcXFxcXFxcIj48L3JlY3Q+XFxcIixcXFwic3VuXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCI1XFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjNcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIyM1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjQuMjJcXFxcXFxcIiB5MT1cXFxcXFxcIjQuMjJcXFxcXFxcIiB4Mj1cXFxcXFxcIjUuNjRcXFxcXFxcIiB5Mj1cXFxcXFxcIjUuNjRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxOC4zNlxcXFxcXFwiIHkxPVxcXFxcXFwiMTguMzZcXFxcXFxcIiB4Mj1cXFxcXFxcIjE5Ljc4XFxcXFxcXCIgeTI9XFxcXFxcXCIxOS43OFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjFcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiNC4yMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTkuNzhcXFxcXFxcIiB4Mj1cXFxcXFxcIjUuNjRcXFxcXFxcIiB5Mj1cXFxcXFxcIjE4LjM2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTguMzZcXFxcXFxcIiB5MT1cXFxcXFxcIjUuNjRcXFxcXFxcIiB4Mj1cXFxcXFxcIjE5Ljc4XFxcXFxcXCIgeTI9XFxcXFxcXCI0LjIyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInN1bnJpc2VcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE3IDE4YTUgNSAwIDAgMC0xMCAwXFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjJcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCI5XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiNC4yMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTAuMjJcXFxcXFxcIiB4Mj1cXFxcXFxcIjUuNjRcXFxcXFxcIiB5Mj1cXFxcXFxcIjExLjY0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMVxcXFxcXFwiIHkxPVxcXFxcXFwiMThcXFxcXFxcIiB4Mj1cXFxcXFxcIjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjE4XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjE4XFxcXFxcXCIgeDI9XFxcXFxcXCIyM1xcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxOC4zNlxcXFxcXFwiIHkxPVxcXFxcXFwiMTEuNjRcXFxcXFxcIiB4Mj1cXFxcXFxcIjE5Ljc4XFxcXFxcXCIgeTI9XFxcXFxcXCIxMC4yMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjIzXFxcXFxcXCIgeTE9XFxcXFxcXCIyMlxcXFxcXFwiIHgyPVxcXFxcXFwiMVxcXFxcXFwiIHkyPVxcXFxcXFwiMjJcXFxcXFxcIj48L2xpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjggNiAxMiAyIDE2IDZcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcInN1bnNldFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTcgMThhNSA1IDAgMCAwLTEwIDBcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI0LjIyXFxcXFxcXCIgeTE9XFxcXFxcXCIxMC4yMlxcXFxcXFwiIHgyPVxcXFxcXFwiNS42NFxcXFxcXFwiIHkyPVxcXFxcXFwiMTEuNjRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiM1xcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyMVxcXFxcXFwiIHkxPVxcXFxcXFwiMThcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxOFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE4LjM2XFxcXFxcXCIgeTE9XFxcXFxcXCIxMS42NFxcXFxcXFwiIHgyPVxcXFxcXFwiMTkuNzhcXFxcXFxcIiB5Mj1cXFxcXFxcIjEwLjIyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjNcXFxcXFxcIiB5MT1cXFxcXFxcIjIyXFxcXFxcXCIgeDI9XFxcXFxcXCIxXFxcXFxcXCIgeTI9XFxcXFxcXCIyMlxcXFxcXFwiPjwvbGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTYgNSAxMiA5IDggNVxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwidGFibGV0XFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjRcXFxcXFxcIiB5PVxcXFxcXFwiMlxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMTZcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIyMFxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTIuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjE4XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInRhZ1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjAuNTkgMTMuNDFsLTcuMTcgNy4xN2EyIDIgMCAwIDEtMi44MyAwTDIgMTJWMmgxMGw4LjU5IDguNTlhMiAyIDAgMCAxIDAgMi44MnpcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCI3XFxcXFxcXCIgeTE9XFxcXFxcXCI3XFxcXFxcXCIgeDI9XFxcXFxcXCI3LjAxXFxcXFxcXCIgeTI9XFxcXFxcXCI3XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInRhcmdldFxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjZcXFxcXFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjJcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJ0ZXJtaW5hbFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI0IDE3IDEwIDExIDQgNVxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTlcXFxcXFxcIiB4Mj1cXFxcXFxcIjIwXFxcXFxcXCIgeTI9XFxcXFxcXCIxOVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ0aGVybW9tZXRlclxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTQgMTQuNzZWMy41YTIuNSAyLjUgMCAwIDAtNSAwdjExLjI2YTQuNSA0LjUgMCAxIDAgNSAwelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJ0aHVtYnMtZG93blxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTAgMTV2NGEzIDMgMCAwIDAgMyAzbDQtOVYySDUuNzJhMiAyIDAgMCAwLTIgMS43bC0xLjM4IDlhMiAyIDAgMCAwIDIgMi4zem03LTEzaDIuNjdBMi4zMSAyLjMxIDAgMCAxIDIyIDR2N2EyLjMxIDIuMzEgMCAwIDEtMi4zMyAySDE3XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInRodW1icy11cFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTQgOVY1YTMgMyAwIDAgMC0zLTNsLTQgOXYxMWgxMS4yOGEyIDIgMCAwIDAgMi0xLjdsMS4zOC05YTIgMiAwIDAgMC0yLTIuM3pNNyAyMkg0YTIgMiAwIDAgMS0yLTJ2LTdhMiAyIDAgMCAxIDItMmgzXFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInRvZ2dsZS1sZWZ0XFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjFcXFxcXFxcIiB5PVxcXFxcXFwiNVxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMjJcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxNFxcXFxcXFwiIHJ4PVxcXFxcXFwiN1xcXFxcXFwiIHJ5PVxcXFxcXFwiN1xcXFxcXFwiPjwvcmVjdD48Y2lyY2xlIGN4PVxcXFxcXFwiOFxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiM1xcXFxcXFwiPjwvY2lyY2xlPlxcXCIsXFxcInRvZ2dsZS1yaWdodFxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIxXFxcXFxcXCIgeT1cXFxcXFxcIjVcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjIyXFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMTRcXFxcXFxcIiByeD1cXFxcXFxcIjdcXFxcXFxcIiByeT1cXFxcXFxcIjdcXFxcXFxcIj48L3JlY3Q+PGNpcmNsZSBjeD1cXFxcXFxcIjE2XFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIzXFxcXFxcXCI+PC9jaXJjbGU+XFxcIixcXFwidG9vbFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTQuNyA2LjNhMSAxIDAgMCAwIDAgMS40bDEuNiAxLjZhMSAxIDAgMCAwIDEuNCAwbDMuNzctMy43N2E2IDYgMCAwIDEtNy45NCA3Ljk0bC02LjkxIDYuOTFhMi4xMiAyLjEyIDAgMCAxLTMtM2w2LjkxLTYuOTFhNiA2IDAgMCAxIDcuOTQtNy45NGwtMy43NiAzLjc2elxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJ0cmFzaC0yXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjMgNiA1IDYgMjEgNlxcXFxcXFwiPjwvcG9seWxpbmU+PHBhdGggZD1cXFxcXFxcIk0xOSA2djE0YTIgMiAwIDAgMS0yIDJIN2EyIDIgMCAwIDEtMi0yVjZtMyAwVjRhMiAyIDAgMCAxIDItMmg0YTIgMiAwIDAgMSAyIDJ2MlxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjEwXFxcXFxcXCIgeTE9XFxcXFxcXCIxMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTBcXFxcXFxcIiB5Mj1cXFxcXFxcIjE3XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTRcXFxcXFxcIiB5MT1cXFxcXFxcIjExXFxcXFxcXCIgeDI9XFxcXFxcXCIxNFxcXFxcXFwiIHkyPVxcXFxcXFwiMTdcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwidHJhc2hcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMyA2IDUgNiAyMSA2XFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTE5IDZ2MTRhMiAyIDAgMCAxLTIgMkg3YTIgMiAwIDAgMS0yLTJWNm0zIDBWNGEyIDIgMCAwIDEgMi0yaDRhMiAyIDAgMCAxIDIgMnYyXFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInRyZWxsb1xcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjNcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMThcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PHJlY3QgeD1cXFxcXFxcIjdcXFxcXFxcIiB5PVxcXFxcXFwiN1xcXFxcXFwiIHdpZHRoPVxcXFxcXFwiM1xcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjlcXFxcXFxcIj48L3JlY3Q+PHJlY3QgeD1cXFxcXFxcIjE0XFxcXFxcXCIgeT1cXFxcXFxcIjdcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjNcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCI1XFxcXFxcXCI+PC9yZWN0PlxcXCIsXFxcInRyZW5kaW5nLWRvd25cXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMjMgMTggMTMuNSA4LjUgOC41IDEzLjUgMSA2XFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTcgMTggMjMgMTggMjMgMTJcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcInRyZW5kaW5nLXVwXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIzIDYgMTMuNSAxNS41IDguNSAxMC41IDEgMThcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNyA2IDIzIDYgMjMgMTJcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcInRyaWFuZ2xlXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xMC4yOSAzLjg2TDEuODIgMThhMiAyIDAgMCAwIDEuNzEgM2gxNi45NGEyIDIgMCAwIDAgMS43MS0zTDEzLjcxIDMuODZhMiAyIDAgMCAwLTMuNDIgMHpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwidHJ1Y2tcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiMVxcXFxcXFwiIHk9XFxcXFxcXCIzXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIxNVxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjEzXFxcXFxcXCI+PC9yZWN0Pjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjE2IDggMjAgOCAyMyAxMSAyMyAxNiAxNiAxNiAxNiA4XFxcXFxcXCI+PC9wb2x5Z29uPjxjaXJjbGUgY3g9XFxcXFxcXCI1LjVcXFxcXFxcIiBjeT1cXFxcXFxcIjE4LjVcXFxcXFxcIiByPVxcXFxcXFwiMi41XFxcXFxcXCI+PC9jaXJjbGU+PGNpcmNsZSBjeD1cXFxcXFxcIjE4LjVcXFxcXFxcIiBjeT1cXFxcXFxcIjE4LjVcXFxcXFxcIiByPVxcXFxcXFwiMi41XFxcXFxcXCI+PC9jaXJjbGU+XFxcIixcXFwidHZcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiMlxcXFxcXFwiIHk9XFxcXFxcXCI3XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIyMFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjE1XFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0Pjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNyAyIDEyIDcgNyAyXFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJ0d2l0Y2hcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIxIDJIM3YxNmg1djRsNC00aDVsNC00VjJ6bS0xMCA5VjdtNSA0VjdcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwidHdpdHRlclxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjMgM2ExMC45IDEwLjkgMCAwIDEtMy4xNCAxLjUzIDQuNDggNC40OCAwIDAgMC03Ljg2IDN2MUExMC42NiAxMC42NiAwIDAgMSAzIDRzLTQgOSA1IDEzYTExLjY0IDExLjY0IDAgMCAxLTcgMmM5IDUgMjAgMCAyMC0xMS41YTQuNSA0LjUgMCAwIDAtLjA4LS44M0E3LjcyIDcuNzIgMCAwIDAgMjMgM3pcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwidHlwZVxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI0IDcgNCA0IDIwIDQgMjAgN1xcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCI5XFxcXFxcXCIgeTE9XFxcXFxcXCIyMFxcXFxcXFwiIHgyPVxcXFxcXFwiMTVcXFxcXFxcIiB5Mj1cXFxcXFxcIjIwXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjRcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIyMFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ1bWJyZWxsYVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjMgMTJhMTEuMDUgMTEuMDUgMCAwIDAtMjIgMHptLTUgN2EzIDMgMCAwIDEtNiAwdi03XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInVuZGVybGluZVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNNiAzdjdhNiA2IDAgMCAwIDYgNiA2IDYgMCAwIDAgNi02VjNcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCI0XFxcXFxcXCIgeTE9XFxcXFxcXCIyMVxcXFxcXFwiIHgyPVxcXFxcXFwiMjBcXFxcXFxcIiB5Mj1cXFxcXFxcIjIxXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInVubG9ja1xcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjExXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIxOFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjExXFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxwYXRoIGQ9XFxcXFxcXCJNNyAxMVY3YTUgNSAwIDAgMSA5LjktMVxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJ1cGxvYWQtY2xvdWRcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTYgMTYgMTIgMTIgOCAxNlxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIyMVxcXFxcXFwiPjwvbGluZT48cGF0aCBkPVxcXFxcXFwiTTIwLjM5IDE4LjM5QTUgNSAwIDAgMCAxOCA5aC0xLjI2QTggOCAwIDEgMCAzIDE2LjNcXFxcXFxcIj48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE2IDE2IDEyIDEyIDggMTZcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcInVwbG9hZFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjEgMTV2NGEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMnYtNFxcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTcgOCAxMiAzIDcgOFxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiM1xcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjE1XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInVzZXItY2hlY2tcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE2IDIxdi0yYTQgNCAwIDAgMC00LTRINWE0IDQgMCAwIDAtNCA0djJcXFxcXFxcIj48L3BhdGg+PGNpcmNsZSBjeD1cXFxcXFxcIjguNVxcXFxcXFwiIGN5PVxcXFxcXFwiN1xcXFxcXFwiIHI9XFxcXFxcXCI0XFxcXFxcXCI+PC9jaXJjbGU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE3IDExIDE5IDEzIDIzIDlcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcInVzZXItbWludXNcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE2IDIxdi0yYTQgNCAwIDAgMC00LTRINWE0IDQgMCAwIDAtNCA0djJcXFxcXFxcIj48L3BhdGg+PGNpcmNsZSBjeD1cXFxcXFxcIjguNVxcXFxcXFwiIGN5PVxcXFxcXFwiN1xcXFxcXFwiIHI9XFxcXFxcXCI0XFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIyM1xcXFxcXFwiIHkxPVxcXFxcXFwiMTFcXFxcXFxcIiB4Mj1cXFxcXFxcIjE3XFxcXFxcXCIgeTI9XFxcXFxcXCIxMVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ1c2VyLXBsdXNcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE2IDIxdi0yYTQgNCAwIDAgMC00LTRINWE0IDQgMCAwIDAtNCA0djJcXFxcXFxcIj48L3BhdGg+PGNpcmNsZSBjeD1cXFxcXFxcIjguNVxcXFxcXFwiIGN5PVxcXFxcXFwiN1xcXFxcXFwiIHI9XFxcXFxcXCI0XFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIyMFxcXFxcXFwiIHkxPVxcXFxcXFwiOFxcXFxcXFwiIHgyPVxcXFxcXFwiMjBcXFxcXFxcIiB5Mj1cXFxcXFxcIjE0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjNcXFxcXFxcIiB5MT1cXFxcXFxcIjExXFxcXFxcXCIgeDI9XFxcXFxcXCIxN1xcXFxcXFwiIHkyPVxcXFxcXFwiMTFcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwidXNlci14XFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNiAyMXYtMmE0IDQgMCAwIDAtNC00SDVhNCA0IDAgMCAwLTQgNHYyXFxcXFxcXCI+PC9wYXRoPjxjaXJjbGUgY3g9XFxcXFxcXCI4LjVcXFxcXFxcIiBjeT1cXFxcXFxcIjdcXFxcXFxcIiByPVxcXFxcXFwiNFxcXFxcXFwiPjwvY2lyY2xlPjxsaW5lIHgxPVxcXFxcXFwiMThcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxM1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjIzXFxcXFxcXCIgeTE9XFxcXFxcXCI4XFxcXFxcXCIgeDI9XFxcXFxcXCIxOFxcXFxcXFwiIHkyPVxcXFxcXFwiMTNcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwidXNlclxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjAgMjF2LTJhNCA0IDAgMCAwLTQtNEg4YTQgNCAwIDAgMC00IDR2MlxcXFxcXFwiPjwvcGF0aD48Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjdcXFxcXFxcIiByPVxcXFxcXFwiNFxcXFxcXFwiPjwvY2lyY2xlPlxcXCIsXFxcInVzZXJzXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNyAyMXYtMmE0IDQgMCAwIDAtNC00SDVhNCA0IDAgMCAwLTQgNHYyXFxcXFxcXCI+PC9wYXRoPjxjaXJjbGUgY3g9XFxcXFxcXCI5XFxcXFxcXCIgY3k9XFxcXFxcXCI3XFxcXFxcXCIgcj1cXFxcXFxcIjRcXFxcXFxcIj48L2NpcmNsZT48cGF0aCBkPVxcXFxcXFwiTTIzIDIxdi0yYTQgNCAwIDAgMC0zLTMuODdcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xNiAzLjEzYTQgNCAwIDAgMSAwIDcuNzVcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwidmlkZW8tb2ZmXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNiAxNnYxYTIgMiAwIDAgMS0yIDJIM2EyIDIgMCAwIDEtMi0yVjdhMiAyIDAgMCAxIDItMmgybTUuNjYgMEgxNGEyIDIgMCAwIDEgMiAydjMuMzRsMSAxTDIzIDd2MTBcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxXFxcXFxcXCIgeDI9XFxcXFxcXCIyM1xcXFxcXFwiIHkyPVxcXFxcXFwiMjNcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwidmlkZW9cXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCIyMyA3IDE2IDEyIDIzIDE3IDIzIDdcXFxcXFxcIj48L3BvbHlnb24+PHJlY3QgeD1cXFxcXFxcIjFcXFxcXFxcIiB5PVxcXFxcXFwiNVxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMTVcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxNFxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD5cXFwiLFxcXCJ2b2ljZW1haWxcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiNS41XFxcXFxcXCIgY3k9XFxcXFxcXCIxMS41XFxcXFxcXCIgcj1cXFxcXFxcIjQuNVxcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCIxOC41XFxcXFxcXCIgY3k9XFxcXFxcXCIxMS41XFxcXFxcXCIgcj1cXFxcXFxcIjQuNVxcXFxcXFwiPjwvY2lyY2xlPjxsaW5lIHgxPVxcXFxcXFwiNS41XFxcXFxcXCIgeTE9XFxcXFxcXCIxNlxcXFxcXFwiIHgyPVxcXFxcXFwiMTguNVxcXFxcXFwiIHkyPVxcXFxcXFwiMTZcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwidm9sdW1lLTFcXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCIxMSA1IDYgOSAyIDkgMiAxNSA2IDE1IDExIDE5IDExIDVcXFxcXFxcIj48L3BvbHlnb24+PHBhdGggZD1cXFxcXFxcIk0xNS41NCA4LjQ2YTUgNSAwIDAgMSAwIDcuMDdcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwidm9sdW1lLTJcXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCIxMSA1IDYgOSAyIDkgMiAxNSA2IDE1IDExIDE5IDExIDVcXFxcXFxcIj48L3BvbHlnb24+PHBhdGggZD1cXFxcXFxcIk0xOS4wNyA0LjkzYTEwIDEwIDAgMCAxIDAgMTQuMTRNMTUuNTQgOC40NmE1IDUgMCAwIDEgMCA3LjA3XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInZvbHVtZS14XFxcIjpcXFwiPHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMTEgNSA2IDkgMiA5IDIgMTUgNiAxNSAxMSAxOSAxMSA1XFxcXFxcXCI+PC9wb2x5Z29uPjxsaW5lIHgxPVxcXFxcXFwiMjNcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjE3XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE3XFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCIyM1xcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwidm9sdW1lXFxcIjpcXFwiPHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMTEgNSA2IDkgMiA5IDIgMTUgNiAxNSAxMSAxOSAxMSA1XFxcXFxcXCI+PC9wb2x5Z29uPlxcXCIsXFxcIndhdGNoXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCI3XFxcXFxcXCI+PC9jaXJjbGU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjEyIDkgMTIgMTIgMTMuNSAxMy41XFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTE2LjUxIDE3LjM1bC0uMzUgMy44M2EyIDIgMCAwIDEtMiAxLjgySDkuODNhMiAyIDAgMCAxLTItMS44MmwtLjM1LTMuODNtLjAxLTEwLjdsLjM1LTMuODNBMiAyIDAgMCAxIDkuODMgMWg0LjM1YTIgMiAwIDAgMSAyIDEuODJsLjM1IDMuODNcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwid2lmaS1vZmZcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjFcXFxcXFxcIiB5MT1cXFxcXFxcIjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIyM1xcXFxcXFwiPjwvbGluZT48cGF0aCBkPVxcXFxcXFwiTTE2LjcyIDExLjA2QTEwLjk0IDEwLjk0IDAgMCAxIDE5IDEyLjU1XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNNSAxMi41NWExMC45NCAxMC45NCAwIDAgMSA1LjE3LTIuMzlcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xMC43MSA1LjA1QTE2IDE2IDAgMCAxIDIyLjU4IDlcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xLjQyIDlhMTUuOTEgMTUuOTEgMCAwIDEgNC43LTIuODhcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk04LjUzIDE2LjExYTYgNiAwIDAgMSA2Ljk1IDBcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMjBcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyLjAxXFxcXFxcXCIgeTI9XFxcXFxcXCIyMFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ3aWZpXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk01IDEyLjU1YTExIDExIDAgMCAxIDE0LjA4IDBcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xLjQyIDlhMTYgMTYgMCAwIDEgMjEuMTYgMFxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTguNTMgMTYuMTFhNiA2IDAgMCAxIDYuOTUgMFxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMFxcXFxcXFwiIHgyPVxcXFxcXFwiMTIuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjIwXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcIndpbmRcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTkuNTkgNC41OUEyIDIgMCAxIDEgMTEgOEgybTEwLjU5IDExLjQxQTIgMiAwIDEgMCAxNCAxNkgybTE1LjczLTguMjdBMi41IDIuNSAwIDEgMSAxOS41IDEySDJcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwieC1jaXJjbGVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIxNVxcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiOVxcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI5XFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCIxNVxcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwieC1vY3RhZ29uXFxcIjpcXFwiPHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiNy44NiAyIDE2LjE0IDIgMjIgNy44NiAyMiAxNi4xNCAxNi4xNCAyMiA3Ljg2IDIyIDIgMTYuMTQgMiA3Ljg2IDcuODYgMlxcXFxcXFwiPjwvcG9seWdvbj48bGluZSB4MT1cXFxcXFxcIjE1XFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCI5XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjE1XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ4LXNxdWFyZVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjNcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMThcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PGxpbmUgeDE9XFxcXFxcXCI5XFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCIxNVxcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNVxcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiOVxcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwieFxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMThcXFxcXFxcIiB5MT1cXFxcXFxcIjZcXFxcXFxcIiB4Mj1cXFxcXFxcIjZcXFxcXFxcIiB5Mj1cXFxcXFxcIjE4XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiNlxcXFxcXFwiIHkxPVxcXFxcXFwiNlxcXFxcXFwiIHgyPVxcXFxcXFwiMThcXFxcXFxcIiB5Mj1cXFxcXFxcIjE4XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInlvdXR1YmVcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIyLjU0IDYuNDJhMi43OCAyLjc4IDAgMCAwLTEuOTQtMkMxOC44OCA0IDEyIDQgMTIgNHMtNi44OCAwLTguNi40NmEyLjc4IDIuNzggMCAwIDAtMS45NCAyQTI5IDI5IDAgMCAwIDEgMTEuNzVhMjkgMjkgMCAwIDAgLjQ2IDUuMzNBMi43OCAyLjc4IDAgMCAwIDMuNCAxOWMxLjcyLjQ2IDguNi40NiA4LjYuNDZzNi44OCAwIDguNi0uNDZhMi43OCAyLjc4IDAgMCAwIDEuOTQtMiAyOSAyOSAwIDAgMCAuNDYtNS4yNSAyOSAyOSAwIDAgMC0uNDYtNS4zM3pcXFxcXFxcIj48L3BhdGg+PHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiOS43NSAxNS4wMiAxNS41IDExLjc1IDkuNzUgOC40OCA5Ljc1IDE1LjAyXFxcXFxcXCI+PC9wb2x5Z29uPlxcXCIsXFxcInphcC1vZmZcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTIuNDEgNi43NSAxMyAyIDEwLjU3IDQuOTJcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxOC41NyAxMi45MSAyMSAxMCAxNS42NiAxMFxcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjggOCAzIDE0IDEyIDE0IDExIDIyIDE2IDE2XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjFcXFxcXFxcIiB5MT1cXFxcXFxcIjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIyM1xcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ6YXBcXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCIxMyAyIDMgMTQgMTIgMTQgMTEgMjIgMjEgMTAgMTIgMTAgMTMgMlxcXFxcXFwiPjwvcG9seWdvbj5cXFwiLFxcXCJ6b29tLWluXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjExXFxcXFxcXCIgY3k9XFxcXFxcXCIxMVxcXFxcXFwiIHI9XFxcXFxcXCI4XFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIyMVxcXFxcXFwiIHkxPVxcXFxcXFwiMjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2LjY1XFxcXFxcXCIgeTI9XFxcXFxcXCIxNi42NVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjExXFxcXFxcXCIgeTE9XFxcXFxcXCI4XFxcXFxcXCIgeDI9XFxcXFxcXCIxMVxcXFxcXFwiIHkyPVxcXFxcXFwiMTRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIxMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTRcXFxcXFxcIiB5Mj1cXFxcXFxcIjExXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInpvb20tb3V0XFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjExXFxcXFxcXCIgY3k9XFxcXFxcXCIxMVxcXFxcXFwiIHI9XFxcXFxcXCI4XFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIyMVxcXFxcXFwiIHkxPVxcXFxcXFwiMjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2LjY1XFxcXFxcXCIgeTI9XFxcXFxcXCIxNi42NVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjExXFxcXFxcXCIgeDI9XFxcXFxcXCIxNFxcXFxcXFwiIHkyPVxcXFxcXFwiMTFcXFxcXFxcIj48L2xpbmU+XFxcIn07XFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvZGVkdXBlLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvZGVkdXBlLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohXFxuICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXFxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXFxuKi9cXG4vKiBnbG9iYWwgZGVmaW5lICovXFxuXFxuKGZ1bmN0aW9uICgpIHtcXG5cXHQndXNlIHN0cmljdCc7XFxuXFxuXFx0dmFyIGNsYXNzTmFtZXMgPSAoZnVuY3Rpb24gKCkge1xcblxcdFxcdC8vIGRvbid0IGluaGVyaXQgZnJvbSBPYmplY3Qgc28gd2UgY2FuIHNraXAgaGFzT3duUHJvcGVydHkgY2hlY2sgbGF0ZXJcXG5cXHRcXHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE1NTE4MzI4L2NyZWF0aW5nLWpzLW9iamVjdC13aXRoLW9iamVjdC1jcmVhdGVudWxsI2Fuc3dlci0yMTA3OTIzMlxcblxcdFxcdGZ1bmN0aW9uIFN0b3JhZ2VPYmplY3QoKSB7fVxcblxcdFxcdFN0b3JhZ2VPYmplY3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBfcGFyc2VBcnJheSAocmVzdWx0U2V0LCBhcnJheSkge1xcblxcdFxcdFxcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xcblxcdFxcdFxcdFxcdF9wYXJzZShyZXN1bHRTZXQsIGFycmF5W2ldKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBfcGFyc2VOdW1iZXIgKHJlc3VsdFNldCwgbnVtKSB7XFxuXFx0XFx0XFx0cmVzdWx0U2V0W251bV0gPSB0cnVlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBfcGFyc2VPYmplY3QgKHJlc3VsdFNldCwgb2JqZWN0KSB7XFxuXFx0XFx0XFx0Zm9yICh2YXIgayBpbiBvYmplY3QpIHtcXG5cXHRcXHRcXHRcXHRpZiAoaGFzT3duLmNhbGwob2JqZWN0LCBrKSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIHNldCB2YWx1ZSB0byBmYWxzZSBpbnN0ZWFkIG9mIGRlbGV0aW5nIGl0IHRvIGF2b2lkIGNoYW5naW5nIG9iamVjdCBzdHJ1Y3R1cmVcXG5cXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL3d3dy5zbWFzaGluZ21hZ2F6aW5lLmNvbS8yMDEyLzExL3dyaXRpbmctZmFzdC1tZW1vcnktZWZmaWNpZW50LWphdmFzY3JpcHQvI2RlLXJlZmVyZW5jaW5nLW1pc2NvbmNlcHRpb25zXFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0U2V0W2tdID0gISFvYmplY3Rba107XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIFNQQUNFID0gL1xcXFxzKy87XFxuXFx0XFx0ZnVuY3Rpb24gX3BhcnNlU3RyaW5nIChyZXN1bHRTZXQsIHN0cikge1xcblxcdFxcdFxcdHZhciBhcnJheSA9IHN0ci5zcGxpdChTUEFDRSk7XFxuXFx0XFx0XFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XFxuXFx0XFx0XFx0XFx0cmVzdWx0U2V0W2FycmF5W2ldXSA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBfcGFyc2UgKHJlc3VsdFNldCwgYXJnKSB7XFxuXFx0XFx0XFx0aWYgKCFhcmcpIHJldHVybjtcXG5cXHRcXHRcXHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XFxuXFxuXFx0XFx0XFx0Ly8gJ2ZvbyBiYXInXFxuXFx0XFx0XFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnKSB7XFxuXFx0XFx0XFx0XFx0X3BhcnNlU3RyaW5nKHJlc3VsdFNldCwgYXJnKTtcXG5cXG5cXHRcXHRcXHQvLyBbJ2ZvbycsICdiYXInLCAuLi5dXFxuXFx0XFx0XFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcXG5cXHRcXHRcXHRcXHRfcGFyc2VBcnJheShyZXN1bHRTZXQsIGFyZyk7XFxuXFxuXFx0XFx0XFx0Ly8geyAnZm9vJzogdHJ1ZSwgLi4uIH1cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0X3BhcnNlT2JqZWN0KHJlc3VsdFNldCwgYXJnKTtcXG5cXG5cXHRcXHRcXHQvLyAnMTMwJ1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcXG5cXHRcXHRcXHRcXHRfcGFyc2VOdW1iZXIocmVzdWx0U2V0LCBhcmcpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gX2NsYXNzTmFtZXMgKCkge1xcblxcdFxcdFxcdC8vIGRvbid0IGxlYWsgYXJndW1lbnRzXFxuXFx0XFx0XFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzIzMyLWxlYWtpbmctYXJndW1lbnRzXFxuXFx0XFx0XFx0dmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XFxuXFx0XFx0XFx0dmFyIGFyZ3MgPSBBcnJheShsZW4pO1xcblxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgY2xhc3NTZXQgPSBuZXcgU3RvcmFnZU9iamVjdCgpO1xcblxcdFxcdFxcdF9wYXJzZUFycmF5KGNsYXNzU2V0LCBhcmdzKTtcXG5cXG5cXHRcXHRcXHR2YXIgbGlzdCA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAodmFyIGsgaW4gY2xhc3NTZXQpIHtcXG5cXHRcXHRcXHRcXHRpZiAoY2xhc3NTZXRba10pIHtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0LnB1c2goaylcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBsaXN0LmpvaW4oJyAnKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIF9jbGFzc05hbWVzO1xcblxcdH0pKCk7XFxuXFxuXFx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xcblxcdH0gZWxzZSBpZiAodHJ1ZSkge1xcblxcdFxcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcXG5cXHRcXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHJldHVybiBjbGFzc05hbWVzO1xcblxcdFxcdH0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxcblxcdFxcdFxcdFxcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcXG5cXHR9IGVsc2Uge31cXG59KCkpO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL2FycmF5L2Zyb20uanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvYXJyYXkvZnJvbS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzXFxcIik7XFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5mcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qc1xcXCIpO1xcbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vaW50ZXJuYWxzL3BhdGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguQXJyYXkuZnJvbTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1mdW5jdGlvbi5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtZnVuY3Rpb24uanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykge1xcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcXG4gIH0gcmV0dXJuIGl0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIGlmICghaXNPYmplY3QoaXQpKSB7XFxuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XFxuICB9IHJldHVybiBpdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mcm9tLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZnJvbS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYmluZC1jb250ZXh0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9iaW5kLWNvbnRleHQuanNcXFwiKTtcXG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcXFwiKTtcXG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcuanNcXFwiKTtcXG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kLmpzXFxcIik7XFxudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzXFxcIik7XFxudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QuanNcXFwiKTtcXG5cXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xcbiAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xcbiAgdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XFxuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xcbiAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xcbiAgdmFyIGluZGV4ID0gMDtcXG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pO1xcbiAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcXG4gIGlmIChtYXBwaW5nKSBtYXBmbiA9IGJpbmQobWFwZm4sIGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xcbiAgLy8gaWYgdGhlIHRhcmdldCBpcyBub3QgaXRlcmFibGUgb3IgaXQncyBhbiBhcnJheSB3aXRoIHRoZSBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIGEgc2ltcGxlIGNhc2VcXG4gIGlmIChpdGVyYXRvck1ldGhvZCAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyYXRvck1ldGhvZCkpKSB7XFxuICAgIGl0ZXJhdG9yID0gaXRlcmF0b3JNZXRob2QuY2FsbChPKTtcXG4gICAgcmVzdWx0ID0gbmV3IEMoKTtcXG4gICAgZm9yICg7IShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XFxuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZ1xcbiAgICAgICAgPyBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSlcXG4gICAgICAgIDogc3RlcC52YWx1ZVxcbiAgICAgICk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcXG4gICAgcmVzdWx0ID0gbmV3IEMobGVuZ3RoKTtcXG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcXG4gICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcXG4gICAgfVxcbiAgfVxcbiAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanNcXFwiKTtcXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qc1xcXCIpO1xcblxcbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXFxuLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXFxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XFxuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XFxuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XFxuICAgIHZhciB2YWx1ZTtcXG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXFxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XFxuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcXG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcXG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xcbiAgfTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9iaW5kLWNvbnRleHQuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2JpbmQtY29udGV4dC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1mdW5jdGlvbi5qc1xcXCIpO1xcblxcbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcXG4gIGFGdW5jdGlvbihmbik7XFxuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XFxuICBzd2l0Y2ggKGxlbmd0aCkge1xcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCk7XFxuICAgIH07XFxuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XFxuICAgIH07XFxuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XFxuICAgIH07XFxuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XFxuICAgIH07XFxuICB9XFxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XFxuICB9O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcXFwiKTtcXG5cXG4vLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgRU5UUklFUykge1xcbiAgdHJ5IHtcXG4gICAgcmV0dXJuIEVOVFJJRVMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcXG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXFxuICB9IGNhdGNoIChlcnJvcikge1xcbiAgICB2YXIgcmV0dXJuTWV0aG9kID0gaXRlcmF0b3JbJ3JldHVybiddO1xcbiAgICBpZiAocmV0dXJuTWV0aG9kICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldHVybk1ldGhvZC5jYWxsKGl0ZXJhdG9yKSk7XFxuICAgIHRocm93IGVycm9yO1xcbiAgfVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbi5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG5cXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XFxudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xcblxcbnRyeSB7XFxuICB2YXIgY2FsbGVkID0gMDtcXG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XFxuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XFxuICAgIH0sXFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcXG4gICAgfVxcbiAgfTtcXG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfTtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXFxuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcXG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XFxuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XFxuICB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcXG4gIHRyeSB7XFxuICAgIHZhciBvYmplY3QgPSB7fTtcXG4gICAgb2JqZWN0W0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9O1xcbiAgICBleGVjKG9iamVjdCk7XFxuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBjbGFzc29mUmF3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qc1xcXCIpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXFxcIik7XFxuXFxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XFxuLy8gRVMzIHdyb25nIGhlcmVcXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcXG5cXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xcbiAgdHJ5IHtcXG4gICAgcmV0dXJuIGl0W2tleV07XFxuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxufTtcXG5cXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcXG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXFxuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXFxcIik7XFxudmFyIG93bktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb3duLWtleXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzXFxcIik7XFxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXFxcIik7XFxudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XFxuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xcbiAgICBpZiAoIWhhcyh0YXJnZXQsIGtleSkpIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcXG4gIH1cXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XFxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XFxuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMtY29yZS5qc1xcXCIpLkl0ZXJhdG9yUHJvdG90eXBlO1xcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qc1xcXCIpO1xcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXFxcIik7XFxudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qc1xcXCIpO1xcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanNcXFwiKTtcXG5cXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XFxuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XFxuICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSwgdHJ1ZSk7XFxuICBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcXG4gIHJldHVybiB7XFxuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXFxuICAgIHZhbHVlOiB2YWx1ZVxcbiAgfTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcmltaXRpdmUuanNcXFwiKTtcXG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XFxuICB2YXIgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShrZXkpO1xcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgdmFsdWUpKTtcXG4gIGVsc2Ugb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvci5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXFxcIik7XFxudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IuanNcXFwiKTtcXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzXFxcIik7XFxudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qc1xcXCIpO1xcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanNcXFwiKTtcXG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRlLmpzXFxcIik7XFxudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlZGVmaW5lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWRlZmluZS5qc1xcXCIpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXFxcIik7XFxudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtcHVyZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qc1xcXCIpO1xcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanNcXFwiKTtcXG52YXIgSXRlcmF0b3JzQ29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanNcXFwiKTtcXG5cXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcXG52YXIgS0VZUyA9ICdrZXlzJztcXG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XFxudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XFxuXFxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcXG5cXG4gIHZhciBnZXRJdGVyYXRpb25NZXRob2QgPSBmdW5jdGlvbiAoS0lORCkge1xcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XFxuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XFxuICAgIHN3aXRjaCAoS0lORCkge1xcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcXG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xcbiAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcXG4gICAgfSByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XFxuICB9O1xcblxcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XFxuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XFxuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XFxuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl1cXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxcbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xcbiAgdmFyIGRlZmF1bHRJdGVyYXRvciA9ICFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcXG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcXG4gIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcXG5cXG4gIC8vIGZpeCBuYXRpdmVcXG4gIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xcbiAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XFxuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xcbiAgICAgIGlmICghSVNfUFVSRSAmJiBnZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkge1xcbiAgICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XFxuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIGhpZGUoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcXG4gICAgICBzZXRUb1N0cmluZ1RhZyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUsIHRydWUpO1xcbiAgICAgIGlmIChJU19QVVJFKSBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXFxuICBpZiAoREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XFxuICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XFxuICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5hdGl2ZUl0ZXJhdG9yLmNhbGwodGhpcyk7IH07XFxuICB9XFxuXFxuICAvLyBkZWZpbmUgaXRlcmF0b3JcXG4gIGlmICgoIUlTX1BVUkUgfHwgRk9SQ0VEKSAmJiBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xcbiAgICBoaWRlKEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yKTtcXG4gIH1cXG4gIEl0ZXJhdG9yc1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcXG5cXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcXG4gIGlmIChERUZBVUxUKSB7XFxuICAgIG1ldGhvZHMgPSB7XFxuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXFxuICAgIH07XFxuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcXG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XFxuICAgICAgICByZWRlZmluZShJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlICQoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xcbiAgfVxcblxcbiAgcmV0dXJuIG1ldGhvZHM7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcXFwiKTtcXG5cXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XFxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXFxcIik7XFxuXFxudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxcbnZhciBleGlzdCA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIGV4aXN0ID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcXG5tb2R1bGUuZXhwb3J0cyA9IFtcXG4gICdjb25zdHJ1Y3RvcicsXFxuICAnaGFzT3duUHJvcGVydHknLFxcbiAgJ2lzUHJvdG90eXBlT2YnLFxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcXG4gICd0b0xvY2FsZVN0cmluZycsXFxuICAndG9TdHJpbmcnLFxcbiAgJ3ZhbHVlT2YnXFxuXTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXFxcIikuZjtcXG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRlLmpzXFxcIik7XFxudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlZGVmaW5lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWRlZmluZS5qc1xcXCIpO1xcbnZhciBzZXRHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qc1xcXCIpO1xcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzXFxcIik7XFxudmFyIGlzRm9yY2VkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWZvcmNlZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzXFxcIik7XFxuXFxuLypcXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XFxuICBvcHRpb25zLmdsb2JhbCAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XFxuICBvcHRpb25zLnN0YXQgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcXG4gIG9wdGlvbnMucmVhbCAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxcbiAgb3B0aW9ucy5mb3JjZWQgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxcbiAgb3B0aW9ucy53cmFwICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxcbiAgb3B0aW9ucy51bnNhZmUgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxcbiAgb3B0aW9ucy5ub1RhcmdldEdldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcXG4qL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcXG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XFxuICBpZiAoR0xPQkFMKSB7XFxuICAgIHRhcmdldCA9IGdsb2JhbDtcXG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XFxuICAgIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcXG4gIH0gZWxzZSB7XFxuICAgIHRhcmdldCA9IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xcbiAgfVxcbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XFxuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XFxuICAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XFxuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XFxuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XFxuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcXG4gICAgfVxcbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXFxuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XFxuICAgICAgaGlkZShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcXG4gICAgfVxcbiAgICAvLyBleHRlbmQgZ2xvYmFsXFxuICAgIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XFxuICB9XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiAhIWV4ZWMoKTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXRvLXN0cmluZy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdG8tc3RyaW5nLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gc2hhcmVkKCduYXRpdmUtZnVuY3Rpb24tdG8tc3RyaW5nJywgRnVuY3Rpb24udG9TdHJpbmcpO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jbGFzc29mICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLmpzXFxcIik7XFxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1xcXCIpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXFxcIik7XFxuXFxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXFxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgTyA9ICdvYmplY3QnO1xcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcXG59O1xcblxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XFxubW9kdWxlLmV4cG9ydHMgPVxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSBPICYmIGdsb2JhbFRoaXMpIHx8XFxuICBjaGVjayh0eXBlb2Ygd2luZG93ID09IE8gJiYgd2luZG93KSB8fFxcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gTyAmJiBzZWxmKSB8fFxcbiAgY2hlY2sodHlwZW9mIGdsb2JhbCA9PSBPICYmIGdsb2JhbCkgfHxcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xcbiAgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcXG5cXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi8uLi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXFxcIikpKVxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcXG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRlLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcXFwiKTtcXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XFxuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XFxufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcXG4gIG9iamVjdFtrZXldID0gdmFsdWU7XFxuICByZXR1cm4gb2JqZWN0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2h0bWwuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcXFwiKTtcXG5cXG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcbnZhciBjcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qc1xcXCIpO1xcblxcbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcXG5tb2R1bGUuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxcbiAgfSkuYSAhPSA3O1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzXFxcIik7XFxuXFxudmFyIHNwbGl0ID0gJycuc3BsaXQ7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXFxuICByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xcbn0pID8gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdC5jYWxsKGl0LCAnJykgOiBPYmplY3QoaXQpO1xcbn0gOiBPYmplY3Q7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwLmpzXFxcIik7XFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hpZGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGUuanNcXFwiKTtcXG52YXIgb2JqZWN0SGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXFxcIik7XFxudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQta2V5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXFxcIik7XFxudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXFxcIik7XFxuXFxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcXG52YXIgc2V0LCBnZXQsIGhhcztcXG5cXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XFxufTtcXG5cXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcXG4gICAgdmFyIHN0YXRlO1xcbiAgICBpZiAoIWlzT2JqZWN0KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XFxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xcbiAgICB9IHJldHVybiBzdGF0ZTtcXG4gIH07XFxufTtcXG5cXG5pZiAoTkFUSVZFX1dFQUtfTUFQKSB7XFxuICB2YXIgc3RvcmUgPSBuZXcgV2Vha01hcCgpO1xcbiAgdmFyIHdtZ2V0ID0gc3RvcmUuZ2V0O1xcbiAgdmFyIHdtaGFzID0gc3RvcmUuaGFzO1xcbiAgdmFyIHdtc2V0ID0gc3RvcmUuc2V0O1xcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xcbiAgICB3bXNldC5jYWxsKHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xcbiAgICByZXR1cm4gbWV0YWRhdGE7XFxuICB9O1xcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XFxuICAgIHJldHVybiB3bWdldC5jYWxsKHN0b3JlLCBpdCkgfHwge307XFxuICB9O1xcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XFxuICAgIHJldHVybiB3bWhhcy5jYWxsKHN0b3JlLCBpdCk7XFxuICB9O1xcbn0gZWxzZSB7XFxuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XFxuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XFxuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XFxuICAgIGhpZGUoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XFxuICAgIHJldHVybiBtZXRhZGF0YTtcXG4gIH07XFxuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XFxuICB9O1xcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XFxuICAgIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKTtcXG4gIH07XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgc2V0OiBzZXQsXFxuICBnZXQ6IGdldCxcXG4gIGhhczogaGFzLFxcbiAgZW5mb3JjZTogZW5mb3JjZSxcXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1xcXCIpO1xcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanNcXFwiKTtcXG5cXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XFxudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xcblxcbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdID09PSBpdCk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxuXFxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFxcXC5wcm90b3R5cGVcXFxcLi87XFxuXFxudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxcbiAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXFxuICAgIDogdHlwZW9mIGRldGVjdGlvbiA9PSAnZnVuY3Rpb24nID8gZmFpbHMoZGV0ZWN0aW9uKVxcbiAgICA6ICEhZGV0ZWN0aW9uO1xcbn07XFxuXFxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcXG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XFxufTtcXG5cXG52YXIgZGF0YSA9IGlzRm9yY2VkLmRhdGEgPSB7fTtcXG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xcblxcbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzXFxcIik7XFxudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZS5qc1xcXCIpO1xcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcXFwiKTtcXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1xcXCIpO1xcbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLXB1cmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanNcXFwiKTtcXG5cXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XFxudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBmYWxzZTtcXG5cXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XFxuXFxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVpdGVyYXRvcnByb3RvdHlwZSUtb2JqZWN0XFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XFxuXFxuaWYgKFtdLmtleXMpIHtcXG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XFxuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcXG4gIGlmICghKCduZXh0JyBpbiBhcnJheUl0ZXJhdG9yKSkgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IHRydWU7XFxuICBlbHNlIHtcXG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xcbiAgICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSBJdGVyYXRvclByb3RvdHlwZSA9IFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTtcXG4gIH1cXG59XFxuXFxuaWYgKEl0ZXJhdG9yUHJvdG90eXBlID09IHVuZGVmaW5lZCkgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcXG5cXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxcbmlmICghSVNfUFVSRSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSxcXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlNcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbm1vZHVsZS5leHBvcnRzID0ge307XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtc3ltYm9sLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxcbiAgcmV0dXJuICFTdHJpbmcoU3ltYm9sKCkpO1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcXFwiKTtcXG52YXIgbmF0aXZlRnVuY3Rpb25Ub1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mdW5jdGlvbi10by1zdHJpbmcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLXRvLXN0cmluZy5qc1xcXCIpO1xcblxcbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QobmF0aXZlRnVuY3Rpb25Ub1N0cmluZy5jYWxsKFdlYWtNYXApKTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXFxcIik7XFxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanNcXFwiKTtcXG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qc1xcXCIpO1xcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qc1xcXCIpO1xcbnZhciBodG1sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2h0bWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2h0bWwuanNcXFwiKTtcXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qc1xcXCIpO1xcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLWtleSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qc1xcXCIpO1xcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcXG5cXG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XFxudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xcblxcbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcXG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXFxuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcXG4gIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cy5sZW5ndGg7XFxuICB2YXIgbHQgPSAnPCc7XFxuICB2YXIgc2NyaXB0ID0gJ3NjcmlwdCc7XFxuICB2YXIgZ3QgPSAnPic7XFxuICB2YXIganMgPSAnamF2YScgKyBzY3JpcHQgKyAnOic7XFxuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XFxuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcXG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcXG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoanMpO1xcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcXG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcXG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgc2NyaXB0ICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnLycgKyBzY3JpcHQgKyBndCk7XFxuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XFxuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XFxuICByZXR1cm4gY3JlYXRlRGljdCgpO1xcbn07XFxuXFxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXFxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XFxuICB2YXIgcmVzdWx0O1xcbiAgaWYgKE8gIT09IG51bGwpIHtcXG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcXG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XFxuICAgIC8vIGFkZCBcXFwiX19wcm90b19fXFxcIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcXG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzKHJlc3VsdCwgUHJvcGVydGllcyk7XFxufTtcXG5cXG5oaWRkZW5LZXlzW0lFX1BST1RPXSA9IHRydWU7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1xcXCIpO1xcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXFxcIik7XFxudmFyIG9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XFxuICBhbk9iamVjdChPKTtcXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcXG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcXG4gIHZhciBpID0gMDtcXG4gIHZhciBrZXk7XFxuICB3aGlsZSAobGVuZ3RoID4gaSkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihPLCBrZXkgPSBrZXlzW2krK10sIFByb3BlcnRpZXNba2V5XSk7XFxuICByZXR1cm4gTztcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qc1xcXCIpO1xcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1xcXCIpO1xcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1wcmltaXRpdmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qc1xcXCIpO1xcblxcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcXG5cXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/IG5hdGl2ZURlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xcbiAgYW5PYmplY3QoTyk7XFxuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XFxuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcXG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcXG4gICAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxcbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XFxuICByZXR1cm4gTztcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qc1xcXCIpO1xcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXFxcIik7XFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcmltaXRpdmUuanNcXFwiKTtcXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXFxcIik7XFxudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qc1xcXCIpO1xcblxcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xcblxcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcXG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XFxuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XFxuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XFxuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XFxuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLmNhbGwoTywgUCksIE9bUF0pO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXFxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcXFwiKTtcXG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qc1xcXCIpO1xcblxcbnZhciBoaWRkZW5LZXlzID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XFxuXFxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XFxuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXFxcIik7XFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzXFxcIik7XFxudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQta2V5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXFxcIik7XFxudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qc1xcXCIpO1xcblxcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcXG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcXG5cXG4vLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxcbm1vZHVsZS5leHBvcnRzID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcXG4gIE8gPSB0b09iamVjdChPKTtcXG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XFxuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XFxuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1xcXCIpO1xcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzXFxcIik7XFxudmFyIGFycmF5SW5jbHVkZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzXFxcIik7XFxudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXFxcIik7XFxuXFxudmFyIGFycmF5SW5kZXhPZiA9IGFycmF5SW5jbHVkZXMoZmFsc2UpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcXG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XFxuICB2YXIgaSA9IDA7XFxuICB2YXIgcmVzdWx0ID0gW107XFxuICB2YXIga2V5O1xcbiAgZm9yIChrZXkgaW4gTykgIWhhcyhoaWRkZW5LZXlzLCBrZXkpICYmIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XFxuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXFxuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcXFwiKTtcXG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qc1xcXCIpO1xcblxcbi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XFxuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xcblxcbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XFxuXFxuZXhwb3J0cy5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XFxuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcXG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xcbn0gOiBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciB2YWxpZGF0ZVNldFByb3RvdHlwZU9mQXJndW1lbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3ZhbGlkYXRlLXNldC1wcm90b3R5cGUtb2YtYXJndW1lbnRzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92YWxpZGF0ZS1zZXQtcHJvdG90eXBlLW9mLWFyZ3VtZW50cy5qc1xcXCIpO1xcblxcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXFxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xcbiAgdmFyIGNvcnJlY3RTZXR0ZXIgPSBmYWxzZTtcXG4gIHZhciB0ZXN0ID0ge307XFxuICB2YXIgc2V0dGVyO1xcbiAgdHJ5IHtcXG4gICAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xcbiAgICBzZXR0ZXIuY2FsbCh0ZXN0LCBbXSk7XFxuICAgIGNvcnJlY3RTZXR0ZXIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XFxuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcXG4gICAgdmFsaWRhdGVTZXRQcm90b3R5cGVPZkFyZ3VtZW50cyhPLCBwcm90byk7XFxuICAgIGlmIChjb3JyZWN0U2V0dGVyKSBzZXR0ZXIuY2FsbChPLCBwcm90byk7XFxuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcXG4gICAgcmV0dXJuIE87XFxuICB9O1xcbn0oKSA6IHVuZGVmaW5lZCk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXFxcIik7XFxudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzXFxcIik7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXFxcIik7XFxuXFxudmFyIFJlZmxlY3QgPSBnbG9iYWwuUmVmbGVjdDtcXG5cXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXFxubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XFxuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGF0aC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWRlZmluZS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWRlZmluZS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanNcXFwiKTtcXG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRlLmpzXFxcIik7XFxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1xcXCIpO1xcbnZhciBzZXRHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qc1xcXCIpO1xcbnZhciBuYXRpdmVGdW5jdGlvblRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXRvLXN0cmluZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdG8tc3RyaW5nLmpzXFxcIik7XFxudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlLmpzXFxcIik7XFxuXFxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcXG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XFxudmFyIFRFTVBMQVRFID0gU3RyaW5nKG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcpLnNwbGl0KCd0b1N0cmluZycpO1xcblxcbnNoYXJlZCgnaW5zcGVjdFNvdXJjZScsIGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XFxufSk7XFxuXFxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gIHZhciB1bnNhZmUgPSBvcHRpb25zID8gISFvcHRpb25zLnVuc2FmZSA6IGZhbHNlO1xcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMuZW51bWVyYWJsZSA6IGZhbHNlO1xcbiAgdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XFxuICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnICYmICFoYXModmFsdWUsICduYW1lJykpIGhpZGUodmFsdWUsICduYW1lJywga2V5KTtcXG4gICAgZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/IGtleSA6ICcnKTtcXG4gIH1cXG4gIGlmIChPID09PSBnbG9iYWwpIHtcXG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XFxuICAgIGVsc2Ugc2V0R2xvYmFsKGtleSwgdmFsdWUpO1xcbiAgICByZXR1cm47XFxuICB9IGVsc2UgaWYgKCF1bnNhZmUpIHtcXG4gICAgZGVsZXRlIE9ba2V5XTtcXG4gIH0gZWxzZSBpZiAoIW5vVGFyZ2V0R2V0ICYmIE9ba2V5XSkge1xcbiAgICBzaW1wbGUgPSB0cnVlO1xcbiAgfVxcbiAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XFxuICBlbHNlIGhpZGUoTywga2V5LCB2YWx1ZSk7XFxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXFxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcXG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcuY2FsbCh0aGlzKTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXFxcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFxcXCIgKyBpdCk7XFxuICByZXR1cm4gaXQ7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1nbG9iYWwuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hpZGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGUuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XFxuICB0cnkge1xcbiAgICBoaWRlKGdsb2JhbCwga2V5LCB2YWx1ZSk7XFxuICB9IGNhdGNoIChlcnJvcikge1xcbiAgICBnbG9iYWxba2V5XSA9IHZhbHVlO1xcbiAgfSByZXR1cm4gdmFsdWU7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXFxcIikuZjtcXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXFxcIik7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG5cXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVEFHLCBTVEFUSUMpIHtcXG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gU1RBVElDID8gaXQgOiBpdC5wcm90b3R5cGUsIFRPX1NUUklOR19UQUcpKSB7XFxuICAgIGRlZmluZVByb3BlcnR5KGl0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcXG4gIH1cXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzXFxcIik7XFxudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy91aWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qc1xcXCIpO1xcblxcbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XFxuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtZ2xvYmFsLmpzXFxcIik7XFxudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtcHVyZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qc1xcXCIpO1xcblxcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcXG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XFxuXFxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcXG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcXG4gIHZlcnNpb246ICczLjEuMycsXFxuICBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctYXQuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1hdC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW50ZWdlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qc1xcXCIpO1xcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzXFxcIik7XFxuXFxuLy8gQ09OVkVSVF9UT19TVFJJTkc6IHRydWUgIC0+IFN0cmluZyNhdFxcbi8vIENPTlZFUlRfVE9fU1RSSU5HOiBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCBwb3MsIENPTlZFUlRfVE9fU1RSSU5HKSB7XFxuICB2YXIgUyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoYXQpKTtcXG4gIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlcihwb3MpO1xcbiAgdmFyIHNpemUgPSBTLmxlbmd0aDtcXG4gIHZhciBmaXJzdCwgc2Vjb25kO1xcbiAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBzaXplKSByZXR1cm4gQ09OVkVSVF9UT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcXG4gIGZpcnN0ID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcXG4gIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcXG4gICAgfHwgKHNlY29uZCA9IFMuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcXG4gICAgICA/IENPTlZFUlRfVE9fU1RSSU5HID8gUy5jaGFyQXQocG9zaXRpb24pIDogZmlyc3RcXG4gICAgICA6IENPTlZFUlRfVE9fU1RSSU5HID8gUy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyAyKSA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW50ZWdlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qc1xcXCIpO1xcblxcbnZhciBtYXggPSBNYXRoLm1heDtcXG52YXIgbWluID0gTWF0aC5taW47XFxuXFxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XFxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxcbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGxlbmd0aCwgbGVuZ3RoKS5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XFxuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlcihpbmRleCk7XFxuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcXG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXIuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XFxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcXG5cXG4vLyBgVG9JbnRlZ2VyYCBhYnN0cmFjdCBvcGVyYXRpb25cXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2ludGVnZXJcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xcbiAgcmV0dXJuIGlzTmFOKGFyZ3VtZW50ID0gK2FyZ3VtZW50KSA/IDAgOiAoYXJndW1lbnQgPiAwID8gZmxvb3IgOiBjZWlsKShhcmd1bWVudCk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWludGVnZXIgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXIuanNcXFwiKTtcXG5cXG52YXIgbWluID0gTWF0aC5taW47XFxuXFxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlcihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanNcXFwiKTtcXG5cXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcXG4gIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXFxcIik7XFxuXFxuLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXFxuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2VcXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xcbiAgdmFyIGZuLCB2YWw7XFxuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcXG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xcbiAgdGhyb3cgVHlwZUVycm9yKFxcXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcXFwiKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbnZhciBpZCA9IDA7XFxudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNikpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3ZhbGlkYXRlLXNldC1wcm90b3R5cGUtb2YtYXJndW1lbnRzLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3ZhbGlkYXRlLXNldC1wcm90b3R5cGUtb2YtYXJndW1lbnRzLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcXFwiKTtcXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xcbiAgYW5PYmplY3QoTyk7XFxuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkge1xcbiAgICB0aHJvdyBUeXBlRXJyb3IoXFxcIkNhbid0IHNldCBcXFwiICsgU3RyaW5nKHByb3RvKSArICcgYXMgYSBwcm90b3R5cGUnKTtcXG4gIH1cXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanNcXFwiKTtcXG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3VpZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzXFxcIik7XFxudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbC5qc1xcXCIpO1xcblxcbnZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xcbnZhciBzdG9yZSA9IHNoYXJlZCgnd2tzJyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9IE5BVElWRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdXFxuICAgIHx8IChOQVRJVkVfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXFxcIik7XFxudmFyIGZyb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktZnJvbSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZnJvbS5qc1xcXCIpO1xcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanNcXFwiKTtcXG5cXG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XFxuICBBcnJheS5mcm9tKGl0ZXJhYmxlKTtcXG59KTtcXG5cXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XFxuICBmcm9tOiBmcm9tXFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgY29kZVBvaW50QXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc3RyaW5nLWF0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctYXQuanNcXFwiKTtcXG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcXFwiKTtcXG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanNcXFwiKTtcXG5cXG52YXIgU1RSSU5HX0lURVJBVE9SID0gJ1N0cmluZyBJdGVyYXRvcic7XFxudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcXG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XFxuXFxuLy8gYFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxcbmRlZmluZUl0ZXJhdG9yKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XFxuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcXG4gICAgc3RyaW5nOiBTdHJpbmcoaXRlcmF0ZWQpLFxcbiAgICBpbmRleDogMFxcbiAgfSk7XFxuLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcXG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XFxuICB2YXIgc3RyaW5nID0gc3RhdGUuc3RyaW5nO1xcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XFxuICB2YXIgcG9pbnQ7XFxuICBpZiAoaW5kZXggPj0gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xcbiAgcG9pbnQgPSBjb2RlUG9pbnRBdChzdHJpbmcsIGluZGV4LCB0cnVlKTtcXG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcXG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxudmFyIGc7XFxyXFxuXFxyXFxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcXHJcXG5nID0gKGZ1bmN0aW9uKCkge1xcclxcblxcdHJldHVybiB0aGlzO1xcclxcbn0pKCk7XFxyXFxuXFxyXFxudHJ5IHtcXHJcXG5cXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcXHJcXG5cXHRnID0gZyB8fCBGdW5jdGlvbihcXFwicmV0dXJuIHRoaXNcXFwiKSgpIHx8ICgxLCBldmFsKShcXFwidGhpc1xcXCIpO1xcclxcbn0gY2F0Y2ggKGUpIHtcXHJcXG5cXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxcclxcblxcdGlmICh0eXBlb2Ygd2luZG93ID09PSBcXFwib2JqZWN0XFxcIikgZyA9IHdpbmRvdztcXHJcXG59XFxyXFxuXFxyXFxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxcclxcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXFxyXFxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxcclxcblxcclxcbm1vZHVsZS5leHBvcnRzID0gZztcXHJcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9zcmMvZGVmYXVsdC1hdHRycy5qc29uXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL3NyYy9kZWZhdWx0LWF0dHJzLmpzb24gKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBleHBvcnRzIHByb3ZpZGVkOiB4bWxucywgd2lkdGgsIGhlaWdodCwgdmlld0JveCwgZmlsbCwgc3Ryb2tlLCBzdHJva2Utd2lkdGgsIHN0cm9rZS1saW5lY2FwLCBzdHJva2UtbGluZWpvaW4sIGRlZmF1bHQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxcInhtbG5zXFxcIjpcXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiLFxcXCJ3aWR0aFxcXCI6MjQsXFxcImhlaWdodFxcXCI6MjQsXFxcInZpZXdCb3hcXFwiOlxcXCIwIDAgMjQgMjRcXFwiLFxcXCJmaWxsXFxcIjpcXFwibm9uZVxcXCIsXFxcInN0cm9rZVxcXCI6XFxcImN1cnJlbnRDb2xvclxcXCIsXFxcInN0cm9rZS13aWR0aFxcXCI6MixcXFwic3Ryb2tlLWxpbmVjYXBcXFwiOlxcXCJyb3VuZFxcXCIsXFxcInN0cm9rZS1saW5lam9pblxcXCI6XFxcInJvdW5kXFxcIn07XFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vc3JjL2ljb24uanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL3NyYy9pY29uLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxudmFyIF9kZWR1cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjbGFzc25hbWVzL2RlZHVwZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9kZWR1cGUuanNcXFwiKTtcXG5cXG52YXIgX2RlZHVwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWR1cGUpO1xcblxcbnZhciBfZGVmYXVsdEF0dHJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kZWZhdWx0LWF0dHJzLmpzb24gKi8gXFxcIi4vc3JjL2RlZmF1bHQtYXR0cnMuanNvblxcXCIpO1xcblxcbnZhciBfZGVmYXVsdEF0dHJzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmF1bHRBdHRycyk7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG52YXIgSWNvbiA9IGZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIEljb24obmFtZSwgY29udGVudHMpIHtcXG4gICAgdmFyIHRhZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xcblxcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWNvbik7XFxuXFxuICAgIHRoaXMubmFtZSA9IG5hbWU7XFxuICAgIHRoaXMuY29udGVudHMgPSBjb250ZW50cztcXG4gICAgdGhpcy50YWdzID0gdGFncztcXG4gICAgdGhpcy5hdHRycyA9IF9leHRlbmRzKHt9LCBfZGVmYXVsdEF0dHJzMi5kZWZhdWx0LCB7IGNsYXNzOiAnZmVhdGhlciBmZWF0aGVyLScgKyBuYW1lIH0pO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBDcmVhdGUgYW4gU1ZHIHN0cmluZy5cXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyc1xcbiAgICogQHJldHVybnMge3N0cmluZ31cXG4gICAqL1xcblxcblxcbiAgX2NyZWF0ZUNsYXNzKEljb24sIFt7XFxuICAgIGtleTogJ3RvU3ZnJyxcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3ZnKCkge1xcbiAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuXFxuICAgICAgdmFyIGNvbWJpbmVkQXR0cnMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5hdHRycywgYXR0cnMsIHsgY2xhc3M6ICgwLCBfZGVkdXBlMi5kZWZhdWx0KSh0aGlzLmF0dHJzLmNsYXNzLCBhdHRycy5jbGFzcykgfSk7XFxuXFxuICAgICAgcmV0dXJuICc8c3ZnICcgKyBhdHRyc1RvU3RyaW5nKGNvbWJpbmVkQXR0cnMpICsgJz4nICsgdGhpcy5jb250ZW50cyArICc8L3N2Zz4nO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGBJY29uYC5cXG4gICAgICpcXG4gICAgICogQWRkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIElmIG9sZCBjb2RlIGV4cGVjdHMgYGZlYXRoZXIuaWNvbnMuPG5hbWU+YFxcbiAgICAgKiB0byBiZSBhIHN0cmluZywgYHRvU3RyaW5nKClgIHdpbGwgZ2V0IGltcGxpY2l0bHkgY2FsbGVkLlxcbiAgICAgKlxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiAndG9TdHJpbmcnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuY29udGVudHM7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBJY29uO1xcbn0oKTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0IGF0dHJpYnV0ZXMgb2JqZWN0IHRvIHN0cmluZyBvZiBIVE1MIGF0dHJpYnV0ZXMuXFxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJzXFxuICogQHJldHVybnMge3N0cmluZ31cXG4gKi9cXG5cXG5cXG5mdW5jdGlvbiBhdHRyc1RvU3RyaW5nKGF0dHJzKSB7XFxuICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cnMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XFxuICAgIHJldHVybiBrZXkgKyAnPVxcXCInICsgYXR0cnNba2V5XSArICdcXFwiJztcXG4gIH0pLmpvaW4oJyAnKTtcXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gSWNvbjtcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9zcmMvaWNvbnMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9zcmMvaWNvbnMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBfaWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaWNvbiAqLyBcXFwiLi9zcmMvaWNvbi5qc1xcXCIpO1xcblxcbnZhciBfaWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pY29uKTtcXG5cXG52YXIgX2ljb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGlzdC9pY29ucy5qc29uICovIFxcXCIuL2Rpc3QvaWNvbnMuanNvblxcXCIpO1xcblxcbnZhciBfaWNvbnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaWNvbnMpO1xcblxcbnZhciBfdGFncyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGFncy5qc29uICovIFxcXCIuL3NyYy90YWdzLmpzb25cXFwiKTtcXG5cXG52YXIgX3RhZ3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFncyk7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBPYmplY3Qua2V5cyhfaWNvbnMyLmRlZmF1bHQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XFxuICByZXR1cm4gbmV3IF9pY29uMi5kZWZhdWx0KGtleSwgX2ljb25zMi5kZWZhdWx0W2tleV0sIF90YWdzMi5kZWZhdWx0W2tleV0pO1xcbn0pLnJlZHVjZShmdW5jdGlvbiAob2JqZWN0LCBpY29uKSB7XFxuICBvYmplY3RbaWNvbi5uYW1lXSA9IGljb247XFxuICByZXR1cm4gb2JqZWN0O1xcbn0sIHt9KTtcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9zcmMvaW5kZXguanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9zcmMvaW5kZXguanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXG52YXIgX2ljb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pY29ucyAqLyBcXFwiLi9zcmMvaWNvbnMuanNcXFwiKTtcXG5cXG52YXIgX2ljb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ljb25zKTtcXG5cXG52YXIgX3RvU3ZnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90by1zdmcgKi8gXFxcIi4vc3JjL3RvLXN2Zy5qc1xcXCIpO1xcblxcbnZhciBfdG9TdmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9TdmcpO1xcblxcbnZhciBfcmVwbGFjZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVwbGFjZSAqLyBcXFwiLi9zcmMvcmVwbGFjZS5qc1xcXCIpO1xcblxcbnZhciBfcmVwbGFjZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZXBsYWNlKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbm1vZHVsZS5leHBvcnRzID0geyBpY29uczogX2ljb25zMi5kZWZhdWx0LCB0b1N2ZzogX3RvU3ZnMi5kZWZhdWx0LCByZXBsYWNlOiBfcmVwbGFjZTIuZGVmYXVsdCB9O1xcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL3NyYy9yZXBsYWNlLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9zcmMvcmVwbGFjZS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyAvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cXG5cXG5cXG52YXIgX2RlZHVwZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNsYXNzbmFtZXMvZGVkdXBlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2RlZHVwZS5qc1xcXCIpO1xcblxcbnZhciBfZGVkdXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZHVwZSk7XFxuXFxudmFyIF9pY29ucyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaWNvbnMgKi8gXFxcIi4vc3JjL2ljb25zLmpzXFxcIik7XFxuXFxudmFyIF9pY29uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pY29ucyk7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG4vKipcXG4gKiBSZXBsYWNlIGFsbCBIVE1MIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIGBkYXRhLWZlYXRoZXJgIGF0dHJpYnV0ZSB3aXRoIFNWRyBtYXJrdXBcXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBlbGVtZW50J3MgYGRhdGEtZmVhdGhlcmAgYXR0cmlidXRlIHZhbHVlLlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyc1xcbiAqL1xcbmZ1bmN0aW9uIHJlcGxhY2UoKSB7XFxuICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xcblxcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmVhdGhlci5yZXBsYWNlKClgIG9ubHkgd29ya3MgaW4gYSBicm93c2VyIGVudmlyb25tZW50LicpO1xcbiAgfVxcblxcbiAgdmFyIGVsZW1lbnRzVG9SZXBsYWNlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZmVhdGhlcl0nKTtcXG5cXG4gIEFycmF5LmZyb20oZWxlbWVudHNUb1JlcGxhY2UpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcXG4gICAgcmV0dXJuIHJlcGxhY2VFbGVtZW50KGVsZW1lbnQsIGF0dHJzKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBSZXBsYWNlIGEgc2luZ2xlIEhUTUwgZWxlbWVudCB3aXRoIFNWRyBtYXJrdXBcXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBlbGVtZW50J3MgYGRhdGEtZmVhdGhlcmAgYXR0cmlidXRlIHZhbHVlLlxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnNcXG4gKi9cXG5mdW5jdGlvbiByZXBsYWNlRWxlbWVudChlbGVtZW50KSB7XFxuICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xcblxcbiAgdmFyIGVsZW1lbnRBdHRycyA9IGdldEF0dHJzKGVsZW1lbnQpO1xcbiAgdmFyIG5hbWUgPSBlbGVtZW50QXR0cnNbJ2RhdGEtZmVhdGhlciddO1xcbiAgZGVsZXRlIGVsZW1lbnRBdHRyc1snZGF0YS1mZWF0aGVyJ107XFxuXFxuICB2YXIgc3ZnU3RyaW5nID0gX2ljb25zMi5kZWZhdWx0W25hbWVdLnRvU3ZnKF9leHRlbmRzKHt9LCBhdHRycywgZWxlbWVudEF0dHJzLCB7IGNsYXNzOiAoMCwgX2RlZHVwZTIuZGVmYXVsdCkoYXR0cnMuY2xhc3MsIGVsZW1lbnRBdHRycy5jbGFzcykgfSkpO1xcbiAgdmFyIHN2Z0RvY3VtZW50ID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdmdTdHJpbmcsICdpbWFnZS9zdmcreG1sJyk7XFxuICB2YXIgc3ZnRWxlbWVudCA9IHN2Z0RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpO1xcblxcbiAgZWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChzdmdFbGVtZW50LCBlbGVtZW50KTtcXG59XFxuXFxuLyoqXFxuICogR2V0IHRoZSBhdHRyaWJ1dGVzIG9mIGFuIEhUTUwgZWxlbWVudC5cXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XFxuICogQHJldHVybnMge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBnZXRBdHRycyhlbGVtZW50KSB7XFxuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmF0dHJpYnV0ZXMpLnJlZHVjZShmdW5jdGlvbiAoYXR0cnMsIGF0dHIpIHtcXG4gICAgYXR0cnNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XFxuICAgIHJldHVybiBhdHRycztcXG4gIH0sIHt9KTtcXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gcmVwbGFjZTtcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9zcmMvdGFncy5qc29uXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL3NyYy90YWdzLmpzb24gKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBleHBvcnRzIHByb3ZpZGVkOiBhY3Rpdml0eSwgYWlycGxheSwgYWxlcnQtY2lyY2xlLCBhbGVydC1vY3RhZ29uLCBhbGVydC10cmlhbmdsZSwgYWxpZ24tY2VudGVyLCBhbGlnbi1qdXN0aWZ5LCBhbGlnbi1sZWZ0LCBhbGlnbi1yaWdodCwgYW5jaG9yLCBhcmNoaXZlLCBhdC1zaWduLCBhd2FyZCwgYXBlcnR1cmUsIGJhci1jaGFydCwgYmFyLWNoYXJ0LTIsIGJhdHRlcnksIGJhdHRlcnktY2hhcmdpbmcsIGJlbGwsIGJlbGwtb2ZmLCBibHVldG9vdGgsIGJvb2stb3BlbiwgYm9vaywgYm9va21hcmssIGJveCwgYnJpZWZjYXNlLCBjYWxlbmRhciwgY2FtZXJhLCBjYXN0LCBjaXJjbGUsIGNsaXBib2FyZCwgY2xvY2ssIGNsb3VkLWRyaXp6bGUsIGNsb3VkLWxpZ2h0bmluZywgY2xvdWQtcmFpbiwgY2xvdWQtc25vdywgY2xvdWQsIGNvZGVwZW4sIGNvZGVzYW5kYm94LCBjb2RlLCBjb2ZmZWUsIGNvbHVtbnMsIGNvbW1hbmQsIGNvbXBhc3MsIGNvcHksIGNvcm5lci1kb3duLWxlZnQsIGNvcm5lci1kb3duLXJpZ2h0LCBjb3JuZXItbGVmdC1kb3duLCBjb3JuZXItbGVmdC11cCwgY29ybmVyLXJpZ2h0LWRvd24sIGNvcm5lci1yaWdodC11cCwgY29ybmVyLXVwLWxlZnQsIGNvcm5lci11cC1yaWdodCwgY3B1LCBjcmVkaXQtY2FyZCwgY3JvcCwgY3Jvc3NoYWlyLCBkYXRhYmFzZSwgZGVsZXRlLCBkaXNjLCBkb2xsYXItc2lnbiwgZHJvcGxldCwgZWRpdCwgZWRpdC0yLCBlZGl0LTMsIGV5ZSwgZXllLW9mZiwgZXh0ZXJuYWwtbGluaywgZmFjZWJvb2ssIGZhc3QtZm9yd2FyZCwgZmlnbWEsIGZpbGUtbWludXMsIGZpbGUtcGx1cywgZmlsZS10ZXh0LCBmaWxtLCBmaWx0ZXIsIGZsYWcsIGZvbGRlci1taW51cywgZm9sZGVyLXBsdXMsIGZvbGRlciwgZnJhbWVyLCBmcm93biwgZ2lmdCwgZ2l0LWJyYW5jaCwgZ2l0LWNvbW1pdCwgZ2l0LW1lcmdlLCBnaXQtcHVsbC1yZXF1ZXN0LCBnaXRodWIsIGdpdGxhYiwgZ2xvYmUsIGhhcmQtZHJpdmUsIGhhc2gsIGhlYWRwaG9uZXMsIGhlYXJ0LCBoZWxwLWNpcmNsZSwgaGV4YWdvbiwgaG9tZSwgaW1hZ2UsIGluYm94LCBpbnN0YWdyYW0sIGtleSwgbGF5ZXJzLCBsYXlvdXQsIGxpZmUtYm91eSwgbGluaywgbGluay0yLCBsaW5rZWRpbiwgbGlzdCwgbG9jaywgbG9nLWluLCBsb2ctb3V0LCBtYWlsLCBtYXAtcGluLCBtYXAsIG1heGltaXplLCBtYXhpbWl6ZS0yLCBtZWgsIG1lbnUsIG1lc3NhZ2UtY2lyY2xlLCBtZXNzYWdlLXNxdWFyZSwgbWljLW9mZiwgbWljLCBtaW5pbWl6ZSwgbWluaW1pemUtMiwgbWludXMsIG1vbml0b3IsIG1vb24sIG1vcmUtaG9yaXpvbnRhbCwgbW9yZS12ZXJ0aWNhbCwgbW91c2UtcG9pbnRlciwgbW92ZSwgbXVzaWMsIG5hdmlnYXRpb24sIG5hdmlnYXRpb24tMiwgb2N0YWdvbiwgcGFja2FnZSwgcGFwZXJjbGlwLCBwYXVzZSwgcGF1c2UtY2lyY2xlLCBwZW4tdG9vbCwgcGVyY2VudCwgcGhvbmUtY2FsbCwgcGhvbmUtZm9yd2FyZGVkLCBwaG9uZS1pbmNvbWluZywgcGhvbmUtbWlzc2VkLCBwaG9uZS1vZmYsIHBob25lLW91dGdvaW5nLCBwaG9uZSwgcGxheSwgcGllLWNoYXJ0LCBwbGF5LWNpcmNsZSwgcGx1cywgcGx1cy1jaXJjbGUsIHBsdXMtc3F1YXJlLCBwb2NrZXQsIHBvd2VyLCBwcmludGVyLCByYWRpbywgcmVmcmVzaC1jdywgcmVmcmVzaC1jY3csIHJlcGVhdCwgcmV3aW5kLCByb3RhdGUtY2N3LCByb3RhdGUtY3csIHJzcywgc2F2ZSwgc2Npc3NvcnMsIHNlYXJjaCwgc2VuZCwgc2V0dGluZ3MsIHNoYXJlLTIsIHNoaWVsZCwgc2hpZWxkLW9mZiwgc2hvcHBpbmctYmFnLCBzaG9wcGluZy1jYXJ0LCBzaHVmZmxlLCBza2lwLWJhY2ssIHNraXAtZm9yd2FyZCwgc2xhY2ssIHNsYXNoLCBzbGlkZXJzLCBzbWFydHBob25lLCBzbWlsZSwgc3BlYWtlciwgc3Rhciwgc3RvcC1jaXJjbGUsIHN1biwgc3VucmlzZSwgc3Vuc2V0LCB0YWJsZXQsIHRhZywgdGFyZ2V0LCB0ZXJtaW5hbCwgdGhlcm1vbWV0ZXIsIHRodW1icy1kb3duLCB0aHVtYnMtdXAsIHRvZ2dsZS1sZWZ0LCB0b2dnbGUtcmlnaHQsIHRvb2wsIHRyYXNoLCB0cmFzaC0yLCB0cmlhbmdsZSwgdHJ1Y2ssIHR2LCB0d2l0Y2gsIHR3aXR0ZXIsIHR5cGUsIHVtYnJlbGxhLCB1bmxvY2ssIHVzZXItY2hlY2ssIHVzZXItbWludXMsIHVzZXItcGx1cywgdXNlci14LCB1c2VyLCB1c2VycywgdmlkZW8tb2ZmLCB2aWRlbywgdm9pY2VtYWlsLCB2b2x1bWUsIHZvbHVtZS0xLCB2b2x1bWUtMiwgdm9sdW1lLXgsIHdhdGNoLCB3aWZpLW9mZiwgd2lmaSwgd2luZCwgeC1jaXJjbGUsIHgtb2N0YWdvbiwgeC1zcXVhcmUsIHgsIHlvdXR1YmUsIHphcC1vZmYsIHphcCwgem9vbS1pbiwgem9vbS1vdXQsIGRlZmF1bHQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxcImFjdGl2aXR5XFxcIjpbXFxcInB1bHNlXFxcIixcXFwiaGVhbHRoXFxcIixcXFwiYWN0aW9uXFxcIixcXFwibW90aW9uXFxcIl0sXFxcImFpcnBsYXlcXFwiOltcXFwic3RyZWFtXFxcIixcXFwiY2FzdFxcXCIsXFxcIm1pcnJvcmluZ1xcXCJdLFxcXCJhbGVydC1jaXJjbGVcXFwiOltcXFwid2FybmluZ1xcXCIsXFxcImFsZXJ0XFxcIixcXFwiZGFuZ2VyXFxcIl0sXFxcImFsZXJ0LW9jdGFnb25cXFwiOltcXFwid2FybmluZ1xcXCIsXFxcImFsZXJ0XFxcIixcXFwiZGFuZ2VyXFxcIl0sXFxcImFsZXJ0LXRyaWFuZ2xlXFxcIjpbXFxcIndhcm5pbmdcXFwiLFxcXCJhbGVydFxcXCIsXFxcImRhbmdlclxcXCJdLFxcXCJhbGlnbi1jZW50ZXJcXFwiOltcXFwidGV4dCBhbGlnbm1lbnRcXFwiLFxcXCJjZW50ZXJcXFwiXSxcXFwiYWxpZ24tanVzdGlmeVxcXCI6W1xcXCJ0ZXh0IGFsaWdubWVudFxcXCIsXFxcImp1c3RpZmllZFxcXCJdLFxcXCJhbGlnbi1sZWZ0XFxcIjpbXFxcInRleHQgYWxpZ25tZW50XFxcIixcXFwibGVmdFxcXCJdLFxcXCJhbGlnbi1yaWdodFxcXCI6W1xcXCJ0ZXh0IGFsaWdubWVudFxcXCIsXFxcInJpZ2h0XFxcIl0sXFxcImFuY2hvclxcXCI6W10sXFxcImFyY2hpdmVcXFwiOltcXFwiaW5kZXhcXFwiLFxcXCJib3hcXFwiXSxcXFwiYXQtc2lnblxcXCI6W1xcXCJtZW50aW9uXFxcIixcXFwiYXRcXFwiLFxcXCJlbWFpbFxcXCIsXFxcIm1lc3NhZ2VcXFwiXSxcXFwiYXdhcmRcXFwiOltcXFwiYWNoaWV2ZW1lbnRcXFwiLFxcXCJiYWRnZVxcXCJdLFxcXCJhcGVydHVyZVxcXCI6W1xcXCJjYW1lcmFcXFwiLFxcXCJwaG90b1xcXCJdLFxcXCJiYXItY2hhcnRcXFwiOltcXFwic3RhdGlzdGljc1xcXCIsXFxcImRpYWdyYW1cXFwiLFxcXCJncmFwaFxcXCJdLFxcXCJiYXItY2hhcnQtMlxcXCI6W1xcXCJzdGF0aXN0aWNzXFxcIixcXFwiZGlhZ3JhbVxcXCIsXFxcImdyYXBoXFxcIl0sXFxcImJhdHRlcnlcXFwiOltcXFwicG93ZXJcXFwiLFxcXCJlbGVjdHJpY2l0eVxcXCJdLFxcXCJiYXR0ZXJ5LWNoYXJnaW5nXFxcIjpbXFxcInBvd2VyXFxcIixcXFwiZWxlY3RyaWNpdHlcXFwiXSxcXFwiYmVsbFxcXCI6W1xcXCJhbGFybVxcXCIsXFxcIm5vdGlmaWNhdGlvblxcXCIsXFxcInNvdW5kXFxcIl0sXFxcImJlbGwtb2ZmXFxcIjpbXFxcImFsYXJtXFxcIixcXFwibm90aWZpY2F0aW9uXFxcIixcXFwic2lsZW50XFxcIl0sXFxcImJsdWV0b290aFxcXCI6W1xcXCJ3aXJlbGVzc1xcXCJdLFxcXCJib29rLW9wZW5cXFwiOltcXFwicmVhZFxcXCIsXFxcImxpYnJhcnlcXFwiXSxcXFwiYm9va1xcXCI6W1xcXCJyZWFkXFxcIixcXFwiZGljdGlvbmFyeVxcXCIsXFxcImJvb2tsZXRcXFwiLFxcXCJtYWdhemluZVxcXCIsXFxcImxpYnJhcnlcXFwiXSxcXFwiYm9va21hcmtcXFwiOltcXFwicmVhZFxcXCIsXFxcImNsaXBcXFwiLFxcXCJtYXJrZXJcXFwiLFxcXCJ0YWdcXFwiXSxcXFwiYm94XFxcIjpbXFxcImN1YmVcXFwiXSxcXFwiYnJpZWZjYXNlXFxcIjpbXFxcIndvcmtcXFwiLFxcXCJiYWdcXFwiLFxcXCJiYWdnYWdlXFxcIixcXFwiZm9sZGVyXFxcIl0sXFxcImNhbGVuZGFyXFxcIjpbXFxcImRhdGVcXFwiXSxcXFwiY2FtZXJhXFxcIjpbXFxcInBob3RvXFxcIl0sXFxcImNhc3RcXFwiOltcXFwiY2hyb21lY2FzdFxcXCIsXFxcImFpcnBsYXlcXFwiXSxcXFwiY2lyY2xlXFxcIjpbXFxcIm9mZlxcXCIsXFxcInplcm9cXFwiLFxcXCJyZWNvcmRcXFwiXSxcXFwiY2xpcGJvYXJkXFxcIjpbXFxcImNvcHlcXFwiXSxcXFwiY2xvY2tcXFwiOltcXFwidGltZVxcXCIsXFxcIndhdGNoXFxcIixcXFwiYWxhcm1cXFwiXSxcXFwiY2xvdWQtZHJpenpsZVxcXCI6W1xcXCJ3ZWF0aGVyXFxcIixcXFwic2hvd2VyXFxcIl0sXFxcImNsb3VkLWxpZ2h0bmluZ1xcXCI6W1xcXCJ3ZWF0aGVyXFxcIixcXFwiYm9sdFxcXCJdLFxcXCJjbG91ZC1yYWluXFxcIjpbXFxcIndlYXRoZXJcXFwiXSxcXFwiY2xvdWQtc25vd1xcXCI6W1xcXCJ3ZWF0aGVyXFxcIixcXFwiYmxpenphcmRcXFwiXSxcXFwiY2xvdWRcXFwiOltcXFwid2VhdGhlclxcXCJdLFxcXCJjb2RlcGVuXFxcIjpbXFxcImxvZ29cXFwiXSxcXFwiY29kZXNhbmRib3hcXFwiOltcXFwibG9nb1xcXCJdLFxcXCJjb2RlXFxcIjpbXFxcInNvdXJjZVxcXCIsXFxcInByb2dyYW1taW5nXFxcIl0sXFxcImNvZmZlZVxcXCI6W1xcXCJkcmlua1xcXCIsXFxcImN1cFxcXCIsXFxcIm11Z1xcXCIsXFxcInRlYVxcXCIsXFxcImNhZmVcXFwiLFxcXCJob3RcXFwiLFxcXCJiZXZlcmFnZVxcXCJdLFxcXCJjb2x1bW5zXFxcIjpbXFxcImxheW91dFxcXCJdLFxcXCJjb21tYW5kXFxcIjpbXFxcImtleWJvYXJkXFxcIixcXFwiY21kXFxcIixcXFwidGVybWluYWxcXFwiLFxcXCJwcm9tcHRcXFwiXSxcXFwiY29tcGFzc1xcXCI6W1xcXCJuYXZpZ2F0aW9uXFxcIixcXFwic2FmYXJpXFxcIixcXFwidHJhdmVsXFxcIixcXFwiZGlyZWN0aW9uXFxcIl0sXFxcImNvcHlcXFwiOltcXFwiY2xvbmVcXFwiLFxcXCJkdXBsaWNhdGVcXFwiXSxcXFwiY29ybmVyLWRvd24tbGVmdFxcXCI6W1xcXCJhcnJvd1xcXCIsXFxcInJldHVyblxcXCJdLFxcXCJjb3JuZXItZG93bi1yaWdodFxcXCI6W1xcXCJhcnJvd1xcXCJdLFxcXCJjb3JuZXItbGVmdC1kb3duXFxcIjpbXFxcImFycm93XFxcIl0sXFxcImNvcm5lci1sZWZ0LXVwXFxcIjpbXFxcImFycm93XFxcIl0sXFxcImNvcm5lci1yaWdodC1kb3duXFxcIjpbXFxcImFycm93XFxcIl0sXFxcImNvcm5lci1yaWdodC11cFxcXCI6W1xcXCJhcnJvd1xcXCJdLFxcXCJjb3JuZXItdXAtbGVmdFxcXCI6W1xcXCJhcnJvd1xcXCJdLFxcXCJjb3JuZXItdXAtcmlnaHRcXFwiOltcXFwiYXJyb3dcXFwiXSxcXFwiY3B1XFxcIjpbXFxcInByb2Nlc3NvclxcXCIsXFxcInRlY2hub2xvZ3lcXFwiXSxcXFwiY3JlZGl0LWNhcmRcXFwiOltcXFwicHVyY2hhc2VcXFwiLFxcXCJwYXltZW50XFxcIixcXFwiY2NcXFwiXSxcXFwiY3JvcFxcXCI6W1xcXCJwaG90b1xcXCIsXFxcImltYWdlXFxcIl0sXFxcImNyb3NzaGFpclxcXCI6W1xcXCJhaW1cXFwiLFxcXCJ0YXJnZXRcXFwiXSxcXFwiZGF0YWJhc2VcXFwiOltcXFwic3RvcmFnZVxcXCIsXFxcIm1lbW9yeVxcXCJdLFxcXCJkZWxldGVcXFwiOltcXFwicmVtb3ZlXFxcIl0sXFxcImRpc2NcXFwiOltcXFwiYWxidW1cXFwiLFxcXCJjZFxcXCIsXFxcImR2ZFxcXCIsXFxcIm11c2ljXFxcIl0sXFxcImRvbGxhci1zaWduXFxcIjpbXFxcImN1cnJlbmN5XFxcIixcXFwibW9uZXlcXFwiLFxcXCJwYXltZW50XFxcIl0sXFxcImRyb3BsZXRcXFwiOltcXFwid2F0ZXJcXFwiXSxcXFwiZWRpdFxcXCI6W1xcXCJwZW5jaWxcXFwiLFxcXCJjaGFuZ2VcXFwiXSxcXFwiZWRpdC0yXFxcIjpbXFxcInBlbmNpbFxcXCIsXFxcImNoYW5nZVxcXCJdLFxcXCJlZGl0LTNcXFwiOltcXFwicGVuY2lsXFxcIixcXFwiY2hhbmdlXFxcIl0sXFxcImV5ZVxcXCI6W1xcXCJ2aWV3XFxcIixcXFwid2F0Y2hcXFwiXSxcXFwiZXllLW9mZlxcXCI6W1xcXCJ2aWV3XFxcIixcXFwid2F0Y2hcXFwiLFxcXCJoaWRlXFxcIixcXFwiaGlkZGVuXFxcIl0sXFxcImV4dGVybmFsLWxpbmtcXFwiOltcXFwib3V0Ym91bmRcXFwiXSxcXFwiZmFjZWJvb2tcXFwiOltcXFwibG9nb1xcXCIsXFxcInNvY2lhbFxcXCJdLFxcXCJmYXN0LWZvcndhcmRcXFwiOltcXFwibXVzaWNcXFwiXSxcXFwiZmlnbWFcXFwiOltcXFwibG9nb1xcXCIsXFxcImRlc2lnblxcXCIsXFxcInRvb2xcXFwiXSxcXFwiZmlsZS1taW51c1xcXCI6W1xcXCJkZWxldGVcXFwiLFxcXCJyZW1vdmVcXFwiLFxcXCJlcmFzZVxcXCJdLFxcXCJmaWxlLXBsdXNcXFwiOltcXFwiYWRkXFxcIixcXFwiY3JlYXRlXFxcIixcXFwibmV3XFxcIl0sXFxcImZpbGUtdGV4dFxcXCI6W1xcXCJkYXRhXFxcIixcXFwidHh0XFxcIixcXFwicGRmXFxcIl0sXFxcImZpbG1cXFwiOltcXFwibW92aWVcXFwiLFxcXCJ2aWRlb1xcXCJdLFxcXCJmaWx0ZXJcXFwiOltcXFwiZnVubmVsXFxcIixcXFwiaG9wcGVyXFxcIl0sXFxcImZsYWdcXFwiOltcXFwicmVwb3J0XFxcIl0sXFxcImZvbGRlci1taW51c1xcXCI6W1xcXCJkaXJlY3RvcnlcXFwiXSxcXFwiZm9sZGVyLXBsdXNcXFwiOltcXFwiZGlyZWN0b3J5XFxcIl0sXFxcImZvbGRlclxcXCI6W1xcXCJkaXJlY3RvcnlcXFwiXSxcXFwiZnJhbWVyXFxcIjpbXFxcImxvZ29cXFwiLFxcXCJkZXNpZ25cXFwiLFxcXCJ0b29sXFxcIl0sXFxcImZyb3duXFxcIjpbXFxcImVtb2ppXFxcIixcXFwiZmFjZVxcXCIsXFxcImJhZFxcXCIsXFxcInNhZFxcXCIsXFxcImVtb3Rpb25cXFwiXSxcXFwiZ2lmdFxcXCI6W1xcXCJwcmVzZW50XFxcIixcXFwiYm94XFxcIixcXFwiYmlydGhkYXlcXFwiLFxcXCJwYXJ0eVxcXCJdLFxcXCJnaXQtYnJhbmNoXFxcIjpbXFxcImNvZGVcXFwiLFxcXCJ2ZXJzaW9uIGNvbnRyb2xcXFwiXSxcXFwiZ2l0LWNvbW1pdFxcXCI6W1xcXCJjb2RlXFxcIixcXFwidmVyc2lvbiBjb250cm9sXFxcIl0sXFxcImdpdC1tZXJnZVxcXCI6W1xcXCJjb2RlXFxcIixcXFwidmVyc2lvbiBjb250cm9sXFxcIl0sXFxcImdpdC1wdWxsLXJlcXVlc3RcXFwiOltcXFwiY29kZVxcXCIsXFxcInZlcnNpb24gY29udHJvbFxcXCJdLFxcXCJnaXRodWJcXFwiOltcXFwibG9nb1xcXCIsXFxcInZlcnNpb24gY29udHJvbFxcXCJdLFxcXCJnaXRsYWJcXFwiOltcXFwibG9nb1xcXCIsXFxcInZlcnNpb24gY29udHJvbFxcXCJdLFxcXCJnbG9iZVxcXCI6W1xcXCJ3b3JsZFxcXCIsXFxcImJyb3dzZXJcXFwiLFxcXCJsYW5ndWFnZVxcXCIsXFxcInRyYW5zbGF0ZVxcXCJdLFxcXCJoYXJkLWRyaXZlXFxcIjpbXFxcImNvbXB1dGVyXFxcIixcXFwic2VydmVyXFxcIixcXFwibWVtb3J5XFxcIixcXFwiZGF0YVxcXCJdLFxcXCJoYXNoXFxcIjpbXFxcImhhc2h0YWdcXFwiLFxcXCJudW1iZXJcXFwiLFxcXCJwb3VuZFxcXCJdLFxcXCJoZWFkcGhvbmVzXFxcIjpbXFxcIm11c2ljXFxcIixcXFwiYXVkaW9cXFwiLFxcXCJzb3VuZFxcXCJdLFxcXCJoZWFydFxcXCI6W1xcXCJsaWtlXFxcIixcXFwibG92ZVxcXCIsXFxcImVtb3Rpb25cXFwiXSxcXFwiaGVscC1jaXJjbGVcXFwiOltcXFwicXVlc3Rpb24gbWFya1xcXCJdLFxcXCJoZXhhZ29uXFxcIjpbXFxcInNoYXBlXFxcIixcXFwibm9kZS5qc1xcXCIsXFxcImxvZ29cXFwiXSxcXFwiaG9tZVxcXCI6W1xcXCJob3VzZVxcXCIsXFxcImxpdmluZ1xcXCJdLFxcXCJpbWFnZVxcXCI6W1xcXCJwaWN0dXJlXFxcIl0sXFxcImluYm94XFxcIjpbXFxcImVtYWlsXFxcIl0sXFxcImluc3RhZ3JhbVxcXCI6W1xcXCJsb2dvXFxcIixcXFwiY2FtZXJhXFxcIl0sXFxcImtleVxcXCI6W1xcXCJwYXNzd29yZFxcXCIsXFxcImxvZ2luXFxcIixcXFwiYXV0aGVudGljYXRpb25cXFwiLFxcXCJzZWN1cmVcXFwiXSxcXFwibGF5ZXJzXFxcIjpbXFxcInN0YWNrXFxcIl0sXFxcImxheW91dFxcXCI6W1xcXCJ3aW5kb3dcXFwiLFxcXCJ3ZWJwYWdlXFxcIl0sXFxcImxpZmUtYm91eVxcXCI6W1xcXCJoZWxwXFxcIixcXFwibGlmZSByaW5nXFxcIixcXFwic3VwcG9ydFxcXCJdLFxcXCJsaW5rXFxcIjpbXFxcImNoYWluXFxcIixcXFwidXJsXFxcIl0sXFxcImxpbmstMlxcXCI6W1xcXCJjaGFpblxcXCIsXFxcInVybFxcXCJdLFxcXCJsaW5rZWRpblxcXCI6W1xcXCJsb2dvXFxcIixcXFwic29jaWFsIG1lZGlhXFxcIl0sXFxcImxpc3RcXFwiOltcXFwib3B0aW9uc1xcXCJdLFxcXCJsb2NrXFxcIjpbXFxcInNlY3VyaXR5XFxcIixcXFwicGFzc3dvcmRcXFwiLFxcXCJzZWN1cmVcXFwiXSxcXFwibG9nLWluXFxcIjpbXFxcInNpZ24gaW5cXFwiLFxcXCJhcnJvd1xcXCIsXFxcImVudGVyXFxcIl0sXFxcImxvZy1vdXRcXFwiOltcXFwic2lnbiBvdXRcXFwiLFxcXCJhcnJvd1xcXCIsXFxcImV4aXRcXFwiXSxcXFwibWFpbFxcXCI6W1xcXCJlbWFpbFxcXCIsXFxcIm1lc3NhZ2VcXFwiXSxcXFwibWFwLXBpblxcXCI6W1xcXCJsb2NhdGlvblxcXCIsXFxcIm5hdmlnYXRpb25cXFwiLFxcXCJ0cmF2ZWxcXFwiLFxcXCJtYXJrZXJcXFwiXSxcXFwibWFwXFxcIjpbXFxcImxvY2F0aW9uXFxcIixcXFwibmF2aWdhdGlvblxcXCIsXFxcInRyYXZlbFxcXCJdLFxcXCJtYXhpbWl6ZVxcXCI6W1xcXCJmdWxsc2NyZWVuXFxcIl0sXFxcIm1heGltaXplLTJcXFwiOltcXFwiZnVsbHNjcmVlblxcXCIsXFxcImFycm93c1xcXCIsXFxcImV4cGFuZFxcXCJdLFxcXCJtZWhcXFwiOltcXFwiZW1vamlcXFwiLFxcXCJmYWNlXFxcIixcXFwibmV1dHJhbFxcXCIsXFxcImVtb3Rpb25cXFwiXSxcXFwibWVudVxcXCI6W1xcXCJiYXJzXFxcIixcXFwibmF2aWdhdGlvblxcXCIsXFxcImhhbWJ1cmdlclxcXCJdLFxcXCJtZXNzYWdlLWNpcmNsZVxcXCI6W1xcXCJjb21tZW50XFxcIixcXFwiY2hhdFxcXCJdLFxcXCJtZXNzYWdlLXNxdWFyZVxcXCI6W1xcXCJjb21tZW50XFxcIixcXFwiY2hhdFxcXCJdLFxcXCJtaWMtb2ZmXFxcIjpbXFxcInJlY29yZFxcXCIsXFxcInNvdW5kXFxcIixcXFwibXV0ZVxcXCJdLFxcXCJtaWNcXFwiOltcXFwicmVjb3JkXFxcIixcXFwic291bmRcXFwiLFxcXCJsaXN0ZW5cXFwiXSxcXFwibWluaW1pemVcXFwiOltcXFwiZXhpdCBmdWxsc2NyZWVuXFxcIixcXFwiY2xvc2VcXFwiXSxcXFwibWluaW1pemUtMlxcXCI6W1xcXCJleGl0IGZ1bGxzY3JlZW5cXFwiLFxcXCJhcnJvd3NcXFwiLFxcXCJjbG9zZVxcXCJdLFxcXCJtaW51c1xcXCI6W1xcXCJzdWJ0cmFjdFxcXCJdLFxcXCJtb25pdG9yXFxcIjpbXFxcInR2XFxcIixcXFwic2NyZWVuXFxcIixcXFwiZGlzcGxheVxcXCJdLFxcXCJtb29uXFxcIjpbXFxcImRhcmtcXFwiLFxcXCJuaWdodFxcXCJdLFxcXCJtb3JlLWhvcml6b250YWxcXFwiOltcXFwiZWxsaXBzaXNcXFwiXSxcXFwibW9yZS12ZXJ0aWNhbFxcXCI6W1xcXCJlbGxpcHNpc1xcXCJdLFxcXCJtb3VzZS1wb2ludGVyXFxcIjpbXFxcImFycm93XFxcIixcXFwiY3Vyc29yXFxcIl0sXFxcIm1vdmVcXFwiOltcXFwiYXJyb3dzXFxcIl0sXFxcIm11c2ljXFxcIjpbXFxcIm5vdGVcXFwiXSxcXFwibmF2aWdhdGlvblxcXCI6W1xcXCJsb2NhdGlvblxcXCIsXFxcInRyYXZlbFxcXCJdLFxcXCJuYXZpZ2F0aW9uLTJcXFwiOltcXFwibG9jYXRpb25cXFwiLFxcXCJ0cmF2ZWxcXFwiXSxcXFwib2N0YWdvblxcXCI6W1xcXCJzdG9wXFxcIl0sXFxcInBhY2thZ2VcXFwiOltcXFwiYm94XFxcIixcXFwiY29udGFpbmVyXFxcIl0sXFxcInBhcGVyY2xpcFxcXCI6W1xcXCJhdHRhY2htZW50XFxcIl0sXFxcInBhdXNlXFxcIjpbXFxcIm11c2ljXFxcIixcXFwic3RvcFxcXCJdLFxcXCJwYXVzZS1jaXJjbGVcXFwiOltcXFwibXVzaWNcXFwiLFxcXCJhdWRpb1xcXCIsXFxcInN0b3BcXFwiXSxcXFwicGVuLXRvb2xcXFwiOltcXFwidmVjdG9yXFxcIixcXFwiZHJhd2luZ1xcXCJdLFxcXCJwZXJjZW50XFxcIjpbXFxcImRpc2NvdW50XFxcIl0sXFxcInBob25lLWNhbGxcXFwiOltcXFwicmluZ1xcXCJdLFxcXCJwaG9uZS1mb3J3YXJkZWRcXFwiOltcXFwiY2FsbFxcXCJdLFxcXCJwaG9uZS1pbmNvbWluZ1xcXCI6W1xcXCJjYWxsXFxcIl0sXFxcInBob25lLW1pc3NlZFxcXCI6W1xcXCJjYWxsXFxcIl0sXFxcInBob25lLW9mZlxcXCI6W1xcXCJjYWxsXFxcIixcXFwibXV0ZVxcXCJdLFxcXCJwaG9uZS1vdXRnb2luZ1xcXCI6W1xcXCJjYWxsXFxcIl0sXFxcInBob25lXFxcIjpbXFxcImNhbGxcXFwiXSxcXFwicGxheVxcXCI6W1xcXCJtdXNpY1xcXCIsXFxcInN0YXJ0XFxcIl0sXFxcInBpZS1jaGFydFxcXCI6W1xcXCJzdGF0aXN0aWNzXFxcIixcXFwiZGlhZ3JhbVxcXCJdLFxcXCJwbGF5LWNpcmNsZVxcXCI6W1xcXCJtdXNpY1xcXCIsXFxcInN0YXJ0XFxcIl0sXFxcInBsdXNcXFwiOltcXFwiYWRkXFxcIixcXFwibmV3XFxcIl0sXFxcInBsdXMtY2lyY2xlXFxcIjpbXFxcImFkZFxcXCIsXFxcIm5ld1xcXCJdLFxcXCJwbHVzLXNxdWFyZVxcXCI6W1xcXCJhZGRcXFwiLFxcXCJuZXdcXFwiXSxcXFwicG9ja2V0XFxcIjpbXFxcImxvZ29cXFwiLFxcXCJzYXZlXFxcIl0sXFxcInBvd2VyXFxcIjpbXFxcIm9uXFxcIixcXFwib2ZmXFxcIl0sXFxcInByaW50ZXJcXFwiOltcXFwiZmF4XFxcIixcXFwib2ZmaWNlXFxcIixcXFwiZGV2aWNlXFxcIl0sXFxcInJhZGlvXFxcIjpbXFxcInNpZ25hbFxcXCJdLFxcXCJyZWZyZXNoLWN3XFxcIjpbXFxcInN5bmNocm9uaXNlXFxcIixcXFwiYXJyb3dzXFxcIl0sXFxcInJlZnJlc2gtY2N3XFxcIjpbXFxcImFycm93c1xcXCJdLFxcXCJyZXBlYXRcXFwiOltcXFwibG9vcFxcXCIsXFxcImFycm93c1xcXCJdLFxcXCJyZXdpbmRcXFwiOltcXFwibXVzaWNcXFwiXSxcXFwicm90YXRlLWNjd1xcXCI6W1xcXCJhcnJvd1xcXCJdLFxcXCJyb3RhdGUtY3dcXFwiOltcXFwiYXJyb3dcXFwiXSxcXFwicnNzXFxcIjpbXFxcImZlZWRcXFwiLFxcXCJzdWJzY3JpYmVcXFwiXSxcXFwic2F2ZVxcXCI6W1xcXCJmbG9wcHkgZGlza1xcXCJdLFxcXCJzY2lzc29yc1xcXCI6W1xcXCJjdXRcXFwiXSxcXFwic2VhcmNoXFxcIjpbXFxcImZpbmRcXFwiLFxcXCJtYWduaWZpZXJcXFwiLFxcXCJtYWduaWZ5aW5nIGdsYXNzXFxcIl0sXFxcInNlbmRcXFwiOltcXFwibWVzc2FnZVxcXCIsXFxcIm1haWxcXFwiLFxcXCJlbWFpbFxcXCIsXFxcInBhcGVyIGFpcnBsYW5lXFxcIixcXFwicGFwZXIgYWVyb3BsYW5lXFxcIl0sXFxcInNldHRpbmdzXFxcIjpbXFxcImNvZ1xcXCIsXFxcImVkaXRcXFwiLFxcXCJnZWFyXFxcIixcXFwicHJlZmVyZW5jZXNcXFwiXSxcXFwic2hhcmUtMlxcXCI6W1xcXCJuZXR3b3JrXFxcIixcXFwiY29ubmVjdGlvbnNcXFwiXSxcXFwic2hpZWxkXFxcIjpbXFxcInNlY3VyaXR5XFxcIixcXFwic2VjdXJlXFxcIl0sXFxcInNoaWVsZC1vZmZcXFwiOltcXFwic2VjdXJpdHlcXFwiLFxcXCJpbnNlY3VyZVxcXCJdLFxcXCJzaG9wcGluZy1iYWdcXFwiOltcXFwiZWNvbW1lcmNlXFxcIixcXFwiY2FydFxcXCIsXFxcInB1cmNoYXNlXFxcIixcXFwic3RvcmVcXFwiXSxcXFwic2hvcHBpbmctY2FydFxcXCI6W1xcXCJlY29tbWVyY2VcXFwiLFxcXCJjYXJ0XFxcIixcXFwicHVyY2hhc2VcXFwiLFxcXCJzdG9yZVxcXCJdLFxcXCJzaHVmZmxlXFxcIjpbXFxcIm11c2ljXFxcIl0sXFxcInNraXAtYmFja1xcXCI6W1xcXCJtdXNpY1xcXCJdLFxcXCJza2lwLWZvcndhcmRcXFwiOltcXFwibXVzaWNcXFwiXSxcXFwic2xhY2tcXFwiOltcXFwibG9nb1xcXCJdLFxcXCJzbGFzaFxcXCI6W1xcXCJiYW5cXFwiLFxcXCJub1xcXCJdLFxcXCJzbGlkZXJzXFxcIjpbXFxcInNldHRpbmdzXFxcIixcXFwiY29udHJvbHNcXFwiXSxcXFwic21hcnRwaG9uZVxcXCI6W1xcXCJjZWxscGhvbmVcXFwiLFxcXCJkZXZpY2VcXFwiXSxcXFwic21pbGVcXFwiOltcXFwiZW1vamlcXFwiLFxcXCJmYWNlXFxcIixcXFwiaGFwcHlcXFwiLFxcXCJnb29kXFxcIixcXFwiZW1vdGlvblxcXCJdLFxcXCJzcGVha2VyXFxcIjpbXFxcImF1ZGlvXFxcIixcXFwibXVzaWNcXFwiXSxcXFwic3RhclxcXCI6W1xcXCJib29rbWFya1xcXCIsXFxcImZhdm9yaXRlXFxcIixcXFwibGlrZVxcXCJdLFxcXCJzdG9wLWNpcmNsZVxcXCI6W1xcXCJtZWRpYVxcXCIsXFxcIm11c2ljXFxcIl0sXFxcInN1blxcXCI6W1xcXCJicmlnaHRuZXNzXFxcIixcXFwid2VhdGhlclxcXCIsXFxcImxpZ2h0XFxcIl0sXFxcInN1bnJpc2VcXFwiOltcXFwid2VhdGhlclxcXCIsXFxcInRpbWVcXFwiLFxcXCJtb3JuaW5nXFxcIixcXFwiZGF5XFxcIl0sXFxcInN1bnNldFxcXCI6W1xcXCJ3ZWF0aGVyXFxcIixcXFwidGltZVxcXCIsXFxcImV2ZW5pbmdcXFwiLFxcXCJuaWdodFxcXCJdLFxcXCJ0YWJsZXRcXFwiOltcXFwiZGV2aWNlXFxcIl0sXFxcInRhZ1xcXCI6W1xcXCJsYWJlbFxcXCJdLFxcXCJ0YXJnZXRcXFwiOltcXFwibG9nb1xcXCIsXFxcImJ1bGxzZXllXFxcIl0sXFxcInRlcm1pbmFsXFxcIjpbXFxcImNvZGVcXFwiLFxcXCJjb21tYW5kIGxpbmVcXFwiLFxcXCJwcm9tcHRcXFwiXSxcXFwidGhlcm1vbWV0ZXJcXFwiOltcXFwidGVtcGVyYXR1cmVcXFwiLFxcXCJjZWxzaXVzXFxcIixcXFwiZmFocmVuaGVpdFxcXCIsXFxcIndlYXRoZXJcXFwiXSxcXFwidGh1bWJzLWRvd25cXFwiOltcXFwiZGlzbGlrZVxcXCIsXFxcImJhZFxcXCIsXFxcImVtb3Rpb25cXFwiXSxcXFwidGh1bWJzLXVwXFxcIjpbXFxcImxpa2VcXFwiLFxcXCJnb29kXFxcIixcXFwiZW1vdGlvblxcXCJdLFxcXCJ0b2dnbGUtbGVmdFxcXCI6W1xcXCJvblxcXCIsXFxcIm9mZlxcXCIsXFxcInN3aXRjaFxcXCJdLFxcXCJ0b2dnbGUtcmlnaHRcXFwiOltcXFwib25cXFwiLFxcXCJvZmZcXFwiLFxcXCJzd2l0Y2hcXFwiXSxcXFwidG9vbFxcXCI6W1xcXCJzZXR0aW5nc1xcXCIsXFxcInNwYW5uZXJcXFwiXSxcXFwidHJhc2hcXFwiOltcXFwiZ2FyYmFnZVxcXCIsXFxcImRlbGV0ZVxcXCIsXFxcInJlbW92ZVxcXCIsXFxcImJpblxcXCJdLFxcXCJ0cmFzaC0yXFxcIjpbXFxcImdhcmJhZ2VcXFwiLFxcXCJkZWxldGVcXFwiLFxcXCJyZW1vdmVcXFwiLFxcXCJiaW5cXFwiXSxcXFwidHJpYW5nbGVcXFwiOltcXFwiZGVsdGFcXFwiXSxcXFwidHJ1Y2tcXFwiOltcXFwiZGVsaXZlcnlcXFwiLFxcXCJ2YW5cXFwiLFxcXCJzaGlwcGluZ1xcXCIsXFxcInRyYW5zcG9ydFxcXCIsXFxcImxvcnJ5XFxcIl0sXFxcInR2XFxcIjpbXFxcInRlbGV2aXNpb25cXFwiLFxcXCJzdHJlYW1cXFwiXSxcXFwidHdpdGNoXFxcIjpbXFxcImxvZ29cXFwiXSxcXFwidHdpdHRlclxcXCI6W1xcXCJsb2dvXFxcIixcXFwic29jaWFsXFxcIl0sXFxcInR5cGVcXFwiOltcXFwidGV4dFxcXCJdLFxcXCJ1bWJyZWxsYVxcXCI6W1xcXCJyYWluXFxcIixcXFwid2VhdGhlclxcXCJdLFxcXCJ1bmxvY2tcXFwiOltcXFwic2VjdXJpdHlcXFwiXSxcXFwidXNlci1jaGVja1xcXCI6W1xcXCJmb2xsb3dlZFxcXCIsXFxcInN1YnNjcmliZWRcXFwiXSxcXFwidXNlci1taW51c1xcXCI6W1xcXCJkZWxldGVcXFwiLFxcXCJyZW1vdmVcXFwiLFxcXCJ1bmZvbGxvd1xcXCIsXFxcInVuc3Vic2NyaWJlXFxcIl0sXFxcInVzZXItcGx1c1xcXCI6W1xcXCJuZXdcXFwiLFxcXCJhZGRcXFwiLFxcXCJjcmVhdGVcXFwiLFxcXCJmb2xsb3dcXFwiLFxcXCJzdWJzY3JpYmVcXFwiXSxcXFwidXNlci14XFxcIjpbXFxcImRlbGV0ZVxcXCIsXFxcInJlbW92ZVxcXCIsXFxcInVuZm9sbG93XFxcIixcXFwidW5zdWJzY3JpYmVcXFwiLFxcXCJ1bmF2YWlsYWJsZVxcXCJdLFxcXCJ1c2VyXFxcIjpbXFxcInBlcnNvblxcXCIsXFxcImFjY291bnRcXFwiXSxcXFwidXNlcnNcXFwiOltcXFwiZ3JvdXBcXFwiXSxcXFwidmlkZW8tb2ZmXFxcIjpbXFxcImNhbWVyYVxcXCIsXFxcIm1vdmllXFxcIixcXFwiZmlsbVxcXCJdLFxcXCJ2aWRlb1xcXCI6W1xcXCJjYW1lcmFcXFwiLFxcXCJtb3ZpZVxcXCIsXFxcImZpbG1cXFwiXSxcXFwidm9pY2VtYWlsXFxcIjpbXFxcInBob25lXFxcIl0sXFxcInZvbHVtZVxcXCI6W1xcXCJtdXNpY1xcXCIsXFxcInNvdW5kXFxcIixcXFwibXV0ZVxcXCJdLFxcXCJ2b2x1bWUtMVxcXCI6W1xcXCJtdXNpY1xcXCIsXFxcInNvdW5kXFxcIl0sXFxcInZvbHVtZS0yXFxcIjpbXFxcIm11c2ljXFxcIixcXFwic291bmRcXFwiXSxcXFwidm9sdW1lLXhcXFwiOltcXFwibXVzaWNcXFwiLFxcXCJzb3VuZFxcXCIsXFxcIm11dGVcXFwiXSxcXFwid2F0Y2hcXFwiOltcXFwiY2xvY2tcXFwiLFxcXCJ0aW1lXFxcIl0sXFxcIndpZmktb2ZmXFxcIjpbXFxcImRpc2FibGVkXFxcIl0sXFxcIndpZmlcXFwiOltcXFwiY29ubmVjdGlvblxcXCIsXFxcInNpZ25hbFxcXCIsXFxcIndpcmVsZXNzXFxcIl0sXFxcIndpbmRcXFwiOltcXFwid2VhdGhlclxcXCIsXFxcImFpclxcXCJdLFxcXCJ4LWNpcmNsZVxcXCI6W1xcXCJjYW5jZWxcXFwiLFxcXCJjbG9zZVxcXCIsXFxcImRlbGV0ZVxcXCIsXFxcInJlbW92ZVxcXCIsXFxcInRpbWVzXFxcIixcXFwiY2xlYXJcXFwiXSxcXFwieC1vY3RhZ29uXFxcIjpbXFxcImRlbGV0ZVxcXCIsXFxcInN0b3BcXFwiLFxcXCJhbGVydFxcXCIsXFxcIndhcm5pbmdcXFwiLFxcXCJ0aW1lc1xcXCIsXFxcImNsZWFyXFxcIl0sXFxcIngtc3F1YXJlXFxcIjpbXFxcImNhbmNlbFxcXCIsXFxcImNsb3NlXFxcIixcXFwiZGVsZXRlXFxcIixcXFwicmVtb3ZlXFxcIixcXFwidGltZXNcXFwiLFxcXCJjbGVhclxcXCJdLFxcXCJ4XFxcIjpbXFxcImNhbmNlbFxcXCIsXFxcImNsb3NlXFxcIixcXFwiZGVsZXRlXFxcIixcXFwicmVtb3ZlXFxcIixcXFwidGltZXNcXFwiLFxcXCJjbGVhclxcXCJdLFxcXCJ5b3V0dWJlXFxcIjpbXFxcImxvZ29cXFwiLFxcXCJ2aWRlb1xcXCIsXFxcInBsYXlcXFwiXSxcXFwiemFwLW9mZlxcXCI6W1xcXCJmbGFzaFxcXCIsXFxcImNhbWVyYVxcXCIsXFxcImxpZ2h0bmluZ1xcXCJdLFxcXCJ6YXBcXFwiOltcXFwiZmxhc2hcXFwiLFxcXCJjYW1lcmFcXFwiLFxcXCJsaWdodG5pbmdcXFwiXSxcXFwiem9vbS1pblxcXCI6W1xcXCJtYWduaWZ5aW5nIGdsYXNzXFxcIl0sXFxcInpvb20tb3V0XFxcIjpbXFxcIm1hZ25pZnlpbmcgZ2xhc3NcXFwiXX07XFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vc3JjL3RvLXN2Zy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9zcmMvdG8tc3ZnLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF9pY29ucyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaWNvbnMgKi8gXFxcIi4vc3JjL2ljb25zLmpzXFxcIik7XFxuXFxudmFyIF9pY29uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pY29ucyk7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG4vKipcXG4gKiBDcmVhdGUgYW4gU1ZHIHN0cmluZy5cXG4gKiBAZGVwcmVjYXRlZFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJzXFxuICogQHJldHVybnMge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiB0b1N2ZyhuYW1lKSB7XFxuICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xcblxcbiAgY29uc29sZS53YXJuKCdmZWF0aGVyLnRvU3ZnKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBmZWF0aGVyLmljb25zW25hbWVdLnRvU3ZnKCkgaW5zdGVhZC4nKTtcXG5cXG4gIGlmICghbmFtZSkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXF1aXJlZCBga2V5YCAoaWNvbiBuYW1lKSBwYXJhbWV0ZXIgaXMgbWlzc2luZy4nKTtcXG4gIH1cXG5cXG4gIGlmICghX2ljb25zMi5kZWZhdWx0W25hbWVdKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignTm8gaWNvbiBtYXRjaGluZyBcXFxcJycgKyBuYW1lICsgJ1xcXFwnLiBTZWUgdGhlIGNvbXBsZXRlIGxpc3Qgb2YgaWNvbnMgYXQgaHR0cHM6Ly9mZWF0aGVyaWNvbnMuY29tJyk7XFxuICB9XFxuXFxuICByZXR1cm4gX2ljb25zMi5kZWZhdWx0W25hbWVdLnRvU3ZnKGF0dHJzKTtcXG59XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gdG9Tdmc7XFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMDpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiBtdWx0aSBjb3JlLWpzL2VzL2FycmF5L2Zyb20gLi9zcmMvaW5kZXguanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL2VzL2FycmF5L2Zyb20gKi9cXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9hcnJheS9mcm9tLmpzXFxcIik7XFxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAvaG9tZS90cmF2aXMvYnVpbGQvZmVhdGhlcmljb25zL2ZlYXRoZXIvc3JjL2luZGV4LmpzICovXFxcIi4vc3JjL2luZGV4LmpzXFxcIik7XFxuXFxuXFxuLyoqKi8gfSlcXG5cXG4vKioqKioqLyB9KTtcXG59KTtcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZWF0aGVyLmpzLm1hcFxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3QvZmVhdGhlci5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vc3JjL2pzL2FwcC5qc1wiOlxuICAvKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAhKioqIC4vc3JjL2pzL2FwcC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKiEgbm8gZXhwb3J0cyBwcm92aWRlZCAqL1xuXG4gIC8qKiovXG4gIGZ1bmN0aW9uIHNyY0pzQXBwSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kdWxlc19ib290c3RyYXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kdWxlcy9ib290c3RyYXAgKi8gXFxcIi4vc3JjL2pzL21vZHVsZXMvYm9vdHN0cmFwLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2R1bGVzX2ZlYXRoZXJfaWNvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kdWxlcy9mZWF0aGVyLWljb25zICovIFxcXCIuL3NyYy9qcy9tb2R1bGVzL2ZlYXRoZXItaWNvbnMuanNcXFwiKTtcXG4vKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogIFJFUVVJUkVEU1xcbiAqIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXFxuICovXFxuXFxuXFxuXFxuLypcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqICBSRUFEWVxcbiAqIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXFxuICovXFxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcXG5cXG4gIGNvbnNvbGUubG9nKCdBUFAgUkVBRFkhJyk7XFxuXFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL2FwcC5qcz9cIik7XG4gICAgLyoqKi9cbiAgfSxcblxuICAvKioqL1xuICBcIi4vc3JjL2pzL21vZHVsZXMvYm9vdHN0cmFwLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgISoqKiAuL3NyYy9qcy9tb2R1bGVzL2Jvb3RzdHJhcC5qcyAqKiohXG4gICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBubyBleHBvcnRzIHByb3ZpZGVkICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gc3JjSnNNb2R1bGVzQm9vdHN0cmFwSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBib290c3RyYXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGJvb3RzdHJhcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmVzbS5qc1xcXCIpO1xcbi8qXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiAgUkVRVUlSRURcXG4gKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxcbiAqL1xcblxcblxcbi8qXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiAgR0xPQkFMXFxuICogLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cXG4gKiAgTm90ZTogSWYgeW91IHdhbnQgdG8gbWFrZSBib290c3RyYXAgZ2xvYmFsbHkgYXZhaWxhYmxlLCBlLmcuIGZvciB1c2luZyBgYm9vdHN0cmFwLm1vZGFsYFxcbiAqIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXFxuICovXFxud2luZG93LmJvb3RzdHJhcCA9IGJvb3RzdHJhcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fO1xcblxcbi8qXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiAgUE9QT1ZFUlNcXG4gKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxcbiAqICBOb3RlOiBEaXNhYmxlIHRoaXMgaWYgeW91J3JlIG5vdCB1c2luZyBCb290c3RyYXAncyBQb3BvdmVyc1xcbiAqIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXFxuICovXFxuY29uc3QgcG9wb3ZlclRyaWdnZXJMaXN0ID0gW11cXG4gIC5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWJzLXRvZ2dsZT1cXFwicG9wb3ZlclxcXCJdJykpO1xcbnBvcG92ZXJUcmlnZ2VyTGlzdC5tYXAoKHBvcG92ZXJUcmlnZ2VyRWwpID0+IHtcXG4gIHJldHVybiBuZXcgYm9vdHN0cmFwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIlBvcG92ZXJcXFwiXShwb3BvdmVyVHJpZ2dlckVsKTtcXG59KTtcXG5cXG4vKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogIFRPT0xUSVBTXFxuICogLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cXG4gKiAgTm90ZTogRGlzYWJsZSB0aGlzIGlmIHlvdSdyZSBub3QgdXNpbmcgQm9vdHN0cmFwJ3MgVG9vbHRpcHNcXG4gKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxcbiAqL1xcbmNvbnN0IHRvb2x0aXBUcmlnZ2VyTGlzdCA9IFtdLnNsaWNlXFxuICAuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1icy10b2dnbGU9XFxcInRvb2x0aXBcXFwiXScpKTtcXG50b29sdGlwVHJpZ2dlckxpc3QubWFwKCh0b29sdGlwVHJpZ2dlckVsKSA9PiB7XFxuICByZXR1cm4gbmV3IGJvb3RzdHJhcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJUb29sdGlwXFxcIl0odG9vbHRpcFRyaWdnZXJFbCk7XFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL21vZHVsZXMvYm9vdHN0cmFwLmpzP1wiKTtcbiAgICAvKioqL1xuICB9LFxuXG4gIC8qKiovXG4gIFwiLi9zcmMvanMvbW9kdWxlcy9mZWF0aGVyLWljb25zLmpzXCI6XG4gIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICEqKiogLi9zcmMvanMvbW9kdWxlcy9mZWF0aGVyLWljb25zLmpzICoqKiFcbiAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qISBubyBleHBvcnRzIHByb3ZpZGVkICovXG5cbiAgLyoqKi9cbiAgZnVuY3Rpb24gc3JjSnNNb2R1bGVzRmVhdGhlckljb25zSnMobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBmZWF0aGVyX2ljb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmZWF0aGVyLWljb25zICovIFxcXCIuL25vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3QvZmVhdGhlci5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBmZWF0aGVyX2ljb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oZmVhdGhlcl9pY29uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcXG4vKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogIFJFUVVJUkVEXFxuICogLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cXG4gKi9cXG5cXG53aW5kb3cuZmVhdGhlciA9IGZlYXRoZXJfaWNvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmE7XFxuXFxuLypcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqICBJTklUXFxuICogLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cXG4gKi9cXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xcbiAgZmVhdGhlcl9pY29uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5yZXBsYWNlKCk7XFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL21vZHVsZXMvZmVhdGhlci1pY29ucy5qcz9cIik7XG4gICAgLyoqKi9cbiAgfVxuICAvKioqKioqL1xuXG59KTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsImQiLCJuYW1lIiwiZ2V0dGVyIiwibyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsInIiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwidCIsIm1vZGUiLCJfX2VzTW9kdWxlIiwibnMiLCJjcmVhdGUiLCJrZXkiLCJiaW5kIiwibiIsIm9iamVjdCIsInByb3BlcnR5IiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9jcmVhdGVQb3BwZXIuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJDcmVhdGVQb3BwZXJKcyIsIl9fd2VicGFja19leHBvcnRzX18iLCJldmFsIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzQ29udGFpbnNKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRCb3VuZGluZ0NsaWVudFJlY3RKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRDbGlwcGluZ1JlY3RKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0Q29tcG9zaXRlUmVjdEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRDb21wdXRlZFN0eWxlSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0RG9jdW1lbnRFbGVtZW50SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0RG9jdW1lbnRSZWN0SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRIVE1MRWxlbWVudFNjcm9sbEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRMYXlvdXRSZWN0SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXROb2RlTmFtZUpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXROb2RlU2Nyb2xsSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0T2Zmc2V0UGFyZW50SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldFBhcmVudE5vZGVKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0U2Nyb2xsUGFyZW50LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRTY3JvbGxQYXJlbnRKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRWaWV3cG9ydFJlY3RKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRXaW5kb3dKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRXaW5kb3dTY3JvbGxKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0V2luZG93U2Nyb2xsQmFyWEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNJbnN0YW5jZU9mSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNJc1Njcm9sbFBhcmVudEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzSXNUYWJsZUVsZW1lbnRKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0xpc3RTY3JvbGxQYXJlbnRzSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJFbnVtc0pzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliSW5kZXhKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJNb2RpZmllcnNBcHBseVN0eWxlc0pzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYk1vZGlmaWVyc0Fycm93SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJNb2RpZmllcnNDb21wdXRlU3R5bGVzSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzRXZlbnRMaXN0ZW5lcnNKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZmxpcC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYk1vZGlmaWVyc0ZsaXBKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYk1vZGlmaWVyc0hpZGVKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaW5kZXguanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJNb2RpZmllcnNJbmRleEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJNb2RpZmllcnNPZmZzZXRKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYk1vZGlmaWVyc1BvcHBlck9mZnNldHNKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzUHJldmVudE92ZXJmbG93SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLWxpdGUuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJQb3BwZXJMaXRlSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliUG9wcGVySnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0NvbXB1dGVBdXRvUGxhY2VtZW50SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0NvbXB1dGVPZmZzZXRzSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0RlYm91bmNlSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0RldGVjdE92ZXJmbG93SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNFeHBhbmRUb0hhc2hNYXBKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9mb3JtYXQuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0Zvcm1hdEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0dldEFsdEF4aXNKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNHZXRCYXNlUGxhY2VtZW50SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNHZXRGcmVzaFNpZGVPYmplY3RKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0dldE1haW5BeGlzRnJvbVBsYWNlbWVudEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNHZXRPcHBvc2l0ZVBsYWNlbWVudEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNHZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzR2V0VmFyaWF0aW9uSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzTWF0aEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlQnlOYW1lLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNNZXJnZUJ5TmFtZUpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzTWVyZ2VQYWRkaW5nT2JqZWN0SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvb3JkZXJNb2RpZmllcnMuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc09yZGVyTW9kaWZpZXJzSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzUmVjdFRvQ2xpZW50UmVjdEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3VuaXF1ZUJ5LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNVbmlxdWVCeUpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNWYWxpZGF0ZU1vZGlmaWVyc0pzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzV2l0aGluSnMiLCIuL25vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuZXNtLmpzIiwibm9kZV9tb2R1bGVzQm9vdHN0cmFwRGlzdEpzQm9vdHN0cmFwRXNtSnMiLCIuL25vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3QvZmVhdGhlci5qcyIsIm5vZGVfbW9kdWxlc0ZlYXRoZXJJY29uc0Rpc3RGZWF0aGVySnMiLCIuL3NyYy9qcy9hcHAuanMiLCJzcmNKc0FwcEpzIiwiLi9zcmMvanMvbW9kdWxlcy9ib290c3RyYXAuanMiLCJzcmNKc01vZHVsZXNCb290c3RyYXBKcyIsIi4vc3JjL2pzL21vZHVsZXMvZmVhdGhlci1pY29ucy5qcyIsInNyY0pzTW9kdWxlc0ZlYXRoZXJJY29uc0pzIl0sIm1hcHBpbmdzIjoiYUFFQSxTQUFTQSxRQUFRQyxHQUFtVixPQUF0T0QsUUFBckQsbUJBQVhFLFFBQW9ELGlCQUFwQkEsT0FBT0MsU0FBbUMsU0FBaUJGLEdBQU8sY0FBY0EsR0FBMkIsU0FBaUJBLEdBQU8sT0FBT0EsR0FBeUIsbUJBQVhDLFFBQXlCRCxFQUFJRyxjQUFnQkYsUUFBVUQsSUFBUUMsT0FBT0csVUFBWSxnQkFBa0JKLElBQXlCQSxJQUduWCxTQUFXSyxHQU9ULElBQUlDLEVBQW1CLEdBUXZCLFNBQVNDLEVBQW9CQyxHQU8zQixHQUFJRixFQUFpQkUsR0FFbkIsT0FBT0YsRUFBaUJFLEdBQVVDLFFBU3BDLElBQUlDLEVBQVNKLEVBQWlCRSxHQUFZLENBRXhDRyxFQUFHSCxFQUdISSxHQUFHLEVBR0hILFFBQVMsSUEyQlgsT0FoQkFKLEVBQVFHLEdBQVVLLEtBQUtILEVBQU9ELFFBQVNDLEVBQVFBLEVBQU9ELFFBQVNGLEdBUS9ERyxFQUFPRSxHQUFJLEVBUUpGLEVBQU9ELFFBYWhCRixFQUFvQk8sRUFBSVQsRUFReEJFLEVBQW9CUSxFQUFJVCxFQVF4QkMsRUFBb0JTLEVBQUksU0FBVVAsRUFBU1EsRUFBTUMsR0FFMUNYLEVBQW9CWSxFQUFFVixFQUFTUSxJQUVsQ0csT0FBT0MsZUFBZVosRUFBU1EsRUFBTSxDQUNuQ0ssWUFBWSxFQUNaQyxJQUFLTCxLQWVYWCxFQUFvQmlCLEVBQUksU0FBVWYsR0FFVixvQkFBWFIsUUFBMEJBLE9BQU93QixhQUUxQ0wsT0FBT0MsZUFBZVosRUFBU1IsT0FBT3dCLFlBQWEsQ0FDakRDLE1BQU8sV0FPWE4sT0FBT0MsZUFBZVosRUFBUyxhQUFjLENBQzNDaUIsT0FBTyxLQXdCWG5CLEVBQW9Cb0IsRUFBSSxTQUFVRCxFQUFPRSxHQUt2QyxHQUhXLEVBQVBBLElBQVVGLEVBQVFuQixFQUFvQm1CLElBRy9CLEVBQVBFLEVBQVUsT0FBT0YsRUFHckIsR0FBVyxFQUFQRSxHQUErQixXQUFuQjdCLFFBQVEyQixJQUF1QkEsR0FBU0EsRUFBTUcsV0FBWSxPQUFPSCxFQUdqRixJQUFJSSxFQUFLVixPQUFPVyxPQUFPLE1BYXZCLEdBVkF4QixFQUFvQmlCLEVBQUVNLEdBSXRCVixPQUFPQyxlQUFlUyxFQUFJLFVBQVcsQ0FDbkNSLFlBQVksRUFDWkksTUFBT0EsSUFJRSxFQUFQRSxHQUE0QixpQkFBVEYsRUFBbUIsSUFBSyxJQUFJTSxLQUFPTixFQUN4RG5CLEVBQW9CUyxFQUFFYyxFQUFJRSxFQUFLLFNBQVVBLEdBQ3ZDLE9BQU9OLEVBQU1NLElBQ2JDLEtBQUssS0FBTUQsSUFJZixPQUFPRixHQVdUdkIsRUFBb0IyQixFQUFJLFNBQVV4QixHQUVoQyxJQUFJUSxFQUFTUixHQUFVQSxFQUFPbUIsV0FFOUIsV0FDRSxPQUFPbkIsRUFBZ0IsU0FHekIsV0FDRSxPQUFPQSxHQVFULE9BSkFILEVBQW9CUyxFQUFFRSxFQUFRLElBQUtBLEdBSTVCQSxHQVdUWCxFQUFvQlksRUFBSSxTQUFVZ0IsRUFBUUMsR0FDeEMsT0FBT2hCLE9BQU9oQixVQUFVaUMsZUFBZXhCLEtBQUtzQixFQUFRQyxJQVV0RDdCLEVBQW9CK0IsRUFBSSxHQVVqQi9CLEVBQW9CQSxFQUFvQmdDLEVBQUksbUJBdFByRCxDQTRQQSxDQUVFQyxvREFRQSxTQUFTQywwQ0FBMEMvQixPQUFRZ0Msb0JBQXFCbkMscUJBRzlFb0MsS0FBSyx5eWFBS1BDLDBEQVFBLFNBQVNDLDhDQUE4Q25DLE9BQVFnQyxvQkFBcUJuQyxxQkFHbEZvQyxLQUFLLG9tQ0FLUEcsdUVBUUEsU0FBU0MsMkRBQTJEckMsT0FBUWdDLG9CQUFxQm5DLHFCQUcvRm9DLEtBQUssd2pCQUtQSyxpRUFRQSxTQUFTQyxxREFBcUR2QyxPQUFRZ0Msb0JBQXFCbkMscUJBR3pGb0MsS0FBSyxtaE5BS1BPLGtFQVFBLFNBQVNDLHNEQUFzRHpDLE9BQVFnQyxvQkFBcUJuQyxxQkFHMUZvQyxLQUFLLHExR0FLUFMsa0VBUUEsU0FBU0Msc0RBQXNEM0MsT0FBUWdDLG9CQUFxQm5DLHFCQUcxRm9DLEtBQUssa2xCQUtQVyxvRUFRQSxTQUFTQyx3REFBd0Q3QyxPQUFRZ0Msb0JBQXFCbkMscUJBRzVGb0MsS0FBSyw0dkJBS1BhLGlFQVFBLFNBQVNDLHFEQUFxRC9DLE9BQVFnQyxvQkFBcUJuQyxxQkFHekZvQyxLQUFLLHloRkFLUGUsc0VBUUEsU0FBU0MsMERBQTBEakQsT0FBUWdDLG9CQUFxQm5DLHFCQUc5Rm9DLEtBQUssMlpBS1BpQiwrREFRQSxTQUFTQyxtREFBbURuRCxPQUFRZ0Msb0JBQXFCbkMscUJBR3ZGb0MsS0FBSywwdENBS1BtQiw2REFRQSxTQUFTQyxpREFBaURyRCxPQUFRZ0Msb0JBQXFCbkMscUJBR3JGb0MsS0FBSyw0V0FLUHFCLCtEQVFBLFNBQVNDLG1EQUFtRHZELE9BQVFnQyxvQkFBcUJuQyxxQkFHdkZvQyxLQUFLLDA0Q0FLUHVCLGlFQVFBLFNBQVNDLHFEQUFxRHpELE9BQVFnQyxvQkFBcUJuQyxxQkFHekZvQyxLQUFLLDQwSUFLUHlCLCtEQVFBLFNBQVNDLG1EQUFtRDNELE9BQVFnQyxvQkFBcUJuQyxxQkFHdkZvQyxLQUFLLCtqREFLUDJCLGlFQVFBLFNBQVNDLHFEQUFxRDdELE9BQVFnQyxvQkFBcUJuQyxxQkFHekZvQyxLQUFLLHlpREFLUDZCLGlFQVFBLFNBQVNDLHFEQUFxRC9ELE9BQVFnQyxvQkFBcUJuQyxxQkFHekZvQyxLQUFLLHE2RUFLUCtCLDJEQVFBLFNBQVNDLCtDQUErQ2pFLE9BQVFnQyxvQkFBcUJuQyxxQkFHbkZvQyxLQUFLLGdoQkFLUGlDLGlFQVFBLFNBQVNDLHFEQUFxRG5FLE9BQVFnQyxvQkFBcUJuQyxxQkFHekZvQyxLQUFLLG9zQkFLUG1DLHFFQVFBLFNBQVNDLHlEQUF5RHJFLE9BQVFnQyxvQkFBcUJuQyxxQkFHN0ZvQyxLQUFLLG1qREFLUHFDLDREQVFBLFNBQVNDLGdEQUFnRHZFLE9BQVFnQyxvQkFBcUJuQyxxQkFHcEZvQyxLQUFLLDgzQ0FLUHVDLGdFQVFBLFNBQVNDLG9EQUFvRHpFLE9BQVFnQyxvQkFBcUJuQyxxQkFHeEZvQyxLQUFLLCszQkFLUHlDLGdFQVFBLFNBQVNDLG9EQUFvRDNFLE9BQVFnQyxvQkFBcUJuQyxxQkFHeEZvQyxLQUFLLG9tQkFLUDJDLG1FQVFBLFNBQVNDLHVEQUF1RDdFLE9BQVFnQyxvQkFBcUJuQyxxQkFHM0ZvQyxLQUFLLGlyRUFLUDZDLDZDQVFBLFNBQVNDLG1DQUFtQy9FLE9BQVFnQyxvQkFBcUJuQyxxQkFHdkVvQyxLQUFLLGlySUFLUCtDLDZDQVFBLFNBQVNDLG1DQUFtQ2pGLE9BQVFnQyxvQkFBcUJuQyxxQkFHdkVvQyxLQUFLLG01T0FLUGlELDZEQVFBLFNBQVNDLGtEQUFrRG5GLE9BQVFnQyxvQkFBcUJuQyxxQkFHdEZvQyxLQUFLLHV4R0FLUG1ELHVEQVFBLFNBQVNDLDRDQUE0Q3JGLE9BQVFnQyxvQkFBcUJuQyxxQkFHaEZvQyxLQUFLLCt3TUFLUHFELCtEQVFBLFNBQVNDLG9EQUFvRHZGLE9BQVFnQyxvQkFBcUJuQyxxQkFHeEZvQyxLQUFLLCs4UEFLUHVELGdFQVFBLFNBQVNDLHFEQUFxRHpGLE9BQVFnQyxvQkFBcUJuQyxxQkFHekZvQyxLQUFLLHF2REFLUHlELHNEQVFBLFNBQVNDLDJDQUEyQzNGLE9BQVFnQyxvQkFBcUJuQyxxQkFHL0VvQyxLQUFLLDRxT0FLUDJELHNEQVFBLFNBQVNDLDJDQUEyQzdGLE9BQVFnQyxvQkFBcUJuQyxxQkFHL0VvQyxLQUFLLDBxRkFLUDZELHVEQVFBLFNBQVNDLDRDQUE0Qy9GLE9BQVFnQyxvQkFBcUJuQyxxQkFHaEZvQyxLQUFLLDhxR0FLUCtELHdEQVFBLFNBQVNDLDZDQUE2Q2pHLE9BQVFnQyxvQkFBcUJuQyxxQkFHakZvQyxLQUFLLG01RUFLUGlFLCtEQVFBLFNBQVNDLG9EQUFvRG5HLE9BQVFnQyxvQkFBcUJuQyxxQkFHeEZvQyxLQUFLLHFtQ0FLUG1FLGlFQVFBLFNBQVNDLHNEQUFzRHJHLE9BQVFnQyxvQkFBcUJuQyxxQkFHMUZvQyxLQUFLLGc5UUFLUHFFLG1EQVFBLFNBQVNDLHdDQUF3Q3ZHLE9BQVFnQyxvQkFBcUJuQyxxQkFHNUVvQyxLQUFLLGl1RUFLUHVFLDhDQVFBLFNBQVNDLG9DQUFvQ3pHLE9BQVFnQyxvQkFBcUJuQyxxQkFHeEVvQyxLQUFLLHFwTEFLUHlFLGtFQVFBLFNBQVNDLHVEQUF1RDNHLE9BQVFnQyxvQkFBcUJuQyxxQkFHM0ZvQyxLQUFLLDJrR0FLUDJFLDREQVFBLFNBQVNDLGlEQUFpRDdHLE9BQVFnQyxvQkFBcUJuQyxxQkFHckZvQyxLQUFLLDY1RkFLUDZFLHNEQVFBLFNBQVNDLDJDQUEyQy9HLE9BQVFnQyxvQkFBcUJuQyxxQkFHL0VvQyxLQUFLLHdpQkFLUCtFLDREQVFBLFNBQVNDLGlEQUFpRGpILE9BQVFnQyxvQkFBcUJuQyxxQkFHckZvQyxLQUFLLGswTEFLUGlGLDZEQVFBLFNBQVNDLGtEQUFrRG5ILE9BQVFnQyxvQkFBcUJuQyxxQkFHdEZvQyxLQUFLLDhaQUtQbUYsb0RBUUEsU0FBU0MseUNBQXlDckgsT0FBUWdDLG9CQUFxQm5DLHFCQUc3RW9DLEtBQUssOGdCQUtQcUYsd0RBUUEsU0FBU0MsNkNBQTZDdkgsT0FBUWdDLG9CQUFxQm5DLHFCQUdqRm9DLEtBQUssbVVBS1B1Riw4REFRQSxTQUFTQyxtREFBbUR6SCxPQUFRZ0Msb0JBQXFCbkMscUJBR3ZGb0MsS0FBSyxvZkFLUHlGLGdFQVFBLFNBQVNDLHFEQUFxRDNILE9BQVFnQyxvQkFBcUJuQyxxQkFHekZvQyxLQUFLLDRYQUtQMkYsc0VBUUEsU0FBU0MsMkRBQTJEN0gsT0FBUWdDLG9CQUFxQm5DLHFCQUcvRm9DLEtBQUssK1lBS1A2RixrRUFRQSxTQUFTQyx1REFBdUQvSCxPQUFRZ0Msb0JBQXFCbkMscUJBRzNGb0MsS0FBSyx3Z0JBS1ArRiwyRUFRQSxTQUFTQyxnRUFBZ0VqSSxPQUFRZ0Msb0JBQXFCbkMscUJBR3BHb0MsS0FBSyxpZkFLUGlHLDBEQVFBLFNBQVNDLCtDQUErQ25JLE9BQVFnQyxvQkFBcUJuQyxxQkFHbkZvQyxLQUFLLDZVQUtQbUcsa0RBUUEsU0FBU0MsdUNBQXVDckksT0FBUWdDLG9CQUFxQm5DLHFCQUczRW9DLEtBQUssaWhCQUtQcUcseURBUUEsU0FBU0MsOENBQThDdkksT0FBUWdDLG9CQUFxQm5DLHFCQUdsRm9DLEtBQUssMndCQUtQdUcsZ0VBUUEsU0FBU0MscURBQXFEekksT0FBUWdDLG9CQUFxQm5DLHFCQUd6Rm9DLEtBQUssMm5CQUtQeUcsNERBUUEsU0FBU0MsaURBQWlEM0ksT0FBUWdDLG9CQUFxQm5DLHFCQUdyRm9DLEtBQUssaXBEQUtQMkcsOERBUUEsU0FBU0MsbURBQW1EN0ksT0FBUWdDLG9CQUFxQm5DLHFCQUd2Rm9DLEtBQUssa2NBS1A2RyxzREFRQSxTQUFTQywyQ0FBMkMvSSxPQUFRZ0Msb0JBQXFCbkMscUJBRy9Fb0MsS0FBSyxrZkFLUCtHLCtEQVFBLFNBQVNDLG9EQUFvRGpKLE9BQVFnQyxvQkFBcUJuQyxxQkFHeEZvQyxLQUFLLHVrSUFLUGlILG9EQVFBLFNBQVNDLHlDQUF5Q25KLE9BQVFnQyxvQkFBcUJuQyxxQkFHN0VvQyxLQUFLLGdrQkFLUG1ILG9EQVFBLFNBQVNDLDBDQUEwQ3JKLE9BQVFnQyxvQkFBcUJuQyxxQkFHOUVvQyxLQUFLLG9oOUlBS1BxSCwrQ0FRQSxTQUFTQyxzQ0FBc0N2SixPQUFRRCxRQUFTRixxQkFDOURvQyxLQUFLLHdoa0tBS1B1SCxrQkFRQSxTQUFTQyxXQUFXekosT0FBUWdDLG9CQUFxQm5DLHFCQUcvQ29DLEtBQUssaXZCQUtQeUgsZ0NBUUEsU0FBU0Msd0JBQXdCM0osT0FBUWdDLG9CQUFxQm5DLHFCQUc1RG9DLEtBQUssMm1EQUtQMkgsb0NBUUEsU0FBU0MsMkJBQTJCN0osT0FBUWdDLG9CQUFxQm5DLHFCQUcvRG9DLEtBQUsifQ==
