"use strict";function _typeof(e){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}!function(t){var r={};function o(e){if(r[e])return r[e].exports;var n=r[e]={i:e,l:!1,exports:{}};return t[e].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=t,o.c=r,o.d=function(e,n,t){o.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"===_typeof(n)&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(n,"a",n),n},o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},o.p="",o(o.s="./src/js/app.js")}({"./node_modules/@popperjs/core/lib/createPopper.js":function node_modulesPopperjsCoreLibCreatePopperJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "popperGenerator", function() { return popperGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPopper", function() { return createPopper; });\n/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");\n/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");\n/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");\n/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/orderModifiers.js */ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js");\n/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/debounce.js */ "./node_modules/@popperjs/core/lib/utils/debounce.js");\n/* harmony import */ var _utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/validateModifiers.js */ "./node_modules/@popperjs/core/lib/utils/validateModifiers.js");\n/* harmony import */ var _utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/uniqueBy.js */ "./node_modules/@popperjs/core/lib/utils/uniqueBy.js");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/mergeByName.js */ "./node_modules/@popperjs/core/lib/utils/mergeByName.js");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectOverflow", function() { return _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });\n\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar INVALID_ELEMENT_ERROR = \'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\';\nvar INFINITE_LOOP_ERROR = \'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\';\nvar DEFAULT_OPTIONS = {\n  placement: \'bottom\',\n  modifiers: [],\n  strategy: \'absolute\'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === \'function\');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: \'bottom\',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(options) {\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_12__["isElement"])(reference) ? Object(_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(reference) : reference.contextElement ? Object(_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(reference.contextElement) : [],\n          popper: Object(_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = Object(_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_5__["default"])(Object(_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_10__["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (true) {\n          var modifiers = Object(_utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_8__["default"])([].concat(orderedModifiers, state.options.modifiers), function (_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          Object(_utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_7__["default"])(modifiers);\n\n          if (Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.options.placement) === _enums_js__WEBPACK_IMPORTED_MODULE_13__["auto"]) {\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\n              var name = _ref2.name;\n              return name === \'flip\';\n            });\n\n            if (!flipModifier) {\n              console.error([\'Popper: "auto" placements require the "flip" modifier be\', \'present and enabled to work.\'].join(\' \'));\n            }\n          }\n\n          var _getComputedStyle = Object(_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(popper),\n              marginTop = _getComputedStyle.marginTop,\n              marginRight = _getComputedStyle.marginRight,\n              marginBottom = _getComputedStyle.marginBottom,\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we\'ll warn the consumer\n\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn([\'Popper: CSS "margin" styles cannot be used to apply padding\', \'between the popper and its reference element or boundary.\', \'To replicate margin, use the `offset` modifier, as well as\', \'the `padding` option in the `preventOverflow` and `flip`\', \'modifiers.\'].join(\' \'));\n          }\n        }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don\'t proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (true) {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: Object(_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(reference, Object(_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper), state.options.strategy === \'fixed\'),\n          popper: Object(_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn\'t persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (true) {\n            __debug_loops__ += 1;\n\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === \'function\') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: Object(_utils_debounce_js__WEBPACK_IMPORTED_MODULE_6__["default"])(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (true) {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === \'function\') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nvar createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\n\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/createPopper.js?')},"./node_modules/@popperjs/core/lib/dom-utils/contains.js":function node_modulesPopperjsCoreLibDomUtilsContainsJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return contains; });\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__["isShadowRoot"])(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/contains.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":function node_modulesPopperjsCoreLibDomUtilsGetBoundingClientRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getBoundingClientRect; });\nfunction getBoundingClientRect(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    width: rect.width,\n    height: rect.height,\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    x: rect.left,\n    y: rect.top\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":function node_modulesPopperjsCoreLibDomUtilsGetClippingRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getClippingRect; });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getViewportRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js");\n/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js");\n/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");\n/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");\n/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");\n/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getInnerBoundingClientRect(element) {\n  var rect = Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_8__["default"])(element);\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_0__["viewport"] ? Object(_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Object(_getViewportRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) : Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__["isHTMLElement"])(clippingParent) ? getInnerBoundingClientRect(clippingParent) : Object(_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Object(_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(element)));\n} // A "clipping parent" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = Object(_listScrollParents_js__WEBPACK_IMPORTED_MODULE_3__["default"])(Object(_getParentNode_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element));\n  var canEscapeClipping = [\'absolute\', \'fixed\'].indexOf(Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element).position) >= 0;\n  var clipperElement = canEscapeClipping && Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__["isHTMLElement"])(element) ? Object(_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__["default"])(element) : element;\n\n  if (!Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__["isElement"])(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__["isElement"])(clippingParent) && Object(_contains_js__WEBPACK_IMPORTED_MODULE_10__["default"])(clippingParent, clipperElement) && Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_11__["default"])(clippingParent) !== \'body\';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === \'clippingParents\' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    accRect.top = Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_13__["max"])(rect.top, accRect.top);\n    accRect.right = Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_13__["min"])(rect.right, accRect.right);\n    accRect.bottom = Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_13__["min"])(rect.bottom, accRect.bottom);\n    accRect.left = Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_13__["max"])(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":function node_modulesPopperjsCoreLibDomUtilsGetCompositeRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getCompositeRect; });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");\n/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getNodeScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");\n\n\n\n\n\n\n // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var documentElement = Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(offsetParent);\n  var rect = Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(elementOrVirtualElement);\n  var isOffsetParentAnElement = Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(offsetParent);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent) !== \'body\' || // https://github.com/popperjs/popper-core/issues/1078\n    Object(_isScrollParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(documentElement)) {\n      scroll = Object(_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent);\n    }\n\n    if (Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(offsetParent)) {\n      offsets = Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(offsetParent);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = Object(_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_4__["default"])(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":function node_modulesPopperjsCoreLibDomUtilsGetComputedStyleJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getComputedStyle; });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n\nfunction getComputedStyle(element) {\n  return Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element).getComputedStyle(element);\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":function node_modulesPopperjsCoreLibDomUtilsGetDocumentElementJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getDocumentElement; });\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return ((Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__["isElement"])(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":function node_modulesPopperjsCoreLibDomUtilsGetDocumentRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getDocumentRect; });\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");\n\n\n\n\n // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);\n  var winScroll = Object(_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_4__["max"])(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_4__["max"])(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + Object(_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);\n  var y = -winScroll.scrollTop;\n\n  if (Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(body || html).direction === \'rtl\') {\n    x += Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_4__["max"])(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":function node_modulesPopperjsCoreLibDomUtilsGetHTMLElementScrollJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getHTMLElementScroll; });\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":function node_modulesPopperjsCoreLibDomUtilsGetLayoutRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getLayoutRect; });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");\n // Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn\'t take into account transforms.\n\nfunction getLayoutRect(element) {\n  var clientRect = Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element); // Use the clientRect sizes if it\'s not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":function node_modulesPopperjsCoreLibDomUtilsGetNodeNameJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getNodeName; });\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js?")},"./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":function node_modulesPopperjsCoreLibDomUtilsGetNodeScrollJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getNodeScroll; });\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js");\n\n\n\n\nfunction getNodeScroll(node) {\n  if (node === Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node) || !Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_2__["isHTMLElement"])(node)) {\n    return Object(_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);\n  } else {\n    return Object(_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node);\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":function node_modulesPopperjsCoreLibDomUtilsGetOffsetParentJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getOffsetParent; });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isTableElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");\n\n\n\n\n\n\n\nfunction getTrueOffsetParent(element) {\n  if (!Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(element) || // https://github.com/popperjs/popper-core/issues/837\n  Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).position === \'fixed\') {\n    return null;\n  }\n\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var isFirefox = navigator.userAgent.toLowerCase().indexOf(\'firefox\') !== -1;\n  var isIE = navigator.userAgent.indexOf(\'Trident\') !== -1;\n\n  if (isIE && Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);\n\n    if (elementCss.position === \'fixed\') {\n      return null;\n    }\n  }\n\n  var currentNode = Object(_getParentNode_js__WEBPACK_IMPORTED_MODULE_5__["default"])(element);\n\n  while (Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(currentNode) && [\'html\', \'body\'].indexOf(Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(currentNode)) < 0) {\n    var css = Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== \'none\' || css.perspective !== \'none\' || css.contain === \'paint\' || [\'transform\', \'perspective\'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === \'filter\' || isFirefox && css.filter && css.filter !== \'none\') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  var window = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && Object(_isTableElement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) && Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent).position === \'static\') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent) === \'html\' || Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent) === \'body\' && Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent).position === \'static\')) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":function node_modulesPopperjsCoreLibDomUtilsGetParentNodeJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getParentNode; });\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n\n\n\nfunction getParentNode(element) {\n  if (Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element) === \'html\') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_2__["isShadowRoot"])(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element) // fallback\n\n  );\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":function node_modulesPopperjsCoreLibDomUtilsGetScrollParentJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getScrollParent; });\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n\n\n\n\nfunction getScrollParent(node) {\n  if ([\'html\', \'body\', \'#document\'].indexOf(Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (Object(_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__["isHTMLElement"])(node) && Object(_isScrollParent_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node)) {\n    return node;\n  }\n\n  return getScrollParent(Object(_getParentNode_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node));\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":function node_modulesPopperjsCoreLibDomUtilsGetViewportRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getViewportRect; });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");\n\n\n\nfunction getViewportRect(element) {\n  var win = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);\n  var html = Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0; // NB: This isn\'t supported on iOS <= 12. If the keyboard is open, the popper\n  // can be obscured underneath it.\n  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n  // if it isn\'t open, so if this isn\'t available, the popper will be detected\n  // to overflow the bottom of the screen too early.\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n    // errors due to floating point numbers, so we need to check precision.\n    // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n    // Feature detection fails in mobile emulation mode in Chrome.\n    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n    // 0.001\n    // Fallback here: "Not Safari" userAgent\n\n    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + Object(_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element),\n    y: y\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js":function node_modulesPopperjsCoreLibDomUtilsGetWindowJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getWindow; });\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getWindow.js?")},"./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":function node_modulesPopperjsCoreLibDomUtilsGetWindowScrollJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getWindowScroll; });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n\nfunction getWindowScroll(node) {\n  var win = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js?')},"./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":function node_modulesPopperjsCoreLibDomUtilsGetWindowScrollBarXJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getWindowScrollBarX; });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");\n\n\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let\'s assume\n  // it\'s not an issue. I don\'t think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn\'t cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return Object(_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object(_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)).left + Object(_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).scrollLeft;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js?')},"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":function node_modulesPopperjsCoreLibDomUtilsInstanceOfJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isElement", function() { return isElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isHTMLElement", function() { return isHTMLElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isShadowRoot", function() { return isShadowRoot; });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n\n\nfunction isElement(node) {\n  var OwnElement = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\nfunction isHTMLElement(node) {\n  var OwnElement = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === \'undefined\') {\n    return false;\n  }\n\n  var OwnElement = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js?')},"./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":function node_modulesPopperjsCoreLibDomUtilsIsScrollParentJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isScrollParent; });\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = Object(_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js?')},"./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":function node_modulesPopperjsCoreLibDomUtilsIsTableElementJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return isTableElement; });\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(Object(_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element)) >= 0;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js?")},"./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":function node_modulesPopperjsCoreLibDomUtilsListScrollParentsJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return listScrollParents; });\n/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");\n\n\n\n\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we\'ll need to re-calculate the\nreference element\'s position.\n*/\n\nfunction listScrollParents(element, list) {\n  var _element$ownerDocumen;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = Object(_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = Object(_getWindow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], Object(_isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(Object(_getParentNode_js__WEBPACK_IMPORTED_MODULE_1__["default"])(target)));\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js?')},"./node_modules/@popperjs/core/lib/enums.js":function node_modulesPopperjsCoreLibEnumsJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "top", function() { return top; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bottom", function() { return bottom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "right", function() { return right; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "left", function() { return left; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "auto", function() { return auto; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basePlacements", function() { return basePlacements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "start", function() { return start; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "end", function() { return end; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clippingParents", function() { return clippingParents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewport", function() { return viewport; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "popper", function() { return popper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reference", function() { return reference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variationPlacements", function() { return variationPlacements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "placements", function() { return placements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beforeRead", function() { return beforeRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "read", function() { return read; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "afterRead", function() { return afterRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beforeMain", function() { return beforeMain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "main", function() { return main; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "afterMain", function() { return afterMain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beforeWrite", function() { return beforeWrite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "write", function() { return write; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "afterWrite", function() { return afterWrite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifierPhases", function() { return modifierPhases; });\nvar top = \'top\';\nvar bottom = \'bottom\';\nvar right = \'right\';\nvar left = \'left\';\nvar auto = \'auto\';\nvar basePlacements = [top, bottom, right, left];\nvar start = \'start\';\nvar end = \'end\';\nvar clippingParents = \'clippingParents\';\nvar viewport = \'viewport\';\nvar popper = \'popper\';\nvar reference = \'reference\';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + "-" + start, placement + "-" + end]);\n}, []);\nvar placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = \'beforeRead\';\nvar read = \'read\';\nvar afterRead = \'afterRead\'; // pure-logic modifiers\n\nvar beforeMain = \'beforeMain\';\nvar main = \'main\';\nvar afterMain = \'afterMain\'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = \'beforeWrite\';\nvar write = \'write\';\nvar afterWrite = \'afterWrite\';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/enums.js?')},"./node_modules/@popperjs/core/lib/index.js":function node_modulesPopperjsCoreLibIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "top", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["top"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bottom", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["bottom"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "right", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["right"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "left", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["left"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "auto", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["auto"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "basePlacements", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["basePlacements"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "start", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["start"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "end", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["end"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clippingParents", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["clippingParents"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "viewport", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["viewport"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popper", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["popper"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reference", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["reference"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variationPlacements", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["variationPlacements"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "placements", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["placements"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "beforeRead", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["beforeRead"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "read", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["read"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "afterRead", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["afterRead"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "beforeMain", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["beforeMain"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "main", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["main"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "afterMain", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["afterMain"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "beforeWrite", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["beforeWrite"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "write", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["write"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "afterWrite", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["afterWrite"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "modifierPhases", function() { return _enums_js__WEBPACK_IMPORTED_MODULE_0__["modifierPhases"]; });\n\n/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyStyles", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["applyStyles"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "arrow", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["arrow"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeStyles", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["computeStyles"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eventListeners", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["eventListeners"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flip", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["flip"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hide", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["hide"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "offset", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["offset"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popperOffsets", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["popperOffsets"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "preventOverflow", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__["preventOverflow"]; });\n\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popperGenerator", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_2__["popperGenerator"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectOverflow", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_2__["detectOverflow"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPopperBase", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_2__["createPopper"]; });\n\n/* harmony import */ var _popper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./popper.js */ "./node_modules/@popperjs/core/lib/popper.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPopper", function() { return _popper_js__WEBPACK_IMPORTED_MODULE_3__["createPopper"]; });\n\n/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPopperLite", function() { return _popper_lite_js__WEBPACK_IMPORTED_MODULE_4__["createPopper"]; });\n\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/index.js?')},"./node_modules/@popperjs/core/lib/modifiers/applyStyles.js":function node_modulesPopperjsCoreLibModifiersApplyStylesJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__[\"isHTMLElement\"])(element) || !Object(_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__[\"isHTMLElement\"])(element) || !Object(_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect,\n  requires: ['computeStyles']\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/applyStyles.js?")},"./node_modules/@popperjs/core/lib/modifiers/arrow.js":function node_modulesPopperjsCoreLibModifiersArrowJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");\n/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");\n/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");\n/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");\n/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");\n/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === \'function\' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return Object(_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_6__["default"])(typeof padding !== \'number\' ? padding : Object(_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_7__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_8__["basePlacements"]));\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.placement);\n  var axis = Object(_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(basePlacement);\n  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_8__["left"], _enums_js__WEBPACK_IMPORTED_MODULE_8__["right"]].indexOf(basePlacement) >= 0;\n  var len = isVertical ? \'height\' : \'width\';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = Object(_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arrowElement);\n  var minProp = axis === \'y\' ? _enums_js__WEBPACK_IMPORTED_MODULE_8__["top"] : _enums_js__WEBPACK_IMPORTED_MODULE_8__["left"];\n  var maxProp = axis === \'y\' ? _enums_js__WEBPACK_IMPORTED_MODULE_8__["bottom"] : _enums_js__WEBPACK_IMPORTED_MODULE_8__["right"];\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = Object(_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__["default"])(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === \'y\' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn\'t overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = Object(_utils_within_js__WEBPACK_IMPORTED_MODULE_5__["default"])(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? \'[data-popper-arrow]\' : _options$element;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === \'string\') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (true) {\n    if (!Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_9__["isHTMLElement"])(arrowElement)) {\n      console.error([\'Popper: "arrow" element must be an HTMLElement (not an SVGElement).\', \'To use an SVG arrow, wrap it in an HTMLElement that will be used as\', \'the arrow.\'].join(\' \'));\n    }\n  }\n\n  if (!Object(_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.elements.popper, arrowElement)) {\n    if (true) {\n      console.error([\'Popper: "arrow" modifier\\\'s `element` must be a child of the popper\', \'element.\'].join(\' \'));\n    }\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  name: \'arrow\',\n  enabled: true,\n  phase: \'main\',\n  fn: arrow,\n  effect: effect,\n  requires: [\'popperOffsets\'],\n  requiresIfExists: [\'preventOverflow\']\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/arrow.js?')},"./node_modules/@popperjs/core/lib/modifiers/computeStyles.js":function node_modulesPopperjsCoreLibModifiersComputeStylesJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapToStyles\", function() { return mapToStyles; });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_6__[\"round\"])(Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_6__[\"round\"])(x * dpr) / dpr) || 0,\n    y: Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_6__[\"round\"])(Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_6__[\"round\"])(y * dpr) / dpr) || 0\n  };\n}\n\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets;\n\n  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,\n      _ref3$x = _ref3.x,\n      x = _ref3$x === void 0 ? 0 : _ref3$x,\n      _ref3$y = _ref3.y,\n      y = _ref3$y === void 0 ? 0 : _ref3$y;\n\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__[\"left\"];\n  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__[\"top\"];\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = Object(_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n\n    if (offsetParent === Object(_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(popper)) {\n      offsetParent = Object(_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(popper);\n\n      if (Object(_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(offsetParent).position !== 'static') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n    offsetParent = offsetParent;\n\n    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__[\"top\"]) {\n      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__[\"bottom\"]; // $FlowFixMe[prop-missing]\n\n      y -= offsetParent[heightProp] - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__[\"left\"]) {\n      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__[\"right\"]; // $FlowFixMe[prop-missing]\n\n      x -= offsetParent[widthProp] - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref4) {\n  var state = _ref4.state,\n      options = _ref4.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n\n  if (true) {\n    var transitionProperty = Object(_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(state.elements.popper).transitionProperty || '';\n\n    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {\n      return transitionProperty.indexOf(property) >= 0;\n    })) {\n      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', '\\n\\n', 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\\n\\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));\n    }\n  }\n\n  var commonStyles = {\n    placement: Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/computeStyles.js?")},"./node_modules/@popperjs/core/lib/modifiers/eventListeners.js":function node_modulesPopperjsCoreLibModifiersEventListenersJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = Object(_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/eventListeners.js?")},"./node_modules/@popperjs/core/lib/modifiers/flip.js":function node_modulesPopperjsCoreLibModifiersFlipJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");\n/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__["auto"]) {\n    return [];\n  }\n\n  var oppositePlacement = Object(_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);\n  return [Object(_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(placement), oppositePlacement, Object(_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [Object(_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__["auto"] ? Object(_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement);\n\n    var isStartVariation = Object(_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__["start"];\n    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_5__["top"], _enums_js__WEBPACK_IMPORTED_MODULE_5__["bottom"]].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? \'width\' : \'height\';\n    var overflow = Object(_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["right"] : _enums_js__WEBPACK_IMPORTED_MODULE_5__["left"] : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["bottom"] : _enums_js__WEBPACK_IMPORTED_MODULE_5__["top"];\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = Object(_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(mainVariationSide);\n    }\n\n    var altVariationSide = Object(_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return "break";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === "break") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  name: \'flip\',\n  enabled: true,\n  phase: \'main\',\n  fn: flip,\n  requiresIfExists: [\'offset\'],\n  data: {\n    _skip: false\n  }\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/flip.js?')},"./node_modules/@popperjs/core/lib/modifiers/hide.js":function node_modulesPopperjsCoreLibModifiersHideJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");\n\n\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__["top"], _enums_js__WEBPACK_IMPORTED_MODULE_0__["right"], _enums_js__WEBPACK_IMPORTED_MODULE_0__["bottom"], _enums_js__WEBPACK_IMPORTED_MODULE_0__["left"]].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = Object(_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {\n    elementContext: \'reference\'\n  });\n  var popperAltOverflow = Object(_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    \'data-popper-reference-hidden\': isReferenceHidden,\n    \'data-popper-escaped\': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  name: \'hide\',\n  enabled: true,\n  phase: \'main\',\n  requiresIfExists: [\'preventOverflow\'],\n  fn: hide\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/hide.js?')},"./node_modules/@popperjs/core/lib/modifiers/index.js":function node_modulesPopperjsCoreLibModifiersIndexJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyStyles", function() { return _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _arrow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "arrow", function() { return _arrow_js__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeStyles", function() { return _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eventListeners", function() { return _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n/* harmony import */ var _flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flip", function() { return _flip_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });\n\n/* harmony import */ var _hide_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hide", function() { return _hide_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });\n\n/* harmony import */ var _offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "offset", function() { return _offset_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });\n\n/* harmony import */ var _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popperOffsets", function() { return _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });\n\n/* harmony import */ var _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "preventOverflow", function() { return _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/index.js?')},"./node_modules/@popperjs/core/lib/modifiers/offset.js":function node_modulesPopperjsCoreLibModifiersOffsetJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceAndSkiddingToXY", function() { return distanceAndSkiddingToXY; });\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);\n  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__["left"], _enums_js__WEBPACK_IMPORTED_MODULE_1__["top"]].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === \'function\' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__["left"], _enums_js__WEBPACK_IMPORTED_MODULE_1__["right"]].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__["placements"].reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  name: \'offset\',\n  enabled: true,\n  phase: \'main\',\n  requires: [\'popperOffsets\'],\n  fn: offset\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/offset.js?')},"./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":function node_modulesPopperjsCoreLibModifiersPopperOffsetsJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ \"./node_modules/@popperjs/core/lib/utils/computeOffsets.js\");\n\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = Object(_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js?")},"./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":function node_modulesPopperjsCoreLibModifiersPreventOverflowJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");\n/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getAltAxis.js */ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js");\n/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");\n/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");\n/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = Object(_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = Object(_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.placement);\n  var variation = Object(_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_8__["default"])(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = Object(_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(basePlacement);\n  var altAxis = Object(_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_3__["default"])(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === \'function\' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis || checkAltAxis) {\n    var mainSide = mainAxis === \'y\' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__["top"] : _enums_js__WEBPACK_IMPORTED_MODULE_0__["left"];\n    var altSide = mainAxis === \'y\' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__["bottom"] : _enums_js__WEBPACK_IMPORTED_MODULE_0__["right"];\n    var len = mainAxis === \'y\' ? \'height\' : \'width\';\n    var offset = popperOffsets[mainAxis];\n    var min = popperOffsets[mainAxis] + overflow[mainSide];\n    var max = popperOffsets[mainAxis] - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__["start"] ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__["start"] ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn\'t go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? Object(_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData[\'arrow#persistent\'] ? state.modifiersData[\'arrow#persistent\'].padding : Object(_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_9__["default"])();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don\'t want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = Object(_utils_within_js__WEBPACK_IMPORTED_MODULE_4__["default"])(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    var arrowOffsetParent = state.elements.arrow && Object(_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === \'y\' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n\n    if (checkMainAxis) {\n      var preventedOffset = Object(_utils_within_js__WEBPACK_IMPORTED_MODULE_4__["default"])(tether ? Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_10__["min"])(min, tetherMin) : min, offset, tether ? Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_10__["max"])(max, tetherMax) : max);\n      popperOffsets[mainAxis] = preventedOffset;\n      data[mainAxis] = preventedOffset - offset;\n    }\n\n    if (checkAltAxis) {\n      var _mainSide = mainAxis === \'x\' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__["top"] : _enums_js__WEBPACK_IMPORTED_MODULE_0__["left"];\n\n      var _altSide = mainAxis === \'x\' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__["bottom"] : _enums_js__WEBPACK_IMPORTED_MODULE_0__["right"];\n\n      var _offset = popperOffsets[altAxis];\n\n      var _min = _offset + overflow[_mainSide];\n\n      var _max = _offset - overflow[_altSide];\n\n      var _preventedOffset = Object(_utils_within_js__WEBPACK_IMPORTED_MODULE_4__["default"])(tether ? Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_10__["min"])(_min, tetherMin) : _min, _offset, tether ? Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_10__["max"])(_max, tetherMax) : _max);\n\n      popperOffsets[altAxis] = _preventedOffset;\n      data[altAxis] = _preventedOffset - _offset;\n    }\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n  name: \'preventOverflow\',\n  enabled: true,\n  phase: \'main\',\n  fn: preventOverflow,\n  requiresIfExists: [\'offset\']\n});\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js?')},"./node_modules/@popperjs/core/lib/popper-lite.js":function node_modulesPopperjsCoreLibPopperLiteJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPopper", function() { return createPopper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultModifiers", function() { return defaultModifiers; });\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popperGenerator", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_0__["popperGenerator"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectOverflow", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_0__["detectOverflow"]; });\n\n/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");\n/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");\n/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");\n/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");\n\n\n\n\n\nvar defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_4__["default"]];\nvar createPopper = /*#__PURE__*/Object(_createPopper_js__WEBPACK_IMPORTED_MODULE_0__["popperGenerator"])({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/popper-lite.js?')},"./node_modules/@popperjs/core/lib/popper.js":function node_modulesPopperjsCoreLibPopperJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPopper", function() { return createPopper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultModifiers", function() { return defaultModifiers; });\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popperGenerator", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_0__["popperGenerator"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "detectOverflow", function() { return _createPopper_js__WEBPACK_IMPORTED_MODULE_0__["detectOverflow"]; });\n\n/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");\n/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");\n/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");\n/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");\n/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");\n/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");\n/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");\n/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");\n/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modifiers/hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");\n/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPopperLite", function() { return _popper_lite_js__WEBPACK_IMPORTED_MODULE_10__["createPopper"]; });\n\n/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyStyles", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["applyStyles"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "arrow", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["arrow"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeStyles", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["computeStyles"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eventListeners", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["eventListeners"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flip", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["flip"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hide", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["hide"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "offset", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["offset"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popperOffsets", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["popperOffsets"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "preventOverflow", function() { return _modifiers_index_js__WEBPACK_IMPORTED_MODULE_11__["preventOverflow"]; });\n\n\n\n\n\n\n\n\n\n\n\nvar defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_8__["default"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_9__["default"]];\nvar createPopper = /*#__PURE__*/Object(_createPopper_js__WEBPACK_IMPORTED_MODULE_0__["popperGenerator"])({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/popper.js?')},"./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":function node_modulesPopperjsCoreLibUtilsComputeAutoPlacementJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return computeAutoPlacement; });\n/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");\n/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n\n\n\n\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_1__["placements"] : _options$allowedAutoP;\n  var variation = Object(_getVariation_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);\n  var placements = variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_1__["variationPlacements"] : _enums_js__WEBPACK_IMPORTED_MODULE_1__["variationPlacements"].filter(function (placement) {\n    return Object(_getVariation_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === variation;\n  }) : _enums_js__WEBPACK_IMPORTED_MODULE_1__["basePlacements"];\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n\n    if (true) {\n      console.error([\'Popper: The `allowedAutoPlacements` option did not allow any\', \'placements. Ensure the `placement` option matches the variation\', \'of the allowed placements.\', \'For example, "auto" cannot be used to allow "bottom-start".\', \'Use "auto-start" instead.\'].join(\' \'));\n    }\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = Object(_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[Object(_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js?')},"./node_modules/@popperjs/core/lib/utils/computeOffsets.js":function node_modulesPopperjsCoreLibUtilsComputeOffsetsJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return computeOffsets; });\n/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");\n/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");\n/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n\n\n\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? Object(_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) : null;\n  var variation = placement ? Object(_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case _enums_js__WEBPACK_IMPORTED_MODULE_3__["top"]:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_3__["bottom"]:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_3__["right"]:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_3__["left"]:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? Object(_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === \'y\' ? \'height\' : \'width\';\n\n    switch (variation) {\n      case _enums_js__WEBPACK_IMPORTED_MODULE_3__["start"]:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case _enums_js__WEBPACK_IMPORTED_MODULE_3__["end"]:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/computeOffsets.js?')},"./node_modules/@popperjs/core/lib/utils/debounce.js":function node_modulesPopperjsCoreLibUtilsDebounceJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return debounce; });\nfunction debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/debounce.js?')},"./node_modules/@popperjs/core/lib/utils/detectOverflow.js":function node_modulesPopperjsCoreLibUtilsDetectOverflowJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return detectOverflow; });\n/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");\n/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js");\n/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");\n/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");\n/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");\n/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");\n/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["clippingParents"] : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["viewport"] : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"] : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = Object(_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])(typeof padding !== \'number\' ? padding : Object(_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_8__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_5__["basePlacements"]));\n  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"] ? _enums_js__WEBPACK_IMPORTED_MODULE_5__["reference"] : _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"];\n  var referenceElement = state.elements.reference;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = Object(_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__["isElement"])(element) ? element : element.contextElement || Object(_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = Object(_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(referenceElement);\n  var popperOffsets = Object(_computeOffsets_js__WEBPACK_IMPORTED_MODULE_3__["default"])({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: \'absolute\',\n    placement: placement\n  });\n  var popperClientRect = Object(_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_4__["default"])(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"] ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__["popper"] && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_5__["right"], _enums_js__WEBPACK_IMPORTED_MODULE_5__["bottom"]].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_5__["top"], _enums_js__WEBPACK_IMPORTED_MODULE_5__["bottom"]].indexOf(key) >= 0 ? \'y\' : \'x\';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/detectOverflow.js?')},"./node_modules/@popperjs/core/lib/utils/expandToHashMap.js":function node_modulesPopperjsCoreLibUtilsExpandToHashMapJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return expandToHashMap; });\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/expandToHashMap.js?')},"./node_modules/@popperjs/core/lib/utils/format.js":function node_modulesPopperjsCoreLibUtilsFormatJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return format; });\nfunction format(str) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return [].concat(args).reduce(function (p, c) {\n    return p.replace(/%s/, c);\n  }, str);\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/format.js?')},"./node_modules/@popperjs/core/lib/utils/getAltAxis.js":function node_modulesPopperjsCoreLibUtilsGetAltAxisJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getAltAxis; });\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getAltAxis.js?")},"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js":function node_modulesPopperjsCoreLibUtilsGetBasePlacementJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getBasePlacement; });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n\nfunction getBasePlacement(placement) {\n  return placement.split(\'-\')[0];\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getBasePlacement.js?')},"./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":function node_modulesPopperjsCoreLibUtilsGetFreshSideObjectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getFreshSideObject; });\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js?')},"./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":function node_modulesPopperjsCoreLibUtilsGetMainAxisFromPlacementJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getMainAxisFromPlacement; });\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js?")},"./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":function node_modulesPopperjsCoreLibUtilsGetOppositePlacementJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getOppositePlacement; });\nvar hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js?")},"./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":function node_modulesPopperjsCoreLibUtilsGetOppositeVariationPlacementJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getOppositeVariationPlacement; });\nvar hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js?")},"./node_modules/@popperjs/core/lib/utils/getVariation.js":function node_modulesPopperjsCoreLibUtilsGetVariationJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return getVariation; });\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/getVariation.js?")},"./node_modules/@popperjs/core/lib/utils/math.js":function node_modulesPopperjsCoreLibUtilsMathJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/math.js?')},"./node_modules/@popperjs/core/lib/utils/mergeByName.js":function node_modulesPopperjsCoreLibUtilsMergeByNameJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mergeByName; });\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/mergeByName.js?')},"./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":function node_modulesPopperjsCoreLibUtilsMergePaddingObjectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mergePaddingObject; });\n/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, Object(_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(), paddingObject);\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js?')},"./node_modules/@popperjs/core/lib/utils/orderModifiers.js":function node_modulesPopperjsCoreLibUtilsOrderModifiersJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return orderModifiers; });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return _enums_js__WEBPACK_IMPORTED_MODULE_0__["modifierPhases"].reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/orderModifiers.js?')},"./node_modules/@popperjs/core/lib/utils/rectToClientRect.js":function node_modulesPopperjsCoreLibUtilsRectToClientRectJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return rectToClientRect; });\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/rectToClientRect.js?')},"./node_modules/@popperjs/core/lib/utils/uniqueBy.js":function node_modulesPopperjsCoreLibUtilsUniqueByJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return uniqueBy; });\nfunction uniqueBy(arr, fn) {\n  var identifiers = new Set();\n  return arr.filter(function (item) {\n    var identifier = fn(item);\n\n    if (!identifiers.has(identifier)) {\n      identifiers.add(identifier);\n      return true;\n    }\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/uniqueBy.js?')},"./node_modules/@popperjs/core/lib/utils/validateModifiers.js":function node_modulesPopperjsCoreLibUtilsValidateModifiersJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return validateModifiers; });\n/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format.js */ "./node_modules/@popperjs/core/lib/utils/format.js");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");\n\n\nvar INVALID_MODIFIER_ERROR = \'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s\';\nvar MISSING_DEPENDENCY_ERROR = \'Popper: modifier "%s" requires "%s", but "%s" modifier is not available\';\nvar VALID_PROPERTIES = [\'name\', \'enabled\', \'phase\', \'fn\', \'effect\', \'requires\', \'options\'];\nfunction validateModifiers(modifiers) {\n  modifiers.forEach(function (modifier) {\n    Object.keys(modifier).forEach(function (key) {\n      switch (key) {\n        case \'name\':\n          if (typeof modifier.name !== \'string\') {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, String(modifier.name), \'"name"\', \'"string"\', "\\"" + String(modifier.name) + "\\""));\n          }\n\n          break;\n\n        case \'enabled\':\n          if (typeof modifier.enabled !== \'boolean\') {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, \'"enabled"\', \'"boolean"\', "\\"" + String(modifier.enabled) + "\\""));\n          }\n\n        case \'phase\':\n          if (_enums_js__WEBPACK_IMPORTED_MODULE_1__["modifierPhases"].indexOf(modifier.phase) < 0) {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, \'"phase"\', "either " + _enums_js__WEBPACK_IMPORTED_MODULE_1__["modifierPhases"].join(\', \'), "\\"" + String(modifier.phase) + "\\""));\n          }\n\n          break;\n\n        case \'fn\':\n          if (typeof modifier.fn !== \'function\') {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, \'"fn"\', \'"function"\', "\\"" + String(modifier.fn) + "\\""));\n          }\n\n          break;\n\n        case \'effect\':\n          if (typeof modifier.effect !== \'function\') {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, \'"effect"\', \'"function"\', "\\"" + String(modifier.fn) + "\\""));\n          }\n\n          break;\n\n        case \'requires\':\n          if (!Array.isArray(modifier.requires)) {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, \'"requires"\', \'"array"\', "\\"" + String(modifier.requires) + "\\""));\n          }\n\n          break;\n\n        case \'requiresIfExists\':\n          if (!Array.isArray(modifier.requiresIfExists)) {\n            console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, \'"requiresIfExists"\', \'"array"\', "\\"" + String(modifier.requiresIfExists) + "\\""));\n          }\n\n          break;\n\n        case \'options\':\n        case \'data\':\n          break;\n\n        default:\n          console.error("PopperJS: an invalid property has been provided to the \\"" + modifier.name + "\\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {\n            return "\\"" + s + "\\"";\n          }).join(\', \') + "; but \\"" + key + "\\" was provided.");\n      }\n\n      modifier.requires && modifier.requires.forEach(function (requirement) {\n        if (modifiers.find(function (mod) {\n          return mod.name === requirement;\n        }) == null) {\n          console.error(Object(_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));\n        }\n      });\n    });\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/validateModifiers.js?')},"./node_modules/@popperjs/core/lib/utils/within.js":function node_modulesPopperjsCoreLibUtilsWithinJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return within; });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");\n\nfunction within(min, value, max) {\n  return Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["max"])(min, Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["min"])(value, max));\n}\n\n//# sourceURL=webpack:///./node_modules/@popperjs/core/lib/utils/within.js?')},"./node_modules/bootstrap/dist/js/bootstrap.esm.js":function node_modulesBootstrapDistJsBootstrapEsmJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Alert\", function() { return Alert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Button\", function() { return Button; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Carousel\", function() { return Carousel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Collapse\", function() { return Collapse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dropdown\", function() { return Dropdown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Modal\", function() { return Modal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Offcanvas\", function() { return Offcanvas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Popover\", function() { return Popover; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ScrollSpy\", function() { return ScrollSpy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tab\", function() { return Tab; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Toast\", function() { return Toast; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tooltip\", function() { return Tooltip; });\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ \"./node_modules/@popperjs/core/lib/index.js\");\n/*!\n  * Bootstrap v5.0.1 (https://getbootstrap.com/)\n  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): dom/selector-engine.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\nconst NODE_TEXT = 3;\nconst SelectorEngine = {\n  find(selector, element = document.documentElement) {\n    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\n  },\n\n  findOne(selector, element = document.documentElement) {\n    return Element.prototype.querySelector.call(element, selector);\n  },\n\n  children(element, selector) {\n    return [].concat(...element.children).filter(child => child.matches(selector));\n  },\n\n  parents(element, selector) {\n    const parents = [];\n    let ancestor = element.parentNode;\n\n    while (ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT) {\n      if (ancestor.matches(selector)) {\n        parents.push(ancestor);\n      }\n\n      ancestor = ancestor.parentNode;\n    }\n\n    return parents;\n  },\n\n  prev(element, selector) {\n    let previous = element.previousElementSibling;\n\n    while (previous) {\n      if (previous.matches(selector)) {\n        return [previous];\n      }\n\n      previous = previous.previousElementSibling;\n    }\n\n    return [];\n  },\n\n  next(element, selector) {\n    let next = element.nextElementSibling;\n\n    while (next) {\n      if (next.matches(selector)) {\n        return [next];\n      }\n\n      next = next.nextElementSibling;\n    }\n\n    return [];\n  }\n\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): util/index.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nconst MAX_UID = 1000000;\nconst MILLISECONDS_MULTIPLIER = 1000;\nconst TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\nconst toType = obj => {\n  if (obj === null || obj === undefined) {\n    return `${obj}`;\n  }\n\n  return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n};\n/**\n * --------------------------------------------------------------------------\n * Public Util Api\n * --------------------------------------------------------------------------\n */\n\n\nconst getUID = prefix => {\n  do {\n    prefix += Math.floor(Math.random() * MAX_UID);\n  } while (document.getElementById(prefix));\n\n  return prefix;\n};\n\nconst getSelector = element => {\n  let selector = element.getAttribute('data-bs-target');\n\n  if (!selector || selector === '#') {\n    let hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,\n    // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n    // `document.querySelector` will rightfully complain it is invalid.\n    // See https://github.com/twbs/bootstrap/issues/32273\n\n    if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {\n      return null;\n    } // Just in case some CMS puts out a full URL with the anchor appended\n\n\n    if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {\n      hrefAttr = `#${hrefAttr.split('#')[1]}`;\n    }\n\n    selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;\n  }\n\n  return selector;\n};\n\nconst getSelectorFromElement = element => {\n  const selector = getSelector(element);\n\n  if (selector) {\n    return document.querySelector(selector) ? selector : null;\n  }\n\n  return null;\n};\n\nconst getElementFromSelector = element => {\n  const selector = getSelector(element);\n  return selector ? document.querySelector(selector) : null;\n};\n\nconst getTransitionDurationFromElement = element => {\n  if (!element) {\n    return 0;\n  } // Get transition-duration of the element\n\n\n  let {\n    transitionDuration,\n    transitionDelay\n  } = window.getComputedStyle(element);\n  const floatTransitionDuration = Number.parseFloat(transitionDuration);\n  const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\n\n  if (!floatTransitionDuration && !floatTransitionDelay) {\n    return 0;\n  } // If multiple durations are defined, take the first\n\n\n  transitionDuration = transitionDuration.split(',')[0];\n  transitionDelay = transitionDelay.split(',')[0];\n  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n};\n\nconst triggerTransitionEnd = element => {\n  element.dispatchEvent(new Event(TRANSITION_END));\n};\n\nconst isElement = obj => {\n  if (!obj || typeof obj !== 'object') {\n    return false;\n  }\n\n  if (typeof obj.jquery !== 'undefined') {\n    obj = obj[0];\n  }\n\n  return typeof obj.nodeType !== 'undefined';\n};\n\nconst getElement = obj => {\n  if (isElement(obj)) {\n    // it's a jQuery object or a node element\n    return obj.jquery ? obj[0] : obj;\n  }\n\n  if (typeof obj === 'string' && obj.length > 0) {\n    return SelectorEngine.findOne(obj);\n  }\n\n  return null;\n};\n\nconst emulateTransitionEnd = (element, duration) => {\n  let called = false;\n  const durationPadding = 5;\n  const emulatedDuration = duration + durationPadding;\n\n  function listener() {\n    called = true;\n    element.removeEventListener(TRANSITION_END, listener);\n  }\n\n  element.addEventListener(TRANSITION_END, listener);\n  setTimeout(() => {\n    if (!called) {\n      triggerTransitionEnd(element);\n    }\n  }, emulatedDuration);\n};\n\nconst typeCheckConfig = (componentName, config, configTypes) => {\n  Object.keys(configTypes).forEach(property => {\n    const expectedTypes = configTypes[property];\n    const value = config[property];\n    const valueType = value && isElement(value) ? 'element' : toType(value);\n\n    if (!new RegExp(expectedTypes).test(valueType)) {\n      throw new TypeError(`${componentName.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\n    }\n  });\n};\n\nconst isVisible = element => {\n  if (!element) {\n    return false;\n  }\n\n  if (element.style && element.parentNode && element.parentNode.style) {\n    const elementStyle = getComputedStyle(element);\n    const parentNodeStyle = getComputedStyle(element.parentNode);\n    return elementStyle.display !== 'none' && parentNodeStyle.display !== 'none' && elementStyle.visibility !== 'hidden';\n  }\n\n  return false;\n};\n\nconst isDisabled = element => {\n  if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n    return true;\n  }\n\n  if (element.classList.contains('disabled')) {\n    return true;\n  }\n\n  if (typeof element.disabled !== 'undefined') {\n    return element.disabled;\n  }\n\n  return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';\n};\n\nconst findShadowRoot = element => {\n  if (!document.documentElement.attachShadow) {\n    return null;\n  } // Can find the shadow root otherwise it'll return the document\n\n\n  if (typeof element.getRootNode === 'function') {\n    const root = element.getRootNode();\n    return root instanceof ShadowRoot ? root : null;\n  }\n\n  if (element instanceof ShadowRoot) {\n    return element;\n  } // when we don't find a shadow root\n\n\n  if (!element.parentNode) {\n    return null;\n  }\n\n  return findShadowRoot(element.parentNode);\n};\n\nconst noop = () => {};\n\nconst reflow = element => element.offsetHeight;\n\nconst getjQuery = () => {\n  const {\n    jQuery\n  } = window;\n\n  if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\n    return jQuery;\n  }\n\n  return null;\n};\n\nconst onDOMContentLoaded = callback => {\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', callback);\n  } else {\n    callback();\n  }\n};\n\nconst isRTL = () => document.documentElement.dir === 'rtl';\n\nconst defineJQueryPlugin = plugin => {\n  onDOMContentLoaded(() => {\n    const $ = getjQuery();\n    /* istanbul ignore if */\n\n    if ($) {\n      const name = plugin.NAME;\n      const JQUERY_NO_CONFLICT = $.fn[name];\n      $.fn[name] = plugin.jQueryInterface;\n      $.fn[name].Constructor = plugin;\n\n      $.fn[name].noConflict = () => {\n        $.fn[name] = JQUERY_NO_CONFLICT;\n        return plugin.jQueryInterface;\n      };\n    }\n  });\n};\n\nconst execute = callback => {\n  if (typeof callback === 'function') {\n    callback();\n  }\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): dom/data.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\nconst elementMap = new Map();\nvar Data = {\n  set(element, key, instance) {\n    if (!elementMap.has(element)) {\n      elementMap.set(element, new Map());\n    }\n\n    const instanceMap = elementMap.get(element); // make it clear we only want one instance per element\n    // can be removed later when multiple key/instances are fine to be used\n\n    if (!instanceMap.has(key) && instanceMap.size !== 0) {\n      // eslint-disable-next-line no-console\n      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);\n      return;\n    }\n\n    instanceMap.set(key, instance);\n  },\n\n  get(element, key) {\n    if (elementMap.has(element)) {\n      return elementMap.get(element).get(key) || null;\n    }\n\n    return null;\n  },\n\n  remove(element, key) {\n    if (!elementMap.has(element)) {\n      return;\n    }\n\n    const instanceMap = elementMap.get(element);\n    instanceMap.delete(key); // free up element references if there are no instances left for an element\n\n    if (instanceMap.size === 0) {\n      elementMap.delete(element);\n    }\n  }\n\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): dom/event-handler.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\nconst stripNameRegex = /\\..*/;\nconst stripUidRegex = /::\\d+$/;\nconst eventRegistry = {}; // Events storage\n\nlet uidEvent = 1;\nconst customEvents = {\n  mouseenter: 'mouseover',\n  mouseleave: 'mouseout'\n};\nconst customEventsRegex = /^(mouseenter|mouseleave)/i;\nconst nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);\n/**\n * ------------------------------------------------------------------------\n * Private methods\n * ------------------------------------------------------------------------\n */\n\nfunction getUidEvent(element, uid) {\n  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;\n}\n\nfunction getEvent(element) {\n  const uid = getUidEvent(element);\n  element.uidEvent = uid;\n  eventRegistry[uid] = eventRegistry[uid] || {};\n  return eventRegistry[uid];\n}\n\nfunction bootstrapHandler(element, fn) {\n  return function handler(event) {\n    event.delegateTarget = element;\n\n    if (handler.oneOff) {\n      EventHandler.off(element, event.type, fn);\n    }\n\n    return fn.apply(element, [event]);\n  };\n}\n\nfunction bootstrapDelegationHandler(element, selector, fn) {\n  return function handler(event) {\n    const domElements = element.querySelectorAll(selector);\n\n    for (let {\n      target\n    } = event; target && target !== this; target = target.parentNode) {\n      for (let i = domElements.length; i--;) {\n        if (domElements[i] === target) {\n          event.delegateTarget = target;\n\n          if (handler.oneOff) {\n            // eslint-disable-next-line unicorn/consistent-destructuring\n            EventHandler.off(element, event.type, selector, fn);\n          }\n\n          return fn.apply(target, [event]);\n        }\n      }\n    } // To please ESLint\n\n\n    return null;\n  };\n}\n\nfunction findHandler(events, handler, delegationSelector = null) {\n  const uidEventList = Object.keys(events);\n\n  for (let i = 0, len = uidEventList.length; i < len; i++) {\n    const event = events[uidEventList[i]];\n\n    if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {\n      return event;\n    }\n  }\n\n  return null;\n}\n\nfunction normalizeParams(originalTypeEvent, handler, delegationFn) {\n  const delegation = typeof handler === 'string';\n  const originalHandler = delegation ? delegationFn : handler;\n  let typeEvent = getTypeEvent(originalTypeEvent);\n  const isNative = nativeEvents.has(typeEvent);\n\n  if (!isNative) {\n    typeEvent = originalTypeEvent;\n  }\n\n  return [delegation, originalHandler, typeEvent];\n}\n\nfunction addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {\n  if (typeof originalTypeEvent !== 'string' || !element) {\n    return;\n  }\n\n  if (!handler) {\n    handler = delegationFn;\n    delegationFn = null;\n  } // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\n  // this prevents the handler from being dispatched the same way as mouseover or mouseout does\n\n\n  if (customEventsRegex.test(originalTypeEvent)) {\n    const wrapFn = fn => {\n      return function (event) {\n        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n          return fn.call(this, event);\n        }\n      };\n    };\n\n    if (delegationFn) {\n      delegationFn = wrapFn(delegationFn);\n    } else {\n      handler = wrapFn(handler);\n    }\n  }\n\n  const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);\n  const events = getEvent(element);\n  const handlers = events[typeEvent] || (events[typeEvent] = {});\n  const previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);\n\n  if (previousFn) {\n    previousFn.oneOff = previousFn.oneOff && oneOff;\n    return;\n  }\n\n  const uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, ''));\n  const fn = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler);\n  fn.delegationSelector = delegation ? handler : null;\n  fn.originalHandler = originalHandler;\n  fn.oneOff = oneOff;\n  fn.uidEvent = uid;\n  handlers[uid] = fn;\n  element.addEventListener(typeEvent, fn, delegation);\n}\n\nfunction removeHandler(element, events, typeEvent, handler, delegationSelector) {\n  const fn = findHandler(events[typeEvent], handler, delegationSelector);\n\n  if (!fn) {\n    return;\n  }\n\n  element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\n  delete events[typeEvent][fn.uidEvent];\n}\n\nfunction removeNamespacedHandlers(element, events, typeEvent, namespace) {\n  const storeElementEvent = events[typeEvent] || {};\n  Object.keys(storeElementEvent).forEach(handlerKey => {\n    if (handlerKey.includes(namespace)) {\n      const event = storeElementEvent[handlerKey];\n      removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);\n    }\n  });\n}\n\nfunction getTypeEvent(event) {\n  // allow to get the native events from namespaced events ('click.bs.button' --\x3e 'click')\n  event = event.replace(stripNameRegex, '');\n  return customEvents[event] || event;\n}\n\nconst EventHandler = {\n  on(element, event, handler, delegationFn) {\n    addHandler(element, event, handler, delegationFn, false);\n  },\n\n  one(element, event, handler, delegationFn) {\n    addHandler(element, event, handler, delegationFn, true);\n  },\n\n  off(element, originalTypeEvent, handler, delegationFn) {\n    if (typeof originalTypeEvent !== 'string' || !element) {\n      return;\n    }\n\n    const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);\n    const inNamespace = typeEvent !== originalTypeEvent;\n    const events = getEvent(element);\n    const isNamespace = originalTypeEvent.startsWith('.');\n\n    if (typeof originalHandler !== 'undefined') {\n      // Simplest case: handler is passed, remove that listener ONLY.\n      if (!events || !events[typeEvent]) {\n        return;\n      }\n\n      removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null);\n      return;\n    }\n\n    if (isNamespace) {\n      Object.keys(events).forEach(elementEvent => {\n        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\n      });\n    }\n\n    const storeElementEvent = events[typeEvent] || {};\n    Object.keys(storeElementEvent).forEach(keyHandlers => {\n      const handlerKey = keyHandlers.replace(stripUidRegex, '');\n\n      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n        const event = storeElementEvent[keyHandlers];\n        removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);\n      }\n    });\n  },\n\n  trigger(element, event, args) {\n    if (typeof event !== 'string' || !element) {\n      return null;\n    }\n\n    const $ = getjQuery();\n    const typeEvent = getTypeEvent(event);\n    const inNamespace = event !== typeEvent;\n    const isNative = nativeEvents.has(typeEvent);\n    let jQueryEvent;\n    let bubbles = true;\n    let nativeDispatch = true;\n    let defaultPrevented = false;\n    let evt = null;\n\n    if (inNamespace && $) {\n      jQueryEvent = $.Event(event, args);\n      $(element).trigger(jQueryEvent);\n      bubbles = !jQueryEvent.isPropagationStopped();\n      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n      defaultPrevented = jQueryEvent.isDefaultPrevented();\n    }\n\n    if (isNative) {\n      evt = document.createEvent('HTMLEvents');\n      evt.initEvent(typeEvent, bubbles, true);\n    } else {\n      evt = new CustomEvent(event, {\n        bubbles,\n        cancelable: true\n      });\n    } // merge custom information in our event\n\n\n    if (typeof args !== 'undefined') {\n      Object.keys(args).forEach(key => {\n        Object.defineProperty(evt, key, {\n          get() {\n            return args[key];\n          }\n\n        });\n      });\n    }\n\n    if (defaultPrevented) {\n      evt.preventDefault();\n    }\n\n    if (nativeDispatch) {\n      element.dispatchEvent(evt);\n    }\n\n    if (evt.defaultPrevented && typeof jQueryEvent !== 'undefined') {\n      jQueryEvent.preventDefault();\n    }\n\n    return evt;\n  }\n\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): base-component.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst VERSION = '5.0.1';\n\nclass BaseComponent {\n  constructor(element) {\n    element = getElement(element);\n\n    if (!element) {\n      return;\n    }\n\n    this._element = element;\n    Data.set(this._element, this.constructor.DATA_KEY, this);\n  }\n\n  dispose() {\n    Data.remove(this._element, this.constructor.DATA_KEY);\n    EventHandler.off(this._element, this.constructor.EVENT_KEY);\n    Object.getOwnPropertyNames(this).forEach(propertyName => {\n      this[propertyName] = null;\n    });\n  }\n\n  _queueCallback(callback, element, isAnimated = true) {\n    if (!isAnimated) {\n      execute(callback);\n      return;\n    }\n\n    const transitionDuration = getTransitionDurationFromElement(element);\n    EventHandler.one(element, 'transitionend', () => execute(callback));\n    emulateTransitionEnd(element, transitionDuration);\n  }\n  /** Static */\n\n\n  static getInstance(element) {\n    return Data.get(element, this.DATA_KEY);\n  }\n\n  static get VERSION() {\n    return VERSION;\n  }\n\n  static get NAME() {\n    throw new Error('You have to implement the static method \"NAME\", for each component!');\n  }\n\n  static get DATA_KEY() {\n    return `bs.${this.NAME}`;\n  }\n\n  static get EVENT_KEY() {\n    return `.${this.DATA_KEY}`;\n  }\n\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): alert.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$c = 'alert';\nconst DATA_KEY$b = 'bs.alert';\nconst EVENT_KEY$b = `.${DATA_KEY$b}`;\nconst DATA_API_KEY$8 = '.data-api';\nconst SELECTOR_DISMISS = '[data-bs-dismiss=\"alert\"]';\nconst EVENT_CLOSE = `close${EVENT_KEY$b}`;\nconst EVENT_CLOSED = `closed${EVENT_KEY$b}`;\nconst EVENT_CLICK_DATA_API$7 = `click${EVENT_KEY$b}${DATA_API_KEY$8}`;\nconst CLASS_NAME_ALERT = 'alert';\nconst CLASS_NAME_FADE$6 = 'fade';\nconst CLASS_NAME_SHOW$9 = 'show';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Alert extends BaseComponent {\n  // Getters\n  static get NAME() {\n    return NAME$c;\n  } // Public\n\n\n  close(element) {\n    const rootElement = element ? this._getRootElement(element) : this._element;\n\n    const customEvent = this._triggerCloseEvent(rootElement);\n\n    if (customEvent === null || customEvent.defaultPrevented) {\n      return;\n    }\n\n    this._removeElement(rootElement);\n  } // Private\n\n\n  _getRootElement(element) {\n    return getElementFromSelector(element) || element.closest(`.${CLASS_NAME_ALERT}`);\n  }\n\n  _triggerCloseEvent(element) {\n    return EventHandler.trigger(element, EVENT_CLOSE);\n  }\n\n  _removeElement(element) {\n    element.classList.remove(CLASS_NAME_SHOW$9);\n    const isAnimated = element.classList.contains(CLASS_NAME_FADE$6);\n\n    this._queueCallback(() => this._destroyElement(element), element, isAnimated);\n  }\n\n  _destroyElement(element) {\n    if (element.parentNode) {\n      element.parentNode.removeChild(element);\n    }\n\n    EventHandler.trigger(element, EVENT_CLOSED);\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      let data = Data.get(this, DATA_KEY$b);\n\n      if (!data) {\n        data = new Alert(this);\n      }\n\n      if (config === 'close') {\n        data[config](this);\n      }\n    });\n  }\n\n  static handleDismiss(alertInstance) {\n    return function (event) {\n      if (event) {\n        event.preventDefault();\n      }\n\n      alertInstance.close(this);\n    };\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$7, SELECTOR_DISMISS, Alert.handleDismiss(new Alert()));\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Alert to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Alert);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): button.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$b = 'button';\nconst DATA_KEY$a = 'bs.button';\nconst EVENT_KEY$a = `.${DATA_KEY$a}`;\nconst DATA_API_KEY$7 = '.data-api';\nconst CLASS_NAME_ACTIVE$3 = 'active';\nconst SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\nconst EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$7}`;\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Button extends BaseComponent {\n  // Getters\n  static get NAME() {\n    return NAME$b;\n  } // Public\n\n\n  toggle() {\n    // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\n    this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      let data = Data.get(this, DATA_KEY$a);\n\n      if (!data) {\n        data = new Button(this);\n      }\n\n      if (config === 'toggle') {\n        data[config]();\n      }\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {\n  event.preventDefault();\n  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\n  let data = Data.get(button, DATA_KEY$a);\n\n  if (!data) {\n    data = new Button(button);\n  }\n\n  data.toggle();\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Button to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Button);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): dom/manipulator.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\nfunction normalizeData(val) {\n  if (val === 'true') {\n    return true;\n  }\n\n  if (val === 'false') {\n    return false;\n  }\n\n  if (val === Number(val).toString()) {\n    return Number(val);\n  }\n\n  if (val === '' || val === 'null') {\n    return null;\n  }\n\n  return val;\n}\n\nfunction normalizeDataKey(key) {\n  return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);\n}\n\nconst Manipulator = {\n  setDataAttribute(element, key, value) {\n    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);\n  },\n\n  removeDataAttribute(element, key) {\n    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);\n  },\n\n  getDataAttributes(element) {\n    if (!element) {\n      return {};\n    }\n\n    const attributes = {};\n    Object.keys(element.dataset).filter(key => key.startsWith('bs')).forEach(key => {\n      let pureKey = key.replace(/^bs/, '');\n      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\n      attributes[pureKey] = normalizeData(element.dataset[key]);\n    });\n    return attributes;\n  },\n\n  getDataAttribute(element, key) {\n    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));\n  },\n\n  offset(element) {\n    const rect = element.getBoundingClientRect();\n    return {\n      top: rect.top + document.body.scrollTop,\n      left: rect.left + document.body.scrollLeft\n    };\n  },\n\n  position(element) {\n    return {\n      top: element.offsetTop,\n      left: element.offsetLeft\n    };\n  }\n\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): carousel.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$a = 'carousel';\nconst DATA_KEY$9 = 'bs.carousel';\nconst EVENT_KEY$9 = `.${DATA_KEY$9}`;\nconst DATA_API_KEY$6 = '.data-api';\nconst ARROW_LEFT_KEY = 'ArrowLeft';\nconst ARROW_RIGHT_KEY = 'ArrowRight';\nconst TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\nconst SWIPE_THRESHOLD = 40;\nconst Default$9 = {\n  interval: 5000,\n  keyboard: true,\n  slide: false,\n  pause: 'hover',\n  wrap: true,\n  touch: true\n};\nconst DefaultType$9 = {\n  interval: '(number|boolean)',\n  keyboard: 'boolean',\n  slide: '(boolean|string)',\n  pause: '(string|boolean)',\n  wrap: 'boolean',\n  touch: 'boolean'\n};\nconst ORDER_NEXT = 'next';\nconst ORDER_PREV = 'prev';\nconst DIRECTION_LEFT = 'left';\nconst DIRECTION_RIGHT = 'right';\nconst EVENT_SLIDE = `slide${EVENT_KEY$9}`;\nconst EVENT_SLID = `slid${EVENT_KEY$9}`;\nconst EVENT_KEYDOWN = `keydown${EVENT_KEY$9}`;\nconst EVENT_MOUSEENTER = `mouseenter${EVENT_KEY$9}`;\nconst EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY$9}`;\nconst EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;\nconst EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;\nconst EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;\nconst EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;\nconst EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;\nconst EVENT_DRAG_START = `dragstart${EVENT_KEY$9}`;\nconst EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$9}${DATA_API_KEY$6}`;\nconst EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$9}${DATA_API_KEY$6}`;\nconst CLASS_NAME_CAROUSEL = 'carousel';\nconst CLASS_NAME_ACTIVE$2 = 'active';\nconst CLASS_NAME_SLIDE = 'slide';\nconst CLASS_NAME_END = 'carousel-item-end';\nconst CLASS_NAME_START = 'carousel-item-start';\nconst CLASS_NAME_NEXT = 'carousel-item-next';\nconst CLASS_NAME_PREV = 'carousel-item-prev';\nconst CLASS_NAME_POINTER_EVENT = 'pointer-event';\nconst SELECTOR_ACTIVE$1 = '.active';\nconst SELECTOR_ACTIVE_ITEM = '.active.carousel-item';\nconst SELECTOR_ITEM = '.carousel-item';\nconst SELECTOR_ITEM_IMG = '.carousel-item img';\nconst SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';\nconst SELECTOR_INDICATORS = '.carousel-indicators';\nconst SELECTOR_INDICATOR = '[data-bs-target]';\nconst SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\nconst SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\nconst POINTER_TYPE_TOUCH = 'touch';\nconst POINTER_TYPE_PEN = 'pen';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Carousel extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._items = null;\n    this._interval = null;\n    this._activeElement = null;\n    this._isPaused = false;\n    this._isSliding = false;\n    this.touchTimeout = null;\n    this.touchStartX = 0;\n    this.touchDeltaX = 0;\n    this._config = this._getConfig(config);\n    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\n    this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n    this._pointerEvent = Boolean(window.PointerEvent);\n\n    this._addEventListeners();\n  } // Getters\n\n\n  static get Default() {\n    return Default$9;\n  }\n\n  static get NAME() {\n    return NAME$a;\n  } // Public\n\n\n  next() {\n    if (!this._isSliding) {\n      this._slide(ORDER_NEXT);\n    }\n  }\n\n  nextWhenVisible() {\n    // Don't call next when the page isn't visible\n    // or the carousel or its parent isn't visible\n    if (!document.hidden && isVisible(this._element)) {\n      this.next();\n    }\n  }\n\n  prev() {\n    if (!this._isSliding) {\n      this._slide(ORDER_PREV);\n    }\n  }\n\n  pause(event) {\n    if (!event) {\n      this._isPaused = true;\n    }\n\n    if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) {\n      triggerTransitionEnd(this._element);\n      this.cycle(true);\n    }\n\n    clearInterval(this._interval);\n    this._interval = null;\n  }\n\n  cycle(event) {\n    if (!event) {\n      this._isPaused = false;\n    }\n\n    if (this._interval) {\n      clearInterval(this._interval);\n      this._interval = null;\n    }\n\n    if (this._config && this._config.interval && !this._isPaused) {\n      this._updateInterval();\n\n      this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\n    }\n  }\n\n  to(index) {\n    this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n\n    const activeIndex = this._getItemIndex(this._activeElement);\n\n    if (index > this._items.length - 1 || index < 0) {\n      return;\n    }\n\n    if (this._isSliding) {\n      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));\n      return;\n    }\n\n    if (activeIndex === index) {\n      this.pause();\n      this.cycle();\n      return;\n    }\n\n    const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n\n    this._slide(order, this._items[index]);\n  } // Private\n\n\n  _getConfig(config) {\n    config = { ...Default$9,\n      ...config\n    };\n    typeCheckConfig(NAME$a, config, DefaultType$9);\n    return config;\n  }\n\n  _handleSwipe() {\n    const absDeltax = Math.abs(this.touchDeltaX);\n\n    if (absDeltax <= SWIPE_THRESHOLD) {\n      return;\n    }\n\n    const direction = absDeltax / this.touchDeltaX;\n    this.touchDeltaX = 0;\n\n    if (!direction) {\n      return;\n    }\n\n    this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);\n  }\n\n  _addEventListeners() {\n    if (this._config.keyboard) {\n      EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));\n    }\n\n    if (this._config.pause === 'hover') {\n      EventHandler.on(this._element, EVENT_MOUSEENTER, event => this.pause(event));\n      EventHandler.on(this._element, EVENT_MOUSELEAVE, event => this.cycle(event));\n    }\n\n    if (this._config.touch && this._touchSupported) {\n      this._addTouchEventListeners();\n    }\n  }\n\n  _addTouchEventListeners() {\n    const start = event => {\n      if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {\n        this.touchStartX = event.clientX;\n      } else if (!this._pointerEvent) {\n        this.touchStartX = event.touches[0].clientX;\n      }\n    };\n\n    const move = event => {\n      // ensure swiping with one touch and not pinching\n      this.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this.touchStartX;\n    };\n\n    const end = event => {\n      if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {\n        this.touchDeltaX = event.clientX - this.touchStartX;\n      }\n\n      this._handleSwipe();\n\n      if (this._config.pause === 'hover') {\n        // If it's a touch-enabled device, mouseenter/leave are fired as\n        // part of the mouse compatibility events on first tap - the carousel\n        // would stop cycling until user tapped out of it;\n        // here, we listen for touchend, explicitly pause the carousel\n        // (as if it's the second time we tap on it, mouseenter compat event\n        // is NOT fired) and after a timeout (to allow for mouse compatibility\n        // events to fire) we explicitly restart cycling\n        this.pause();\n\n        if (this.touchTimeout) {\n          clearTimeout(this.touchTimeout);\n        }\n\n        this.touchTimeout = setTimeout(event => this.cycle(event), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\n      }\n    };\n\n    SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach(itemImg => {\n      EventHandler.on(itemImg, EVENT_DRAG_START, e => e.preventDefault());\n    });\n\n    if (this._pointerEvent) {\n      EventHandler.on(this._element, EVENT_POINTERDOWN, event => start(event));\n      EventHandler.on(this._element, EVENT_POINTERUP, event => end(event));\n\n      this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n    } else {\n      EventHandler.on(this._element, EVENT_TOUCHSTART, event => start(event));\n      EventHandler.on(this._element, EVENT_TOUCHMOVE, event => move(event));\n      EventHandler.on(this._element, EVENT_TOUCHEND, event => end(event));\n    }\n  }\n\n  _keydown(event) {\n    if (/input|textarea/i.test(event.target.tagName)) {\n      return;\n    }\n\n    if (event.key === ARROW_LEFT_KEY) {\n      event.preventDefault();\n\n      this._slide(DIRECTION_RIGHT);\n    } else if (event.key === ARROW_RIGHT_KEY) {\n      event.preventDefault();\n\n      this._slide(DIRECTION_LEFT);\n    }\n  }\n\n  _getItemIndex(element) {\n    this._items = element && element.parentNode ? SelectorEngine.find(SELECTOR_ITEM, element.parentNode) : [];\n    return this._items.indexOf(element);\n  }\n\n  _getItemByOrder(order, activeElement) {\n    const isNext = order === ORDER_NEXT;\n    const isPrev = order === ORDER_PREV;\n\n    const activeIndex = this._getItemIndex(activeElement);\n\n    const lastItemIndex = this._items.length - 1;\n    const isGoingToWrap = isPrev && activeIndex === 0 || isNext && activeIndex === lastItemIndex;\n\n    if (isGoingToWrap && !this._config.wrap) {\n      return activeElement;\n    }\n\n    const delta = isPrev ? -1 : 1;\n    const itemIndex = (activeIndex + delta) % this._items.length;\n    return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\n  }\n\n  _triggerSlideEvent(relatedTarget, eventDirectionName) {\n    const targetIndex = this._getItemIndex(relatedTarget);\n\n    const fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element));\n\n    return EventHandler.trigger(this._element, EVENT_SLIDE, {\n      relatedTarget,\n      direction: eventDirectionName,\n      from: fromIndex,\n      to: targetIndex\n    });\n  }\n\n  _setActiveIndicatorElement(element) {\n    if (this._indicatorsElement) {\n      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE$1, this._indicatorsElement);\n      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\n      activeIndicator.removeAttribute('aria-current');\n      const indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement);\n\n      for (let i = 0; i < indicators.length; i++) {\n        if (Number.parseInt(indicators[i].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(element)) {\n          indicators[i].classList.add(CLASS_NAME_ACTIVE$2);\n          indicators[i].setAttribute('aria-current', 'true');\n          break;\n        }\n      }\n    }\n  }\n\n  _updateInterval() {\n    const element = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n\n    if (!element) {\n      return;\n    }\n\n    const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\n\n    if (elementInterval) {\n      this._config.defaultInterval = this._config.defaultInterval || this._config.interval;\n      this._config.interval = elementInterval;\n    } else {\n      this._config.interval = this._config.defaultInterval || this._config.interval;\n    }\n  }\n\n  _slide(directionOrOrder, element) {\n    const order = this._directionToOrder(directionOrOrder);\n\n    const activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n\n    const activeElementIndex = this._getItemIndex(activeElement);\n\n    const nextElement = element || this._getItemByOrder(order, activeElement);\n\n    const nextElementIndex = this._getItemIndex(nextElement);\n\n    const isCycling = Boolean(this._interval);\n    const isNext = order === ORDER_NEXT;\n    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n\n    const eventDirectionName = this._orderToDirection(order);\n\n    if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE$2)) {\n      this._isSliding = false;\n      return;\n    }\n\n    const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\n\n    if (slideEvent.defaultPrevented) {\n      return;\n    }\n\n    if (!activeElement || !nextElement) {\n      // Some weirdness is happening, so we bail\n      return;\n    }\n\n    this._isSliding = true;\n\n    if (isCycling) {\n      this.pause();\n    }\n\n    this._setActiveIndicatorElement(nextElement);\n\n    this._activeElement = nextElement;\n\n    const triggerSlidEvent = () => {\n      EventHandler.trigger(this._element, EVENT_SLID, {\n        relatedTarget: nextElement,\n        direction: eventDirectionName,\n        from: activeElementIndex,\n        to: nextElementIndex\n      });\n    };\n\n    if (this._element.classList.contains(CLASS_NAME_SLIDE)) {\n      nextElement.classList.add(orderClassName);\n      reflow(nextElement);\n      activeElement.classList.add(directionalClassName);\n      nextElement.classList.add(directionalClassName);\n\n      const completeCallBack = () => {\n        nextElement.classList.remove(directionalClassName, orderClassName);\n        nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\n        this._isSliding = false;\n        setTimeout(triggerSlidEvent, 0);\n      };\n\n      this._queueCallback(completeCallBack, activeElement, true);\n    } else {\n      activeElement.classList.remove(CLASS_NAME_ACTIVE$2);\n      nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n      this._isSliding = false;\n      triggerSlidEvent();\n    }\n\n    if (isCycling) {\n      this.cycle();\n    }\n  }\n\n  _directionToOrder(direction) {\n    if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {\n      return direction;\n    }\n\n    if (isRTL()) {\n      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n    }\n\n    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n  }\n\n  _orderToDirection(order) {\n    if (![ORDER_NEXT, ORDER_PREV].includes(order)) {\n      return order;\n    }\n\n    if (isRTL()) {\n      return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n\n    return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n  } // Static\n\n\n  static carouselInterface(element, config) {\n    let data = Data.get(element, DATA_KEY$9);\n    let _config = { ...Default$9,\n      ...Manipulator.getDataAttributes(element)\n    };\n\n    if (typeof config === 'object') {\n      _config = { ..._config,\n        ...config\n      };\n    }\n\n    const action = typeof config === 'string' ? config : _config.slide;\n\n    if (!data) {\n      data = new Carousel(element, _config);\n    }\n\n    if (typeof config === 'number') {\n      data.to(config);\n    } else if (typeof action === 'string') {\n      if (typeof data[action] === 'undefined') {\n        throw new TypeError(`No method named \"${action}\"`);\n      }\n\n      data[action]();\n    } else if (_config.interval && _config.ride) {\n      data.pause();\n      data.cycle();\n    }\n  }\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      Carousel.carouselInterface(this, config);\n    });\n  }\n\n  static dataApiClickHandler(event) {\n    const target = getElementFromSelector(this);\n\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n      return;\n    }\n\n    const config = { ...Manipulator.getDataAttributes(target),\n      ...Manipulator.getDataAttributes(this)\n    };\n    const slideIndex = this.getAttribute('data-bs-slide-to');\n\n    if (slideIndex) {\n      config.interval = false;\n    }\n\n    Carousel.carouselInterface(target, config);\n\n    if (slideIndex) {\n      Data.get(target, DATA_KEY$9).to(slideIndex);\n    }\n\n    event.preventDefault();\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);\nEventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {\n  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n\n  for (let i = 0, len = carousels.length; i < len; i++) {\n    Carousel.carouselInterface(carousels[i], Data.get(carousels[i], DATA_KEY$9));\n  }\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Carousel to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Carousel);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): collapse.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$9 = 'collapse';\nconst DATA_KEY$8 = 'bs.collapse';\nconst EVENT_KEY$8 = `.${DATA_KEY$8}`;\nconst DATA_API_KEY$5 = '.data-api';\nconst Default$8 = {\n  toggle: true,\n  parent: ''\n};\nconst DefaultType$8 = {\n  toggle: 'boolean',\n  parent: '(string|element)'\n};\nconst EVENT_SHOW$5 = `show${EVENT_KEY$8}`;\nconst EVENT_SHOWN$5 = `shown${EVENT_KEY$8}`;\nconst EVENT_HIDE$5 = `hide${EVENT_KEY$8}`;\nconst EVENT_HIDDEN$5 = `hidden${EVENT_KEY$8}`;\nconst EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;\nconst CLASS_NAME_SHOW$8 = 'show';\nconst CLASS_NAME_COLLAPSE = 'collapse';\nconst CLASS_NAME_COLLAPSING = 'collapsing';\nconst CLASS_NAME_COLLAPSED = 'collapsed';\nconst WIDTH = 'width';\nconst HEIGHT = 'height';\nconst SELECTOR_ACTIVES = '.show, .collapsing';\nconst SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Collapse extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._isTransitioning = false;\n    this._config = this._getConfig(config);\n    this._triggerArray = SelectorEngine.find(`${SELECTOR_DATA_TOGGLE$4}[href=\"#${this._element.id}\"],` + `${SELECTOR_DATA_TOGGLE$4}[data-bs-target=\"#${this._element.id}\"]`);\n    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\n\n    for (let i = 0, len = toggleList.length; i < len; i++) {\n      const elem = toggleList[i];\n      const selector = getSelectorFromElement(elem);\n      const filterElement = SelectorEngine.find(selector).filter(foundElem => foundElem === this._element);\n\n      if (selector !== null && filterElement.length) {\n        this._selector = selector;\n\n        this._triggerArray.push(elem);\n      }\n    }\n\n    this._parent = this._config.parent ? this._getParent() : null;\n\n    if (!this._config.parent) {\n      this._addAriaAndCollapsedClass(this._element, this._triggerArray);\n    }\n\n    if (this._config.toggle) {\n      this.toggle();\n    }\n  } // Getters\n\n\n  static get Default() {\n    return Default$8;\n  }\n\n  static get NAME() {\n    return NAME$9;\n  } // Public\n\n\n  toggle() {\n    if (this._element.classList.contains(CLASS_NAME_SHOW$8)) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n\n  show() {\n    if (this._isTransitioning || this._element.classList.contains(CLASS_NAME_SHOW$8)) {\n      return;\n    }\n\n    let actives;\n    let activesData;\n\n    if (this._parent) {\n      actives = SelectorEngine.find(SELECTOR_ACTIVES, this._parent).filter(elem => {\n        if (typeof this._config.parent === 'string') {\n          return elem.getAttribute('data-bs-parent') === this._config.parent;\n        }\n\n        return elem.classList.contains(CLASS_NAME_COLLAPSE);\n      });\n\n      if (actives.length === 0) {\n        actives = null;\n      }\n    }\n\n    const container = SelectorEngine.findOne(this._selector);\n\n    if (actives) {\n      const tempActiveData = actives.find(elem => container !== elem);\n      activesData = tempActiveData ? Data.get(tempActiveData, DATA_KEY$8) : null;\n\n      if (activesData && activesData._isTransitioning) {\n        return;\n      }\n    }\n\n    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$5);\n\n    if (startEvent.defaultPrevented) {\n      return;\n    }\n\n    if (actives) {\n      actives.forEach(elemActive => {\n        if (container !== elemActive) {\n          Collapse.collapseInterface(elemActive, 'hide');\n        }\n\n        if (!activesData) {\n          Data.set(elemActive, DATA_KEY$8, null);\n        }\n      });\n    }\n\n    const dimension = this._getDimension();\n\n    this._element.classList.remove(CLASS_NAME_COLLAPSE);\n\n    this._element.classList.add(CLASS_NAME_COLLAPSING);\n\n    this._element.style[dimension] = 0;\n\n    if (this._triggerArray.length) {\n      this._triggerArray.forEach(element => {\n        element.classList.remove(CLASS_NAME_COLLAPSED);\n        element.setAttribute('aria-expanded', true);\n      });\n    }\n\n    this.setTransitioning(true);\n\n    const complete = () => {\n      this._element.classList.remove(CLASS_NAME_COLLAPSING);\n\n      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$8);\n\n      this._element.style[dimension] = '';\n      this.setTransitioning(false);\n      EventHandler.trigger(this._element, EVENT_SHOWN$5);\n    };\n\n    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n    const scrollSize = `scroll${capitalizedDimension}`;\n\n    this._queueCallback(complete, this._element, true);\n\n    this._element.style[dimension] = `${this._element[scrollSize]}px`;\n  }\n\n  hide() {\n    if (this._isTransitioning || !this._element.classList.contains(CLASS_NAME_SHOW$8)) {\n      return;\n    }\n\n    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$5);\n\n    if (startEvent.defaultPrevented) {\n      return;\n    }\n\n    const dimension = this._getDimension();\n\n    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;\n    reflow(this._element);\n\n    this._element.classList.add(CLASS_NAME_COLLAPSING);\n\n    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$8);\n\n    const triggerArrayLength = this._triggerArray.length;\n\n    if (triggerArrayLength > 0) {\n      for (let i = 0; i < triggerArrayLength; i++) {\n        const trigger = this._triggerArray[i];\n        const elem = getElementFromSelector(trigger);\n\n        if (elem && !elem.classList.contains(CLASS_NAME_SHOW$8)) {\n          trigger.classList.add(CLASS_NAME_COLLAPSED);\n          trigger.setAttribute('aria-expanded', false);\n        }\n      }\n    }\n\n    this.setTransitioning(true);\n\n    const complete = () => {\n      this.setTransitioning(false);\n\n      this._element.classList.remove(CLASS_NAME_COLLAPSING);\n\n      this._element.classList.add(CLASS_NAME_COLLAPSE);\n\n      EventHandler.trigger(this._element, EVENT_HIDDEN$5);\n    };\n\n    this._element.style[dimension] = '';\n\n    this._queueCallback(complete, this._element, true);\n  }\n\n  setTransitioning(isTransitioning) {\n    this._isTransitioning = isTransitioning;\n  } // Private\n\n\n  _getConfig(config) {\n    config = { ...Default$8,\n      ...config\n    };\n    config.toggle = Boolean(config.toggle); // Coerce string values\n\n    typeCheckConfig(NAME$9, config, DefaultType$8);\n    return config;\n  }\n\n  _getDimension() {\n    return this._element.classList.contains(WIDTH) ? WIDTH : HEIGHT;\n  }\n\n  _getParent() {\n    let {\n      parent\n    } = this._config;\n    parent = getElement(parent);\n    const selector = `${SELECTOR_DATA_TOGGLE$4}[data-bs-parent=\"${parent}\"]`;\n    SelectorEngine.find(selector, parent).forEach(element => {\n      const selected = getElementFromSelector(element);\n\n      this._addAriaAndCollapsedClass(selected, [element]);\n    });\n    return parent;\n  }\n\n  _addAriaAndCollapsedClass(element, triggerArray) {\n    if (!element || !triggerArray.length) {\n      return;\n    }\n\n    const isOpen = element.classList.contains(CLASS_NAME_SHOW$8);\n    triggerArray.forEach(elem => {\n      if (isOpen) {\n        elem.classList.remove(CLASS_NAME_COLLAPSED);\n      } else {\n        elem.classList.add(CLASS_NAME_COLLAPSED);\n      }\n\n      elem.setAttribute('aria-expanded', isOpen);\n    });\n  } // Static\n\n\n  static collapseInterface(element, config) {\n    let data = Data.get(element, DATA_KEY$8);\n    const _config = { ...Default$8,\n      ...Manipulator.getDataAttributes(element),\n      ...(typeof config === 'object' && config ? config : {})\n    };\n\n    if (!data && _config.toggle && typeof config === 'string' && /show|hide/.test(config)) {\n      _config.toggle = false;\n    }\n\n    if (!data) {\n      data = new Collapse(element, _config);\n    }\n\n    if (typeof config === 'string') {\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n\n      data[config]();\n    }\n  }\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      Collapse.collapseInterface(this, config);\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {\n  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n  if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {\n    event.preventDefault();\n  }\n\n  const triggerData = Manipulator.getDataAttributes(this);\n  const selector = getSelectorFromElement(this);\n  const selectorElements = SelectorEngine.find(selector);\n  selectorElements.forEach(element => {\n    const data = Data.get(element, DATA_KEY$8);\n    let config;\n\n    if (data) {\n      // update parent attribute\n      if (data._parent === null && typeof triggerData.parent === 'string') {\n        data._config.parent = triggerData.parent;\n        data._parent = data._getParent();\n      }\n\n      config = 'toggle';\n    } else {\n      config = triggerData;\n    }\n\n    Collapse.collapseInterface(element, config);\n  });\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Collapse to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Collapse);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): dropdown.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$8 = 'dropdown';\nconst DATA_KEY$7 = 'bs.dropdown';\nconst EVENT_KEY$7 = `.${DATA_KEY$7}`;\nconst DATA_API_KEY$4 = '.data-api';\nconst ESCAPE_KEY$2 = 'Escape';\nconst SPACE_KEY = 'Space';\nconst TAB_KEY = 'Tab';\nconst ARROW_UP_KEY = 'ArrowUp';\nconst ARROW_DOWN_KEY = 'ArrowDown';\nconst RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\n\nconst REGEXP_KEYDOWN = new RegExp(`${ARROW_UP_KEY}|${ARROW_DOWN_KEY}|${ESCAPE_KEY$2}`);\nconst EVENT_HIDE$4 = `hide${EVENT_KEY$7}`;\nconst EVENT_HIDDEN$4 = `hidden${EVENT_KEY$7}`;\nconst EVENT_SHOW$4 = `show${EVENT_KEY$7}`;\nconst EVENT_SHOWN$4 = `shown${EVENT_KEY$7}`;\nconst EVENT_CLICK = `click${EVENT_KEY$7}`;\nconst EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;\nconst EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$7}${DATA_API_KEY$4}`;\nconst EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$7}${DATA_API_KEY$4}`;\nconst CLASS_NAME_SHOW$7 = 'show';\nconst CLASS_NAME_DROPUP = 'dropup';\nconst CLASS_NAME_DROPEND = 'dropend';\nconst CLASS_NAME_DROPSTART = 'dropstart';\nconst CLASS_NAME_NAVBAR = 'navbar';\nconst SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]';\nconst SELECTOR_MENU = '.dropdown-menu';\nconst SELECTOR_NAVBAR_NAV = '.navbar-nav';\nconst SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\nconst PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';\nconst PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';\nconst PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';\nconst PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';\nconst PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';\nconst PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';\nconst Default$7 = {\n  offset: [0, 2],\n  boundary: 'clippingParents',\n  reference: 'toggle',\n  display: 'dynamic',\n  popperConfig: null,\n  autoClose: true\n};\nconst DefaultType$7 = {\n  offset: '(array|string|function)',\n  boundary: '(string|element)',\n  reference: '(string|element|object)',\n  display: 'string',\n  popperConfig: '(null|object|function)',\n  autoClose: '(boolean|string)'\n};\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Dropdown extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._popper = null;\n    this._config = this._getConfig(config);\n    this._menu = this._getMenuElement();\n    this._inNavbar = this._detectNavbar();\n\n    this._addEventListeners();\n  } // Getters\n\n\n  static get Default() {\n    return Default$7;\n  }\n\n  static get DefaultType() {\n    return DefaultType$7;\n  }\n\n  static get NAME() {\n    return NAME$8;\n  } // Public\n\n\n  toggle() {\n    if (isDisabled(this._element)) {\n      return;\n    }\n\n    const isActive = this._element.classList.contains(CLASS_NAME_SHOW$7);\n\n    if (isActive) {\n      this.hide();\n      return;\n    }\n\n    this.show();\n  }\n\n  show() {\n    if (isDisabled(this._element) || this._menu.classList.contains(CLASS_NAME_SHOW$7)) {\n      return;\n    }\n\n    const parent = Dropdown.getParentFromElement(this._element);\n    const relatedTarget = {\n      relatedTarget: this._element\n    };\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, relatedTarget);\n\n    if (showEvent.defaultPrevented) {\n      return;\n    } // Totally disable Popper for Dropdowns in Navbar\n\n\n    if (this._inNavbar) {\n      Manipulator.setDataAttribute(this._menu, 'popper', 'none');\n    } else {\n      if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === 'undefined') {\n        throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org)');\n      }\n\n      let referenceElement = this._element;\n\n      if (this._config.reference === 'parent') {\n        referenceElement = parent;\n      } else if (isElement(this._config.reference)) {\n        referenceElement = getElement(this._config.reference);\n      } else if (typeof this._config.reference === 'object') {\n        referenceElement = this._config.reference;\n      }\n\n      const popperConfig = this._getPopperConfig();\n\n      const isDisplayStatic = popperConfig.modifiers.find(modifier => modifier.name === 'applyStyles' && modifier.enabled === false);\n      this._popper = _popperjs_core__WEBPACK_IMPORTED_MODULE_0__[\"createPopper\"](referenceElement, this._menu, popperConfig);\n\n      if (isDisplayStatic) {\n        Manipulator.setDataAttribute(this._menu, 'popper', 'static');\n      }\n    } // If this is a touch-enabled device we add extra\n    // empty mouseover listeners to the body's immediate children;\n    // only needed because of broken event delegation on iOS\n    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n\n    if ('ontouchstart' in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) {\n      [].concat(...document.body.children).forEach(elem => EventHandler.on(elem, 'mouseover', noop));\n    }\n\n    this._element.focus();\n\n    this._element.setAttribute('aria-expanded', true);\n\n    this._menu.classList.toggle(CLASS_NAME_SHOW$7);\n\n    this._element.classList.toggle(CLASS_NAME_SHOW$7);\n\n    EventHandler.trigger(this._element, EVENT_SHOWN$4, relatedTarget);\n  }\n\n  hide() {\n    if (isDisabled(this._element) || !this._menu.classList.contains(CLASS_NAME_SHOW$7)) {\n      return;\n    }\n\n    const relatedTarget = {\n      relatedTarget: this._element\n    };\n\n    this._completeHide(relatedTarget);\n  }\n\n  dispose() {\n    if (this._popper) {\n      this._popper.destroy();\n    }\n\n    super.dispose();\n  }\n\n  update() {\n    this._inNavbar = this._detectNavbar();\n\n    if (this._popper) {\n      this._popper.update();\n    }\n  } // Private\n\n\n  _addEventListeners() {\n    EventHandler.on(this._element, EVENT_CLICK, event => {\n      event.preventDefault();\n      this.toggle();\n    });\n  }\n\n  _completeHide(relatedTarget) {\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4, relatedTarget);\n\n    if (hideEvent.defaultPrevented) {\n      return;\n    } // If this is a touch-enabled device we remove the extra\n    // empty mouseover listeners we added for iOS support\n\n\n    if ('ontouchstart' in document.documentElement) {\n      [].concat(...document.body.children).forEach(elem => EventHandler.off(elem, 'mouseover', noop));\n    }\n\n    if (this._popper) {\n      this._popper.destroy();\n    }\n\n    this._menu.classList.remove(CLASS_NAME_SHOW$7);\n\n    this._element.classList.remove(CLASS_NAME_SHOW$7);\n\n    this._element.setAttribute('aria-expanded', 'false');\n\n    Manipulator.removeDataAttribute(this._menu, 'popper');\n    EventHandler.trigger(this._element, EVENT_HIDDEN$4, relatedTarget);\n  }\n\n  _getConfig(config) {\n    config = { ...this.constructor.Default,\n      ...Manipulator.getDataAttributes(this._element),\n      ...config\n    };\n    typeCheckConfig(NAME$8, config, this.constructor.DefaultType);\n\n    if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {\n      // Popper virtual elements require a getBoundingClientRect method\n      throw new TypeError(`${NAME$8.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`);\n    }\n\n    return config;\n  }\n\n  _getMenuElement() {\n    return SelectorEngine.next(this._element, SELECTOR_MENU)[0];\n  }\n\n  _getPlacement() {\n    const parentDropdown = this._element.parentNode;\n\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n      return PLACEMENT_RIGHT;\n    }\n\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n      return PLACEMENT_LEFT;\n    } // We need to trim the value because custom properties can also include spaces\n\n\n    const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';\n\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n    }\n\n    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n  }\n\n  _detectNavbar() {\n    return this._element.closest(`.${CLASS_NAME_NAVBAR}`) !== null;\n  }\n\n  _getOffset() {\n    const {\n      offset\n    } = this._config;\n\n    if (typeof offset === 'string') {\n      return offset.split(',').map(val => Number.parseInt(val, 10));\n    }\n\n    if (typeof offset === 'function') {\n      return popperData => offset(popperData, this._element);\n    }\n\n    return offset;\n  }\n\n  _getPopperConfig() {\n    const defaultBsPopperConfig = {\n      placement: this._getPlacement(),\n      modifiers: [{\n        name: 'preventOverflow',\n        options: {\n          boundary: this._config.boundary\n        }\n      }, {\n        name: 'offset',\n        options: {\n          offset: this._getOffset()\n        }\n      }]\n    }; // Disable Popper if we have a static display\n\n    if (this._config.display === 'static') {\n      defaultBsPopperConfig.modifiers = [{\n        name: 'applyStyles',\n        enabled: false\n      }];\n    }\n\n    return { ...defaultBsPopperConfig,\n      ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)\n    };\n  }\n\n  _selectMenuItem(event) {\n    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible);\n\n    if (!items.length) {\n      return;\n    }\n\n    let index = items.indexOf(event.target); // Up\n\n    if (event.key === ARROW_UP_KEY && index > 0) {\n      index--;\n    } // Down\n\n\n    if (event.key === ARROW_DOWN_KEY && index < items.length - 1) {\n      index++;\n    } // index is -1 if the first keydown is an ArrowUp\n\n\n    index = index === -1 ? 0 : index;\n    items[index].focus();\n  } // Static\n\n\n  static dropdownInterface(element, config) {\n    let data = Data.get(element, DATA_KEY$7);\n\n    const _config = typeof config === 'object' ? config : null;\n\n    if (!data) {\n      data = new Dropdown(element, _config);\n    }\n\n    if (typeof config === 'string') {\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n\n      data[config]();\n    }\n  }\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      Dropdown.dropdownInterface(this, config);\n    });\n  }\n\n  static clearMenus(event) {\n    if (event && (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY)) {\n      return;\n    }\n\n    const toggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE$3);\n\n    for (let i = 0, len = toggles.length; i < len; i++) {\n      const context = Data.get(toggles[i], DATA_KEY$7);\n\n      if (!context || context._config.autoClose === false) {\n        continue;\n      }\n\n      if (!context._element.classList.contains(CLASS_NAME_SHOW$7)) {\n        continue;\n      }\n\n      const relatedTarget = {\n        relatedTarget: context._element\n      };\n\n      if (event) {\n        const composedPath = event.composedPath();\n        const isMenuTarget = composedPath.includes(context._menu);\n\n        if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {\n          continue;\n        } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n\n\n        if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n          continue;\n        }\n\n        if (event.type === 'click') {\n          relatedTarget.clickEvent = event;\n        }\n      }\n\n      context._completeHide(relatedTarget);\n    }\n  }\n\n  static getParentFromElement(element) {\n    return getElementFromSelector(element) || element.parentNode;\n  }\n\n  static dataApiKeydownHandler(event) {\n    // If not input/textarea:\n    //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\n    // If input/textarea:\n    //  - If space key => not a dropdown command\n    //  - If key is other than escape\n    //    - If key is not up or down => not a dropdown command\n    //    - If trigger inside the menu => not a dropdown command\n    if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY$2 && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) {\n      return;\n    }\n\n    const isActive = this.classList.contains(CLASS_NAME_SHOW$7);\n\n    if (!isActive && event.key === ESCAPE_KEY$2) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (isDisabled(this)) {\n      return;\n    }\n\n    const getToggleButton = () => this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0];\n\n    if (event.key === ESCAPE_KEY$2) {\n      getToggleButton().focus();\n      Dropdown.clearMenus();\n      return;\n    }\n\n    if (!isActive && (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY)) {\n      getToggleButton().click();\n      return;\n    }\n\n    if (!isActive || event.key === SPACE_KEY) {\n      Dropdown.clearMenus();\n      return;\n    }\n\n    Dropdown.getInstance(getToggleButton())._selectMenuItem(event);\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\nEventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\nEventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\nEventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\nEventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\n  event.preventDefault();\n  Dropdown.dropdownInterface(this);\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Dropdown to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Dropdown);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): util/scrollBar.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\nconst SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\nconst SELECTOR_STICKY_CONTENT = '.sticky-top';\n\nconst getWidth = () => {\n  // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n  const documentWidth = document.documentElement.clientWidth;\n  return Math.abs(window.innerWidth - documentWidth);\n};\n\nconst hide = (width = getWidth()) => {\n  _disableOverFlow(); // give padding to element to balances the hidden scrollbar width\n\n\n  _setElementAttributes('body', 'paddingRight', calculatedValue => calculatedValue + width); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements, to keep shown fullwidth\n\n\n  _setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', calculatedValue => calculatedValue + width);\n\n  _setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', calculatedValue => calculatedValue - width);\n};\n\nconst _disableOverFlow = () => {\n  const actualValue = document.body.style.overflow;\n\n  if (actualValue) {\n    Manipulator.setDataAttribute(document.body, 'overflow', actualValue);\n  }\n\n  document.body.style.overflow = 'hidden';\n};\n\nconst _setElementAttributes = (selector, styleProp, callback) => {\n  const scrollbarWidth = getWidth();\n  SelectorEngine.find(selector).forEach(element => {\n    if (element !== document.body && window.innerWidth > element.clientWidth + scrollbarWidth) {\n      return;\n    }\n\n    const actualValue = element.style[styleProp];\n    const calculatedValue = window.getComputedStyle(element)[styleProp];\n    Manipulator.setDataAttribute(element, styleProp, actualValue);\n    element.style[styleProp] = `${callback(Number.parseFloat(calculatedValue))}px`;\n  });\n};\n\nconst reset = () => {\n  _resetElementAttributes('body', 'overflow');\n\n  _resetElementAttributes('body', 'paddingRight');\n\n  _resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight');\n\n  _resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight');\n};\n\nconst _resetElementAttributes = (selector, styleProp) => {\n  SelectorEngine.find(selector).forEach(element => {\n    const value = Manipulator.getDataAttribute(element, styleProp);\n\n    if (typeof value === 'undefined') {\n      element.style.removeProperty(styleProp);\n    } else {\n      Manipulator.removeDataAttribute(element, styleProp);\n      element.style[styleProp] = value;\n    }\n  });\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): util/backdrop.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\nconst Default$6 = {\n  isVisible: true,\n  // if false, we use the backdrop helper without adding any element to the dom\n  isAnimated: false,\n  rootElement: document.body,\n  // give the choice to place backdrop under different elements\n  clickCallback: null\n};\nconst DefaultType$6 = {\n  isVisible: 'boolean',\n  isAnimated: 'boolean',\n  rootElement: 'element',\n  clickCallback: '(function|null)'\n};\nconst NAME$7 = 'backdrop';\nconst CLASS_NAME_BACKDROP = 'modal-backdrop';\nconst CLASS_NAME_FADE$5 = 'fade';\nconst CLASS_NAME_SHOW$6 = 'show';\nconst EVENT_MOUSEDOWN = `mousedown.bs.${NAME$7}`;\n\nclass Backdrop {\n  constructor(config) {\n    this._config = this._getConfig(config);\n    this._isAppended = false;\n    this._element = null;\n  }\n\n  show(callback) {\n    if (!this._config.isVisible) {\n      execute(callback);\n      return;\n    }\n\n    this._append();\n\n    if (this._config.isAnimated) {\n      reflow(this._getElement());\n    }\n\n    this._getElement().classList.add(CLASS_NAME_SHOW$6);\n\n    this._emulateAnimation(() => {\n      execute(callback);\n    });\n  }\n\n  hide(callback) {\n    if (!this._config.isVisible) {\n      execute(callback);\n      return;\n    }\n\n    this._getElement().classList.remove(CLASS_NAME_SHOW$6);\n\n    this._emulateAnimation(() => {\n      this.dispose();\n      execute(callback);\n    });\n  } // Private\n\n\n  _getElement() {\n    if (!this._element) {\n      const backdrop = document.createElement('div');\n      backdrop.className = CLASS_NAME_BACKDROP;\n\n      if (this._config.isAnimated) {\n        backdrop.classList.add(CLASS_NAME_FADE$5);\n      }\n\n      this._element = backdrop;\n    }\n\n    return this._element;\n  }\n\n  _getConfig(config) {\n    config = { ...Default$6,\n      ...(typeof config === 'object' ? config : {})\n    };\n    config.rootElement = config.rootElement || document.body;\n    typeCheckConfig(NAME$7, config, DefaultType$6);\n    return config;\n  }\n\n  _append() {\n    if (this._isAppended) {\n      return;\n    }\n\n    this._config.rootElement.appendChild(this._getElement());\n\n    EventHandler.on(this._getElement(), EVENT_MOUSEDOWN, () => {\n      execute(this._config.clickCallback);\n    });\n    this._isAppended = true;\n  }\n\n  dispose() {\n    if (!this._isAppended) {\n      return;\n    }\n\n    EventHandler.off(this._element, EVENT_MOUSEDOWN);\n\n    this._getElement().parentNode.removeChild(this._element);\n\n    this._isAppended = false;\n  }\n\n  _emulateAnimation(callback) {\n    if (!this._config.isAnimated) {\n      execute(callback);\n      return;\n    }\n\n    const backdropTransitionDuration = getTransitionDurationFromElement(this._getElement());\n    EventHandler.one(this._getElement(), 'transitionend', () => execute(callback));\n    emulateTransitionEnd(this._getElement(), backdropTransitionDuration);\n  }\n\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): modal.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$6 = 'modal';\nconst DATA_KEY$6 = 'bs.modal';\nconst EVENT_KEY$6 = `.${DATA_KEY$6}`;\nconst DATA_API_KEY$3 = '.data-api';\nconst ESCAPE_KEY$1 = 'Escape';\nconst Default$5 = {\n  backdrop: true,\n  keyboard: true,\n  focus: true\n};\nconst DefaultType$5 = {\n  backdrop: '(boolean|string)',\n  keyboard: 'boolean',\n  focus: 'boolean'\n};\nconst EVENT_HIDE$3 = `hide${EVENT_KEY$6}`;\nconst EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$6}`;\nconst EVENT_HIDDEN$3 = `hidden${EVENT_KEY$6}`;\nconst EVENT_SHOW$3 = `show${EVENT_KEY$6}`;\nconst EVENT_SHOWN$3 = `shown${EVENT_KEY$6}`;\nconst EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$6}`;\nconst EVENT_RESIZE = `resize${EVENT_KEY$6}`;\nconst EVENT_CLICK_DISMISS$2 = `click.dismiss${EVENT_KEY$6}`;\nconst EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$6}`;\nconst EVENT_MOUSEUP_DISMISS = `mouseup.dismiss${EVENT_KEY$6}`;\nconst EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$6}`;\nconst EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;\nconst CLASS_NAME_OPEN = 'modal-open';\nconst CLASS_NAME_FADE$4 = 'fade';\nconst CLASS_NAME_SHOW$5 = 'show';\nconst CLASS_NAME_STATIC = 'modal-static';\nconst SELECTOR_DIALOG = '.modal-dialog';\nconst SELECTOR_MODAL_BODY = '.modal-body';\nconst SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\nconst SELECTOR_DATA_DISMISS$2 = '[data-bs-dismiss=\"modal\"]';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Modal extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._config = this._getConfig(config);\n    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\n    this._backdrop = this._initializeBackDrop();\n    this._isShown = false;\n    this._ignoreBackdropClick = false;\n    this._isTransitioning = false;\n  } // Getters\n\n\n  static get Default() {\n    return Default$5;\n  }\n\n  static get NAME() {\n    return NAME$6;\n  } // Public\n\n\n  toggle(relatedTarget) {\n    return this._isShown ? this.hide() : this.show(relatedTarget);\n  }\n\n  show(relatedTarget) {\n    if (this._isShown || this._isTransitioning) {\n      return;\n    }\n\n    if (this._isAnimated()) {\n      this._isTransitioning = true;\n    }\n\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\n      relatedTarget\n    });\n\n    if (this._isShown || showEvent.defaultPrevented) {\n      return;\n    }\n\n    this._isShown = true;\n    hide();\n    document.body.classList.add(CLASS_NAME_OPEN);\n\n    this._adjustDialog();\n\n    this._setEscapeEvent();\n\n    this._setResizeEvent();\n\n    EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, SELECTOR_DATA_DISMISS$2, event => this.hide(event));\n    EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, () => {\n      EventHandler.one(this._element, EVENT_MOUSEUP_DISMISS, event => {\n        if (event.target === this._element) {\n          this._ignoreBackdropClick = true;\n        }\n      });\n    });\n\n    this._showBackdrop(() => this._showElement(relatedTarget));\n  }\n\n  hide(event) {\n    if (event) {\n      event.preventDefault();\n    }\n\n    if (!this._isShown || this._isTransitioning) {\n      return;\n    }\n\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n\n    this._isShown = false;\n\n    const isAnimated = this._isAnimated();\n\n    if (isAnimated) {\n      this._isTransitioning = true;\n    }\n\n    this._setEscapeEvent();\n\n    this._setResizeEvent();\n\n    EventHandler.off(document, EVENT_FOCUSIN$2);\n\n    this._element.classList.remove(CLASS_NAME_SHOW$5);\n\n    EventHandler.off(this._element, EVENT_CLICK_DISMISS$2);\n    EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS);\n\n    this._queueCallback(() => this._hideModal(), this._element, isAnimated);\n  }\n\n  dispose() {\n    [window, this._dialog].forEach(htmlElement => EventHandler.off(htmlElement, EVENT_KEY$6));\n\n    this._backdrop.dispose();\n\n    super.dispose();\n    /**\n     * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`\n     * Do not move `document` in `htmlElements` array\n     * It will remove `EVENT_CLICK_DATA_API` event that should remain\n     */\n\n    EventHandler.off(document, EVENT_FOCUSIN$2);\n  }\n\n  handleUpdate() {\n    this._adjustDialog();\n  } // Private\n\n\n  _initializeBackDrop() {\n    return new Backdrop({\n      isVisible: Boolean(this._config.backdrop),\n      // 'static' option will be translated to true, and booleans will keep their value\n      isAnimated: this._isAnimated()\n    });\n  }\n\n  _getConfig(config) {\n    config = { ...Default$5,\n      ...Manipulator.getDataAttributes(this._element),\n      ...config\n    };\n    typeCheckConfig(NAME$6, config, DefaultType$5);\n    return config;\n  }\n\n  _showElement(relatedTarget) {\n    const isAnimated = this._isAnimated();\n\n    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n\n    if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\n      // Don't move modal's DOM position\n      document.body.appendChild(this._element);\n    }\n\n    this._element.style.display = 'block';\n\n    this._element.removeAttribute('aria-hidden');\n\n    this._element.setAttribute('aria-modal', true);\n\n    this._element.setAttribute('role', 'dialog');\n\n    this._element.scrollTop = 0;\n\n    if (modalBody) {\n      modalBody.scrollTop = 0;\n    }\n\n    if (isAnimated) {\n      reflow(this._element);\n    }\n\n    this._element.classList.add(CLASS_NAME_SHOW$5);\n\n    if (this._config.focus) {\n      this._enforceFocus();\n    }\n\n    const transitionComplete = () => {\n      if (this._config.focus) {\n        this._element.focus();\n      }\n\n      this._isTransitioning = false;\n      EventHandler.trigger(this._element, EVENT_SHOWN$3, {\n        relatedTarget\n      });\n    };\n\n    this._queueCallback(transitionComplete, this._dialog, isAnimated);\n  }\n\n  _enforceFocus() {\n    EventHandler.off(document, EVENT_FOCUSIN$2); // guard against infinite focus loop\n\n    EventHandler.on(document, EVENT_FOCUSIN$2, event => {\n      if (document !== event.target && this._element !== event.target && !this._element.contains(event.target)) {\n        this._element.focus();\n      }\n    });\n  }\n\n  _setEscapeEvent() {\n    if (this._isShown) {\n      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {\n        if (this._config.keyboard && event.key === ESCAPE_KEY$1) {\n          event.preventDefault();\n          this.hide();\n        } else if (!this._config.keyboard && event.key === ESCAPE_KEY$1) {\n          this._triggerBackdropTransition();\n        }\n      });\n    } else {\n      EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS$1);\n    }\n  }\n\n  _setResizeEvent() {\n    if (this._isShown) {\n      EventHandler.on(window, EVENT_RESIZE, () => this._adjustDialog());\n    } else {\n      EventHandler.off(window, EVENT_RESIZE);\n    }\n  }\n\n  _hideModal() {\n    this._element.style.display = 'none';\n\n    this._element.setAttribute('aria-hidden', true);\n\n    this._element.removeAttribute('aria-modal');\n\n    this._element.removeAttribute('role');\n\n    this._isTransitioning = false;\n\n    this._backdrop.hide(() => {\n      document.body.classList.remove(CLASS_NAME_OPEN);\n\n      this._resetAdjustments();\n\n      reset();\n      EventHandler.trigger(this._element, EVENT_HIDDEN$3);\n    });\n  }\n\n  _showBackdrop(callback) {\n    EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, event => {\n      if (this._ignoreBackdropClick) {\n        this._ignoreBackdropClick = false;\n        return;\n      }\n\n      if (event.target !== event.currentTarget) {\n        return;\n      }\n\n      if (this._config.backdrop === true) {\n        this.hide();\n      } else if (this._config.backdrop === 'static') {\n        this._triggerBackdropTransition();\n      }\n    });\n\n    this._backdrop.show(callback);\n  }\n\n  _isAnimated() {\n    return this._element.classList.contains(CLASS_NAME_FADE$4);\n  }\n\n  _triggerBackdropTransition() {\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n\n    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n\n    if (!isModalOverflowing) {\n      this._element.style.overflowY = 'hidden';\n    }\n\n    this._element.classList.add(CLASS_NAME_STATIC);\n\n    const modalTransitionDuration = getTransitionDurationFromElement(this._dialog);\n    EventHandler.off(this._element, 'transitionend');\n    EventHandler.one(this._element, 'transitionend', () => {\n      this._element.classList.remove(CLASS_NAME_STATIC);\n\n      if (!isModalOverflowing) {\n        EventHandler.one(this._element, 'transitionend', () => {\n          this._element.style.overflowY = '';\n        });\n        emulateTransitionEnd(this._element, modalTransitionDuration);\n      }\n    });\n    emulateTransitionEnd(this._element, modalTransitionDuration);\n\n    this._element.focus();\n  } // ----------------------------------------------------------------------\n  // the following methods are used to handle overflowing modals\n  // ----------------------------------------------------------------------\n\n\n  _adjustDialog() {\n    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n    const scrollbarWidth = getWidth();\n    const isBodyOverflowing = scrollbarWidth > 0;\n\n    if (!isBodyOverflowing && isModalOverflowing && !isRTL() || isBodyOverflowing && !isModalOverflowing && isRTL()) {\n      this._element.style.paddingLeft = `${scrollbarWidth}px`;\n    }\n\n    if (isBodyOverflowing && !isModalOverflowing && !isRTL() || !isBodyOverflowing && isModalOverflowing && isRTL()) {\n      this._element.style.paddingRight = `${scrollbarWidth}px`;\n    }\n  }\n\n  _resetAdjustments() {\n    this._element.style.paddingLeft = '';\n    this._element.style.paddingRight = '';\n  } // Static\n\n\n  static jQueryInterface(config, relatedTarget) {\n    return this.each(function () {\n      const data = Modal.getInstance(this) || new Modal(this, typeof config === 'object' ? config : {});\n\n      if (typeof config !== 'string') {\n        return;\n      }\n\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n\n      data[config](relatedTarget);\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\n  const target = getElementFromSelector(this);\n\n  if (['A', 'AREA'].includes(this.tagName)) {\n    event.preventDefault();\n  }\n\n  EventHandler.one(target, EVENT_SHOW$3, showEvent => {\n    if (showEvent.defaultPrevented) {\n      // only register focus restorer if modal will actually get shown\n      return;\n    }\n\n    EventHandler.one(target, EVENT_HIDDEN$3, () => {\n      if (isVisible(this)) {\n        this.focus();\n      }\n    });\n  });\n  const data = Modal.getInstance(target) || new Modal(target);\n  data.toggle(this);\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Modal to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Modal);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): offcanvas.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$5 = 'offcanvas';\nconst DATA_KEY$5 = 'bs.offcanvas';\nconst EVENT_KEY$5 = `.${DATA_KEY$5}`;\nconst DATA_API_KEY$2 = '.data-api';\nconst EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$5}${DATA_API_KEY$2}`;\nconst ESCAPE_KEY = 'Escape';\nconst Default$4 = {\n  backdrop: true,\n  keyboard: true,\n  scroll: false\n};\nconst DefaultType$4 = {\n  backdrop: 'boolean',\n  keyboard: 'boolean',\n  scroll: 'boolean'\n};\nconst CLASS_NAME_SHOW$4 = 'show';\nconst OPEN_SELECTOR = '.offcanvas.show';\nconst EVENT_SHOW$2 = `show${EVENT_KEY$5}`;\nconst EVENT_SHOWN$2 = `shown${EVENT_KEY$5}`;\nconst EVENT_HIDE$2 = `hide${EVENT_KEY$5}`;\nconst EVENT_HIDDEN$2 = `hidden${EVENT_KEY$5}`;\nconst EVENT_FOCUSIN$1 = `focusin${EVENT_KEY$5}`;\nconst EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$5}${DATA_API_KEY$2}`;\nconst EVENT_CLICK_DISMISS$1 = `click.dismiss${EVENT_KEY$5}`;\nconst EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$5}`;\nconst SELECTOR_DATA_DISMISS$1 = '[data-bs-dismiss=\"offcanvas\"]';\nconst SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Offcanvas extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._config = this._getConfig(config);\n    this._isShown = false;\n    this._backdrop = this._initializeBackDrop();\n\n    this._addEventListeners();\n  } // Getters\n\n\n  static get NAME() {\n    return NAME$5;\n  }\n\n  static get Default() {\n    return Default$4;\n  } // Public\n\n\n  toggle(relatedTarget) {\n    return this._isShown ? this.hide() : this.show(relatedTarget);\n  }\n\n  show(relatedTarget) {\n    if (this._isShown) {\n      return;\n    }\n\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$2, {\n      relatedTarget\n    });\n\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n\n    this._isShown = true;\n    this._element.style.visibility = 'visible';\n\n    this._backdrop.show();\n\n    if (!this._config.scroll) {\n      hide();\n\n      this._enforceFocusOnElement(this._element);\n    }\n\n    this._element.removeAttribute('aria-hidden');\n\n    this._element.setAttribute('aria-modal', true);\n\n    this._element.setAttribute('role', 'dialog');\n\n    this._element.classList.add(CLASS_NAME_SHOW$4);\n\n    const completeCallBack = () => {\n      EventHandler.trigger(this._element, EVENT_SHOWN$2, {\n        relatedTarget\n      });\n    };\n\n    this._queueCallback(completeCallBack, this._element, true);\n  }\n\n  hide() {\n    if (!this._isShown) {\n      return;\n    }\n\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$2);\n\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n\n    EventHandler.off(document, EVENT_FOCUSIN$1);\n\n    this._element.blur();\n\n    this._isShown = false;\n\n    this._element.classList.remove(CLASS_NAME_SHOW$4);\n\n    this._backdrop.hide();\n\n    const completeCallback = () => {\n      this._element.setAttribute('aria-hidden', true);\n\n      this._element.removeAttribute('aria-modal');\n\n      this._element.removeAttribute('role');\n\n      this._element.style.visibility = 'hidden';\n\n      if (!this._config.scroll) {\n        reset();\n      }\n\n      EventHandler.trigger(this._element, EVENT_HIDDEN$2);\n    };\n\n    this._queueCallback(completeCallback, this._element, true);\n  }\n\n  dispose() {\n    this._backdrop.dispose();\n\n    super.dispose();\n    EventHandler.off(document, EVENT_FOCUSIN$1);\n  } // Private\n\n\n  _getConfig(config) {\n    config = { ...Default$4,\n      ...Manipulator.getDataAttributes(this._element),\n      ...(typeof config === 'object' ? config : {})\n    };\n    typeCheckConfig(NAME$5, config, DefaultType$4);\n    return config;\n  }\n\n  _initializeBackDrop() {\n    return new Backdrop({\n      isVisible: this._config.backdrop,\n      isAnimated: true,\n      rootElement: this._element.parentNode,\n      clickCallback: () => this.hide()\n    });\n  }\n\n  _enforceFocusOnElement(element) {\n    EventHandler.off(document, EVENT_FOCUSIN$1); // guard against infinite focus loop\n\n    EventHandler.on(document, EVENT_FOCUSIN$1, event => {\n      if (document !== event.target && element !== event.target && !element.contains(event.target)) {\n        element.focus();\n      }\n    });\n    element.focus();\n  }\n\n  _addEventListeners() {\n    EventHandler.on(this._element, EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, () => this.hide());\n    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {\n      if (this._config.keyboard && event.key === ESCAPE_KEY) {\n        this.hide();\n      }\n    });\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Data.get(this, DATA_KEY$5) || new Offcanvas(this, typeof config === 'object' ? config : {});\n\n      if (typeof config !== 'string') {\n        return;\n      }\n\n      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n\n      data[config](this);\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\n  const target = getElementFromSelector(this);\n\n  if (['A', 'AREA'].includes(this.tagName)) {\n    event.preventDefault();\n  }\n\n  if (isDisabled(this)) {\n    return;\n  }\n\n  EventHandler.one(target, EVENT_HIDDEN$2, () => {\n    // focus on trigger when it is closed\n    if (isVisible(this)) {\n      this.focus();\n    }\n  }); // avoid conflict when clicking a toggler of an offcanvas, while another is open\n\n  const allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\n\n  if (allReadyOpen && allReadyOpen !== target) {\n    Offcanvas.getInstance(allReadyOpen).hide();\n  }\n\n  const data = Data.get(target, DATA_KEY$5) || new Offcanvas(target);\n  data.toggle(this);\n});\nEventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {\n  SelectorEngine.find(OPEN_SELECTOR).forEach(el => (Data.get(el, DATA_KEY$5) || new Offcanvas(el)).show());\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n */\n\ndefineJQueryPlugin(Offcanvas);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): util/sanitizer.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\nconst uriAttrs = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);\nconst ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n *\n * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n */\n\nconst SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i;\n/**\n * A pattern that matches safe data URLs. Only matches image, video and audio types.\n *\n * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n */\n\nconst DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i;\n\nconst allowedAttribute = (attr, allowedAttributeList) => {\n  const attrName = attr.nodeName.toLowerCase();\n\n  if (allowedAttributeList.includes(attrName)) {\n    if (uriAttrs.has(attrName)) {\n      return Boolean(SAFE_URL_PATTERN.test(attr.nodeValue) || DATA_URL_PATTERN.test(attr.nodeValue));\n    }\n\n    return true;\n  }\n\n  const regExp = allowedAttributeList.filter(attrRegex => attrRegex instanceof RegExp); // Check if a regular expression validates the attribute.\n\n  for (let i = 0, len = regExp.length; i < len; i++) {\n    if (regExp[i].test(attrName)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst DefaultAllowlist = {\n  // Global attributes allowed on any supplied element below.\n  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n  a: ['target', 'href', 'title', 'rel'],\n  area: [],\n  b: [],\n  br: [],\n  col: [],\n  code: [],\n  div: [],\n  em: [],\n  hr: [],\n  h1: [],\n  h2: [],\n  h3: [],\n  h4: [],\n  h5: [],\n  h6: [],\n  i: [],\n  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n  li: [],\n  ol: [],\n  p: [],\n  pre: [],\n  s: [],\n  small: [],\n  span: [],\n  sub: [],\n  sup: [],\n  strong: [],\n  u: [],\n  ul: []\n};\nfunction sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {\n  if (!unsafeHtml.length) {\n    return unsafeHtml;\n  }\n\n  if (sanitizeFn && typeof sanitizeFn === 'function') {\n    return sanitizeFn(unsafeHtml);\n  }\n\n  const domParser = new window.DOMParser();\n  const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\n  const allowlistKeys = Object.keys(allowList);\n  const elements = [].concat(...createdDocument.body.querySelectorAll('*'));\n\n  for (let i = 0, len = elements.length; i < len; i++) {\n    const el = elements[i];\n    const elName = el.nodeName.toLowerCase();\n\n    if (!allowlistKeys.includes(elName)) {\n      el.parentNode.removeChild(el);\n      continue;\n    }\n\n    const attributeList = [].concat(...el.attributes);\n    const allowedAttributes = [].concat(allowList['*'] || [], allowList[elName] || []);\n    attributeList.forEach(attr => {\n      if (!allowedAttribute(attr, allowedAttributes)) {\n        el.removeAttribute(attr.nodeName);\n      }\n    });\n  }\n\n  return createdDocument.body.innerHTML;\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): tooltip.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$4 = 'tooltip';\nconst DATA_KEY$4 = 'bs.tooltip';\nconst EVENT_KEY$4 = `.${DATA_KEY$4}`;\nconst CLASS_PREFIX$1 = 'bs-tooltip';\nconst BSCLS_PREFIX_REGEX$1 = new RegExp(`(^|\\\\s)${CLASS_PREFIX$1}\\\\S+`, 'g');\nconst DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);\nconst DefaultType$3 = {\n  animation: 'boolean',\n  template: 'string',\n  title: '(string|element|function)',\n  trigger: 'string',\n  delay: '(number|object)',\n  html: 'boolean',\n  selector: '(string|boolean)',\n  placement: '(string|function)',\n  offset: '(array|string|function)',\n  container: '(string|element|boolean)',\n  fallbackPlacements: 'array',\n  boundary: '(string|element)',\n  customClass: '(string|function)',\n  sanitize: 'boolean',\n  sanitizeFn: '(null|function)',\n  allowList: 'object',\n  popperConfig: '(null|object|function)'\n};\nconst AttachmentMap = {\n  AUTO: 'auto',\n  TOP: 'top',\n  RIGHT: isRTL() ? 'left' : 'right',\n  BOTTOM: 'bottom',\n  LEFT: isRTL() ? 'right' : 'left'\n};\nconst Default$3 = {\n  animation: true,\n  template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + '</div>',\n  trigger: 'hover focus',\n  title: '',\n  delay: 0,\n  html: false,\n  selector: false,\n  placement: 'top',\n  offset: [0, 0],\n  container: false,\n  fallbackPlacements: ['top', 'right', 'bottom', 'left'],\n  boundary: 'clippingParents',\n  customClass: '',\n  sanitize: true,\n  sanitizeFn: null,\n  allowList: DefaultAllowlist,\n  popperConfig: null\n};\nconst Event$2 = {\n  HIDE: `hide${EVENT_KEY$4}`,\n  HIDDEN: `hidden${EVENT_KEY$4}`,\n  SHOW: `show${EVENT_KEY$4}`,\n  SHOWN: `shown${EVENT_KEY$4}`,\n  INSERTED: `inserted${EVENT_KEY$4}`,\n  CLICK: `click${EVENT_KEY$4}`,\n  FOCUSIN: `focusin${EVENT_KEY$4}`,\n  FOCUSOUT: `focusout${EVENT_KEY$4}`,\n  MOUSEENTER: `mouseenter${EVENT_KEY$4}`,\n  MOUSELEAVE: `mouseleave${EVENT_KEY$4}`\n};\nconst CLASS_NAME_FADE$3 = 'fade';\nconst CLASS_NAME_MODAL = 'modal';\nconst CLASS_NAME_SHOW$3 = 'show';\nconst HOVER_STATE_SHOW = 'show';\nconst HOVER_STATE_OUT = 'out';\nconst SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\nconst TRIGGER_HOVER = 'hover';\nconst TRIGGER_FOCUS = 'focus';\nconst TRIGGER_CLICK = 'click';\nconst TRIGGER_MANUAL = 'manual';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Tooltip extends BaseComponent {\n  constructor(element, config) {\n    if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === 'undefined') {\n      throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org)');\n    }\n\n    super(element); // private\n\n    this._isEnabled = true;\n    this._timeout = 0;\n    this._hoverState = '';\n    this._activeTrigger = {};\n    this._popper = null; // Protected\n\n    this._config = this._getConfig(config);\n    this.tip = null;\n\n    this._setListeners();\n  } // Getters\n\n\n  static get Default() {\n    return Default$3;\n  }\n\n  static get NAME() {\n    return NAME$4;\n  }\n\n  static get Event() {\n    return Event$2;\n  }\n\n  static get DefaultType() {\n    return DefaultType$3;\n  } // Public\n\n\n  enable() {\n    this._isEnabled = true;\n  }\n\n  disable() {\n    this._isEnabled = false;\n  }\n\n  toggleEnabled() {\n    this._isEnabled = !this._isEnabled;\n  }\n\n  toggle(event) {\n    if (!this._isEnabled) {\n      return;\n    }\n\n    if (event) {\n      const context = this._initializeOnDelegatedTarget(event);\n\n      context._activeTrigger.click = !context._activeTrigger.click;\n\n      if (context._isWithActiveTrigger()) {\n        context._enter(null, context);\n      } else {\n        context._leave(null, context);\n      }\n    } else {\n      if (this.getTipElement().classList.contains(CLASS_NAME_SHOW$3)) {\n        this._leave(null, this);\n\n        return;\n      }\n\n      this._enter(null, this);\n    }\n  }\n\n  dispose() {\n    clearTimeout(this._timeout);\n    EventHandler.off(this._element.closest(`.${CLASS_NAME_MODAL}`), 'hide.bs.modal', this._hideModalHandler);\n\n    if (this.tip && this.tip.parentNode) {\n      this.tip.parentNode.removeChild(this.tip);\n    }\n\n    if (this._popper) {\n      this._popper.destroy();\n    }\n\n    super.dispose();\n  }\n\n  show() {\n    if (this._element.style.display === 'none') {\n      throw new Error('Please use show on visible elements');\n    }\n\n    if (!(this.isWithContent() && this._isEnabled)) {\n      return;\n    }\n\n    const showEvent = EventHandler.trigger(this._element, this.constructor.Event.SHOW);\n    const shadowRoot = findShadowRoot(this._element);\n    const isInTheDom = shadowRoot === null ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);\n\n    if (showEvent.defaultPrevented || !isInTheDom) {\n      return;\n    }\n\n    const tip = this.getTipElement();\n    const tipId = getUID(this.constructor.NAME);\n    tip.setAttribute('id', tipId);\n\n    this._element.setAttribute('aria-describedby', tipId);\n\n    this.setContent();\n\n    if (this._config.animation) {\n      tip.classList.add(CLASS_NAME_FADE$3);\n    }\n\n    const placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;\n\n    const attachment = this._getAttachment(placement);\n\n    this._addAttachmentClass(attachment);\n\n    const {\n      container\n    } = this._config;\n    Data.set(tip, this.constructor.DATA_KEY, this);\n\n    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n      container.appendChild(tip);\n      EventHandler.trigger(this._element, this.constructor.Event.INSERTED);\n    }\n\n    if (this._popper) {\n      this._popper.update();\n    } else {\n      this._popper = _popperjs_core__WEBPACK_IMPORTED_MODULE_0__[\"createPopper\"](this._element, tip, this._getPopperConfig(attachment));\n    }\n\n    tip.classList.add(CLASS_NAME_SHOW$3);\n    const customClass = typeof this._config.customClass === 'function' ? this._config.customClass() : this._config.customClass;\n\n    if (customClass) {\n      tip.classList.add(...customClass.split(' '));\n    } // If this is a touch-enabled device we add extra\n    // empty mouseover listeners to the body's immediate children;\n    // only needed because of broken event delegation on iOS\n    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n\n    if ('ontouchstart' in document.documentElement) {\n      [].concat(...document.body.children).forEach(element => {\n        EventHandler.on(element, 'mouseover', noop);\n      });\n    }\n\n    const complete = () => {\n      const prevHoverState = this._hoverState;\n      this._hoverState = null;\n      EventHandler.trigger(this._element, this.constructor.Event.SHOWN);\n\n      if (prevHoverState === HOVER_STATE_OUT) {\n        this._leave(null, this);\n      }\n    };\n\n    const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$3);\n\n    this._queueCallback(complete, this.tip, isAnimated);\n  }\n\n  hide() {\n    if (!this._popper) {\n      return;\n    }\n\n    const tip = this.getTipElement();\n\n    const complete = () => {\n      if (this._isWithActiveTrigger()) {\n        return;\n      }\n\n      if (this._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {\n        tip.parentNode.removeChild(tip);\n      }\n\n      this._cleanTipClass();\n\n      this._element.removeAttribute('aria-describedby');\n\n      EventHandler.trigger(this._element, this.constructor.Event.HIDDEN);\n\n      if (this._popper) {\n        this._popper.destroy();\n\n        this._popper = null;\n      }\n    };\n\n    const hideEvent = EventHandler.trigger(this._element, this.constructor.Event.HIDE);\n\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n\n    tip.classList.remove(CLASS_NAME_SHOW$3); // If this is a touch-enabled device we remove the extra\n    // empty mouseover listeners we added for iOS support\n\n    if ('ontouchstart' in document.documentElement) {\n      [].concat(...document.body.children).forEach(element => EventHandler.off(element, 'mouseover', noop));\n    }\n\n    this._activeTrigger[TRIGGER_CLICK] = false;\n    this._activeTrigger[TRIGGER_FOCUS] = false;\n    this._activeTrigger[TRIGGER_HOVER] = false;\n    const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$3);\n\n    this._queueCallback(complete, this.tip, isAnimated);\n\n    this._hoverState = '';\n  }\n\n  update() {\n    if (this._popper !== null) {\n      this._popper.update();\n    }\n  } // Protected\n\n\n  isWithContent() {\n    return Boolean(this.getTitle());\n  }\n\n  getTipElement() {\n    if (this.tip) {\n      return this.tip;\n    }\n\n    const element = document.createElement('div');\n    element.innerHTML = this._config.template;\n    this.tip = element.children[0];\n    return this.tip;\n  }\n\n  setContent() {\n    const tip = this.getTipElement();\n    this.setElementContent(SelectorEngine.findOne(SELECTOR_TOOLTIP_INNER, tip), this.getTitle());\n    tip.classList.remove(CLASS_NAME_FADE$3, CLASS_NAME_SHOW$3);\n  }\n\n  setElementContent(element, content) {\n    if (element === null) {\n      return;\n    }\n\n    if (isElement(content)) {\n      content = getElement(content); // content is a DOM node or a jQuery\n\n      if (this._config.html) {\n        if (content.parentNode !== element) {\n          element.innerHTML = '';\n          element.appendChild(content);\n        }\n      } else {\n        element.textContent = content.textContent;\n      }\n\n      return;\n    }\n\n    if (this._config.html) {\n      if (this._config.sanitize) {\n        content = sanitizeHtml(content, this._config.allowList, this._config.sanitizeFn);\n      }\n\n      element.innerHTML = content;\n    } else {\n      element.textContent = content;\n    }\n  }\n\n  getTitle() {\n    let title = this._element.getAttribute('data-bs-original-title');\n\n    if (!title) {\n      title = typeof this._config.title === 'function' ? this._config.title.call(this._element) : this._config.title;\n    }\n\n    return title;\n  }\n\n  updateAttachment(attachment) {\n    if (attachment === 'right') {\n      return 'end';\n    }\n\n    if (attachment === 'left') {\n      return 'start';\n    }\n\n    return attachment;\n  } // Private\n\n\n  _initializeOnDelegatedTarget(event, context) {\n    const dataKey = this.constructor.DATA_KEY;\n    context = context || Data.get(event.delegateTarget, dataKey);\n\n    if (!context) {\n      context = new this.constructor(event.delegateTarget, this._getDelegateConfig());\n      Data.set(event.delegateTarget, dataKey, context);\n    }\n\n    return context;\n  }\n\n  _getOffset() {\n    const {\n      offset\n    } = this._config;\n\n    if (typeof offset === 'string') {\n      return offset.split(',').map(val => Number.parseInt(val, 10));\n    }\n\n    if (typeof offset === 'function') {\n      return popperData => offset(popperData, this._element);\n    }\n\n    return offset;\n  }\n\n  _getPopperConfig(attachment) {\n    const defaultBsPopperConfig = {\n      placement: attachment,\n      modifiers: [{\n        name: 'flip',\n        options: {\n          fallbackPlacements: this._config.fallbackPlacements\n        }\n      }, {\n        name: 'offset',\n        options: {\n          offset: this._getOffset()\n        }\n      }, {\n        name: 'preventOverflow',\n        options: {\n          boundary: this._config.boundary\n        }\n      }, {\n        name: 'arrow',\n        options: {\n          element: `.${this.constructor.NAME}-arrow`\n        }\n      }, {\n        name: 'onChange',\n        enabled: true,\n        phase: 'afterWrite',\n        fn: data => this._handlePopperPlacementChange(data)\n      }],\n      onFirstUpdate: data => {\n        if (data.options.placement !== data.placement) {\n          this._handlePopperPlacementChange(data);\n        }\n      }\n    };\n    return { ...defaultBsPopperConfig,\n      ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)\n    };\n  }\n\n  _addAttachmentClass(attachment) {\n    this.getTipElement().classList.add(`${CLASS_PREFIX$1}-${this.updateAttachment(attachment)}`);\n  }\n\n  _getAttachment(placement) {\n    return AttachmentMap[placement.toUpperCase()];\n  }\n\n  _setListeners() {\n    const triggers = this._config.trigger.split(' ');\n\n    triggers.forEach(trigger => {\n      if (trigger === 'click') {\n        EventHandler.on(this._element, this.constructor.Event.CLICK, this._config.selector, event => this.toggle(event));\n      } else if (trigger !== TRIGGER_MANUAL) {\n        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN;\n        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;\n        EventHandler.on(this._element, eventIn, this._config.selector, event => this._enter(event));\n        EventHandler.on(this._element, eventOut, this._config.selector, event => this._leave(event));\n      }\n    });\n\n    this._hideModalHandler = () => {\n      if (this._element) {\n        this.hide();\n      }\n    };\n\n    EventHandler.on(this._element.closest(`.${CLASS_NAME_MODAL}`), 'hide.bs.modal', this._hideModalHandler);\n\n    if (this._config.selector) {\n      this._config = { ...this._config,\n        trigger: 'manual',\n        selector: ''\n      };\n    } else {\n      this._fixTitle();\n    }\n  }\n\n  _fixTitle() {\n    const title = this._element.getAttribute('title');\n\n    const originalTitleType = typeof this._element.getAttribute('data-bs-original-title');\n\n    if (title || originalTitleType !== 'string') {\n      this._element.setAttribute('data-bs-original-title', title || '');\n\n      if (title && !this._element.getAttribute('aria-label') && !this._element.textContent) {\n        this._element.setAttribute('aria-label', title);\n      }\n\n      this._element.setAttribute('title', '');\n    }\n  }\n\n  _enter(event, context) {\n    context = this._initializeOnDelegatedTarget(event, context);\n\n    if (event) {\n      context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n    }\n\n    if (context.getTipElement().classList.contains(CLASS_NAME_SHOW$3) || context._hoverState === HOVER_STATE_SHOW) {\n      context._hoverState = HOVER_STATE_SHOW;\n      return;\n    }\n\n    clearTimeout(context._timeout);\n    context._hoverState = HOVER_STATE_SHOW;\n\n    if (!context._config.delay || !context._config.delay.show) {\n      context.show();\n      return;\n    }\n\n    context._timeout = setTimeout(() => {\n      if (context._hoverState === HOVER_STATE_SHOW) {\n        context.show();\n      }\n    }, context._config.delay.show);\n  }\n\n  _leave(event, context) {\n    context = this._initializeOnDelegatedTarget(event, context);\n\n    if (event) {\n      context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n    }\n\n    if (context._isWithActiveTrigger()) {\n      return;\n    }\n\n    clearTimeout(context._timeout);\n    context._hoverState = HOVER_STATE_OUT;\n\n    if (!context._config.delay || !context._config.delay.hide) {\n      context.hide();\n      return;\n    }\n\n    context._timeout = setTimeout(() => {\n      if (context._hoverState === HOVER_STATE_OUT) {\n        context.hide();\n      }\n    }, context._config.delay.hide);\n  }\n\n  _isWithActiveTrigger() {\n    for (const trigger in this._activeTrigger) {\n      if (this._activeTrigger[trigger]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _getConfig(config) {\n    const dataAttributes = Manipulator.getDataAttributes(this._element);\n    Object.keys(dataAttributes).forEach(dataAttr => {\n      if (DISALLOWED_ATTRIBUTES.has(dataAttr)) {\n        delete dataAttributes[dataAttr];\n      }\n    });\n    config = { ...this.constructor.Default,\n      ...dataAttributes,\n      ...(typeof config === 'object' && config ? config : {})\n    };\n    config.container = config.container === false ? document.body : getElement(config.container);\n\n    if (typeof config.delay === 'number') {\n      config.delay = {\n        show: config.delay,\n        hide: config.delay\n      };\n    }\n\n    if (typeof config.title === 'number') {\n      config.title = config.title.toString();\n    }\n\n    if (typeof config.content === 'number') {\n      config.content = config.content.toString();\n    }\n\n    typeCheckConfig(NAME$4, config, this.constructor.DefaultType);\n\n    if (config.sanitize) {\n      config.template = sanitizeHtml(config.template, config.allowList, config.sanitizeFn);\n    }\n\n    return config;\n  }\n\n  _getDelegateConfig() {\n    const config = {};\n\n    if (this._config) {\n      for (const key in this._config) {\n        if (this.constructor.Default[key] !== this._config[key]) {\n          config[key] = this._config[key];\n        }\n      }\n    }\n\n    return config;\n  }\n\n  _cleanTipClass() {\n    const tip = this.getTipElement();\n    const tabClass = tip.getAttribute('class').match(BSCLS_PREFIX_REGEX$1);\n\n    if (tabClass !== null && tabClass.length > 0) {\n      tabClass.map(token => token.trim()).forEach(tClass => tip.classList.remove(tClass));\n    }\n  }\n\n  _handlePopperPlacementChange(popperData) {\n    const {\n      state\n    } = popperData;\n\n    if (!state) {\n      return;\n    }\n\n    this.tip = state.elements.popper;\n\n    this._cleanTipClass();\n\n    this._addAttachmentClass(this._getAttachment(state.placement));\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      let data = Data.get(this, DATA_KEY$4);\n\n      const _config = typeof config === 'object' && config;\n\n      if (!data && /dispose|hide/.test(config)) {\n        return;\n      }\n\n      if (!data) {\n        data = new Tooltip(this, _config);\n      }\n\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      }\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Tooltip to jQuery only if jQuery is present\n */\n\n\ndefineJQueryPlugin(Tooltip);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): popover.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$3 = 'popover';\nconst DATA_KEY$3 = 'bs.popover';\nconst EVENT_KEY$3 = `.${DATA_KEY$3}`;\nconst CLASS_PREFIX = 'bs-popover';\nconst BSCLS_PREFIX_REGEX = new RegExp(`(^|\\\\s)${CLASS_PREFIX}\\\\S+`, 'g');\nconst Default$2 = { ...Tooltip.Default,\n  placement: 'right',\n  offset: [0, 8],\n  trigger: 'click',\n  content: '',\n  template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + '</div>'\n};\nconst DefaultType$2 = { ...Tooltip.DefaultType,\n  content: '(string|element|function)'\n};\nconst Event$1 = {\n  HIDE: `hide${EVENT_KEY$3}`,\n  HIDDEN: `hidden${EVENT_KEY$3}`,\n  SHOW: `show${EVENT_KEY$3}`,\n  SHOWN: `shown${EVENT_KEY$3}`,\n  INSERTED: `inserted${EVENT_KEY$3}`,\n  CLICK: `click${EVENT_KEY$3}`,\n  FOCUSIN: `focusin${EVENT_KEY$3}`,\n  FOCUSOUT: `focusout${EVENT_KEY$3}`,\n  MOUSEENTER: `mouseenter${EVENT_KEY$3}`,\n  MOUSELEAVE: `mouseleave${EVENT_KEY$3}`\n};\nconst CLASS_NAME_FADE$2 = 'fade';\nconst CLASS_NAME_SHOW$2 = 'show';\nconst SELECTOR_TITLE = '.popover-header';\nconst SELECTOR_CONTENT = '.popover-body';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Popover extends Tooltip {\n  // Getters\n  static get Default() {\n    return Default$2;\n  }\n\n  static get NAME() {\n    return NAME$3;\n  }\n\n  static get Event() {\n    return Event$1;\n  }\n\n  static get DefaultType() {\n    return DefaultType$2;\n  } // Overrides\n\n\n  isWithContent() {\n    return this.getTitle() || this._getContent();\n  }\n\n  setContent() {\n    const tip = this.getTipElement(); // we use append for html objects to maintain js events\n\n    this.setElementContent(SelectorEngine.findOne(SELECTOR_TITLE, tip), this.getTitle());\n\n    let content = this._getContent();\n\n    if (typeof content === 'function') {\n      content = content.call(this._element);\n    }\n\n    this.setElementContent(SelectorEngine.findOne(SELECTOR_CONTENT, tip), content);\n    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);\n  } // Private\n\n\n  _addAttachmentClass(attachment) {\n    this.getTipElement().classList.add(`${CLASS_PREFIX}-${this.updateAttachment(attachment)}`);\n  }\n\n  _getContent() {\n    return this._element.getAttribute('data-bs-content') || this._config.content;\n  }\n\n  _cleanTipClass() {\n    const tip = this.getTipElement();\n    const tabClass = tip.getAttribute('class').match(BSCLS_PREFIX_REGEX);\n\n    if (tabClass !== null && tabClass.length > 0) {\n      tabClass.map(token => token.trim()).forEach(tClass => tip.classList.remove(tClass));\n    }\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      let data = Data.get(this, DATA_KEY$3);\n\n      const _config = typeof config === 'object' ? config : null;\n\n      if (!data && /dispose|hide/.test(config)) {\n        return;\n      }\n\n      if (!data) {\n        data = new Popover(this, _config);\n        Data.set(this, DATA_KEY$3, data);\n      }\n\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      }\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Popover to jQuery only if jQuery is present\n */\n\n\ndefineJQueryPlugin(Popover);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): scrollspy.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$2 = 'scrollspy';\nconst DATA_KEY$2 = 'bs.scrollspy';\nconst EVENT_KEY$2 = `.${DATA_KEY$2}`;\nconst DATA_API_KEY$1 = '.data-api';\nconst Default$1 = {\n  offset: 10,\n  method: 'auto',\n  target: ''\n};\nconst DefaultType$1 = {\n  offset: 'number',\n  method: 'string',\n  target: '(string|element)'\n};\nconst EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;\nconst EVENT_SCROLL = `scroll${EVENT_KEY$2}`;\nconst EVENT_LOAD_DATA_API = `load${EVENT_KEY$2}${DATA_API_KEY$1}`;\nconst CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\nconst CLASS_NAME_ACTIVE$1 = 'active';\nconst SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\nconst SELECTOR_NAV_LIST_GROUP$1 = '.nav, .list-group';\nconst SELECTOR_NAV_LINKS = '.nav-link';\nconst SELECTOR_NAV_ITEMS = '.nav-item';\nconst SELECTOR_LIST_ITEMS = '.list-group-item';\nconst SELECTOR_DROPDOWN$1 = '.dropdown';\nconst SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\nconst METHOD_OFFSET = 'offset';\nconst METHOD_POSITION = 'position';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass ScrollSpy extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._scrollElement = this._element.tagName === 'BODY' ? window : this._element;\n    this._config = this._getConfig(config);\n    this._selector = `${this._config.target} ${SELECTOR_NAV_LINKS}, ${this._config.target} ${SELECTOR_LIST_ITEMS}, ${this._config.target} .${CLASS_NAME_DROPDOWN_ITEM}`;\n    this._offsets = [];\n    this._targets = [];\n    this._activeTarget = null;\n    this._scrollHeight = 0;\n    EventHandler.on(this._scrollElement, EVENT_SCROLL, () => this._process());\n    this.refresh();\n\n    this._process();\n  } // Getters\n\n\n  static get Default() {\n    return Default$1;\n  }\n\n  static get NAME() {\n    return NAME$2;\n  } // Public\n\n\n  refresh() {\n    const autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;\n    const offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\n    const offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;\n    this._offsets = [];\n    this._targets = [];\n    this._scrollHeight = this._getScrollHeight();\n    const targets = SelectorEngine.find(this._selector);\n    targets.map(element => {\n      const targetSelector = getSelectorFromElement(element);\n      const target = targetSelector ? SelectorEngine.findOne(targetSelector) : null;\n\n      if (target) {\n        const targetBCR = target.getBoundingClientRect();\n\n        if (targetBCR.width || targetBCR.height) {\n          return [Manipulator[offsetMethod](target).top + offsetBase, targetSelector];\n        }\n      }\n\n      return null;\n    }).filter(item => item).sort((a, b) => a[0] - b[0]).forEach(item => {\n      this._offsets.push(item[0]);\n\n      this._targets.push(item[1]);\n    });\n  }\n\n  dispose() {\n    EventHandler.off(this._scrollElement, EVENT_KEY$2);\n    super.dispose();\n  } // Private\n\n\n  _getConfig(config) {\n    config = { ...Default$1,\n      ...Manipulator.getDataAttributes(this._element),\n      ...(typeof config === 'object' && config ? config : {})\n    };\n\n    if (typeof config.target !== 'string' && isElement(config.target)) {\n      let {\n        id\n      } = config.target;\n\n      if (!id) {\n        id = getUID(NAME$2);\n        config.target.id = id;\n      }\n\n      config.target = `#${id}`;\n    }\n\n    typeCheckConfig(NAME$2, config, DefaultType$1);\n    return config;\n  }\n\n  _getScrollTop() {\n    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n  }\n\n  _getScrollHeight() {\n    return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n  }\n\n  _getOffsetHeight() {\n    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n  }\n\n  _process() {\n    const scrollTop = this._getScrollTop() + this._config.offset;\n\n    const scrollHeight = this._getScrollHeight();\n\n    const maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();\n\n    if (this._scrollHeight !== scrollHeight) {\n      this.refresh();\n    }\n\n    if (scrollTop >= maxScroll) {\n      const target = this._targets[this._targets.length - 1];\n\n      if (this._activeTarget !== target) {\n        this._activate(target);\n      }\n\n      return;\n    }\n\n    if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {\n      this._activeTarget = null;\n\n      this._clear();\n\n      return;\n    }\n\n    for (let i = this._offsets.length; i--;) {\n      const isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);\n\n      if (isActiveTarget) {\n        this._activate(this._targets[i]);\n      }\n    }\n  }\n\n  _activate(target) {\n    this._activeTarget = target;\n\n    this._clear();\n\n    const queries = this._selector.split(',').map(selector => `${selector}[data-bs-target=\"${target}\"],${selector}[href=\"${target}\"]`);\n\n    const link = SelectorEngine.findOne(queries.join(','));\n\n    if (link.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, link.closest(SELECTOR_DROPDOWN$1)).classList.add(CLASS_NAME_ACTIVE$1);\n      link.classList.add(CLASS_NAME_ACTIVE$1);\n    } else {\n      // Set triggered link as active\n      link.classList.add(CLASS_NAME_ACTIVE$1);\n      SelectorEngine.parents(link, SELECTOR_NAV_LIST_GROUP$1).forEach(listGroup => {\n        // Set triggered links parents as active\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n        SelectorEngine.prev(listGroup, `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`).forEach(item => item.classList.add(CLASS_NAME_ACTIVE$1)); // Handle special case when .nav-link is inside .nav-item\n\n        SelectorEngine.prev(listGroup, SELECTOR_NAV_ITEMS).forEach(navItem => {\n          SelectorEngine.children(navItem, SELECTOR_NAV_LINKS).forEach(item => item.classList.add(CLASS_NAME_ACTIVE$1));\n        });\n      });\n    }\n\n    EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, {\n      relatedTarget: target\n    });\n  }\n\n  _clear() {\n    SelectorEngine.find(this._selector).filter(node => node.classList.contains(CLASS_NAME_ACTIVE$1)).forEach(node => node.classList.remove(CLASS_NAME_ACTIVE$1));\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = ScrollSpy.getInstance(this) || new ScrollSpy(this, typeof config === 'object' ? config : {});\n\n      if (typeof config !== 'string') {\n        return;\n      }\n\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n\n      data[config]();\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(window, EVENT_LOAD_DATA_API, () => {\n  SelectorEngine.find(SELECTOR_DATA_SPY).forEach(spy => new ScrollSpy(spy));\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .ScrollSpy to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(ScrollSpy);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): tab.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME$1 = 'tab';\nconst DATA_KEY$1 = 'bs.tab';\nconst EVENT_KEY$1 = `.${DATA_KEY$1}`;\nconst DATA_API_KEY = '.data-api';\nconst EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;\nconst EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;\nconst EVENT_SHOW$1 = `show${EVENT_KEY$1}`;\nconst EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;\nconst EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}${DATA_API_KEY}`;\nconst CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';\nconst CLASS_NAME_ACTIVE = 'active';\nconst CLASS_NAME_FADE$1 = 'fade';\nconst CLASS_NAME_SHOW$1 = 'show';\nconst SELECTOR_DROPDOWN = '.dropdown';\nconst SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\nconst SELECTOR_ACTIVE = '.active';\nconst SELECTOR_ACTIVE_UL = ':scope > li > .active';\nconst SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]';\nconst SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\nconst SELECTOR_DROPDOWN_ACTIVE_CHILD = ':scope > .dropdown-menu .active';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Tab extends BaseComponent {\n  // Getters\n  static get NAME() {\n    return NAME$1;\n  } // Public\n\n\n  show() {\n    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(CLASS_NAME_ACTIVE)) {\n      return;\n    }\n\n    let previous;\n    const target = getElementFromSelector(this._element);\n\n    const listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);\n\n    if (listElement) {\n      const itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;\n      previous = SelectorEngine.find(itemSelector, listElement);\n      previous = previous[previous.length - 1];\n    }\n\n    const hideEvent = previous ? EventHandler.trigger(previous, EVENT_HIDE$1, {\n      relatedTarget: this._element\n    }) : null;\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$1, {\n      relatedTarget: previous\n    });\n\n    if (showEvent.defaultPrevented || hideEvent !== null && hideEvent.defaultPrevented) {\n      return;\n    }\n\n    this._activate(this._element, listElement);\n\n    const complete = () => {\n      EventHandler.trigger(previous, EVENT_HIDDEN$1, {\n        relatedTarget: this._element\n      });\n      EventHandler.trigger(this._element, EVENT_SHOWN$1, {\n        relatedTarget: previous\n      });\n    };\n\n    if (target) {\n      this._activate(target, target.parentNode, complete);\n    } else {\n      complete();\n    }\n  } // Private\n\n\n  _activate(element, container, callback) {\n    const activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? SelectorEngine.find(SELECTOR_ACTIVE_UL, container) : SelectorEngine.children(container, SELECTOR_ACTIVE);\n    const active = activeElements[0];\n    const isTransitioning = callback && active && active.classList.contains(CLASS_NAME_FADE$1);\n\n    const complete = () => this._transitionComplete(element, active, callback);\n\n    if (active && isTransitioning) {\n      active.classList.remove(CLASS_NAME_SHOW$1);\n\n      this._queueCallback(complete, element, true);\n    } else {\n      complete();\n    }\n  }\n\n  _transitionComplete(element, active, callback) {\n    if (active) {\n      active.classList.remove(CLASS_NAME_ACTIVE);\n      const dropdownChild = SelectorEngine.findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);\n\n      if (dropdownChild) {\n        dropdownChild.classList.remove(CLASS_NAME_ACTIVE);\n      }\n\n      if (active.getAttribute('role') === 'tab') {\n        active.setAttribute('aria-selected', false);\n      }\n    }\n\n    element.classList.add(CLASS_NAME_ACTIVE);\n\n    if (element.getAttribute('role') === 'tab') {\n      element.setAttribute('aria-selected', true);\n    }\n\n    reflow(element);\n\n    if (element.classList.contains(CLASS_NAME_FADE$1)) {\n      element.classList.add(CLASS_NAME_SHOW$1);\n    }\n\n    let parent = element.parentNode;\n\n    if (parent && parent.nodeName === 'LI') {\n      parent = parent.parentNode;\n    }\n\n    if (parent && parent.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {\n      const dropdownElement = element.closest(SELECTOR_DROPDOWN);\n\n      if (dropdownElement) {\n        SelectorEngine.find(SELECTOR_DROPDOWN_TOGGLE, dropdownElement).forEach(dropdown => dropdown.classList.add(CLASS_NAME_ACTIVE));\n      }\n\n      element.setAttribute('aria-expanded', true);\n    }\n\n    if (callback) {\n      callback();\n    }\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Data.get(this, DATA_KEY$1) || new Tab(this);\n\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      }\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * Data Api implementation\n * ------------------------------------------------------------------------\n */\n\n\nEventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\n  if (['A', 'AREA'].includes(this.tagName)) {\n    event.preventDefault();\n  }\n\n  if (isDisabled(this)) {\n    return;\n  }\n\n  const data = Data.get(this, DATA_KEY$1) || new Tab(this);\n  data.show();\n});\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Tab to jQuery only if jQuery is present\n */\n\ndefineJQueryPlugin(Tab);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.0.1): toast.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n/**\n * ------------------------------------------------------------------------\n * Constants\n * ------------------------------------------------------------------------\n */\n\nconst NAME = 'toast';\nconst DATA_KEY = 'bs.toast';\nconst EVENT_KEY = `.${DATA_KEY}`;\nconst EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY}`;\nconst EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;\nconst EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;\nconst EVENT_FOCUSIN = `focusin${EVENT_KEY}`;\nconst EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;\nconst EVENT_HIDE = `hide${EVENT_KEY}`;\nconst EVENT_HIDDEN = `hidden${EVENT_KEY}`;\nconst EVENT_SHOW = `show${EVENT_KEY}`;\nconst EVENT_SHOWN = `shown${EVENT_KEY}`;\nconst CLASS_NAME_FADE = 'fade';\nconst CLASS_NAME_HIDE = 'hide';\nconst CLASS_NAME_SHOW = 'show';\nconst CLASS_NAME_SHOWING = 'showing';\nconst DefaultType = {\n  animation: 'boolean',\n  autohide: 'boolean',\n  delay: 'number'\n};\nconst Default = {\n  animation: true,\n  autohide: true,\n  delay: 5000\n};\nconst SELECTOR_DATA_DISMISS = '[data-bs-dismiss=\"toast\"]';\n/**\n * ------------------------------------------------------------------------\n * Class Definition\n * ------------------------------------------------------------------------\n */\n\nclass Toast extends BaseComponent {\n  constructor(element, config) {\n    super(element);\n    this._config = this._getConfig(config);\n    this._timeout = null;\n    this._hasMouseInteraction = false;\n    this._hasKeyboardInteraction = false;\n\n    this._setListeners();\n  } // Getters\n\n\n  static get DefaultType() {\n    return DefaultType;\n  }\n\n  static get Default() {\n    return Default;\n  }\n\n  static get NAME() {\n    return NAME;\n  } // Public\n\n\n  show() {\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\n\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n\n    this._clearTimeout();\n\n    if (this._config.animation) {\n      this._element.classList.add(CLASS_NAME_FADE);\n    }\n\n    const complete = () => {\n      this._element.classList.remove(CLASS_NAME_SHOWING);\n\n      this._element.classList.add(CLASS_NAME_SHOW);\n\n      EventHandler.trigger(this._element, EVENT_SHOWN);\n\n      this._maybeScheduleHide();\n    };\n\n    this._element.classList.remove(CLASS_NAME_HIDE);\n\n    reflow(this._element);\n\n    this._element.classList.add(CLASS_NAME_SHOWING);\n\n    this._queueCallback(complete, this._element, this._config.animation);\n  }\n\n  hide() {\n    if (!this._element.classList.contains(CLASS_NAME_SHOW)) {\n      return;\n    }\n\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\n\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n\n    const complete = () => {\n      this._element.classList.add(CLASS_NAME_HIDE);\n\n      EventHandler.trigger(this._element, EVENT_HIDDEN);\n    };\n\n    this._element.classList.remove(CLASS_NAME_SHOW);\n\n    this._queueCallback(complete, this._element, this._config.animation);\n  }\n\n  dispose() {\n    this._clearTimeout();\n\n    if (this._element.classList.contains(CLASS_NAME_SHOW)) {\n      this._element.classList.remove(CLASS_NAME_SHOW);\n    }\n\n    super.dispose();\n  } // Private\n\n\n  _getConfig(config) {\n    config = { ...Default,\n      ...Manipulator.getDataAttributes(this._element),\n      ...(typeof config === 'object' && config ? config : {})\n    };\n    typeCheckConfig(NAME, config, this.constructor.DefaultType);\n    return config;\n  }\n\n  _maybeScheduleHide() {\n    if (!this._config.autohide) {\n      return;\n    }\n\n    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n      return;\n    }\n\n    this._timeout = setTimeout(() => {\n      this.hide();\n    }, this._config.delay);\n  }\n\n  _onInteraction(event, isInteracting) {\n    switch (event.type) {\n      case 'mouseover':\n      case 'mouseout':\n        this._hasMouseInteraction = isInteracting;\n        break;\n\n      case 'focusin':\n      case 'focusout':\n        this._hasKeyboardInteraction = isInteracting;\n        break;\n    }\n\n    if (isInteracting) {\n      this._clearTimeout();\n\n      return;\n    }\n\n    const nextElement = event.relatedTarget;\n\n    if (this._element === nextElement || this._element.contains(nextElement)) {\n      return;\n    }\n\n    this._maybeScheduleHide();\n  }\n\n  _setListeners() {\n    EventHandler.on(this._element, EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, () => this.hide());\n    EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));\n    EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));\n    EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));\n    EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));\n  }\n\n  _clearTimeout() {\n    clearTimeout(this._timeout);\n    this._timeout = null;\n  } // Static\n\n\n  static jQueryInterface(config) {\n    return this.each(function () {\n      let data = Data.get(this, DATA_KEY);\n\n      const _config = typeof config === 'object' && config;\n\n      if (!data) {\n        data = new Toast(this, _config);\n      }\n\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config](this);\n      }\n    });\n  }\n\n}\n/**\n * ------------------------------------------------------------------------\n * jQuery\n * ------------------------------------------------------------------------\n * add .Toast to jQuery only if jQuery is present\n */\n\n\ndefineJQueryPlugin(Toast);\n\n\n//# sourceMappingURL=bootstrap.esm.js.map\n\n\n//# sourceURL=webpack:///./node_modules/bootstrap/dist/js/bootstrap.esm.js?")},"./node_modules/dropzone/dist/dropzone.js":function node_modulesDropzoneDistDropzoneJs(module,exports,__webpack_require__){eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse { var i, a; }\n})(self, function() {\nreturn /******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 3099:\n/***/ (function(module) {\n\nmodule.exports = function (it) {\n  if (typeof it != 'function') {\n    throw TypeError(String(it) + ' is not a function');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ 6077:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(111);\n\nmodule.exports = function (it) {\n  if (!isObject(it) && it !== null) {\n    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ 1223:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(5112);\nvar create = __webpack_require__(30);\nvar definePropertyModule = __webpack_require__(3070);\n\nvar UNSCOPABLES = wellKnownSymbol('unscopables');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: create(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nmodule.exports = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\n\n/***/ }),\n\n/***/ 1530:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar charAt = __webpack_require__(8710).charAt;\n\n// `AdvanceStringIndex` abstract operation\n// https://tc39.es/ecma262/#sec-advancestringindex\nmodule.exports = function (S, index, unicode) {\n  return index + (unicode ? charAt(S, index).length : 1);\n};\n\n\n/***/ }),\n\n/***/ 5787:\n/***/ (function(module) {\n\nmodule.exports = function (it, Constructor, name) {\n  if (!(it instanceof Constructor)) {\n    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ 9670:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(111);\n\nmodule.exports = function (it) {\n  if (!isObject(it)) {\n    throw TypeError(String(it) + ' is not an object');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ 4019:\n/***/ (function(module) {\n\nmodule.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';\n\n\n/***/ }),\n\n/***/ 260:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar NATIVE_ARRAY_BUFFER = __webpack_require__(4019);\nvar DESCRIPTORS = __webpack_require__(9781);\nvar global = __webpack_require__(7854);\nvar isObject = __webpack_require__(111);\nvar has = __webpack_require__(6656);\nvar classof = __webpack_require__(648);\nvar createNonEnumerableProperty = __webpack_require__(8880);\nvar redefine = __webpack_require__(1320);\nvar defineProperty = __webpack_require__(3070).f;\nvar getPrototypeOf = __webpack_require__(9518);\nvar setPrototypeOf = __webpack_require__(7674);\nvar wellKnownSymbol = __webpack_require__(5112);\nvar uid = __webpack_require__(9711);\n\nvar Int8Array = global.Int8Array;\nvar Int8ArrayPrototype = Int8Array && Int8Array.prototype;\nvar Uint8ClampedArray = global.Uint8ClampedArray;\nvar Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;\nvar TypedArray = Int8Array && getPrototypeOf(Int8Array);\nvar TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);\nvar ObjectPrototype = Object.prototype;\nvar isPrototypeOf = ObjectPrototype.isPrototypeOf;\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');\n// Fixing native typed arrays in Opera Presto crashes the browser, see #595\nvar NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';\nvar TYPED_ARRAY_TAG_REQIRED = false;\nvar NAME;\n\nvar TypedArrayConstructorsList = {\n  Int8Array: 1,\n  Uint8Array: 1,\n  Uint8ClampedArray: 1,\n  Int16Array: 2,\n  Uint16Array: 2,\n  Int32Array: 4,\n  Uint32Array: 4,\n  Float32Array: 4,\n  Float64Array: 8\n};\n\nvar BigIntArrayConstructorsList = {\n  BigInt64Array: 8,\n  BigUint64Array: 8\n};\n\nvar isView = function isView(it) {\n  if (!isObject(it)) return false;\n  var klass = classof(it);\n  return klass === 'DataView'\n    || has(TypedArrayConstructorsList, klass)\n    || has(BigIntArrayConstructorsList, klass);\n};\n\nvar isTypedArray = function (it) {\n  if (!isObject(it)) return false;\n  var klass = classof(it);\n  return has(TypedArrayConstructorsList, klass)\n    || has(BigIntArrayConstructorsList, klass);\n};\n\nvar aTypedArray = function (it) {\n  if (isTypedArray(it)) return it;\n  throw TypeError('Target is not a typed array');\n};\n\nvar aTypedArrayConstructor = function (C) {\n  if (setPrototypeOf) {\n    if (isPrototypeOf.call(TypedArray, C)) return C;\n  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {\n    var TypedArrayConstructor = global[ARRAY];\n    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {\n      return C;\n    }\n  } throw TypeError('Target is not a typed array constructor');\n};\n\nvar exportTypedArrayMethod = function (KEY, property, forced) {\n  if (!DESCRIPTORS) return;\n  if (forced) for (var ARRAY in TypedArrayConstructorsList) {\n    var TypedArrayConstructor = global[ARRAY];\n    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {\n      delete TypedArrayConstructor.prototype[KEY];\n    }\n  }\n  if (!TypedArrayPrototype[KEY] || forced) {\n    redefine(TypedArrayPrototype, KEY, forced ? property\n      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);\n  }\n};\n\nvar exportTypedArrayStaticMethod = function (KEY, property, forced) {\n  var ARRAY, TypedArrayConstructor;\n  if (!DESCRIPTORS) return;\n  if (setPrototypeOf) {\n    if (forced) for (ARRAY in TypedArrayConstructorsList) {\n      TypedArrayConstructor = global[ARRAY];\n      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {\n        delete TypedArrayConstructor[KEY];\n      }\n    }\n    if (!TypedArray[KEY] || forced) {\n      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable\n      try {\n        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);\n      } catch (error) { /* empty */ }\n    } else return;\n  }\n  for (ARRAY in TypedArrayConstructorsList) {\n    TypedArrayConstructor = global[ARRAY];\n    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n      redefine(TypedArrayConstructor, KEY, property);\n    }\n  }\n};\n\nfor (NAME in TypedArrayConstructorsList) {\n  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;\n}\n\n// WebKit bug - typed arrays constructors prototype is Object.prototype\nif (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {\n  // eslint-disable-next-line no-shadow -- safe\n  TypedArray = function TypedArray() {\n    throw TypeError('Incorrect invocation');\n  };\n  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {\n    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);\n  }\n}\n\nif (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {\n  TypedArrayPrototype = TypedArray.prototype;\n  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {\n    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);\n  }\n}\n\n// WebKit bug - one more object in Uint8ClampedArray prototype chain\nif (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {\n  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);\n}\n\nif (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {\n  TYPED_ARRAY_TAG_REQIRED = true;\n  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {\n    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;\n  } });\n  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {\n    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);\n  }\n}\n\nmodule.exports = {\n  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,\n  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,\n  aTypedArray: aTypedArray,\n  aTypedArrayConstructor: aTypedArrayConstructor,\n  exportTypedArrayMethod: exportTypedArrayMethod,\n  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,\n  isView: isView,\n  isTypedArray: isTypedArray,\n  TypedArray: TypedArray,\n  TypedArrayPrototype: TypedArrayPrototype\n};\n\n\n/***/ }),\n\n/***/ 3331:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar global = __webpack_require__(7854);\nvar DESCRIPTORS = __webpack_require__(9781);\nvar NATIVE_ARRAY_BUFFER = __webpack_require__(4019);\nvar createNonEnumerableProperty = __webpack_require__(8880);\nvar redefineAll = __webpack_require__(2248);\nvar fails = __webpack_require__(7293);\nvar anInstance = __webpack_require__(5787);\nvar toInteger = __webpack_require__(9958);\nvar toLength = __webpack_require__(7466);\nvar toIndex = __webpack_require__(7067);\nvar IEEE754 = __webpack_require__(1179);\nvar getPrototypeOf = __webpack_require__(9518);\nvar setPrototypeOf = __webpack_require__(7674);\nvar getOwnPropertyNames = __webpack_require__(8006).f;\nvar defineProperty = __webpack_require__(3070).f;\nvar arrayFill = __webpack_require__(1285);\nvar setToStringTag = __webpack_require__(8003);\nvar InternalStateModule = __webpack_require__(9909);\n\nvar getInternalState = InternalStateModule.get;\nvar setInternalState = InternalStateModule.set;\nvar ARRAY_BUFFER = 'ArrayBuffer';\nvar DATA_VIEW = 'DataView';\nvar PROTOTYPE = 'prototype';\nvar WRONG_LENGTH = 'Wrong length';\nvar WRONG_INDEX = 'Wrong index';\nvar NativeArrayBuffer = global[ARRAY_BUFFER];\nvar $ArrayBuffer = NativeArrayBuffer;\nvar $DataView = global[DATA_VIEW];\nvar $DataViewPrototype = $DataView && $DataView[PROTOTYPE];\nvar ObjectPrototype = Object.prototype;\nvar RangeError = global.RangeError;\n\nvar packIEEE754 = IEEE754.pack;\nvar unpackIEEE754 = IEEE754.unpack;\n\nvar packInt8 = function (number) {\n  return [number & 0xFF];\n};\n\nvar packInt16 = function (number) {\n  return [number & 0xFF, number >> 8 & 0xFF];\n};\n\nvar packInt32 = function (number) {\n  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];\n};\n\nvar unpackInt32 = function (buffer) {\n  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];\n};\n\nvar packFloat32 = function (number) {\n  return packIEEE754(number, 23, 4);\n};\n\nvar packFloat64 = function (number) {\n  return packIEEE754(number, 52, 8);\n};\n\nvar addGetter = function (Constructor, key) {\n  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });\n};\n\nvar get = function (view, count, index, isLittleEndian) {\n  var intIndex = toIndex(index);\n  var store = getInternalState(view);\n  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);\n  var bytes = getInternalState(store.buffer).bytes;\n  var start = intIndex + store.byteOffset;\n  var pack = bytes.slice(start, start + count);\n  return isLittleEndian ? pack : pack.reverse();\n};\n\nvar set = function (view, count, index, conversion, value, isLittleEndian) {\n  var intIndex = toIndex(index);\n  var store = getInternalState(view);\n  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);\n  var bytes = getInternalState(store.buffer).bytes;\n  var start = intIndex + store.byteOffset;\n  var pack = conversion(+value);\n  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];\n};\n\nif (!NATIVE_ARRAY_BUFFER) {\n  $ArrayBuffer = function ArrayBuffer(length) {\n    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);\n    var byteLength = toIndex(length);\n    setInternalState(this, {\n      bytes: arrayFill.call(new Array(byteLength), 0),\n      byteLength: byteLength\n    });\n    if (!DESCRIPTORS) this.byteLength = byteLength;\n  };\n\n  $DataView = function DataView(buffer, byteOffset, byteLength) {\n    anInstance(this, $DataView, DATA_VIEW);\n    anInstance(buffer, $ArrayBuffer, DATA_VIEW);\n    var bufferLength = getInternalState(buffer).byteLength;\n    var offset = toInteger(byteOffset);\n    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);\n    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);\n    setInternalState(this, {\n      buffer: buffer,\n      byteLength: byteLength,\n      byteOffset: offset\n    });\n    if (!DESCRIPTORS) {\n      this.buffer = buffer;\n      this.byteLength = byteLength;\n      this.byteOffset = offset;\n    }\n  };\n\n  if (DESCRIPTORS) {\n    addGetter($ArrayBuffer, 'byteLength');\n    addGetter($DataView, 'buffer');\n    addGetter($DataView, 'byteLength');\n    addGetter($DataView, 'byteOffset');\n  }\n\n  redefineAll($DataView[PROTOTYPE], {\n    getInt8: function getInt8(byteOffset) {\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset) {\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /* , littleEndian */) {\n      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));\n    },\n    getUint32: function getUint32(byteOffset /* , littleEndian */) {\n      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);\n    },\n    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);\n    },\n    setInt8: function setInt8(byteOffset, value) {\n      set(this, 1, byteOffset, packInt8, value);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      set(this, 1, byteOffset, packInt8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {\n      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);\n    }\n  });\n} else {\n  /* eslint-disable no-new -- required for testing */\n  if (!fails(function () {\n    NativeArrayBuffer(1);\n  }) || !fails(function () {\n    new NativeArrayBuffer(-1);\n  }) || fails(function () {\n    new NativeArrayBuffer();\n    new NativeArrayBuffer(1.5);\n    new NativeArrayBuffer(NaN);\n    return NativeArrayBuffer.name != ARRAY_BUFFER;\n  })) {\n  /* eslint-enable no-new -- required for testing */\n    $ArrayBuffer = function ArrayBuffer(length) {\n      anInstance(this, $ArrayBuffer);\n      return new NativeArrayBuffer(toIndex(length));\n    };\n    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];\n    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {\n      if (!((key = keys[j++]) in $ArrayBuffer)) {\n        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);\n      }\n    }\n    ArrayBufferPrototype.constructor = $ArrayBuffer;\n  }\n\n  // WebKit bug - the same parent prototype for typed arrays and data view\n  if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) {\n    setPrototypeOf($DataViewPrototype, ObjectPrototype);\n  }\n\n  // iOS Safari 7.x bug\n  var testView = new $DataView(new $ArrayBuffer(2));\n  var nativeSetInt8 = $DataViewPrototype.setInt8;\n  testView.setInt8(0, 2147483648);\n  testView.setInt8(1, 2147483649);\n  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {\n    setInt8: function setInt8(byteOffset, value) {\n      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);\n    }\n  }, { unsafe: true });\n}\n\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\n\nmodule.exports = {\n  ArrayBuffer: $ArrayBuffer,\n  DataView: $DataView\n};\n\n\n/***/ }),\n\n/***/ 1048:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar toObject = __webpack_require__(7908);\nvar toAbsoluteIndex = __webpack_require__(1400);\nvar toLength = __webpack_require__(7466);\n\nvar min = Math.min;\n\n// `Array.prototype.copyWithin` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.copywithin\nmodule.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {\n  var O = toObject(this);\n  var len = toLength(O.length);\n  var to = toAbsoluteIndex(target, len);\n  var from = toAbsoluteIndex(start, len);\n  var end = arguments.length > 2 ? arguments[2] : undefined;\n  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);\n  var inc = 1;\n  if (from < to && to < from + count) {\n    inc = -1;\n    from += count - 1;\n    to += count - 1;\n  }\n  while (count-- > 0) {\n    if (from in O) O[to] = O[from];\n    else delete O[to];\n    to += inc;\n    from += inc;\n  } return O;\n};\n\n\n/***/ }),\n\n/***/ 1285:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar toObject = __webpack_require__(7908);\nvar toAbsoluteIndex = __webpack_require__(1400);\nvar toLength = __webpack_require__(7466);\n\n// `Array.prototype.fill` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.fill\nmodule.exports = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject(this);\n  var length = toLength(O.length);\n  var argumentsLength = arguments.length;\n  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);\n  var end = argumentsLength > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n\n\n/***/ }),\n\n/***/ 8533:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $forEach = __webpack_require__(2092).forEach;\nvar arrayMethodIsStrict = __webpack_require__(9341);\n\nvar STRICT_METHOD = arrayMethodIsStrict('forEach');\n\n// `Array.prototype.forEach` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.foreach\nmodule.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {\n  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n} : [].forEach;\n\n\n/***/ }),\n\n/***/ 8457:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar bind = __webpack_require__(9974);\nvar toObject = __webpack_require__(7908);\nvar callWithSafeIterationClosing = __webpack_require__(3411);\nvar isArrayIteratorMethod = __webpack_require__(7659);\nvar toLength = __webpack_require__(7466);\nvar createProperty = __webpack_require__(6135);\nvar getIteratorMethod = __webpack_require__(1246);\n\n// `Array.from` method implementation\n// https://tc39.es/ecma262/#sec-array.from\nmodule.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n  var O = toObject(arrayLike);\n  var C = typeof this == 'function' ? this : Array;\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  var iteratorMethod = getIteratorMethod(O);\n  var index = 0;\n  var length, result, step, iterator, next, value;\n  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);\n  // if the target is not iterable or it's an array with the default iterator - use a simple case\n  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n    iterator = iteratorMethod.call(O);\n    next = iterator.next;\n    result = new C();\n    for (;!(step = next.call(iterator)).done; index++) {\n      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n      createProperty(result, index, value);\n    }\n  } else {\n    length = toLength(O.length);\n    result = new C(length);\n    for (;length > index; index++) {\n      value = mapping ? mapfn(O[index], index) : O[index];\n      createProperty(result, index, value);\n    }\n  }\n  result.length = index;\n  return result;\n};\n\n\n/***/ }),\n\n/***/ 1318:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar toIndexedObject = __webpack_require__(5656);\nvar toLength = __webpack_require__(7466);\nvar toAbsoluteIndex = __webpack_require__(1400);\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\n\n/***/ }),\n\n/***/ 2092:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar bind = __webpack_require__(9974);\nvar IndexedObject = __webpack_require__(8361);\nvar toObject = __webpack_require__(7908);\nvar toLength = __webpack_require__(7466);\nvar arraySpeciesCreate = __webpack_require__(5417);\n\nvar push = [].push;\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation\nvar createMethod = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_OUT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push.call(target, value); // filter\n        } else switch (TYPE) {\n          case 4: return false;             // every\n          case 7: push.call(target, value); // filterOut\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod(6),\n  // `Array.prototype.filterOut` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterOut: createMethod(7)\n};\n\n\n/***/ }),\n\n/***/ 6583:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar toIndexedObject = __webpack_require__(5656);\nvar toInteger = __webpack_require__(9958);\nvar toLength = __webpack_require__(7466);\nvar arrayMethodIsStrict = __webpack_require__(9341);\n\nvar min = Math.min;\nvar nativeLastIndexOf = [].lastIndexOf;\nvar NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;\nvar STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');\nvar FORCED = NEGATIVE_ZERO || !STRICT_METHOD;\n\n// `Array.prototype.lastIndexOf` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.lastindexof\nmodule.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {\n  // convert -0 to +0\n  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;\n  var O = toIndexedObject(this);\n  var length = toLength(O.length);\n  var index = length - 1;\n  if (arguments.length > 1) index = min(index, toInteger(arguments[1]));\n  if (index < 0) index = length + index;\n  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;\n  return -1;\n} : nativeLastIndexOf;\n\n\n/***/ }),\n\n/***/ 1194:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar fails = __webpack_require__(7293);\nvar wellKnownSymbol = __webpack_require__(5112);\nvar V8_VERSION = __webpack_require__(7392);\n\nvar SPECIES = wellKnownSymbol('species');\n\nmodule.exports = function (METHOD_NAME) {\n  // We can't use this feature detection in V8 since it causes\n  // deoptimization and serious performance degradation\n  // https://github.com/zloirock/core-js/issues/677\n  return V8_VERSION >= 51 || !fails(function () {\n    var array = [];\n    var constructor = array.constructor = {};\n    constructor[SPECIES] = function () {\n      return { foo: 1 };\n    };\n    return array[METHOD_NAME](Boolean).foo !== 1;\n  });\n};\n\n\n/***/ }),\n\n/***/ 9341:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar fails = __webpack_require__(7293);\n\nmodule.exports = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing\n    method.call(null, argument || function () { throw 1; }, 1);\n  });\n};\n\n\n/***/ }),\n\n/***/ 3671:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar aFunction = __webpack_require__(3099);\nvar toObject = __webpack_require__(7908);\nvar IndexedObject = __webpack_require__(8361);\nvar toLength = __webpack_require__(7466);\n\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aFunction(callbackfn);\n    var O = toObject(that);\n    var self = IndexedObject(O);\n    var length = toLength(O.length);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw TypeError('Reduce of empty array with no initial value');\n      }\n    }\n    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n    return memo;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.reduce` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduce\n  left: createMethod(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n  right: createMethod(true)\n};\n\n\n/***/ }),\n\n/***/ 5417:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(111);\nvar isArray = __webpack_require__(3157);\nvar wellKnownSymbol = __webpack_require__(5112);\n\nvar SPECIES = wellKnownSymbol('species');\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nmodule.exports = function (originalArray, length) {\n  var C;\n  if (isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    else if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n};\n\n\n/***/ }),\n\n/***/ 3411:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(9670);\nvar iteratorClose = __webpack_require__(9212);\n\n// call something on iterator step with safe closing on error\nmodule.exports = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (error) {\n    iteratorClose(iterator);\n    throw error;\n  }\n};\n\n\n/***/ }),\n\n/***/ 7072:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(5112);\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR] = function () {\n    return this;\n  };\n  // eslint-disable-next-line no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nmodule.exports = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\n\n/***/ }),\n\n/***/ 4326:\n/***/ (function(module) {\n\nvar toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n/***/ }),\n\n/***/ 648:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar TO_STRING_TAG_SUPPORT = __webpack_require__(1694);\nvar classofRaw = __webpack_require__(4326);\nvar wellKnownSymbol = __webpack_require__(5112);\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n};\n\n\n/***/ }),\n\n/***/ 9920:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar has = __webpack_require__(6656);\nvar ownKeys = __webpack_require__(3887);\nvar getOwnPropertyDescriptorModule = __webpack_require__(1236);\nvar definePropertyModule = __webpack_require__(3070);\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n\n\n/***/ }),\n\n/***/ 8544:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar fails = __webpack_require__(7293);\n\nmodule.exports = !fails(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\n\n/***/ }),\n\n/***/ 4994:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar IteratorPrototype = __webpack_require__(3383).IteratorPrototype;\nvar create = __webpack_require__(30);\nvar createPropertyDescriptor = __webpack_require__(9114);\nvar setToStringTag = __webpack_require__(8003);\nvar Iterators = __webpack_require__(7497);\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (IteratorConstructor, NAME, next) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });\n  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n  Iterators[TO_STRING_TAG] = returnThis;\n  return IteratorConstructor;\n};\n\n\n/***/ }),\n\n/***/ 8880:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(9781);\nvar definePropertyModule = __webpack_require__(3070);\nvar createPropertyDescriptor = __webpack_require__(9114);\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n\n/***/ 9114:\n/***/ (function(module) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n\n/***/ 6135:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar toPrimitive = __webpack_require__(7593);\nvar definePropertyModule = __webpack_require__(3070);\nvar createPropertyDescriptor = __webpack_require__(9114);\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPrimitive(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n\n\n/***/ }),\n\n/***/ 654:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(2109);\nvar createIteratorConstructor = __webpack_require__(4994);\nvar getPrototypeOf = __webpack_require__(9518);\nvar setPrototypeOf = __webpack_require__(7674);\nvar setToStringTag = __webpack_require__(8003);\nvar createNonEnumerableProperty = __webpack_require__(8880);\nvar redefine = __webpack_require__(1320);\nvar wellKnownSymbol = __webpack_require__(5112);\nvar IS_PURE = __webpack_require__(1913);\nvar Iterators = __webpack_require__(7497);\nvar IteratorsCore = __webpack_require__(3383);\n\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR = wellKnownSymbol('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf) {\n          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {\n          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\n    }\n  }\n\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    INCORRECT_VALUES_NAME = true;\n    defaultIterator = function values() { return nativeIterator.call(this); };\n  }\n\n  // define iterator\n  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);\n  }\n  Iterators[NAME] = defaultIterator;\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        redefine(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  return methods;\n};\n\n\n/***/ }),\n\n/***/ 9781:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar fails = __webpack_require__(7293);\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\n\n/***/ }),\n\n/***/ 317:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar global = __webpack_require__(7854);\nvar isObject = __webpack_require__(111);\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n\n/***/ 8324:\n/***/ (function(module) {\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nmodule.exports = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n\n/***/ }),\n\n/***/ 8113:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar getBuiltIn = __webpack_require__(5005);\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n\n\n/***/ }),\n\n/***/ 7392:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar global = __webpack_require__(7854);\nvar userAgent = __webpack_require__(8113);\n\nvar process = global.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  version = match[0] + match[1];\n} else if (userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = match[1];\n  }\n}\n\nmodule.exports = version && +version;\n\n\n/***/ }),\n\n/***/ 748:\n/***/ (function(module) {\n\n// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\n\n/***/ }),\n\n/***/ 2109:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar global = __webpack_require__(7854);\nvar getOwnPropertyDescriptor = __webpack_require__(1236).f;\nvar createNonEnumerableProperty = __webpack_require__(8880);\nvar redefine = __webpack_require__(1320);\nvar setGlobal = __webpack_require__(3505);\nvar copyConstructorProperties = __webpack_require__(9920);\nvar isForced = __webpack_require__(4705);\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty === typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n\n\n/***/ }),\n\n/***/ 7293:\n/***/ (function(module) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\n\n/***/ }),\n\n/***/ 7007:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\n// TODO: Remove from `core-js@4` since it's moved to entry points\n__webpack_require__(4916);\nvar redefine = __webpack_require__(1320);\nvar fails = __webpack_require__(7293);\nvar wellKnownSymbol = __webpack_require__(5112);\nvar regexpExec = __webpack_require__(2261);\nvar createNonEnumerableProperty = __webpack_require__(8880);\n\nvar SPECIES = wellKnownSymbol('species');\n\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n  // #replace needs built-in support for named groups.\n  // #match works fine because it just return the exec results, even if it has\n  // a \"grops\" property.\n  var re = /./;\n  re.exec = function () {\n    var result = [];\n    result.groups = { a: '7' };\n    return result;\n  };\n  return ''.replace(re, '$<a>') !== '7';\n});\n\n// IE <= 11 replaces $0 with the whole match, as if it was $&\n// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0\nvar REPLACE_KEEPS_$0 = (function () {\n  return 'a'.replace(/./, '$0') === '$0';\n})();\n\nvar REPLACE = wellKnownSymbol('replace');\n// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string\nvar REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {\n  if (/./[REPLACE]) {\n    return /./[REPLACE]('a', '$0') === '';\n  }\n  return false;\n})();\n\n// Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n// Weex JS has frozen built-in prototypes, so use try / catch wrapper\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {\n  // eslint-disable-next-line regexp/no-empty-group -- required for testing\n  var re = /(?:)/;\n  var originalExec = re.exec;\n  re.exec = function () { return originalExec.apply(this, arguments); };\n  var result = 'ab'.split(re);\n  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';\n});\n\nmodule.exports = function (KEY, length, exec, sham) {\n  var SYMBOL = wellKnownSymbol(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n\n    if (KEY === 'split') {\n      // We can't use real regex here since it causes deoptimization\n      // and serious performance degradation in V8\n      // https://github.com/zloirock/core-js/issues/306\n      re = {};\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n      re.flags = '';\n      re[SYMBOL] = /./[SYMBOL];\n    }\n\n    re.exec = function () { execCalled = true; return null; };\n\n    re[SYMBOL]('');\n    return !execCalled;\n  });\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    (KEY === 'replace' && !(\n      REPLACE_SUPPORTS_NAMED_GROUPS &&\n      REPLACE_KEEPS_$0 &&\n      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE\n    )) ||\n    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)\n  ) {\n    var nativeRegExpMethod = /./[SYMBOL];\n    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {\n      if (regexp.exec === regexpExec) {\n        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n          // The native String method already delegates to @@method (this\n          // polyfilled function), leasing to infinite recursion.\n          // We avoid it by directly calling the native @@method method.\n          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };\n        }\n        return { done: true, value: nativeMethod.call(str, regexp, arg2) };\n      }\n      return { done: false };\n    }, {\n      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,\n      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE\n    });\n    var stringMethod = methods[0];\n    var regexMethod = methods[1];\n\n    redefine(String.prototype, KEY, stringMethod);\n    redefine(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) { return regexMethod.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) { return regexMethod.call(string, this); }\n    );\n  }\n\n  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);\n};\n\n\n/***/ }),\n\n/***/ 9974:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar aFunction = __webpack_require__(3099);\n\n// optional / simple context binding\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 0: return function () {\n      return fn.call(that);\n    };\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/***/ }),\n\n/***/ 5005:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar path = __webpack_require__(857);\nvar global = __webpack_require__(7854);\n\nvar aFunction = function (variable) {\n  return typeof variable == 'function' ? variable : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])\n    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];\n};\n\n\n/***/ }),\n\n/***/ 1246:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar classof = __webpack_require__(648);\nvar Iterators = __webpack_require__(7497);\nvar wellKnownSymbol = __webpack_require__(5112);\n\nvar ITERATOR = wellKnownSymbol('iterator');\n\nmodule.exports = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n/***/ }),\n\n/***/ 8554:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(9670);\nvar getIteratorMethod = __webpack_require__(1246);\n\nmodule.exports = function (it) {\n  var iteratorMethod = getIteratorMethod(it);\n  if (typeof iteratorMethod != 'function') {\n    throw TypeError(String(it) + ' is not iterable');\n  } return anObject(iteratorMethod.call(it));\n};\n\n\n/***/ }),\n\n/***/ 647:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar toObject = __webpack_require__(7908);\n\nvar floor = Math.floor;\nvar replace = ''.replace;\nvar SUBSTITUTION_SYMBOLS = /\\$([$&'`]|\\d\\d?|<[^>]*>)/g;\nvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&'`]|\\d\\d?)/g;\n\n// https://tc39.es/ecma262/#sec-getsubstitution\nmodule.exports = function (matched, str, position, captures, namedCaptures, replacement) {\n  var tailPos = position + matched.length;\n  var m = captures.length;\n  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n  if (namedCaptures !== undefined) {\n    namedCaptures = toObject(namedCaptures);\n    symbols = SUBSTITUTION_SYMBOLS;\n  }\n  return replace.call(replacement, symbols, function (match, ch) {\n    var capture;\n    switch (ch.charAt(0)) {\n      case '$': return '$';\n      case '&': return matched;\n      case '`': return str.slice(0, position);\n      case \"'\": return str.slice(tailPos);\n      case '<':\n        capture = namedCaptures[ch.slice(1, -1)];\n        break;\n      default: // \\d\\d?\n        var n = +ch;\n        if (n === 0) return match;\n        if (n > m) {\n          var f = floor(n / 10);\n          if (f === 0) return match;\n          if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);\n          return match;\n        }\n        capture = captures[n - 1];\n    }\n    return capture === undefined ? '' : capture;\n  });\n};\n\n\n/***/ }),\n\n/***/ 7854:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  /* global globalThis -- safe */\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  check(typeof self == 'object' && self) ||\n  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\n\n/***/ }),\n\n/***/ 6656:\n/***/ (function(module) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n/***/ }),\n\n/***/ 3501:\n/***/ (function(module) {\n\nmodule.exports = {};\n\n\n/***/ }),\n\n/***/ 490:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar getBuiltIn = __webpack_require__(5005);\n\nmodule.exports = getBuiltIn('document', 'documentElement');\n\n\n/***/ }),\n\n/***/ 4664:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(9781);\nvar fails = __webpack_require__(7293);\nvar createElement = __webpack_require__(317);\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ 1179:\n/***/ (function(module) {\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nvar abs = Math.abs;\nvar pow = Math.pow;\nvar floor = Math.floor;\nvar log = Math.log;\nvar LN2 = Math.LN2;\n\nvar pack = function (number, mantissaLength, bytes) {\n  var buffer = new Array(bytes);\n  var exponentLength = bytes * 8 - mantissaLength - 1;\n  var eMax = (1 << exponentLength) - 1;\n  var eBias = eMax >> 1;\n  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;\n  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;\n  var index = 0;\n  var exponent, mantissa, c;\n  number = abs(number);\n  // eslint-disable-next-line no-self-compare -- NaN check\n  if (number != number || number === Infinity) {\n    // eslint-disable-next-line no-self-compare -- NaN check\n    mantissa = number != number ? 1 : 0;\n    exponent = eMax;\n  } else {\n    exponent = floor(log(number) / LN2);\n    if (number * (c = pow(2, -exponent)) < 1) {\n      exponent--;\n      c *= 2;\n    }\n    if (exponent + eBias >= 1) {\n      number += rt / c;\n    } else {\n      number += rt * pow(2, 1 - eBias);\n    }\n    if (number * c >= 2) {\n      exponent++;\n      c /= 2;\n    }\n    if (exponent + eBias >= eMax) {\n      mantissa = 0;\n      exponent = eMax;\n    } else if (exponent + eBias >= 1) {\n      mantissa = (number * c - 1) * pow(2, mantissaLength);\n      exponent = exponent + eBias;\n    } else {\n      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);\n      exponent = 0;\n    }\n  }\n  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);\n  exponent = exponent << mantissaLength | mantissa;\n  exponentLength += mantissaLength;\n  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);\n  buffer[--index] |= sign * 128;\n  return buffer;\n};\n\nvar unpack = function (buffer, mantissaLength) {\n  var bytes = buffer.length;\n  var exponentLength = bytes * 8 - mantissaLength - 1;\n  var eMax = (1 << exponentLength) - 1;\n  var eBias = eMax >> 1;\n  var nBits = exponentLength - 7;\n  var index = bytes - 1;\n  var sign = buffer[index--];\n  var exponent = sign & 127;\n  var mantissa;\n  sign >>= 7;\n  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);\n  mantissa = exponent & (1 << -nBits) - 1;\n  exponent >>= -nBits;\n  nBits += mantissaLength;\n  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);\n  if (exponent === 0) {\n    exponent = 1 - eBias;\n  } else if (exponent === eMax) {\n    return mantissa ? NaN : sign ? -Infinity : Infinity;\n  } else {\n    mantissa = mantissa + pow(2, mantissaLength);\n    exponent = exponent - eBias;\n  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);\n};\n\nmodule.exports = {\n  pack: pack,\n  unpack: unpack\n};\n\n\n/***/ }),\n\n/***/ 8361:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar fails = __webpack_require__(7293);\nvar classof = __webpack_require__(4326);\n\nvar split = ''.split;\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object;\n\n\n/***/ }),\n\n/***/ 9587:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(111);\nvar setPrototypeOf = __webpack_require__(7674);\n\n// makes subclassing work correct for wrapped built-ins\nmodule.exports = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf &&\n    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n    typeof (NewTarget = dummy.constructor) == 'function' &&\n    NewTarget !== Wrapper &&\n    isObject(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf($this, NewTargetPrototype);\n  return $this;\n};\n\n\n/***/ }),\n\n/***/ 2788:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar store = __webpack_require__(5465);\n\nvar functionToString = Function.toString;\n\n// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper\nif (typeof store.inspectSource != 'function') {\n  store.inspectSource = function (it) {\n    return functionToString.call(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n\n\n/***/ }),\n\n/***/ 9909:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar NATIVE_WEAK_MAP = __webpack_require__(8536);\nvar global = __webpack_require__(7854);\nvar isObject = __webpack_require__(111);\nvar createNonEnumerableProperty = __webpack_require__(8880);\nvar objectHas = __webpack_require__(6656);\nvar shared = __webpack_require__(5465);\nvar sharedKey = __webpack_require__(6200);\nvar hiddenKeys = __webpack_require__(3501);\n\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = store.get;\n  var wmhas = store.has;\n  var wmset = store.set;\n  set = function (it, metadata) {\n    metadata.facade = it;\n    wmset.call(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget.call(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas.call(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return objectHas(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return objectHas(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\n\n/***/ }),\n\n/***/ 7659:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(5112);\nvar Iterators = __webpack_require__(7497);\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n};\n\n\n/***/ }),\n\n/***/ 3157:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar classof = __webpack_require__(4326);\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\nmodule.exports = Array.isArray || function isArray(arg) {\n  return classof(arg) == 'Array';\n};\n\n\n/***/ }),\n\n/***/ 4705:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar fails = __webpack_require__(7293);\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : typeof detection == 'function' ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n\n\n/***/ }),\n\n/***/ 111:\n/***/ (function(module) {\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/***/ }),\n\n/***/ 1913:\n/***/ (function(module) {\n\nmodule.exports = false;\n\n\n/***/ }),\n\n/***/ 7850:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(111);\nvar classof = __webpack_require__(4326);\nvar wellKnownSymbol = __webpack_require__(5112);\n\nvar MATCH = wellKnownSymbol('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');\n};\n\n\n/***/ }),\n\n/***/ 9212:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(9670);\n\nmodule.exports = function (iterator) {\n  var returnMethod = iterator['return'];\n  if (returnMethod !== undefined) {\n    return anObject(returnMethod.call(iterator)).value;\n  }\n};\n\n\n/***/ }),\n\n/***/ 3383:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar fails = __webpack_require__(7293);\nvar getPrototypeOf = __webpack_require__(9518);\nvar createNonEnumerableProperty = __webpack_require__(8880);\nvar has = __webpack_require__(6656);\nvar wellKnownSymbol = __webpack_require__(5112);\nvar IS_PURE = __webpack_require__(1913);\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar BUGGY_SAFARI_ITERATORS = false;\n\nvar returnThis = function () { return this; };\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype[ITERATOR].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nif ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {\n  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\n}\n\nmodule.exports = {\n  IteratorPrototype: IteratorPrototype,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\n\n\n/***/ }),\n\n/***/ 7497:\n/***/ (function(module) {\n\nmodule.exports = {};\n\n\n/***/ }),\n\n/***/ 133:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar fails = __webpack_require__(7293);\n\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  // Chrome 38 Symbol has incorrect toString conversion\n  /* global Symbol -- required for testing */\n  return !String(Symbol());\n});\n\n\n/***/ }),\n\n/***/ 590:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar fails = __webpack_require__(7293);\nvar wellKnownSymbol = __webpack_require__(5112);\nvar IS_PURE = __webpack_require__(1913);\n\nvar ITERATOR = wellKnownSymbol('iterator');\n\nmodule.exports = !fails(function () {\n  var url = new URL('b?a=1&b=2&c=3', 'http://a');\n  var searchParams = url.searchParams;\n  var result = '';\n  url.pathname = 'c%20d';\n  searchParams.forEach(function (value, key) {\n    searchParams['delete']('b');\n    result += key + value;\n  });\n  return (IS_PURE && !url.toJSON)\n    || !searchParams.sort\n    || url.href !== 'http://a/c%20d?a=1&c=3'\n    || searchParams.get('c') !== '3'\n    || String(new URLSearchParams('?a=1')) !== 'a=1'\n    || !searchParams[ITERATOR]\n    // throws in Edge\n    || new URL('https://a@b').username !== 'a'\n    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'\n    // not punycoded in Edge\n    || new URL('http://тест').host !== 'xn--e1aybc'\n    // not escaped in Chrome 62-\n    || new URL('http://a#б').hash !== '#%D0%B1'\n    // fails in Chrome 66-\n    || result !== 'a1c3'\n    // throws in Safari\n    || new URL('http://x', undefined).host !== 'x';\n});\n\n\n/***/ }),\n\n/***/ 8536:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar global = __webpack_require__(7854);\nvar inspectSource = __webpack_require__(2788);\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));\n\n\n/***/ }),\n\n/***/ 1574:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar DESCRIPTORS = __webpack_require__(9781);\nvar fails = __webpack_require__(7293);\nvar objectKeys = __webpack_require__(1956);\nvar getOwnPropertySymbolsModule = __webpack_require__(5181);\nvar propertyIsEnumerableModule = __webpack_require__(5296);\nvar toObject = __webpack_require__(7908);\nvar IndexedObject = __webpack_require__(8361);\n\nvar nativeAssign = Object.assign;\nvar defineProperty = Object.defineProperty;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nmodule.exports = !nativeAssign || fails(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  /* global Symbol -- required for testing */\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n    }\n  } return T;\n} : nativeAssign;\n\n\n/***/ }),\n\n/***/ 30:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(9670);\nvar defineProperties = __webpack_require__(6048);\nvar enumBugKeys = __webpack_require__(748);\nvar hiddenKeys = __webpack_require__(3501);\nvar html = __webpack_require__(490);\nvar documentCreateElement = __webpack_require__(317);\nvar sharedKey = __webpack_require__(6200);\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    /* global ActiveXObject -- old IE */\n    activeXDocument = document.domain && new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : defineProperties(result, Properties);\n};\n\n\n/***/ }),\n\n/***/ 6048:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(9781);\nvar definePropertyModule = __webpack_require__(3070);\nvar anObject = __webpack_require__(9670);\nvar objectKeys = __webpack_require__(1956);\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);\n  return O;\n};\n\n\n/***/ }),\n\n/***/ 3070:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(9781);\nvar IE8_DOM_DEFINE = __webpack_require__(4664);\nvar anObject = __webpack_require__(9670);\nvar toPrimitive = __webpack_require__(7593);\n\nvar nativeDefineProperty = Object.defineProperty;\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return nativeDefineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n\n/***/ 1236:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(9781);\nvar propertyIsEnumerableModule = __webpack_require__(5296);\nvar createPropertyDescriptor = __webpack_require__(9114);\nvar toIndexedObject = __webpack_require__(5656);\nvar toPrimitive = __webpack_require__(7593);\nvar has = __webpack_require__(6656);\nvar IE8_DOM_DEFINE = __webpack_require__(4664);\n\nvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return nativeGetOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n\n\n/***/ }),\n\n/***/ 8006:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\nvar internalObjectKeys = __webpack_require__(6324);\nvar enumBugKeys = __webpack_require__(748);\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\n\n/***/ }),\n\n/***/ 5181:\n/***/ (function(__unused_webpack_module, exports) {\n\nexports.f = Object.getOwnPropertySymbols;\n\n\n/***/ }),\n\n/***/ 9518:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar has = __webpack_require__(6656);\nvar toObject = __webpack_require__(7908);\nvar sharedKey = __webpack_require__(6200);\nvar CORRECT_PROTOTYPE_GETTER = __webpack_require__(8544);\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar ObjectPrototype = Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectPrototype : null;\n};\n\n\n/***/ }),\n\n/***/ 6324:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar has = __webpack_require__(6656);\nvar toIndexedObject = __webpack_require__(5656);\nvar indexOf = __webpack_require__(1318).indexOf;\nvar hiddenKeys = __webpack_require__(3501);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~indexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n/***/ }),\n\n/***/ 1956:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar internalObjectKeys = __webpack_require__(6324);\nvar enumBugKeys = __webpack_require__(748);\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\n\n/***/ }),\n\n/***/ 5296:\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\nvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : nativePropertyIsEnumerable;\n\n\n/***/ }),\n\n/***/ 7674:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n/* eslint-disable no-proto -- safe */\nvar anObject = __webpack_require__(9670);\nvar aPossiblePrototype = __webpack_require__(6077);\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n    setter.call(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter.call(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\n\n/***/ }),\n\n/***/ 288:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar TO_STRING_TAG_SUPPORT = __webpack_require__(1694);\nvar classof = __webpack_require__(648);\n\n// `Object.prototype.toString` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.tostring\nmodule.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {\n  return '[object ' + classof(this) + ']';\n};\n\n\n/***/ }),\n\n/***/ 3887:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar getBuiltIn = __webpack_require__(5005);\nvar getOwnPropertyNamesModule = __webpack_require__(8006);\nvar getOwnPropertySymbolsModule = __webpack_require__(5181);\nvar anObject = __webpack_require__(9670);\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n\n\n/***/ }),\n\n/***/ 857:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar global = __webpack_require__(7854);\n\nmodule.exports = global;\n\n\n/***/ }),\n\n/***/ 2248:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar redefine = __webpack_require__(1320);\n\nmodule.exports = function (target, src, options) {\n  for (var key in src) redefine(target, key, src[key], options);\n  return target;\n};\n\n\n/***/ }),\n\n/***/ 1320:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar global = __webpack_require__(7854);\nvar createNonEnumerableProperty = __webpack_require__(8880);\nvar has = __webpack_require__(6656);\nvar setGlobal = __webpack_require__(3505);\nvar inspectSource = __webpack_require__(2788);\nvar InternalStateModule = __webpack_require__(9909);\n\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(String).split('String');\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  var state;\n  if (typeof value == 'function') {\n    if (typeof key == 'string' && !has(value, 'name')) {\n      createNonEnumerableProperty(value, 'name', key);\n    }\n    state = enforceInternalState(value);\n    if (!state.source) {\n      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');\n    }\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else createNonEnumerableProperty(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, 'toString', function toString() {\n  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);\n});\n\n\n/***/ }),\n\n/***/ 7651:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar classof = __webpack_require__(4326);\nvar regexpExec = __webpack_require__(2261);\n\n// `RegExpExec` abstract operation\n// https://tc39.es/ecma262/#sec-regexpexec\nmodule.exports = function (R, S) {\n  var exec = R.exec;\n  if (typeof exec === 'function') {\n    var result = exec.call(R, S);\n    if (typeof result !== 'object') {\n      throw TypeError('RegExp exec method returned something other than an Object or null');\n    }\n    return result;\n  }\n\n  if (classof(R) !== 'RegExp') {\n    throw TypeError('RegExp#exec called on incompatible receiver');\n  }\n\n  return regexpExec.call(R, S);\n};\n\n\n\n/***/ }),\n\n/***/ 2261:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar regexpFlags = __webpack_require__(7066);\nvar stickyHelpers = __webpack_require__(2999);\n\nvar nativeExec = RegExp.prototype.exec;\n// This always refers to the native implementation, because the\n// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,\n// which loads this file before patching the method.\nvar nativeReplace = String.prototype.replace;\n\nvar patchedExec = nativeExec;\n\nvar UPDATES_LAST_INDEX_WRONG = (function () {\n  var re1 = /a/;\n  var re2 = /b*/g;\n  nativeExec.call(re1, 'a');\n  nativeExec.call(re2, 'a');\n  return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n})();\n\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;\n\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\n// eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;\n\nif (PATCH) {\n  patchedExec = function exec(str) {\n    var re = this;\n    var lastIndex, reCopy, match, i;\n    var sticky = UNSUPPORTED_Y && re.sticky;\n    var flags = regexpFlags.call(re);\n    var source = re.source;\n    var charsAdded = 0;\n    var strCopy = str;\n\n    if (sticky) {\n      flags = flags.replace('y', '');\n      if (flags.indexOf('g') === -1) {\n        flags += 'g';\n      }\n\n      strCopy = String(str).slice(re.lastIndex);\n      // Support anchored sticky behavior.\n      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\\n')) {\n        source = '(?: ' + source + ')';\n        strCopy = ' ' + strCopy;\n        charsAdded++;\n      }\n      // ^(? + rx + ) is needed, in combination with some str slicing, to\n      // simulate the 'y' flag.\n      reCopy = new RegExp('^(?:' + source + ')', flags);\n    }\n\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp('^' + source + '$(?!\\\\s)', flags);\n    }\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n\n    match = nativeExec.call(sticky ? reCopy : re, strCopy);\n\n    if (sticky) {\n      if (match) {\n        match.input = match.input.slice(charsAdded);\n        match[0] = match[0].slice(charsAdded);\n        match.index = re.lastIndex;\n        re.lastIndex += match[0].length;\n      } else re.lastIndex = 0;\n    } else if (UPDATES_LAST_INDEX_WRONG && match) {\n      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match && match.length > 1) {\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n      nativeReplace.call(match[0], reCopy, function () {\n        for (i = 1; i < arguments.length - 2; i++) {\n          if (arguments[i] === undefined) match[i] = undefined;\n        }\n      });\n    }\n\n    return match;\n  };\n}\n\nmodule.exports = patchedExec;\n\n\n/***/ }),\n\n/***/ 7066:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar anObject = __webpack_require__(9670);\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\n\n/***/ }),\n\n/***/ 2999:\n/***/ (function(__unused_webpack_module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar fails = __webpack_require__(7293);\n\n// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,\n// so we use an intermediate function.\nfunction RE(s, f) {\n  return RegExp(s, f);\n}\n\nexports.UNSUPPORTED_Y = fails(function () {\n  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError\n  var re = RE('a', 'y');\n  re.lastIndex = 2;\n  return re.exec('abcd') != null;\n});\n\nexports.BROKEN_CARET = fails(function () {\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687\n  var re = RE('^r', 'gy');\n  re.lastIndex = 2;\n  return re.exec('str') != null;\n});\n\n\n/***/ }),\n\n/***/ 4488:\n/***/ (function(module) {\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n\n\n/***/ }),\n\n/***/ 3505:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar global = __webpack_require__(7854);\nvar createNonEnumerableProperty = __webpack_require__(8880);\n\nmodule.exports = function (key, value) {\n  try {\n    createNonEnumerableProperty(global, key, value);\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n\n\n/***/ }),\n\n/***/ 6340:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar getBuiltIn = __webpack_require__(5005);\nvar definePropertyModule = __webpack_require__(3070);\nvar wellKnownSymbol = __webpack_require__(5112);\nvar DESCRIPTORS = __webpack_require__(9781);\n\nvar SPECIES = wellKnownSymbol('species');\n\nmodule.exports = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule.f;\n\n  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {\n    defineProperty(Constructor, SPECIES, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\n\n/***/ }),\n\n/***/ 8003:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar defineProperty = __webpack_require__(3070).f;\nvar has = __webpack_require__(6656);\nvar wellKnownSymbol = __webpack_require__(5112);\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\nmodule.exports = function (it, TAG, STATIC) {\n  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });\n  }\n};\n\n\n/***/ }),\n\n/***/ 6200:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar shared = __webpack_require__(2309);\nvar uid = __webpack_require__(9711);\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n\n/***/ }),\n\n/***/ 5465:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar global = __webpack_require__(7854);\nvar setGlobal = __webpack_require__(3505);\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\nmodule.exports = store;\n\n\n/***/ }),\n\n/***/ 2309:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar IS_PURE = __webpack_require__(1913);\nvar store = __webpack_require__(5465);\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.9.0',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'\n});\n\n\n/***/ }),\n\n/***/ 6707:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(9670);\nvar aFunction = __webpack_require__(3099);\nvar wellKnownSymbol = __webpack_require__(5112);\n\nvar SPECIES = wellKnownSymbol('species');\n\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nmodule.exports = function (O, defaultConstructor) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);\n};\n\n\n/***/ }),\n\n/***/ 8710:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(9958);\nvar requireObjectCoercible = __webpack_require__(4488);\n\n// `String.prototype.{ codePointAt, at }` methods implementation\nvar createMethod = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = String(requireObjectCoercible($this));\n    var position = toInteger(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = S.charCodeAt(position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING ? S.charAt(position) : first\n        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod(true)\n};\n\n\n/***/ }),\n\n/***/ 3197:\n/***/ (function(module) {\n\n\"use strict\";\n\n// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\nvar regexNonASCII = /[^\\0-\\u007E]/; // non-ASCII chars\nvar regexSeparators = /[.\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\nvar OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n */\nvar ucs2decode = function (string) {\n  var output = [];\n  var counter = 0;\n  var length = string.length;\n  while (counter < length) {\n    var value = string.charCodeAt(counter++);\n    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n      // It's a high surrogate, and there is a next character.\n      var extra = string.charCodeAt(counter++);\n      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n      } else {\n        // It's an unmatched surrogate; only append this code unit, in case the\n        // next code unit is the high surrogate of a surrogate pair.\n        output.push(value);\n        counter--;\n      }\n    } else {\n      output.push(value);\n    }\n  }\n  return output;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n */\nvar digitToBasic = function (digit) {\n  //  0..25 map to ASCII a..z or A..Z\n  // 26..35 map to ASCII 0..9\n  return digit + 22 + 75 * (digit < 26);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n */\nvar adapt = function (delta, numPoints, firstTime) {\n  var k = 0;\n  delta = firstTime ? floor(delta / damp) : delta >> 1;\n  delta += floor(delta / numPoints);\n  for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n    delta = floor(delta / baseMinusTMin);\n  }\n  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n */\n// eslint-disable-next-line max-statements -- TODO\nvar encode = function (input) {\n  var output = [];\n\n  // Convert the input in UCS-2 to an array of Unicode code points.\n  input = ucs2decode(input);\n\n  // Cache the length.\n  var inputLength = input.length;\n\n  // Initialize the state.\n  var n = initialN;\n  var delta = 0;\n  var bias = initialBias;\n  var i, currentValue;\n\n  // Handle the basic code points.\n  for (i = 0; i < input.length; i++) {\n    currentValue = input[i];\n    if (currentValue < 0x80) {\n      output.push(stringFromCharCode(currentValue));\n    }\n  }\n\n  var basicLength = output.length; // number of basic code points.\n  var handledCPCount = basicLength; // number of code points that have been handled;\n\n  // Finish the basic string with a delimiter unless it's empty.\n  if (basicLength) {\n    output.push(delimiter);\n  }\n\n  // Main encoding loop:\n  while (handledCPCount < inputLength) {\n    // All non-basic code points < n have been handled already. Find the next larger one:\n    var m = maxInt;\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n      if (currentValue >= n && currentValue < m) {\n        m = currentValue;\n      }\n    }\n\n    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.\n    var handledCPCountPlusOne = handledCPCount + 1;\n    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n      throw RangeError(OVERFLOW_ERROR);\n    }\n\n    delta += (m - n) * handledCPCountPlusOne;\n    n = m;\n\n    for (i = 0; i < input.length; i++) {\n      currentValue = input[i];\n      if (currentValue < n && ++delta > maxInt) {\n        throw RangeError(OVERFLOW_ERROR);\n      }\n      if (currentValue == n) {\n        // Represent delta as a generalized variable-length integer.\n        var q = delta;\n        for (var k = base; /* no condition */; k += base) {\n          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n          if (q < t) break;\n          var qMinusT = q - t;\n          var baseMinusT = base - t;\n          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));\n          q = floor(qMinusT / baseMinusT);\n        }\n\n        output.push(stringFromCharCode(digitToBasic(q)));\n        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n        delta = 0;\n        ++handledCPCount;\n      }\n    }\n\n    ++delta;\n    ++n;\n  }\n  return output.join('');\n};\n\nmodule.exports = function (input) {\n  var encoded = [];\n  var labels = input.toLowerCase().replace(regexSeparators, '\\u002E').split('.');\n  var i, label;\n  for (i = 0; i < labels.length; i++) {\n    label = labels[i];\n    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);\n  }\n  return encoded.join('.');\n};\n\n\n/***/ }),\n\n/***/ 6091:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar fails = __webpack_require__(7293);\nvar whitespaces = __webpack_require__(1361);\n\nvar non = '\\u200B\\u0085\\u180E';\n\n// check that a method works with the correct list\n// of whitespaces and has a correct name\nmodule.exports = function (METHOD_NAME) {\n  return fails(function () {\n    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;\n  });\n};\n\n\n/***/ }),\n\n/***/ 3111:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar requireObjectCoercible = __webpack_require__(4488);\nvar whitespaces = __webpack_require__(1361);\n\nvar whitespace = '[' + whitespaces + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod = function (TYPE) {\n  return function ($this) {\n    var string = String(requireObjectCoercible($this));\n    if (TYPE & 1) string = string.replace(ltrim, '');\n    if (TYPE & 2) string = string.replace(rtrim, '');\n    return string;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod(3)\n};\n\n\n/***/ }),\n\n/***/ 1400:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(9958);\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n\n/***/ }),\n\n/***/ 7067:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(9958);\nvar toLength = __webpack_require__(7466);\n\n// `ToIndex` abstract operation\n// https://tc39.es/ecma262/#sec-toindex\nmodule.exports = function (it) {\n  if (it === undefined) return 0;\n  var number = toInteger(it);\n  var length = toLength(number);\n  if (number !== length) throw RangeError('Wrong length or index');\n  return length;\n};\n\n\n/***/ }),\n\n/***/ 5656:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(8361);\nvar requireObjectCoercible = __webpack_require__(4488);\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n\n\n/***/ }),\n\n/***/ 9958:\n/***/ (function(module) {\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToInteger` abstract operation\n// https://tc39.es/ecma262/#sec-tointeger\nmodule.exports = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n\n\n/***/ }),\n\n/***/ 7466:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(9958);\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\n\n/***/ }),\n\n/***/ 7908:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar requireObjectCoercible = __webpack_require__(4488);\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n\n\n/***/ }),\n\n/***/ 4590:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar toPositiveInteger = __webpack_require__(3002);\n\nmodule.exports = function (it, BYTES) {\n  var offset = toPositiveInteger(it);\n  if (offset % BYTES) throw RangeError('Wrong offset');\n  return offset;\n};\n\n\n/***/ }),\n\n/***/ 3002:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(9958);\n\nmodule.exports = function (it) {\n  var result = toInteger(it);\n  if (result < 0) throw RangeError(\"The argument can't be less than 0\");\n  return result;\n};\n\n\n/***/ }),\n\n/***/ 7593:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(111);\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (input, PREFERRED_STRING) {\n  if (!isObject(input)) return input;\n  var fn, val;\n  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/***/ }),\n\n/***/ 1694:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(5112);\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n\n\n/***/ }),\n\n/***/ 9843:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(2109);\nvar global = __webpack_require__(7854);\nvar DESCRIPTORS = __webpack_require__(9781);\nvar TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(3832);\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar ArrayBufferModule = __webpack_require__(3331);\nvar anInstance = __webpack_require__(5787);\nvar createPropertyDescriptor = __webpack_require__(9114);\nvar createNonEnumerableProperty = __webpack_require__(8880);\nvar toLength = __webpack_require__(7466);\nvar toIndex = __webpack_require__(7067);\nvar toOffset = __webpack_require__(4590);\nvar toPrimitive = __webpack_require__(7593);\nvar has = __webpack_require__(6656);\nvar classof = __webpack_require__(648);\nvar isObject = __webpack_require__(111);\nvar create = __webpack_require__(30);\nvar setPrototypeOf = __webpack_require__(7674);\nvar getOwnPropertyNames = __webpack_require__(8006).f;\nvar typedArrayFrom = __webpack_require__(7321);\nvar forEach = __webpack_require__(2092).forEach;\nvar setSpecies = __webpack_require__(6340);\nvar definePropertyModule = __webpack_require__(3070);\nvar getOwnPropertyDescriptorModule = __webpack_require__(1236);\nvar InternalStateModule = __webpack_require__(9909);\nvar inheritIfRequired = __webpack_require__(9587);\n\nvar getInternalState = InternalStateModule.get;\nvar setInternalState = InternalStateModule.set;\nvar nativeDefineProperty = definePropertyModule.f;\nvar nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\nvar round = Math.round;\nvar RangeError = global.RangeError;\nvar ArrayBuffer = ArrayBufferModule.ArrayBuffer;\nvar DataView = ArrayBufferModule.DataView;\nvar NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;\nvar TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;\nvar TypedArray = ArrayBufferViewCore.TypedArray;\nvar TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;\nvar aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;\nvar isTypedArray = ArrayBufferViewCore.isTypedArray;\nvar BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\nvar WRONG_LENGTH = 'Wrong length';\n\nvar fromList = function (C, list) {\n  var index = 0;\n  var length = list.length;\n  var result = new (aTypedArrayConstructor(C))(length);\n  while (length > index) result[index] = list[index++];\n  return result;\n};\n\nvar addGetter = function (it, key) {\n  nativeDefineProperty(it, key, { get: function () {\n    return getInternalState(this)[key];\n  } });\n};\n\nvar isArrayBuffer = function (it) {\n  var klass;\n  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';\n};\n\nvar isTypedArrayIndex = function (target, key) {\n  return isTypedArray(target)\n    && typeof key != 'symbol'\n    && key in target\n    && String(+key) == String(key);\n};\n\nvar wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {\n  return isTypedArrayIndex(target, key = toPrimitive(key, true))\n    ? createPropertyDescriptor(2, target[key])\n    : nativeGetOwnPropertyDescriptor(target, key);\n};\n\nvar wrappedDefineProperty = function defineProperty(target, key, descriptor) {\n  if (isTypedArrayIndex(target, key = toPrimitive(key, true))\n    && isObject(descriptor)\n    && has(descriptor, 'value')\n    && !has(descriptor, 'get')\n    && !has(descriptor, 'set')\n    // TODO: add validation descriptor w/o calling accessors\n    && !descriptor.configurable\n    && (!has(descriptor, 'writable') || descriptor.writable)\n    && (!has(descriptor, 'enumerable') || descriptor.enumerable)\n  ) {\n    target[key] = descriptor.value;\n    return target;\n  } return nativeDefineProperty(target, key, descriptor);\n};\n\nif (DESCRIPTORS) {\n  if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;\n    definePropertyModule.f = wrappedDefineProperty;\n    addGetter(TypedArrayPrototype, 'buffer');\n    addGetter(TypedArrayPrototype, 'byteOffset');\n    addGetter(TypedArrayPrototype, 'byteLength');\n    addGetter(TypedArrayPrototype, 'length');\n  }\n\n  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {\n    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,\n    defineProperty: wrappedDefineProperty\n  });\n\n  module.exports = function (TYPE, wrapper, CLAMPED) {\n    var BYTES = TYPE.match(/\\d+$/)[0] / 8;\n    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';\n    var GETTER = 'get' + TYPE;\n    var SETTER = 'set' + TYPE;\n    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];\n    var TypedArrayConstructor = NativeTypedArrayConstructor;\n    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;\n    var exported = {};\n\n    var getter = function (that, index) {\n      var data = getInternalState(that);\n      return data.view[GETTER](index * BYTES + data.byteOffset, true);\n    };\n\n    var setter = function (that, index, value) {\n      var data = getInternalState(that);\n      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;\n      data.view[SETTER](index * BYTES + data.byteOffset, value, true);\n    };\n\n    var addElement = function (that, index) {\n      nativeDefineProperty(that, index, {\n        get: function () {\n          return getter(this, index);\n        },\n        set: function (value) {\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n\n    if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {\n        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);\n        var index = 0;\n        var byteOffset = 0;\n        var buffer, byteLength, length;\n        if (!isObject(data)) {\n          length = toIndex(data);\n          byteLength = length * BYTES;\n          buffer = new ArrayBuffer(byteLength);\n        } else if (isArrayBuffer(data)) {\n          buffer = data;\n          byteOffset = toOffset(offset, BYTES);\n          var $len = data.byteLength;\n          if ($length === undefined) {\n            if ($len % BYTES) throw RangeError(WRONG_LENGTH);\n            byteLength = $len - byteOffset;\n            if (byteLength < 0) throw RangeError(WRONG_LENGTH);\n          } else {\n            byteLength = toLength($length) * BYTES;\n            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if (isTypedArray(data)) {\n          return fromList(TypedArrayConstructor, data);\n        } else {\n          return typedArrayFrom.call(TypedArrayConstructor, data);\n        }\n        setInternalState(that, {\n          buffer: buffer,\n          byteOffset: byteOffset,\n          byteLength: byteLength,\n          length: length,\n          view: new DataView(buffer)\n        });\n        while (index < length) addElement(that, index++);\n      });\n\n      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\n      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);\n    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {\n      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {\n        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);\n        return inheritIfRequired(function () {\n          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));\n          if (isArrayBuffer(data)) return $length !== undefined\n            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)\n            : typedArrayOffset !== undefined\n              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))\n              : new NativeTypedArrayConstructor(data);\n          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);\n          return typedArrayFrom.call(TypedArrayConstructor, data);\n        }(), dummy, TypedArrayConstructor);\n      });\n\n      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\n      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {\n        if (!(key in TypedArrayConstructor)) {\n          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);\n        }\n      });\n      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;\n    }\n\n    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {\n      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);\n    }\n\n    if (TYPED_ARRAY_TAG) {\n      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);\n    }\n\n    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;\n\n    $({\n      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS\n    }, exported);\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {\n      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);\n    }\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {\n      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);\n    }\n\n    setSpecies(CONSTRUCTOR_NAME);\n  };\n} else module.exports = function () { /* empty */ };\n\n\n/***/ }),\n\n/***/ 3832:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n/* eslint-disable no-new -- required for testing */\nvar global = __webpack_require__(7854);\nvar fails = __webpack_require__(7293);\nvar checkCorrectnessOfIteration = __webpack_require__(7072);\nvar NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__(260).NATIVE_ARRAY_BUFFER_VIEWS;\n\nvar ArrayBuffer = global.ArrayBuffer;\nvar Int8Array = global.Int8Array;\n\nmodule.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {\n  Int8Array(1);\n}) || !fails(function () {\n  new Int8Array(-1);\n}) || !checkCorrectnessOfIteration(function (iterable) {\n  new Int8Array();\n  new Int8Array(null);\n  new Int8Array(1.5);\n  new Int8Array(iterable);\n}, true) || fails(function () {\n  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill\n  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;\n});\n\n\n/***/ }),\n\n/***/ 3074:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar aTypedArrayConstructor = __webpack_require__(260).aTypedArrayConstructor;\nvar speciesConstructor = __webpack_require__(6707);\n\nmodule.exports = function (instance, list) {\n  var C = speciesConstructor(instance, instance.constructor);\n  var index = 0;\n  var length = list.length;\n  var result = new (aTypedArrayConstructor(C))(length);\n  while (length > index) result[index] = list[index++];\n  return result;\n};\n\n\n/***/ }),\n\n/***/ 7321:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar toObject = __webpack_require__(7908);\nvar toLength = __webpack_require__(7466);\nvar getIteratorMethod = __webpack_require__(1246);\nvar isArrayIteratorMethod = __webpack_require__(7659);\nvar bind = __webpack_require__(9974);\nvar aTypedArrayConstructor = __webpack_require__(260).aTypedArrayConstructor;\n\nmodule.exports = function from(source /* , mapfn, thisArg */) {\n  var O = toObject(source);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  var iteratorMethod = getIteratorMethod(O);\n  var i, length, result, step, iterator, next;\n  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {\n    iterator = iteratorMethod.call(O);\n    next = iterator.next;\n    O = [];\n    while (!(step = next.call(iterator)).done) {\n      O.push(step.value);\n    }\n  }\n  if (mapping && argumentsLength > 2) {\n    mapfn = bind(mapfn, arguments[2], 2);\n  }\n  length = toLength(O.length);\n  result = new (aTypedArrayConstructor(this))(length);\n  for (i = 0; length > i; i++) {\n    result[i] = mapping ? mapfn(O[i], i) : O[i];\n  }\n  return result;\n};\n\n\n/***/ }),\n\n/***/ 9711:\n/***/ (function(module) {\n\nvar id = 0;\nvar postfix = Math.random();\n\nmodule.exports = function (key) {\n  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n\n\n/***/ }),\n\n/***/ 3307:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar NATIVE_SYMBOL = __webpack_require__(133);\n\nmodule.exports = NATIVE_SYMBOL\n  /* global Symbol -- safe */\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\n\n/***/ }),\n\n/***/ 5112:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar global = __webpack_require__(7854);\nvar shared = __webpack_require__(2309);\nvar has = __webpack_require__(6656);\nvar uid = __webpack_require__(9711);\nvar NATIVE_SYMBOL = __webpack_require__(133);\nvar USE_SYMBOL_AS_UID = __webpack_require__(3307);\n\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!has(WellKnownSymbolsStore, name)) {\n    if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];\n    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\n  } return WellKnownSymbolsStore[name];\n};\n\n\n/***/ }),\n\n/***/ 1361:\n/***/ (function(module) {\n\n// a string of all valid unicode whitespaces\nmodule.exports = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002' +\n  '\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\n\n/***/ }),\n\n/***/ 8264:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(2109);\nvar global = __webpack_require__(7854);\nvar arrayBufferModule = __webpack_require__(3331);\nvar setSpecies = __webpack_require__(6340);\n\nvar ARRAY_BUFFER = 'ArrayBuffer';\nvar ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];\nvar NativeArrayBuffer = global[ARRAY_BUFFER];\n\n// `ArrayBuffer` constructor\n// https://tc39.es/ecma262/#sec-arraybuffer-constructor\n$({ global: true, forced: NativeArrayBuffer !== ArrayBuffer }, {\n  ArrayBuffer: ArrayBuffer\n});\n\nsetSpecies(ARRAY_BUFFER);\n\n\n/***/ }),\n\n/***/ 2222:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(2109);\nvar fails = __webpack_require__(7293);\nvar isArray = __webpack_require__(3157);\nvar isObject = __webpack_require__(111);\nvar toObject = __webpack_require__(7908);\nvar toLength = __webpack_require__(7466);\nvar createProperty = __webpack_require__(6135);\nvar arraySpeciesCreate = __webpack_require__(5417);\nvar arrayMethodHasSpeciesSupport = __webpack_require__(1194);\nvar wellKnownSymbol = __webpack_require__(5112);\nvar V8_VERSION = __webpack_require__(7392);\n\nvar IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\nvar MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';\n\n// We can't use this feature detection in V8 since it causes\n// deoptimization and serious performance degradation\n// https://github.com/zloirock/core-js/issues/679\nvar IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {\n  var array = [];\n  array[IS_CONCAT_SPREADABLE] = false;\n  return array.concat()[0] !== array;\n});\n\nvar SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');\n\nvar isConcatSpreadable = function (O) {\n  if (!isObject(O)) return false;\n  var spreadable = O[IS_CONCAT_SPREADABLE];\n  return spreadable !== undefined ? !!spreadable : isArray(O);\n};\n\nvar FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;\n\n// `Array.prototype.concat` method\n// https://tc39.es/ecma262/#sec-array.prototype.concat\n// with adding support of @@isConcatSpreadable and @@species\n$({ target: 'Array', proto: true, forced: FORCED }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  concat: function concat(arg) {\n    var O = toObject(this);\n    var A = arraySpeciesCreate(O, 0);\n    var n = 0;\n    var i, k, length, len, E;\n    for (i = -1, length = arguments.length; i < length; i++) {\n      E = i === -1 ? O : arguments[i];\n      if (isConcatSpreadable(E)) {\n        len = toLength(E.length);\n        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);\n      } else {\n        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n        createProperty(A, n++, E);\n      }\n    }\n    A.length = n;\n    return A;\n  }\n});\n\n\n/***/ }),\n\n/***/ 7327:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(2109);\nvar $filter = __webpack_require__(2092).filter;\nvar arrayMethodHasSpeciesSupport = __webpack_require__(1194);\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');\n\n// `Array.prototype.filter` method\n// https://tc39.es/ecma262/#sec-array.prototype.filter\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  filter: function filter(callbackfn /* , thisArg */) {\n    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n\n/***/ }),\n\n/***/ 2772:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(2109);\nvar $indexOf = __webpack_require__(1318).indexOf;\nvar arrayMethodIsStrict = __webpack_require__(9341);\n\nvar nativeIndexOf = [].indexOf;\n\nvar NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;\nvar STRICT_METHOD = arrayMethodIsStrict('indexOf');\n\n// `Array.prototype.indexOf` method\n// https://tc39.es/ecma262/#sec-array.prototype.indexof\n$({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD }, {\n  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {\n    return NEGATIVE_ZERO\n      // convert -0 to +0\n      ? nativeIndexOf.apply(this, arguments) || 0\n      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n\n/***/ }),\n\n/***/ 6992:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar toIndexedObject = __webpack_require__(5656);\nvar addToUnscopables = __webpack_require__(1223);\nvar Iterators = __webpack_require__(7497);\nvar InternalStateModule = __webpack_require__(9909);\nvar defineIterator = __webpack_require__(654);\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nmodule.exports = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nIterators.Arguments = Iterators.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n/***/ }),\n\n/***/ 1249:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(2109);\nvar $map = __webpack_require__(2092).map;\nvar arrayMethodHasSpeciesSupport = __webpack_require__(1194);\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');\n\n// `Array.prototype.map` method\n// https://tc39.es/ecma262/#sec-array.prototype.map\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n\n/***/ }),\n\n/***/ 7042:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(2109);\nvar isObject = __webpack_require__(111);\nvar isArray = __webpack_require__(3157);\nvar toAbsoluteIndex = __webpack_require__(1400);\nvar toLength = __webpack_require__(7466);\nvar toIndexedObject = __webpack_require__(5656);\nvar createProperty = __webpack_require__(6135);\nvar wellKnownSymbol = __webpack_require__(5112);\nvar arrayMethodHasSpeciesSupport = __webpack_require__(1194);\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');\n\nvar SPECIES = wellKnownSymbol('species');\nvar nativeSlice = [].slice;\nvar max = Math.max;\n\n// `Array.prototype.slice` method\n// https://tc39.es/ecma262/#sec-array.prototype.slice\n// fallback for not array-like ES3 strings and DOM objects\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  slice: function slice(start, end) {\n    var O = toIndexedObject(this);\n    var length = toLength(O.length);\n    var k = toAbsoluteIndex(start, length);\n    var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible\n    var Constructor, result, n;\n    if (isArray(O)) {\n      Constructor = O.constructor;\n      // cross-realm fallback\n      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {\n        Constructor = undefined;\n      } else if (isObject(Constructor)) {\n        Constructor = Constructor[SPECIES];\n        if (Constructor === null) Constructor = undefined;\n      }\n      if (Constructor === Array || Constructor === undefined) {\n        return nativeSlice.call(O, k, fin);\n      }\n    }\n    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));\n    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);\n    result.length = n;\n    return result;\n  }\n});\n\n\n/***/ }),\n\n/***/ 561:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(2109);\nvar toAbsoluteIndex = __webpack_require__(1400);\nvar toInteger = __webpack_require__(9958);\nvar toLength = __webpack_require__(7466);\nvar toObject = __webpack_require__(7908);\nvar arraySpeciesCreate = __webpack_require__(5417);\nvar createProperty = __webpack_require__(6135);\nvar arrayMethodHasSpeciesSupport = __webpack_require__(1194);\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');\n\nvar max = Math.max;\nvar min = Math.min;\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\nvar MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';\n\n// `Array.prototype.splice` method\n// https://tc39.es/ecma262/#sec-array.prototype.splice\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  splice: function splice(start, deleteCount /* , ...items */) {\n    var O = toObject(this);\n    var len = toLength(O.length);\n    var actualStart = toAbsoluteIndex(start, len);\n    var argumentsLength = arguments.length;\n    var insertCount, actualDeleteCount, A, k, from, to;\n    if (argumentsLength === 0) {\n      insertCount = actualDeleteCount = 0;\n    } else if (argumentsLength === 1) {\n      insertCount = 0;\n      actualDeleteCount = len - actualStart;\n    } else {\n      insertCount = argumentsLength - 2;\n      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);\n    }\n    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {\n      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);\n    }\n    A = arraySpeciesCreate(O, actualDeleteCount);\n    for (k = 0; k < actualDeleteCount; k++) {\n      from = actualStart + k;\n      if (from in O) createProperty(A, k, O[from]);\n    }\n    A.length = actualDeleteCount;\n    if (insertCount < actualDeleteCount) {\n      for (k = actualStart; k < len - actualDeleteCount; k++) {\n        from = k + actualDeleteCount;\n        to = k + insertCount;\n        if (from in O) O[to] = O[from];\n        else delete O[to];\n      }\n      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];\n    } else if (insertCount > actualDeleteCount) {\n      for (k = len - actualDeleteCount; k > actualStart; k--) {\n        from = k + actualDeleteCount - 1;\n        to = k + insertCount - 1;\n        if (from in O) O[to] = O[from];\n        else delete O[to];\n      }\n    }\n    for (k = 0; k < insertCount; k++) {\n      O[k + actualStart] = arguments[k + 2];\n    }\n    O.length = len - actualDeleteCount + insertCount;\n    return A;\n  }\n});\n\n\n/***/ }),\n\n/***/ 8309:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(9781);\nvar defineProperty = __webpack_require__(3070).f;\n\nvar FunctionPrototype = Function.prototype;\nvar FunctionPrototypeToString = FunctionPrototype.toString;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// Function instances `.name` property\n// https://tc39.es/ecma262/#sec-function-instances-name\nif (DESCRIPTORS && !(NAME in FunctionPrototype)) {\n  defineProperty(FunctionPrototype, NAME, {\n    configurable: true,\n    get: function () {\n      try {\n        return FunctionPrototypeToString.call(this).match(nameRE)[1];\n      } catch (error) {\n        return '';\n      }\n    }\n  });\n}\n\n\n/***/ }),\n\n/***/ 489:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\nvar $ = __webpack_require__(2109);\nvar fails = __webpack_require__(7293);\nvar toObject = __webpack_require__(7908);\nvar nativeGetPrototypeOf = __webpack_require__(9518);\nvar CORRECT_PROTOTYPE_GETTER = __webpack_require__(8544);\n\nvar FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {\n  getPrototypeOf: function getPrototypeOf(it) {\n    return nativeGetPrototypeOf(toObject(it));\n  }\n});\n\n\n\n/***/ }),\n\n/***/ 1539:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\nvar TO_STRING_TAG_SUPPORT = __webpack_require__(1694);\nvar redefine = __webpack_require__(1320);\nvar toString = __webpack_require__(288);\n\n// `Object.prototype.toString` method\n// https://tc39.es/ecma262/#sec-object.prototype.tostring\nif (!TO_STRING_TAG_SUPPORT) {\n  redefine(Object.prototype, 'toString', toString, { unsafe: true });\n}\n\n\n/***/ }),\n\n/***/ 4916:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(2109);\nvar exec = __webpack_require__(2261);\n\n// `RegExp.prototype.exec` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.exec\n$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {\n  exec: exec\n});\n\n\n/***/ }),\n\n/***/ 9714:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar redefine = __webpack_require__(1320);\nvar anObject = __webpack_require__(9670);\nvar fails = __webpack_require__(7293);\nvar flags = __webpack_require__(7066);\n\nvar TO_STRING = 'toString';\nvar RegExpPrototype = RegExp.prototype;\nvar nativeToString = RegExpPrototype[TO_STRING];\n\nvar NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });\n// FF44- RegExp#toString has a wrong name\nvar INCORRECT_NAME = nativeToString.name != TO_STRING;\n\n// `RegExp.prototype.toString` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.tostring\nif (NOT_GENERIC || INCORRECT_NAME) {\n  redefine(RegExp.prototype, TO_STRING, function toString() {\n    var R = anObject(this);\n    var p = String(R.source);\n    var rf = R.flags;\n    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);\n    return '/' + p + '/' + f;\n  }, { unsafe: true });\n}\n\n\n/***/ }),\n\n/***/ 8783:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar charAt = __webpack_require__(8710).charAt;\nvar InternalStateModule = __webpack_require__(9909);\nvar defineIterator = __webpack_require__(654);\n\nvar STRING_ITERATOR = 'String Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\n\n// `String.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\ndefineIterator(String, 'String', function (iterated) {\n  setInternalState(this, {\n    type: STRING_ITERATOR,\n    string: String(iterated),\n    index: 0\n  });\n// `%StringIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return { value: undefined, done: true };\n  point = charAt(string, index);\n  state.index += point.length;\n  return { value: point, done: false };\n});\n\n\n/***/ }),\n\n/***/ 4723:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar fixRegExpWellKnownSymbolLogic = __webpack_require__(7007);\nvar anObject = __webpack_require__(9670);\nvar toLength = __webpack_require__(7466);\nvar requireObjectCoercible = __webpack_require__(4488);\nvar advanceStringIndex = __webpack_require__(1530);\nvar regExpExec = __webpack_require__(7651);\n\n// @@match logic\nfixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {\n  return [\n    // `String.prototype.match` method\n    // https://tc39.es/ecma262/#sec-string.prototype.match\n    function match(regexp) {\n      var O = requireObjectCoercible(this);\n      var matcher = regexp == undefined ? undefined : regexp[MATCH];\n      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n    },\n    // `RegExp.prototype[@@match]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match\n    function (regexp) {\n      var res = maybeCallNative(nativeMatch, regexp, this);\n      if (res.done) return res.value;\n\n      var rx = anObject(regexp);\n      var S = String(this);\n\n      if (!rx.global) return regExpExec(rx, S);\n\n      var fullUnicode = rx.unicode;\n      rx.lastIndex = 0;\n      var A = [];\n      var n = 0;\n      var result;\n      while ((result = regExpExec(rx, S)) !== null) {\n        var matchStr = String(result[0]);\n        A[n] = matchStr;\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n        n++;\n      }\n      return n === 0 ? null : A;\n    }\n  ];\n});\n\n\n/***/ }),\n\n/***/ 5306:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar fixRegExpWellKnownSymbolLogic = __webpack_require__(7007);\nvar anObject = __webpack_require__(9670);\nvar toLength = __webpack_require__(7466);\nvar toInteger = __webpack_require__(9958);\nvar requireObjectCoercible = __webpack_require__(4488);\nvar advanceStringIndex = __webpack_require__(1530);\nvar getSubstitution = __webpack_require__(647);\nvar regExpExec = __webpack_require__(7651);\n\nvar max = Math.max;\nvar min = Math.min;\n\nvar maybeToString = function (it) {\n  return it === undefined ? it : String(it);\n};\n\n// @@replace logic\nfixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {\n  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;\n  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;\n  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';\n\n  return [\n    // `String.prototype.replace` method\n    // https://tc39.es/ecma262/#sec-string.prototype.replace\n    function replace(searchValue, replaceValue) {\n      var O = requireObjectCoercible(this);\n      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];\n      return replacer !== undefined\n        ? replacer.call(searchValue, O, replaceValue)\n        : nativeReplace.call(String(O), searchValue, replaceValue);\n    },\n    // `RegExp.prototype[@@replace]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace\n    function (regexp, replaceValue) {\n      if (\n        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||\n        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)\n      ) {\n        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);\n        if (res.done) return res.value;\n      }\n\n      var rx = anObject(regexp);\n      var S = String(this);\n\n      var functionalReplace = typeof replaceValue === 'function';\n      if (!functionalReplace) replaceValue = String(replaceValue);\n\n      var global = rx.global;\n      if (global) {\n        var fullUnicode = rx.unicode;\n        rx.lastIndex = 0;\n      }\n      var results = [];\n      while (true) {\n        var result = regExpExec(rx, S);\n        if (result === null) break;\n\n        results.push(result);\n        if (!global) break;\n\n        var matchStr = String(result[0]);\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n      }\n\n      var accumulatedResult = '';\n      var nextSourcePosition = 0;\n      for (var i = 0; i < results.length; i++) {\n        result = results[i];\n\n        var matched = String(result[0]);\n        var position = max(min(toInteger(result.index), S.length), 0);\n        var captures = [];\n        // NOTE: This is equivalent to\n        //   captures = result.slice(1).map(maybeToString)\n        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n        // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));\n        var namedCaptures = result.groups;\n        if (functionalReplace) {\n          var replacerArgs = [matched].concat(captures, position, S);\n          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);\n          var replacement = String(replaceValue.apply(undefined, replacerArgs));\n        } else {\n          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n        }\n        if (position >= nextSourcePosition) {\n          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;\n          nextSourcePosition = position + matched.length;\n        }\n      }\n      return accumulatedResult + S.slice(nextSourcePosition);\n    }\n  ];\n});\n\n\n/***/ }),\n\n/***/ 3123:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar fixRegExpWellKnownSymbolLogic = __webpack_require__(7007);\nvar isRegExp = __webpack_require__(7850);\nvar anObject = __webpack_require__(9670);\nvar requireObjectCoercible = __webpack_require__(4488);\nvar speciesConstructor = __webpack_require__(6707);\nvar advanceStringIndex = __webpack_require__(1530);\nvar toLength = __webpack_require__(7466);\nvar callRegExpExec = __webpack_require__(7651);\nvar regexpExec = __webpack_require__(2261);\nvar fails = __webpack_require__(7293);\n\nvar arrayPush = [].push;\nvar min = Math.min;\nvar MAX_UINT32 = 0xFFFFFFFF;\n\n// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError\nvar SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });\n\n// @@split logic\nfixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {\n  var internalSplit;\n  if (\n    'abbc'.split(/(b)*/)[1] == 'c' ||\n    // eslint-disable-next-line regexp/no-empty-group -- required for testing\n    'test'.split(/(?:)/, -1).length != 4 ||\n    'ab'.split(/(?:ab)*/).length != 2 ||\n    '.'.split(/(.?)(.?)/).length != 4 ||\n    // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing\n    '.'.split(/()()/).length > 1 ||\n    ''.split(/.?/).length\n  ) {\n    // based on es5-shim implementation, need to rework it\n    internalSplit = function (separator, limit) {\n      var string = String(requireObjectCoercible(this));\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (separator === undefined) return [string];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) {\n        return nativeSplit.call(string, separator, lim);\n      }\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var match, lastIndex, lastLength;\n      while (match = regexpExec.call(separatorCopy, string)) {\n        lastIndex = separatorCopy.lastIndex;\n        if (lastIndex > lastLastIndex) {\n          output.push(string.slice(lastLastIndex, match.index));\n          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));\n          lastLength = match[0].length;\n          lastLastIndex = lastIndex;\n          if (output.length >= lim) break;\n        }\n        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string.length) {\n        if (lastLength || !separatorCopy.test('')) output.push('');\n      } else output.push(string.slice(lastLastIndex));\n      return output.length > lim ? output.slice(0, lim) : output;\n    };\n  // Chakra, V8\n  } else if ('0'.split(undefined, 0).length) {\n    internalSplit = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);\n    };\n  } else internalSplit = nativeSplit;\n\n  return [\n    // `String.prototype.split` method\n    // https://tc39.es/ecma262/#sec-string.prototype.split\n    function split(separator, limit) {\n      var O = requireObjectCoercible(this);\n      var splitter = separator == undefined ? undefined : separator[SPLIT];\n      return splitter !== undefined\n        ? splitter.call(separator, O, limit)\n        : internalSplit.call(String(O), separator, limit);\n    },\n    // `RegExp.prototype[@@split]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split\n    //\n    // NOTE: This cannot be properly polyfilled in engines that don't support\n    // the 'y' flag.\n    function (regexp, limit) {\n      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);\n      if (res.done) return res.value;\n\n      var rx = anObject(regexp);\n      var S = String(this);\n      var C = speciesConstructor(rx, RegExp);\n\n      var unicodeMatching = rx.unicode;\n      var flags = (rx.ignoreCase ? 'i' : '') +\n                  (rx.multiline ? 'm' : '') +\n                  (rx.unicode ? 'u' : '') +\n                  (SUPPORTS_Y ? 'y' : 'g');\n\n      // ^(? + rx + ) is needed, in combination with some S slicing, to\n      // simulate the 'y' flag.\n      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];\n      var p = 0;\n      var q = 0;\n      var A = [];\n      while (q < S.length) {\n        splitter.lastIndex = SUPPORTS_Y ? q : 0;\n        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));\n        var e;\n        if (\n          z === null ||\n          (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p\n        ) {\n          q = advanceStringIndex(S, q, unicodeMatching);\n        } else {\n          A.push(S.slice(p, q));\n          if (A.length === lim) return A;\n          for (var i = 1; i <= z.length - 1; i++) {\n            A.push(z[i]);\n            if (A.length === lim) return A;\n          }\n          q = p = e;\n        }\n      }\n      A.push(S.slice(p));\n      return A;\n    }\n  ];\n}, !SUPPORTS_Y);\n\n\n/***/ }),\n\n/***/ 3210:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(2109);\nvar $trim = __webpack_require__(3111).trim;\nvar forcedStringTrimMethod = __webpack_require__(6091);\n\n// `String.prototype.trim` method\n// https://tc39.es/ecma262/#sec-string.prototype.trim\n$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {\n  trim: function trim() {\n    return $trim(this);\n  }\n});\n\n\n/***/ }),\n\n/***/ 2990:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $copyWithin = __webpack_require__(1048);\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.copyWithin` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin\nexportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */) {\n  return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n});\n\n\n/***/ }),\n\n/***/ 8927:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $every = __webpack_require__(2092).every;\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.every` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every\nexportTypedArrayMethod('every', function every(callbackfn /* , thisArg */) {\n  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n});\n\n\n/***/ }),\n\n/***/ 3105:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $fill = __webpack_require__(1285);\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.fill` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill\n// eslint-disable-next-line no-unused-vars -- required for `.length`\nexportTypedArrayMethod('fill', function fill(value /* , start, end */) {\n  return $fill.apply(aTypedArray(this), arguments);\n});\n\n\n/***/ }),\n\n/***/ 5035:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $filter = __webpack_require__(2092).filter;\nvar fromSpeciesAndList = __webpack_require__(3074);\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.filter` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter\nexportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */) {\n  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  return fromSpeciesAndList(this, list);\n});\n\n\n/***/ }),\n\n/***/ 7174:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $findIndex = __webpack_require__(2092).findIndex;\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.findIndex` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex\nexportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */) {\n  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n});\n\n\n/***/ }),\n\n/***/ 4345:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $find = __webpack_require__(2092).find;\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.find` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find\nexportTypedArrayMethod('find', function find(predicate /* , thisArg */) {\n  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n});\n\n\n/***/ }),\n\n/***/ 2846:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $forEach = __webpack_require__(2092).forEach;\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.forEach` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach\nexportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */) {\n  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n});\n\n\n/***/ }),\n\n/***/ 4731:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $includes = __webpack_require__(1318).includes;\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.includes` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes\nexportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */) {\n  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n});\n\n\n/***/ }),\n\n/***/ 7209:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $indexOf = __webpack_require__(1318).indexOf;\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.indexOf` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof\nexportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */) {\n  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n});\n\n\n/***/ }),\n\n/***/ 6319:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar global = __webpack_require__(7854);\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar ArrayIterators = __webpack_require__(6992);\nvar wellKnownSymbol = __webpack_require__(5112);\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar Uint8Array = global.Uint8Array;\nvar arrayValues = ArrayIterators.values;\nvar arrayKeys = ArrayIterators.keys;\nvar arrayEntries = ArrayIterators.entries;\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];\n\nvar CORRECT_ITER_NAME = !!nativeTypedArrayIterator\n  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);\n\nvar typedArrayValues = function values() {\n  return arrayValues.call(aTypedArray(this));\n};\n\n// `%TypedArray%.prototype.entries` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries\nexportTypedArrayMethod('entries', function entries() {\n  return arrayEntries.call(aTypedArray(this));\n});\n// `%TypedArray%.prototype.keys` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys\nexportTypedArrayMethod('keys', function keys() {\n  return arrayKeys.call(aTypedArray(this));\n});\n// `%TypedArray%.prototype.values` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values\nexportTypedArrayMethod('values', typedArrayValues, !CORRECT_ITER_NAME);\n// `%TypedArray%.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator\nexportTypedArrayMethod(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);\n\n\n/***/ }),\n\n/***/ 8867:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar $join = [].join;\n\n// `%TypedArray%.prototype.join` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join\n// eslint-disable-next-line no-unused-vars -- required for `.length`\nexportTypedArrayMethod('join', function join(separator) {\n  return $join.apply(aTypedArray(this), arguments);\n});\n\n\n/***/ }),\n\n/***/ 7789:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $lastIndexOf = __webpack_require__(6583);\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.lastIndexOf` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof\n// eslint-disable-next-line no-unused-vars -- required for `.length`\nexportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {\n  return $lastIndexOf.apply(aTypedArray(this), arguments);\n});\n\n\n/***/ }),\n\n/***/ 3739:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $map = __webpack_require__(2092).map;\nvar speciesConstructor = __webpack_require__(6707);\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.map` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map\nexportTypedArrayMethod('map', function map(mapfn /* , thisArg */) {\n  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {\n    return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);\n  });\n});\n\n\n/***/ }),\n\n/***/ 4483:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $reduceRight = __webpack_require__(3671).right;\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.reduceRicht` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright\nexportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */) {\n  return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);\n});\n\n\n/***/ }),\n\n/***/ 9368:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $reduce = __webpack_require__(3671).left;\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce\nexportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */) {\n  return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);\n});\n\n\n/***/ }),\n\n/***/ 2056:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar floor = Math.floor;\n\n// `%TypedArray%.prototype.reverse` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse\nexportTypedArrayMethod('reverse', function reverse() {\n  var that = this;\n  var length = aTypedArray(that).length;\n  var middle = floor(length / 2);\n  var index = 0;\n  var value;\n  while (index < middle) {\n    value = that[index];\n    that[index++] = that[--length];\n    that[length] = value;\n  } return that;\n});\n\n\n/***/ }),\n\n/***/ 3462:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar toLength = __webpack_require__(7466);\nvar toOffset = __webpack_require__(4590);\nvar toObject = __webpack_require__(7908);\nvar fails = __webpack_require__(7293);\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\nvar FORCED = fails(function () {\n  /* global Int8Array -- safe */\n  new Int8Array(1).set({});\n});\n\n// `%TypedArray%.prototype.set` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set\nexportTypedArrayMethod('set', function set(arrayLike /* , offset */) {\n  aTypedArray(this);\n  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);\n  var length = this.length;\n  var src = toObject(arrayLike);\n  var len = toLength(src.length);\n  var index = 0;\n  if (len + offset > length) throw RangeError('Wrong length');\n  while (index < len) this[offset + index] = src[index++];\n}, FORCED);\n\n\n/***/ }),\n\n/***/ 678:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar speciesConstructor = __webpack_require__(6707);\nvar fails = __webpack_require__(7293);\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar $slice = [].slice;\n\nvar FORCED = fails(function () {\n  /* global Int8Array -- safe */\n  new Int8Array(1).slice();\n});\n\n// `%TypedArray%.prototype.slice` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice\nexportTypedArrayMethod('slice', function slice(start, end) {\n  var list = $slice.call(aTypedArray(this), start, end);\n  var C = speciesConstructor(this, this.constructor);\n  var index = 0;\n  var length = list.length;\n  var result = new (aTypedArrayConstructor(C))(length);\n  while (length > index) result[index] = list[index++];\n  return result;\n}, FORCED);\n\n\n/***/ }),\n\n/***/ 7462:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar $some = __webpack_require__(2092).some;\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.some` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some\nexportTypedArrayMethod('some', function some(callbackfn /* , thisArg */) {\n  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n});\n\n\n/***/ }),\n\n/***/ 3824:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar $sort = [].sort;\n\n// `%TypedArray%.prototype.sort` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort\nexportTypedArrayMethod('sort', function sort(comparefn) {\n  return $sort.call(aTypedArray(this), comparefn);\n});\n\n\n/***/ }),\n\n/***/ 5021:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar toLength = __webpack_require__(7466);\nvar toAbsoluteIndex = __webpack_require__(1400);\nvar speciesConstructor = __webpack_require__(6707);\n\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\n\n// `%TypedArray%.prototype.subarray` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray\nexportTypedArrayMethod('subarray', function subarray(begin, end) {\n  var O = aTypedArray(this);\n  var length = O.length;\n  var beginIndex = toAbsoluteIndex(begin, length);\n  return new (speciesConstructor(O, O.constructor))(\n    O.buffer,\n    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,\n    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)\n  );\n});\n\n\n/***/ }),\n\n/***/ 2974:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar global = __webpack_require__(7854);\nvar ArrayBufferViewCore = __webpack_require__(260);\nvar fails = __webpack_require__(7293);\n\nvar Int8Array = global.Int8Array;\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar $toLocaleString = [].toLocaleString;\nvar $slice = [].slice;\n\n// iOS Safari 6.x fails here\nvar TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {\n  $toLocaleString.call(new Int8Array(1));\n});\n\nvar FORCED = fails(function () {\n  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();\n}) || !fails(function () {\n  Int8Array.prototype.toLocaleString.call([1, 2]);\n});\n\n// `%TypedArray%.prototype.toLocaleString` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring\nexportTypedArrayMethod('toLocaleString', function toLocaleString() {\n  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);\n}, FORCED);\n\n\n/***/ }),\n\n/***/ 5016:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\nvar exportTypedArrayMethod = __webpack_require__(260).exportTypedArrayMethod;\nvar fails = __webpack_require__(7293);\nvar global = __webpack_require__(7854);\n\nvar Uint8Array = global.Uint8Array;\nvar Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};\nvar arrayToString = [].toString;\nvar arrayJoin = [].join;\n\nif (fails(function () { arrayToString.call({}); })) {\n  arrayToString = function toString() {\n    return arrayJoin.call(this);\n  };\n}\n\nvar IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;\n\n// `%TypedArray%.prototype.toString` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring\nexportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);\n\n\n/***/ }),\n\n/***/ 2472:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\nvar createTypedArrayConstructor = __webpack_require__(9843);\n\n// `Uint8Array` constructor\n// https://tc39.es/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Uint8', function (init) {\n  return function Uint8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n/***/ }),\n\n/***/ 4747:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\nvar global = __webpack_require__(7854);\nvar DOMIterables = __webpack_require__(8324);\nvar forEach = __webpack_require__(8533);\nvar createNonEnumerableProperty = __webpack_require__(8880);\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  var Collection = global[COLLECTION_NAME];\n  var CollectionPrototype = Collection && Collection.prototype;\n  // some Chrome versions have non-configurable methods on DOMTokenList\n  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {\n    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);\n  } catch (error) {\n    CollectionPrototype.forEach = forEach;\n  }\n}\n\n\n/***/ }),\n\n/***/ 3948:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\nvar global = __webpack_require__(7854);\nvar DOMIterables = __webpack_require__(8324);\nvar ArrayIteratorMethods = __webpack_require__(6992);\nvar createNonEnumerableProperty = __webpack_require__(8880);\nvar wellKnownSymbol = __webpack_require__(5112);\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  var Collection = global[COLLECTION_NAME];\n  var CollectionPrototype = Collection && Collection.prototype;\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\n      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG]) {\n      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n}\n\n\n/***/ }),\n\n/***/ 1637:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\n// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`\n__webpack_require__(6992);\nvar $ = __webpack_require__(2109);\nvar getBuiltIn = __webpack_require__(5005);\nvar USE_NATIVE_URL = __webpack_require__(590);\nvar redefine = __webpack_require__(1320);\nvar redefineAll = __webpack_require__(2248);\nvar setToStringTag = __webpack_require__(8003);\nvar createIteratorConstructor = __webpack_require__(4994);\nvar InternalStateModule = __webpack_require__(9909);\nvar anInstance = __webpack_require__(5787);\nvar hasOwn = __webpack_require__(6656);\nvar bind = __webpack_require__(9974);\nvar classof = __webpack_require__(648);\nvar anObject = __webpack_require__(9670);\nvar isObject = __webpack_require__(111);\nvar create = __webpack_require__(30);\nvar createPropertyDescriptor = __webpack_require__(9114);\nvar getIterator = __webpack_require__(8554);\nvar getIteratorMethod = __webpack_require__(1246);\nvar wellKnownSymbol = __webpack_require__(5112);\n\nvar $fetch = getBuiltIn('fetch');\nvar Headers = getBuiltIn('Headers');\nvar ITERATOR = wellKnownSymbol('iterator');\nvar URL_SEARCH_PARAMS = 'URLSearchParams';\nvar URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);\nvar getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);\n\nvar plus = /\\+/g;\nvar sequences = Array(4);\n\nvar percentSequence = function (bytes) {\n  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\\\da-f]{2}){' + bytes + '})', 'gi'));\n};\n\nvar percentDecode = function (sequence) {\n  try {\n    return decodeURIComponent(sequence);\n  } catch (error) {\n    return sequence;\n  }\n};\n\nvar deserialize = function (it) {\n  var result = it.replace(plus, ' ');\n  var bytes = 4;\n  try {\n    return decodeURIComponent(result);\n  } catch (error) {\n    while (bytes) {\n      result = result.replace(percentSequence(bytes--), percentDecode);\n    }\n    return result;\n  }\n};\n\nvar find = /[!'()~]|%20/g;\n\nvar replace = {\n  '!': '%21',\n  \"'\": '%27',\n  '(': '%28',\n  ')': '%29',\n  '~': '%7E',\n  '%20': '+'\n};\n\nvar replacer = function (match) {\n  return replace[match];\n};\n\nvar serialize = function (it) {\n  return encodeURIComponent(it).replace(find, replacer);\n};\n\nvar parseSearchParams = function (result, query) {\n  if (query) {\n    var attributes = query.split('&');\n    var index = 0;\n    var attribute, entry;\n    while (index < attributes.length) {\n      attribute = attributes[index++];\n      if (attribute.length) {\n        entry = attribute.split('=');\n        result.push({\n          key: deserialize(entry.shift()),\n          value: deserialize(entry.join('='))\n        });\n      }\n    }\n  }\n};\n\nvar updateSearchParams = function (query) {\n  this.entries.length = 0;\n  parseSearchParams(this.entries, query);\n};\n\nvar validateArgumentsLength = function (passed, required) {\n  if (passed < required) throw TypeError('Not enough arguments');\n};\n\nvar URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {\n  setInternalState(this, {\n    type: URL_SEARCH_PARAMS_ITERATOR,\n    iterator: getIterator(getInternalParamsState(params).entries),\n    kind: kind\n  });\n}, 'Iterator', function next() {\n  var state = getInternalIteratorState(this);\n  var kind = state.kind;\n  var step = state.iterator.next();\n  var entry = step.value;\n  if (!step.done) {\n    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];\n  } return step;\n});\n\n// `URLSearchParams` constructor\n// https://url.spec.whatwg.org/#interface-urlsearchparams\nvar URLSearchParamsConstructor = function URLSearchParams(/* init */) {\n  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);\n  var init = arguments.length > 0 ? arguments[0] : undefined;\n  var that = this;\n  var entries = [];\n  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;\n\n  setInternalState(that, {\n    type: URL_SEARCH_PARAMS,\n    entries: entries,\n    updateURL: function () { /* empty */ },\n    updateSearchParams: updateSearchParams\n  });\n\n  if (init !== undefined) {\n    if (isObject(init)) {\n      iteratorMethod = getIteratorMethod(init);\n      if (typeof iteratorMethod === 'function') {\n        iterator = iteratorMethod.call(init);\n        next = iterator.next;\n        while (!(step = next.call(iterator)).done) {\n          entryIterator = getIterator(anObject(step.value));\n          entryNext = entryIterator.next;\n          if (\n            (first = entryNext.call(entryIterator)).done ||\n            (second = entryNext.call(entryIterator)).done ||\n            !entryNext.call(entryIterator).done\n          ) throw TypeError('Expected sequence with length 2');\n          entries.push({ key: first.value + '', value: second.value + '' });\n        }\n      } else for (key in init) if (hasOwn(init, key)) entries.push({ key: key, value: init[key] + '' });\n    } else {\n      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');\n    }\n  }\n};\n\nvar URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;\n\nredefineAll(URLSearchParamsPrototype, {\n  // `URLSearchParams.prototype.append` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-append\n  append: function append(name, value) {\n    validateArgumentsLength(arguments.length, 2);\n    var state = getInternalParamsState(this);\n    state.entries.push({ key: name + '', value: value + '' });\n    state.updateURL();\n  },\n  // `URLSearchParams.prototype.delete` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete\n  'delete': function (name) {\n    validateArgumentsLength(arguments.length, 1);\n    var state = getInternalParamsState(this);\n    var entries = state.entries;\n    var key = name + '';\n    var index = 0;\n    while (index < entries.length) {\n      if (entries[index].key === key) entries.splice(index, 1);\n      else index++;\n    }\n    state.updateURL();\n  },\n  // `URLSearchParams.prototype.get` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-get\n  get: function get(name) {\n    validateArgumentsLength(arguments.length, 1);\n    var entries = getInternalParamsState(this).entries;\n    var key = name + '';\n    var index = 0;\n    for (; index < entries.length; index++) {\n      if (entries[index].key === key) return entries[index].value;\n    }\n    return null;\n  },\n  // `URLSearchParams.prototype.getAll` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall\n  getAll: function getAll(name) {\n    validateArgumentsLength(arguments.length, 1);\n    var entries = getInternalParamsState(this).entries;\n    var key = name + '';\n    var result = [];\n    var index = 0;\n    for (; index < entries.length; index++) {\n      if (entries[index].key === key) result.push(entries[index].value);\n    }\n    return result;\n  },\n  // `URLSearchParams.prototype.has` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-has\n  has: function has(name) {\n    validateArgumentsLength(arguments.length, 1);\n    var entries = getInternalParamsState(this).entries;\n    var key = name + '';\n    var index = 0;\n    while (index < entries.length) {\n      if (entries[index++].key === key) return true;\n    }\n    return false;\n  },\n  // `URLSearchParams.prototype.set` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-set\n  set: function set(name, value) {\n    validateArgumentsLength(arguments.length, 1);\n    var state = getInternalParamsState(this);\n    var entries = state.entries;\n    var found = false;\n    var key = name + '';\n    var val = value + '';\n    var index = 0;\n    var entry;\n    for (; index < entries.length; index++) {\n      entry = entries[index];\n      if (entry.key === key) {\n        if (found) entries.splice(index--, 1);\n        else {\n          found = true;\n          entry.value = val;\n        }\n      }\n    }\n    if (!found) entries.push({ key: key, value: val });\n    state.updateURL();\n  },\n  // `URLSearchParams.prototype.sort` method\n  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort\n  sort: function sort() {\n    var state = getInternalParamsState(this);\n    var entries = state.entries;\n    // Array#sort is not stable in some engines\n    var slice = entries.slice();\n    var entry, entriesIndex, sliceIndex;\n    entries.length = 0;\n    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {\n      entry = slice[sliceIndex];\n      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {\n        if (entries[entriesIndex].key > entry.key) {\n          entries.splice(entriesIndex, 0, entry);\n          break;\n        }\n      }\n      if (entriesIndex === sliceIndex) entries.push(entry);\n    }\n    state.updateURL();\n  },\n  // `URLSearchParams.prototype.forEach` method\n  forEach: function forEach(callback /* , thisArg */) {\n    var entries = getInternalParamsState(this).entries;\n    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);\n    var index = 0;\n    var entry;\n    while (index < entries.length) {\n      entry = entries[index++];\n      boundFunction(entry.value, entry.key, this);\n    }\n  },\n  // `URLSearchParams.prototype.keys` method\n  keys: function keys() {\n    return new URLSearchParamsIterator(this, 'keys');\n  },\n  // `URLSearchParams.prototype.values` method\n  values: function values() {\n    return new URLSearchParamsIterator(this, 'values');\n  },\n  // `URLSearchParams.prototype.entries` method\n  entries: function entries() {\n    return new URLSearchParamsIterator(this, 'entries');\n  }\n}, { enumerable: true });\n\n// `URLSearchParams.prototype[@@iterator]` method\nredefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);\n\n// `URLSearchParams.prototype.toString` method\n// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\nredefine(URLSearchParamsPrototype, 'toString', function toString() {\n  var entries = getInternalParamsState(this).entries;\n  var result = [];\n  var index = 0;\n  var entry;\n  while (index < entries.length) {\n    entry = entries[index++];\n    result.push(serialize(entry.key) + '=' + serialize(entry.value));\n  } return result.join('&');\n}, { enumerable: true });\n\nsetToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);\n\n$({ global: true, forced: !USE_NATIVE_URL }, {\n  URLSearchParams: URLSearchParamsConstructor\n});\n\n// Wrap `fetch` for correct work with polyfilled `URLSearchParams`\n// https://github.com/zloirock/core-js/issues/674\nif (!USE_NATIVE_URL && typeof $fetch == 'function' && typeof Headers == 'function') {\n  $({ global: true, enumerable: true, forced: true }, {\n    fetch: function fetch(input /* , init */) {\n      var args = [input];\n      var init, body, headers;\n      if (arguments.length > 1) {\n        init = arguments[1];\n        if (isObject(init)) {\n          body = init.body;\n          if (classof(body) === URL_SEARCH_PARAMS) {\n            headers = init.headers ? new Headers(init.headers) : new Headers();\n            if (!headers.has('content-type')) {\n              headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n            }\n            init = create(init, {\n              body: createPropertyDescriptor(0, String(body)),\n              headers: createPropertyDescriptor(0, headers)\n            });\n          }\n        }\n        args.push(init);\n      } return $fetch.apply(this, args);\n    }\n  });\n}\n\nmodule.exports = {\n  URLSearchParams: URLSearchParamsConstructor,\n  getState: getInternalParamsState\n};\n\n\n/***/ }),\n\n/***/ 285:\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {\n\n\"use strict\";\n\n// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`\n__webpack_require__(8783);\nvar $ = __webpack_require__(2109);\nvar DESCRIPTORS = __webpack_require__(9781);\nvar USE_NATIVE_URL = __webpack_require__(590);\nvar global = __webpack_require__(7854);\nvar defineProperties = __webpack_require__(6048);\nvar redefine = __webpack_require__(1320);\nvar anInstance = __webpack_require__(5787);\nvar has = __webpack_require__(6656);\nvar assign = __webpack_require__(1574);\nvar arrayFrom = __webpack_require__(8457);\nvar codeAt = __webpack_require__(8710).codeAt;\nvar toASCII = __webpack_require__(3197);\nvar setToStringTag = __webpack_require__(8003);\nvar URLSearchParamsModule = __webpack_require__(1637);\nvar InternalStateModule = __webpack_require__(9909);\n\nvar NativeURL = global.URL;\nvar URLSearchParams = URLSearchParamsModule.URLSearchParams;\nvar getInternalSearchParamsState = URLSearchParamsModule.getState;\nvar setInternalState = InternalStateModule.set;\nvar getInternalURLState = InternalStateModule.getterFor('URL');\nvar floor = Math.floor;\nvar pow = Math.pow;\n\nvar INVALID_AUTHORITY = 'Invalid authority';\nvar INVALID_SCHEME = 'Invalid scheme';\nvar INVALID_HOST = 'Invalid host';\nvar INVALID_PORT = 'Invalid port';\n\nvar ALPHA = /[A-Za-z]/;\nvar ALPHANUMERIC = /[\\d+-.A-Za-z]/;\nvar DIGIT = /\\d/;\nvar HEX_START = /^(0x|0X)/;\nvar OCT = /^[0-7]+$/;\nvar DEC = /^\\d+$/;\nvar HEX = /^[\\dA-Fa-f]+$/;\n/* eslint-disable no-control-regex -- safe */\nvar FORBIDDEN_HOST_CODE_POINT = /[\\u0000\\t\\u000A\\u000D #%/:?@[\\\\]]/;\nvar FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\\u0000\\t\\u000A\\u000D #/:?@[\\\\]]/;\nvar LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\\u0000-\\u001F ]+|[\\u0000-\\u001F ]+$/g;\nvar TAB_AND_NEW_LINE = /[\\t\\u000A\\u000D]/g;\n/* eslint-enable no-control-regex -- safe */\nvar EOF;\n\nvar parseHost = function (url, input) {\n  var result, codePoints, index;\n  if (input.charAt(0) == '[') {\n    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;\n    result = parseIPv6(input.slice(1, -1));\n    if (!result) return INVALID_HOST;\n    url.host = result;\n  // opaque host\n  } else if (!isSpecial(url)) {\n    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;\n    result = '';\n    codePoints = arrayFrom(input);\n    for (index = 0; index < codePoints.length; index++) {\n      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);\n    }\n    url.host = result;\n  } else {\n    input = toASCII(input);\n    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;\n    result = parseIPv4(input);\n    if (result === null) return INVALID_HOST;\n    url.host = result;\n  }\n};\n\nvar parseIPv4 = function (input) {\n  var parts = input.split('.');\n  var partsLength, numbers, index, part, radix, number, ipv4;\n  if (parts.length && parts[parts.length - 1] == '') {\n    parts.pop();\n  }\n  partsLength = parts.length;\n  if (partsLength > 4) return input;\n  numbers = [];\n  for (index = 0; index < partsLength; index++) {\n    part = parts[index];\n    if (part == '') return input;\n    radix = 10;\n    if (part.length > 1 && part.charAt(0) == '0') {\n      radix = HEX_START.test(part) ? 16 : 8;\n      part = part.slice(radix == 8 ? 1 : 2);\n    }\n    if (part === '') {\n      number = 0;\n    } else {\n      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;\n      number = parseInt(part, radix);\n    }\n    numbers.push(number);\n  }\n  for (index = 0; index < partsLength; index++) {\n    number = numbers[index];\n    if (index == partsLength - 1) {\n      if (number >= pow(256, 5 - partsLength)) return null;\n    } else if (number > 255) return null;\n  }\n  ipv4 = numbers.pop();\n  for (index = 0; index < numbers.length; index++) {\n    ipv4 += numbers[index] * pow(256, 3 - index);\n  }\n  return ipv4;\n};\n\n// eslint-disable-next-line max-statements -- TODO\nvar parseIPv6 = function (input) {\n  var address = [0, 0, 0, 0, 0, 0, 0, 0];\n  var pieceIndex = 0;\n  var compress = null;\n  var pointer = 0;\n  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;\n\n  var char = function () {\n    return input.charAt(pointer);\n  };\n\n  if (char() == ':') {\n    if (input.charAt(1) != ':') return;\n    pointer += 2;\n    pieceIndex++;\n    compress = pieceIndex;\n  }\n  while (char()) {\n    if (pieceIndex == 8) return;\n    if (char() == ':') {\n      if (compress !== null) return;\n      pointer++;\n      pieceIndex++;\n      compress = pieceIndex;\n      continue;\n    }\n    value = length = 0;\n    while (length < 4 && HEX.test(char())) {\n      value = value * 16 + parseInt(char(), 16);\n      pointer++;\n      length++;\n    }\n    if (char() == '.') {\n      if (length == 0) return;\n      pointer -= length;\n      if (pieceIndex > 6) return;\n      numbersSeen = 0;\n      while (char()) {\n        ipv4Piece = null;\n        if (numbersSeen > 0) {\n          if (char() == '.' && numbersSeen < 4) pointer++;\n          else return;\n        }\n        if (!DIGIT.test(char())) return;\n        while (DIGIT.test(char())) {\n          number = parseInt(char(), 10);\n          if (ipv4Piece === null) ipv4Piece = number;\n          else if (ipv4Piece == 0) return;\n          else ipv4Piece = ipv4Piece * 10 + number;\n          if (ipv4Piece > 255) return;\n          pointer++;\n        }\n        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;\n        numbersSeen++;\n        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;\n      }\n      if (numbersSeen != 4) return;\n      break;\n    } else if (char() == ':') {\n      pointer++;\n      if (!char()) return;\n    } else if (char()) return;\n    address[pieceIndex++] = value;\n  }\n  if (compress !== null) {\n    swaps = pieceIndex - compress;\n    pieceIndex = 7;\n    while (pieceIndex != 0 && swaps > 0) {\n      swap = address[pieceIndex];\n      address[pieceIndex--] = address[compress + swaps - 1];\n      address[compress + --swaps] = swap;\n    }\n  } else if (pieceIndex != 8) return;\n  return address;\n};\n\nvar findLongestZeroSequence = function (ipv6) {\n  var maxIndex = null;\n  var maxLength = 1;\n  var currStart = null;\n  var currLength = 0;\n  var index = 0;\n  for (; index < 8; index++) {\n    if (ipv6[index] !== 0) {\n      if (currLength > maxLength) {\n        maxIndex = currStart;\n        maxLength = currLength;\n      }\n      currStart = null;\n      currLength = 0;\n    } else {\n      if (currStart === null) currStart = index;\n      ++currLength;\n    }\n  }\n  if (currLength > maxLength) {\n    maxIndex = currStart;\n    maxLength = currLength;\n  }\n  return maxIndex;\n};\n\nvar serializeHost = function (host) {\n  var result, index, compress, ignore0;\n  // ipv4\n  if (typeof host == 'number') {\n    result = [];\n    for (index = 0; index < 4; index++) {\n      result.unshift(host % 256);\n      host = floor(host / 256);\n    } return result.join('.');\n  // ipv6\n  } else if (typeof host == 'object') {\n    result = '';\n    compress = findLongestZeroSequence(host);\n    for (index = 0; index < 8; index++) {\n      if (ignore0 && host[index] === 0) continue;\n      if (ignore0) ignore0 = false;\n      if (compress === index) {\n        result += index ? ':' : '::';\n        ignore0 = true;\n      } else {\n        result += host[index].toString(16);\n        if (index < 7) result += ':';\n      }\n    }\n    return '[' + result + ']';\n  } return host;\n};\n\nvar C0ControlPercentEncodeSet = {};\nvar fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {\n  ' ': 1, '\"': 1, '<': 1, '>': 1, '`': 1\n});\nvar pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {\n  '#': 1, '?': 1, '{': 1, '}': 1\n});\nvar userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {\n  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\\\': 1, ']': 1, '^': 1, '|': 1\n});\n\nvar percentEncode = function (char, set) {\n  var code = codeAt(char, 0);\n  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);\n};\n\nvar specialSchemes = {\n  ftp: 21,\n  file: null,\n  http: 80,\n  https: 443,\n  ws: 80,\n  wss: 443\n};\n\nvar isSpecial = function (url) {\n  return has(specialSchemes, url.scheme);\n};\n\nvar includesCredentials = function (url) {\n  return url.username != '' || url.password != '';\n};\n\nvar cannotHaveUsernamePasswordPort = function (url) {\n  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';\n};\n\nvar isWindowsDriveLetter = function (string, normalized) {\n  var second;\n  return string.length == 2 && ALPHA.test(string.charAt(0))\n    && ((second = string.charAt(1)) == ':' || (!normalized && second == '|'));\n};\n\nvar startsWithWindowsDriveLetter = function (string) {\n  var third;\n  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (\n    string.length == 2 ||\n    ((third = string.charAt(2)) === '/' || third === '\\\\' || third === '?' || third === '#')\n  );\n};\n\nvar shortenURLsPath = function (url) {\n  var path = url.path;\n  var pathSize = path.length;\n  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {\n    path.pop();\n  }\n};\n\nvar isSingleDot = function (segment) {\n  return segment === '.' || segment.toLowerCase() === '%2e';\n};\n\nvar isDoubleDot = function (segment) {\n  segment = segment.toLowerCase();\n  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';\n};\n\n// States:\nvar SCHEME_START = {};\nvar SCHEME = {};\nvar NO_SCHEME = {};\nvar SPECIAL_RELATIVE_OR_AUTHORITY = {};\nvar PATH_OR_AUTHORITY = {};\nvar RELATIVE = {};\nvar RELATIVE_SLASH = {};\nvar SPECIAL_AUTHORITY_SLASHES = {};\nvar SPECIAL_AUTHORITY_IGNORE_SLASHES = {};\nvar AUTHORITY = {};\nvar HOST = {};\nvar HOSTNAME = {};\nvar PORT = {};\nvar FILE = {};\nvar FILE_SLASH = {};\nvar FILE_HOST = {};\nvar PATH_START = {};\nvar PATH = {};\nvar CANNOT_BE_A_BASE_URL_PATH = {};\nvar QUERY = {};\nvar FRAGMENT = {};\n\n// eslint-disable-next-line max-statements -- TODO\nvar parseURL = function (url, input, stateOverride, base) {\n  var state = stateOverride || SCHEME_START;\n  var pointer = 0;\n  var buffer = '';\n  var seenAt = false;\n  var seenBracket = false;\n  var seenPasswordToken = false;\n  var codePoints, char, bufferCodePoints, failure;\n\n  if (!stateOverride) {\n    url.scheme = '';\n    url.username = '';\n    url.password = '';\n    url.host = null;\n    url.port = null;\n    url.path = [];\n    url.query = null;\n    url.fragment = null;\n    url.cannotBeABaseURL = false;\n    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');\n  }\n\n  input = input.replace(TAB_AND_NEW_LINE, '');\n\n  codePoints = arrayFrom(input);\n\n  while (pointer <= codePoints.length) {\n    char = codePoints[pointer];\n    switch (state) {\n      case SCHEME_START:\n        if (char && ALPHA.test(char)) {\n          buffer += char.toLowerCase();\n          state = SCHEME;\n        } else if (!stateOverride) {\n          state = NO_SCHEME;\n          continue;\n        } else return INVALID_SCHEME;\n        break;\n\n      case SCHEME:\n        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {\n          buffer += char.toLowerCase();\n        } else if (char == ':') {\n          if (stateOverride && (\n            (isSpecial(url) != has(specialSchemes, buffer)) ||\n            (buffer == 'file' && (includesCredentials(url) || url.port !== null)) ||\n            (url.scheme == 'file' && !url.host)\n          )) return;\n          url.scheme = buffer;\n          if (stateOverride) {\n            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;\n            return;\n          }\n          buffer = '';\n          if (url.scheme == 'file') {\n            state = FILE;\n          } else if (isSpecial(url) && base && base.scheme == url.scheme) {\n            state = SPECIAL_RELATIVE_OR_AUTHORITY;\n          } else if (isSpecial(url)) {\n            state = SPECIAL_AUTHORITY_SLASHES;\n          } else if (codePoints[pointer + 1] == '/') {\n            state = PATH_OR_AUTHORITY;\n            pointer++;\n          } else {\n            url.cannotBeABaseURL = true;\n            url.path.push('');\n            state = CANNOT_BE_A_BASE_URL_PATH;\n          }\n        } else if (!stateOverride) {\n          buffer = '';\n          state = NO_SCHEME;\n          pointer = 0;\n          continue;\n        } else return INVALID_SCHEME;\n        break;\n\n      case NO_SCHEME:\n        if (!base || (base.cannotBeABaseURL && char != '#')) return INVALID_SCHEME;\n        if (base.cannotBeABaseURL && char == '#') {\n          url.scheme = base.scheme;\n          url.path = base.path.slice();\n          url.query = base.query;\n          url.fragment = '';\n          url.cannotBeABaseURL = true;\n          state = FRAGMENT;\n          break;\n        }\n        state = base.scheme == 'file' ? FILE : RELATIVE;\n        continue;\n\n      case SPECIAL_RELATIVE_OR_AUTHORITY:\n        if (char == '/' && codePoints[pointer + 1] == '/') {\n          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n          pointer++;\n        } else {\n          state = RELATIVE;\n          continue;\n        } break;\n\n      case PATH_OR_AUTHORITY:\n        if (char == '/') {\n          state = AUTHORITY;\n          break;\n        } else {\n          state = PATH;\n          continue;\n        }\n\n      case RELATIVE:\n        url.scheme = base.scheme;\n        if (char == EOF) {\n          url.username = base.username;\n          url.password = base.password;\n          url.host = base.host;\n          url.port = base.port;\n          url.path = base.path.slice();\n          url.query = base.query;\n        } else if (char == '/' || (char == '\\\\' && isSpecial(url))) {\n          state = RELATIVE_SLASH;\n        } else if (char == '?') {\n          url.username = base.username;\n          url.password = base.password;\n          url.host = base.host;\n          url.port = base.port;\n          url.path = base.path.slice();\n          url.query = '';\n          state = QUERY;\n        } else if (char == '#') {\n          url.username = base.username;\n          url.password = base.password;\n          url.host = base.host;\n          url.port = base.port;\n          url.path = base.path.slice();\n          url.query = base.query;\n          url.fragment = '';\n          state = FRAGMENT;\n        } else {\n          url.username = base.username;\n          url.password = base.password;\n          url.host = base.host;\n          url.port = base.port;\n          url.path = base.path.slice();\n          url.path.pop();\n          state = PATH;\n          continue;\n        } break;\n\n      case RELATIVE_SLASH:\n        if (isSpecial(url) && (char == '/' || char == '\\\\')) {\n          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n        } else if (char == '/') {\n          state = AUTHORITY;\n        } else {\n          url.username = base.username;\n          url.password = base.password;\n          url.host = base.host;\n          url.port = base.port;\n          state = PATH;\n          continue;\n        } break;\n\n      case SPECIAL_AUTHORITY_SLASHES:\n        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;\n        pointer++;\n        break;\n\n      case SPECIAL_AUTHORITY_IGNORE_SLASHES:\n        if (char != '/' && char != '\\\\') {\n          state = AUTHORITY;\n          continue;\n        } break;\n\n      case AUTHORITY:\n        if (char == '@') {\n          if (seenAt) buffer = '%40' + buffer;\n          seenAt = true;\n          bufferCodePoints = arrayFrom(buffer);\n          for (var i = 0; i < bufferCodePoints.length; i++) {\n            var codePoint = bufferCodePoints[i];\n            if (codePoint == ':' && !seenPasswordToken) {\n              seenPasswordToken = true;\n              continue;\n            }\n            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);\n            if (seenPasswordToken) url.password += encodedCodePoints;\n            else url.username += encodedCodePoints;\n          }\n          buffer = '';\n        } else if (\n          char == EOF || char == '/' || char == '?' || char == '#' ||\n          (char == '\\\\' && isSpecial(url))\n        ) {\n          if (seenAt && buffer == '') return INVALID_AUTHORITY;\n          pointer -= arrayFrom(buffer).length + 1;\n          buffer = '';\n          state = HOST;\n        } else buffer += char;\n        break;\n\n      case HOST:\n      case HOSTNAME:\n        if (stateOverride && url.scheme == 'file') {\n          state = FILE_HOST;\n          continue;\n        } else if (char == ':' && !seenBracket) {\n          if (buffer == '') return INVALID_HOST;\n          failure = parseHost(url, buffer);\n          if (failure) return failure;\n          buffer = '';\n          state = PORT;\n          if (stateOverride == HOSTNAME) return;\n        } else if (\n          char == EOF || char == '/' || char == '?' || char == '#' ||\n          (char == '\\\\' && isSpecial(url))\n        ) {\n          if (isSpecial(url) && buffer == '') return INVALID_HOST;\n          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;\n          failure = parseHost(url, buffer);\n          if (failure) return failure;\n          buffer = '';\n          state = PATH_START;\n          if (stateOverride) return;\n          continue;\n        } else {\n          if (char == '[') seenBracket = true;\n          else if (char == ']') seenBracket = false;\n          buffer += char;\n        } break;\n\n      case PORT:\n        if (DIGIT.test(char)) {\n          buffer += char;\n        } else if (\n          char == EOF || char == '/' || char == '?' || char == '#' ||\n          (char == '\\\\' && isSpecial(url)) ||\n          stateOverride\n        ) {\n          if (buffer != '') {\n            var port = parseInt(buffer, 10);\n            if (port > 0xFFFF) return INVALID_PORT;\n            url.port = (isSpecial(url) && port === specialSchemes[url.scheme]) ? null : port;\n            buffer = '';\n          }\n          if (stateOverride) return;\n          state = PATH_START;\n          continue;\n        } else return INVALID_PORT;\n        break;\n\n      case FILE:\n        url.scheme = 'file';\n        if (char == '/' || char == '\\\\') state = FILE_SLASH;\n        else if (base && base.scheme == 'file') {\n          if (char == EOF) {\n            url.host = base.host;\n            url.path = base.path.slice();\n            url.query = base.query;\n          } else if (char == '?') {\n            url.host = base.host;\n            url.path = base.path.slice();\n            url.query = '';\n            state = QUERY;\n          } else if (char == '#') {\n            url.host = base.host;\n            url.path = base.path.slice();\n            url.query = base.query;\n            url.fragment = '';\n            state = FRAGMENT;\n          } else {\n            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {\n              url.host = base.host;\n              url.path = base.path.slice();\n              shortenURLsPath(url);\n            }\n            state = PATH;\n            continue;\n          }\n        } else {\n          state = PATH;\n          continue;\n        } break;\n\n      case FILE_SLASH:\n        if (char == '/' || char == '\\\\') {\n          state = FILE_HOST;\n          break;\n        }\n        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {\n          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);\n          else url.host = base.host;\n        }\n        state = PATH;\n        continue;\n\n      case FILE_HOST:\n        if (char == EOF || char == '/' || char == '\\\\' || char == '?' || char == '#') {\n          if (!stateOverride && isWindowsDriveLetter(buffer)) {\n            state = PATH;\n          } else if (buffer == '') {\n            url.host = '';\n            if (stateOverride) return;\n            state = PATH_START;\n          } else {\n            failure = parseHost(url, buffer);\n            if (failure) return failure;\n            if (url.host == 'localhost') url.host = '';\n            if (stateOverride) return;\n            buffer = '';\n            state = PATH_START;\n          } continue;\n        } else buffer += char;\n        break;\n\n      case PATH_START:\n        if (isSpecial(url)) {\n          state = PATH;\n          if (char != '/' && char != '\\\\') continue;\n        } else if (!stateOverride && char == '?') {\n          url.query = '';\n          state = QUERY;\n        } else if (!stateOverride && char == '#') {\n          url.fragment = '';\n          state = FRAGMENT;\n        } else if (char != EOF) {\n          state = PATH;\n          if (char != '/') continue;\n        } break;\n\n      case PATH:\n        if (\n          char == EOF || char == '/' ||\n          (char == '\\\\' && isSpecial(url)) ||\n          (!stateOverride && (char == '?' || char == '#'))\n        ) {\n          if (isDoubleDot(buffer)) {\n            shortenURLsPath(url);\n            if (char != '/' && !(char == '\\\\' && isSpecial(url))) {\n              url.path.push('');\n            }\n          } else if (isSingleDot(buffer)) {\n            if (char != '/' && !(char == '\\\\' && isSpecial(url))) {\n              url.path.push('');\n            }\n          } else {\n            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {\n              if (url.host) url.host = '';\n              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter\n            }\n            url.path.push(buffer);\n          }\n          buffer = '';\n          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {\n            while (url.path.length > 1 && url.path[0] === '') {\n              url.path.shift();\n            }\n          }\n          if (char == '?') {\n            url.query = '';\n            state = QUERY;\n          } else if (char == '#') {\n            url.fragment = '';\n            state = FRAGMENT;\n          }\n        } else {\n          buffer += percentEncode(char, pathPercentEncodeSet);\n        } break;\n\n      case CANNOT_BE_A_BASE_URL_PATH:\n        if (char == '?') {\n          url.query = '';\n          state = QUERY;\n        } else if (char == '#') {\n          url.fragment = '';\n          state = FRAGMENT;\n        } else if (char != EOF) {\n          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);\n        } break;\n\n      case QUERY:\n        if (!stateOverride && char == '#') {\n          url.fragment = '';\n          state = FRAGMENT;\n        } else if (char != EOF) {\n          if (char == \"'\" && isSpecial(url)) url.query += '%27';\n          else if (char == '#') url.query += '%23';\n          else url.query += percentEncode(char, C0ControlPercentEncodeSet);\n        } break;\n\n      case FRAGMENT:\n        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);\n        break;\n    }\n\n    pointer++;\n  }\n};\n\n// `URL` constructor\n// https://url.spec.whatwg.org/#url-class\nvar URLConstructor = function URL(url /* , base */) {\n  var that = anInstance(this, URLConstructor, 'URL');\n  var base = arguments.length > 1 ? arguments[1] : undefined;\n  var urlString = String(url);\n  var state = setInternalState(that, { type: 'URL' });\n  var baseState, failure;\n  if (base !== undefined) {\n    if (base instanceof URLConstructor) baseState = getInternalURLState(base);\n    else {\n      failure = parseURL(baseState = {}, String(base));\n      if (failure) throw TypeError(failure);\n    }\n  }\n  failure = parseURL(state, urlString, null, baseState);\n  if (failure) throw TypeError(failure);\n  var searchParams = state.searchParams = new URLSearchParams();\n  var searchParamsState = getInternalSearchParamsState(searchParams);\n  searchParamsState.updateSearchParams(state.query);\n  searchParamsState.updateURL = function () {\n    state.query = String(searchParams) || null;\n  };\n  if (!DESCRIPTORS) {\n    that.href = serializeURL.call(that);\n    that.origin = getOrigin.call(that);\n    that.protocol = getProtocol.call(that);\n    that.username = getUsername.call(that);\n    that.password = getPassword.call(that);\n    that.host = getHost.call(that);\n    that.hostname = getHostname.call(that);\n    that.port = getPort.call(that);\n    that.pathname = getPathname.call(that);\n    that.search = getSearch.call(that);\n    that.searchParams = getSearchParams.call(that);\n    that.hash = getHash.call(that);\n  }\n};\n\nvar URLPrototype = URLConstructor.prototype;\n\nvar serializeURL = function () {\n  var url = getInternalURLState(this);\n  var scheme = url.scheme;\n  var username = url.username;\n  var password = url.password;\n  var host = url.host;\n  var port = url.port;\n  var path = url.path;\n  var query = url.query;\n  var fragment = url.fragment;\n  var output = scheme + ':';\n  if (host !== null) {\n    output += '//';\n    if (includesCredentials(url)) {\n      output += username + (password ? ':' + password : '') + '@';\n    }\n    output += serializeHost(host);\n    if (port !== null) output += ':' + port;\n  } else if (scheme == 'file') output += '//';\n  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';\n  if (query !== null) output += '?' + query;\n  if (fragment !== null) output += '#' + fragment;\n  return output;\n};\n\nvar getOrigin = function () {\n  var url = getInternalURLState(this);\n  var scheme = url.scheme;\n  var port = url.port;\n  if (scheme == 'blob') try {\n    return new URL(scheme.path[0]).origin;\n  } catch (error) {\n    return 'null';\n  }\n  if (scheme == 'file' || !isSpecial(url)) return 'null';\n  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');\n};\n\nvar getProtocol = function () {\n  return getInternalURLState(this).scheme + ':';\n};\n\nvar getUsername = function () {\n  return getInternalURLState(this).username;\n};\n\nvar getPassword = function () {\n  return getInternalURLState(this).password;\n};\n\nvar getHost = function () {\n  var url = getInternalURLState(this);\n  var host = url.host;\n  var port = url.port;\n  return host === null ? ''\n    : port === null ? serializeHost(host)\n    : serializeHost(host) + ':' + port;\n};\n\nvar getHostname = function () {\n  var host = getInternalURLState(this).host;\n  return host === null ? '' : serializeHost(host);\n};\n\nvar getPort = function () {\n  var port = getInternalURLState(this).port;\n  return port === null ? '' : String(port);\n};\n\nvar getPathname = function () {\n  var url = getInternalURLState(this);\n  var path = url.path;\n  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';\n};\n\nvar getSearch = function () {\n  var query = getInternalURLState(this).query;\n  return query ? '?' + query : '';\n};\n\nvar getSearchParams = function () {\n  return getInternalURLState(this).searchParams;\n};\n\nvar getHash = function () {\n  var fragment = getInternalURLState(this).fragment;\n  return fragment ? '#' + fragment : '';\n};\n\nvar accessorDescriptor = function (getter, setter) {\n  return { get: getter, set: setter, configurable: true, enumerable: true };\n};\n\nif (DESCRIPTORS) {\n  defineProperties(URLPrototype, {\n    // `URL.prototype.href` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-href\n    href: accessorDescriptor(serializeURL, function (href) {\n      var url = getInternalURLState(this);\n      var urlString = String(href);\n      var failure = parseURL(url, urlString);\n      if (failure) throw TypeError(failure);\n      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);\n    }),\n    // `URL.prototype.origin` getter\n    // https://url.spec.whatwg.org/#dom-url-origin\n    origin: accessorDescriptor(getOrigin),\n    // `URL.prototype.protocol` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-protocol\n    protocol: accessorDescriptor(getProtocol, function (protocol) {\n      var url = getInternalURLState(this);\n      parseURL(url, String(protocol) + ':', SCHEME_START);\n    }),\n    // `URL.prototype.username` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-username\n    username: accessorDescriptor(getUsername, function (username) {\n      var url = getInternalURLState(this);\n      var codePoints = arrayFrom(String(username));\n      if (cannotHaveUsernamePasswordPort(url)) return;\n      url.username = '';\n      for (var i = 0; i < codePoints.length; i++) {\n        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);\n      }\n    }),\n    // `URL.prototype.password` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-password\n    password: accessorDescriptor(getPassword, function (password) {\n      var url = getInternalURLState(this);\n      var codePoints = arrayFrom(String(password));\n      if (cannotHaveUsernamePasswordPort(url)) return;\n      url.password = '';\n      for (var i = 0; i < codePoints.length; i++) {\n        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);\n      }\n    }),\n    // `URL.prototype.host` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-host\n    host: accessorDescriptor(getHost, function (host) {\n      var url = getInternalURLState(this);\n      if (url.cannotBeABaseURL) return;\n      parseURL(url, String(host), HOST);\n    }),\n    // `URL.prototype.hostname` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-hostname\n    hostname: accessorDescriptor(getHostname, function (hostname) {\n      var url = getInternalURLState(this);\n      if (url.cannotBeABaseURL) return;\n      parseURL(url, String(hostname), HOSTNAME);\n    }),\n    // `URL.prototype.port` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-port\n    port: accessorDescriptor(getPort, function (port) {\n      var url = getInternalURLState(this);\n      if (cannotHaveUsernamePasswordPort(url)) return;\n      port = String(port);\n      if (port == '') url.port = null;\n      else parseURL(url, port, PORT);\n    }),\n    // `URL.prototype.pathname` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-pathname\n    pathname: accessorDescriptor(getPathname, function (pathname) {\n      var url = getInternalURLState(this);\n      if (url.cannotBeABaseURL) return;\n      url.path = [];\n      parseURL(url, pathname + '', PATH_START);\n    }),\n    // `URL.prototype.search` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-search\n    search: accessorDescriptor(getSearch, function (search) {\n      var url = getInternalURLState(this);\n      search = String(search);\n      if (search == '') {\n        url.query = null;\n      } else {\n        if ('?' == search.charAt(0)) search = search.slice(1);\n        url.query = '';\n        parseURL(url, search, QUERY);\n      }\n      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);\n    }),\n    // `URL.prototype.searchParams` getter\n    // https://url.spec.whatwg.org/#dom-url-searchparams\n    searchParams: accessorDescriptor(getSearchParams),\n    // `URL.prototype.hash` accessors pair\n    // https://url.spec.whatwg.org/#dom-url-hash\n    hash: accessorDescriptor(getHash, function (hash) {\n      var url = getInternalURLState(this);\n      hash = String(hash);\n      if (hash == '') {\n        url.fragment = null;\n        return;\n      }\n      if ('#' == hash.charAt(0)) hash = hash.slice(1);\n      url.fragment = '';\n      parseURL(url, hash, FRAGMENT);\n    })\n  });\n}\n\n// `URL.prototype.toJSON` method\n// https://url.spec.whatwg.org/#dom-url-tojson\nredefine(URLPrototype, 'toJSON', function toJSON() {\n  return serializeURL.call(this);\n}, { enumerable: true });\n\n// `URL.prototype.toString` method\n// https://url.spec.whatwg.org/#URL-stringification-behavior\nredefine(URLPrototype, 'toString', function toString() {\n  return serializeURL.call(this);\n}, { enumerable: true });\n\nif (NativeURL) {\n  var nativeCreateObjectURL = NativeURL.createObjectURL;\n  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;\n  // `URL.createObjectURL` method\n  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {\n    return nativeCreateObjectURL.apply(NativeURL, arguments);\n  });\n  // `URL.revokeObjectURL` method\n  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {\n    return nativeRevokeObjectURL.apply(NativeURL, arguments);\n  });\n}\n\nsetToStringTag(URLConstructor, 'URL');\n\n$({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {\n  URL: URLConstructor\n});\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(__webpack_module_cache__[moduleId]) {\n/******/ \t\t\treturn __webpack_module_cache__[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t!function() {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = function(exports, definition) {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/global */\n/******/ \t!function() {\n/******/ \t\t__webpack_require__.g = (function() {\n/******/ \t\t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\t\ttry {\n/******/ \t\t\t\treturn this || new Function('return this')();\n/******/ \t\t\t} catch (e) {\n/******/ \t\t\t\tif (typeof window === 'object') return window;\n/******/ \t\t\t}\n/******/ \t\t})();\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t!function() {\n/******/ \t\t__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t!function() {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__webpack_require__.r = function(exports) {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n!function() {\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"Dropzone\": function() { return /* reexport */ Dropzone; },\n  \"default\": function() { return /* binding */ dropzone_dist; }\n});\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js\nvar es_array_concat = __webpack_require__(2222);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js\nvar es_array_filter = __webpack_require__(7327);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.index-of.js\nvar es_array_index_of = __webpack_require__(2772);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js\nvar es_array_iterator = __webpack_require__(6992);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js\nvar es_array_map = __webpack_require__(1249);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js\nvar es_array_slice = __webpack_require__(7042);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js\nvar es_array_splice = __webpack_require__(561);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array-buffer.constructor.js\nvar es_array_buffer_constructor = __webpack_require__(8264);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js\nvar es_function_name = __webpack_require__(8309);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-prototype-of.js\nvar es_object_get_prototype_of = __webpack_require__(489);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js\nvar es_object_to_string = __webpack_require__(1539);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js\nvar es_regexp_exec = __webpack_require__(4916);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js\nvar es_regexp_to_string = __webpack_require__(9714);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js\nvar es_string_iterator = __webpack_require__(8783);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match.js\nvar es_string_match = __webpack_require__(4723);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js\nvar es_string_replace = __webpack_require__(5306);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js\nvar es_string_split = __webpack_require__(3123);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.trim.js\nvar es_string_trim = __webpack_require__(3210);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.uint8-array.js\nvar es_typed_array_uint8_array = __webpack_require__(2472);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.copy-within.js\nvar es_typed_array_copy_within = __webpack_require__(2990);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.every.js\nvar es_typed_array_every = __webpack_require__(8927);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.fill.js\nvar es_typed_array_fill = __webpack_require__(3105);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.filter.js\nvar es_typed_array_filter = __webpack_require__(5035);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find.js\nvar es_typed_array_find = __webpack_require__(4345);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find-index.js\nvar es_typed_array_find_index = __webpack_require__(7174);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.for-each.js\nvar es_typed_array_for_each = __webpack_require__(2846);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.includes.js\nvar es_typed_array_includes = __webpack_require__(4731);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.index-of.js\nvar es_typed_array_index_of = __webpack_require__(7209);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.iterator.js\nvar es_typed_array_iterator = __webpack_require__(6319);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.join.js\nvar es_typed_array_join = __webpack_require__(8867);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.last-index-of.js\nvar es_typed_array_last_index_of = __webpack_require__(7789);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.map.js\nvar es_typed_array_map = __webpack_require__(3739);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce.js\nvar es_typed_array_reduce = __webpack_require__(9368);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce-right.js\nvar es_typed_array_reduce_right = __webpack_require__(4483);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reverse.js\nvar es_typed_array_reverse = __webpack_require__(2056);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.set.js\nvar es_typed_array_set = __webpack_require__(3462);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.slice.js\nvar es_typed_array_slice = __webpack_require__(678);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.some.js\nvar es_typed_array_some = __webpack_require__(7462);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.sort.js\nvar es_typed_array_sort = __webpack_require__(3824);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.subarray.js\nvar es_typed_array_subarray = __webpack_require__(5021);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-locale-string.js\nvar es_typed_array_to_locale_string = __webpack_require__(2974);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-string.js\nvar es_typed_array_to_string = __webpack_require__(5016);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js\nvar web_dom_collections_for_each = __webpack_require__(4747);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js\nvar web_dom_collections_iterator = __webpack_require__(3948);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url.js\nvar web_url = __webpack_require__(285);\n;// CONCATENATED MODULE: ./src/emitter.js\n\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// The Emitter class provides the ability to call `.on()` on Dropzone to listen\n// to events.\n// It is strongly based on component's emitter class, and I removed the\n// functionality because of the dependency hell with different frameworks.\nvar Emitter = /*#__PURE__*/function () {\n  function Emitter() {\n    _classCallCheck(this, Emitter);\n  }\n\n  _createClass(Emitter, [{\n    key: \"on\",\n    value: // Add an event listener for given event\n    function on(event, fn) {\n      this._callbacks = this._callbacks || {}; // Create namespace for this event\n\n      if (!this._callbacks[event]) {\n        this._callbacks[event] = [];\n      }\n\n      this._callbacks[event].push(fn);\n\n      return this;\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      this._callbacks = this._callbacks || {};\n      var callbacks = this._callbacks[event];\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (callbacks) {\n        var _iterator = _createForOfIteratorHelper(callbacks, true),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var callback = _step.value;\n            callback.apply(this, args);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } // trigger a corresponding DOM event\n\n\n      if (this.element) {\n        this.element.dispatchEvent(this.makeEvent(\"dropzone:\" + event, {\n          args: args\n        }));\n      }\n\n      return this;\n    }\n  }, {\n    key: \"makeEvent\",\n    value: function makeEvent(eventName, detail) {\n      var params = {\n        bubbles: true,\n        cancelable: true,\n        detail: detail\n      };\n\n      if (typeof window.CustomEvent === \"function\") {\n        return new CustomEvent(eventName, params);\n      } else {\n        // IE 11 support\n        // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n        var evt = document.createEvent(\"CustomEvent\");\n        evt.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);\n        return evt;\n      }\n    } // Remove event listener for given event. If fn is not provided, all event\n    // listeners for that event will be removed. If neither is provided, all\n    // event listeners will be removed.\n\n  }, {\n    key: \"off\",\n    value: function off(event, fn) {\n      if (!this._callbacks || arguments.length === 0) {\n        this._callbacks = {};\n        return this;\n      } // specific event\n\n\n      var callbacks = this._callbacks[event];\n\n      if (!callbacks) {\n        return this;\n      } // remove all handlers\n\n\n      if (arguments.length === 1) {\n        delete this._callbacks[event];\n        return this;\n      } // remove specific handler\n\n\n      for (var i = 0; i < callbacks.length; i++) {\n        var callback = callbacks[i];\n\n        if (callback === fn) {\n          callbacks.splice(i, 1);\n          break;\n        }\n      }\n\n      return this;\n    }\n  }]);\n\n  return Emitter;\n}();\n\n\n;// CONCATENATED MODULE: ./src/preview-template.html\n// Module\nvar code = \"<div class=\\\"dz-preview dz-file-preview\\\"> <div class=\\\"dz-image\\\"><img data-dz-thumbnail/></div> <div class=\\\"dz-details\\\"> <div class=\\\"dz-size\\\"><span data-dz-size></span></div> <div class=\\\"dz-filename\\\"><span data-dz-name></span></div> </div> <div class=\\\"dz-progress\\\"> <span class=\\\"dz-upload\\\" data-dz-uploadprogress></span> </div> <div class=\\\"dz-error-message\\\"><span data-dz-errormessage></span></div> <div class=\\\"dz-success-mark\\\"> <svg width=\\\"54px\\\" height=\\\"54px\\\" viewBox=\\\"0 0 54 54\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"> <title>Check</title> <g stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\"> <path d=\\\"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\\\" stroke-opacity=\\\"0.198794158\\\" stroke=\\\"#747474\\\" fill-opacity=\\\"0.816519475\\\" fill=\\\"#FFFFFF\\\"></path> </g> </svg> </div> <div class=\\\"dz-error-mark\\\"> <svg width=\\\"54px\\\" height=\\\"54px\\\" viewBox=\\\"0 0 54 54\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"> <title>Error</title> <g stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill=\\\"none\\\" fill-rule=\\\"evenodd\\\"> <g stroke=\\\"#747474\\\" stroke-opacity=\\\"0.198794158\\\" fill=\\\"#FFFFFF\\\" fill-opacity=\\\"0.816519475\\\"> <path d=\\\"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\\\"></path> </g> </g> </svg> </div> </div> \";\n// Exports\n/* harmony default export */ var preview_template = (code);\n;// CONCATENATED MODULE: ./src/options.js\n\n\n\n\n\nfunction options_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = options_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction options_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return options_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return options_arrayLikeToArray(o, minLen); }\n\nfunction options_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\nvar defaultOptions = {\n  /**\n   * Has to be specified on elements other than form (or when the form\n   * doesn't have an `action` attribute). You can also\n   * provide a function that will be called with `files` and\n   * must return the url (since `v3.12.0`)\n   */\n  url: null,\n\n  /**\n   * Can be changed to `\"put\"` if necessary. You can also provide a function\n   * that will be called with `files` and must return the method (since `v3.12.0`).\n   */\n  method: \"post\",\n\n  /**\n   * Will be set on the XHRequest.\n   */\n  withCredentials: false,\n\n  /**\n   * The timeout for the XHR requests in milliseconds (since `v4.4.0`).\n   * If set to null or 0, no timeout is going to be set.\n   */\n  timeout: null,\n\n  /**\n   * How many file uploads to process in parallel (See the\n   * Enqueuing file uploads documentation section for more info)\n   */\n  parallelUploads: 2,\n\n  /**\n   * Whether to send multiple files in one request. If\n   * this it set to true, then the fallback file input element will\n   * have the `multiple` attribute as well. This option will\n   * also trigger additional events (like `processingmultiple`). See the events\n   * documentation section for more information.\n   */\n  uploadMultiple: false,\n\n  /**\n   * Whether you want files to be uploaded in chunks to your server. This can't be\n   * used in combination with `uploadMultiple`.\n   *\n   * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.\n   */\n  chunking: false,\n\n  /**\n   * If `chunking` is enabled, this defines whether **every** file should be chunked,\n   * even if the file size is below chunkSize. This means, that the additional chunk\n   * form data will be submitted and the `chunksUploaded` callback will be invoked.\n   */\n  forceChunking: false,\n\n  /**\n   * If `chunking` is `true`, then this defines the chunk size in bytes.\n   */\n  chunkSize: 2000000,\n\n  /**\n   * If `true`, the individual chunks of a file are being uploaded simultaneously.\n   */\n  parallelChunkUploads: false,\n\n  /**\n   * Whether a chunk should be retried if it fails.\n   */\n  retryChunks: false,\n\n  /**\n   * If `retryChunks` is true, how many times should it be retried.\n   */\n  retryChunksLimit: 3,\n\n  /**\n   * The maximum filesize (in bytes) that is allowed to be uploaded.\n   */\n  maxFilesize: 256,\n\n  /**\n   * The name of the file param that gets transferred.\n   * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then\n   * Dropzone will append `[]` to the name.\n   */\n  paramName: \"file\",\n\n  /**\n   * Whether thumbnails for images should be generated\n   */\n  createImageThumbnails: true,\n\n  /**\n   * In MB. When the filename exceeds this limit, the thumbnail will not be generated.\n   */\n  maxThumbnailFilesize: 10,\n\n  /**\n   * If `null`, the ratio of the image will be used to calculate it.\n   */\n  thumbnailWidth: 120,\n\n  /**\n   * The same as `thumbnailWidth`. If both are null, images will not be resized.\n   */\n  thumbnailHeight: 120,\n\n  /**\n   * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.\n   * Can be either `contain` or `crop`.\n   */\n  thumbnailMethod: \"crop\",\n\n  /**\n   * If set, images will be resized to these dimensions before being **uploaded**.\n   * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect\n   * ratio of the file will be preserved.\n   *\n   * The `options.transformFile` function uses these options, so if the `transformFile` function\n   * is overridden, these options don't do anything.\n   */\n  resizeWidth: null,\n\n  /**\n   * See `resizeWidth`.\n   */\n  resizeHeight: null,\n\n  /**\n   * The mime type of the resized image (before it gets uploaded to the server).\n   * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.\n   * See `resizeWidth` for more information.\n   */\n  resizeMimeType: null,\n\n  /**\n   * The quality of the resized images. See `resizeWidth`.\n   */\n  resizeQuality: 0.8,\n\n  /**\n   * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.\n   * Can be either `contain` or `crop`.\n   */\n  resizeMethod: \"contain\",\n\n  /**\n   * The base that is used to calculate the **displayed** filesize. You can\n   * change this to 1024 if you would rather display kibibytes, mebibytes,\n   * etc... 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte`\n   * not `1 kilobyte`. You can change this to `1024` if you don't care about\n   * validity.\n   */\n  filesizeBase: 1000,\n\n  /**\n   * If not `null` defines how many files this Dropzone handles. If it exceeds,\n   * the event `maxfilesexceeded` will be called. The dropzone element gets the\n   * class `dz-max-files-reached` accordingly so you can provide visual\n   * feedback.\n   */\n  maxFiles: null,\n\n  /**\n   * An optional object to send additional headers to the server. Eg:\n   * `{ \"My-Awesome-Header\": \"header value\" }`\n   */\n  headers: null,\n\n  /**\n   * If `true`, the dropzone element itself will be clickable, if `false`\n   * nothing will be clickable.\n   *\n   * You can also pass an HTML element, a CSS selector (for multiple elements)\n   * or an array of those. In that case, all of those elements will trigger an\n   * upload when clicked.\n   */\n  clickable: true,\n\n  /**\n   * Whether hidden files in directories should be ignored.\n   */\n  ignoreHiddenFiles: true,\n\n  /**\n   * The default implementation of `accept` checks the file's mime type or\n   * extension against this list. This is a comma separated list of mime\n   * types or file extensions.\n   *\n   * Eg.: `image/*,application/pdf,.psd`\n   *\n   * If the Dropzone is `clickable` this option will also be used as\n   * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)\n   * parameter on the hidden file input as well.\n   */\n  acceptedFiles: null,\n\n  /**\n   * **Deprecated!**\n   * Use acceptedFiles instead.\n   */\n  acceptedMimeTypes: null,\n\n  /**\n   * If false, files will be added to the queue but the queue will not be\n   * processed automatically.\n   * This can be useful if you need some additional user input before sending\n   * files (or if you want want all files sent at once).\n   * If you're ready to send the file simply call `myDropzone.processQueue()`.\n   *\n   * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation\n   * section for more information.\n   */\n  autoProcessQueue: true,\n\n  /**\n   * If false, files added to the dropzone will not be queued by default.\n   * You'll have to call `enqueueFile(file)` manually.\n   */\n  autoQueue: true,\n\n  /**\n   * If `true`, this will add a link to every file preview to remove or cancel (if\n   * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`\n   * and `dictRemoveFile` options are used for the wording.\n   */\n  addRemoveLinks: false,\n\n  /**\n   * Defines where to display the file previews – if `null` the\n   * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS\n   * selector. The element should have the `dropzone-previews` class so\n   * the previews are displayed properly.\n   */\n  previewsContainer: null,\n\n  /**\n   * Set this to `true` if you don't want previews to be shown.\n   */\n  disablePreviews: false,\n\n  /**\n   * This is the element the hidden input field (which is used when clicking on the\n   * dropzone to trigger file selection) will be appended to. This might\n   * be important in case you use frameworks to switch the content of your page.\n   *\n   * Can be a selector string, or an element directly.\n   */\n  hiddenInputContainer: \"body\",\n\n  /**\n   * If null, no capture type will be specified\n   * If camera, mobile devices will skip the file selection and choose camera\n   * If microphone, mobile devices will skip the file selection and choose the microphone\n   * If camcorder, mobile devices will skip the file selection and choose the camera in video mode\n   * On apple devices multiple must be set to false.  AcceptedFiles may need to\n   * be set to an appropriate mime type (e.g. \"image/*\", \"audio/*\", or \"video/*\").\n   */\n  capture: null,\n\n  /**\n   * **Deprecated**. Use `renameFile` instead.\n   */\n  renameFilename: null,\n\n  /**\n   * A function that is invoked before the file is uploaded to the server and renames the file.\n   * This function gets the `File` as argument and can use the `file.name`. The actual name of the\n   * file that gets used during the upload can be accessed through `file.upload.filename`.\n   */\n  renameFile: null,\n\n  /**\n   * If `true` the fallback will be forced. This is very useful to test your server\n   * implementations first and make sure that everything works as\n   * expected without dropzone if you experience problems, and to test\n   * how your fallbacks will look.\n   */\n  forceFallback: false,\n\n  /**\n   * The text used before any files are dropped.\n   */\n  dictDefaultMessage: \"Drop files here to upload\",\n\n  /**\n   * The text that replaces the default message text it the browser is not supported.\n   */\n  dictFallbackMessage: \"Your browser does not support drag'n'drop file uploads.\",\n\n  /**\n   * The text that will be added before the fallback form.\n   * If you provide a  fallback element yourself, or if this option is `null` this will\n   * be ignored.\n   */\n  dictFallbackText: \"Please use the fallback form below to upload your files like in the olden days.\",\n\n  /**\n   * If the filesize is too big.\n   * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.\n   */\n  dictFileTooBig: \"File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.\",\n\n  /**\n   * If the file doesn't match the file type.\n   */\n  dictInvalidFileType: \"You can't upload files of this type.\",\n\n  /**\n   * If the server response was invalid.\n   * `{{statusCode}}` will be replaced with the servers status code.\n   */\n  dictResponseError: \"Server responded with {{statusCode}} code.\",\n\n  /**\n   * If `addRemoveLinks` is true, the text to be used for the cancel upload link.\n   */\n  dictCancelUpload: \"Cancel upload\",\n\n  /**\n   * The text that is displayed if an upload was manually canceled\n   */\n  dictUploadCanceled: \"Upload canceled.\",\n\n  /**\n   * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.\n   */\n  dictCancelUploadConfirmation: \"Are you sure you want to cancel this upload?\",\n\n  /**\n   * If `addRemoveLinks` is true, the text to be used to remove a file.\n   */\n  dictRemoveFile: \"Remove file\",\n\n  /**\n   * If this is not null, then the user will be prompted before removing a file.\n   */\n  dictRemoveFileConfirmation: null,\n\n  /**\n   * Displayed if `maxFiles` is st and exceeded.\n   * The string `{{maxFiles}}` will be replaced by the configuration value.\n   */\n  dictMaxFilesExceeded: \"You can not upload any more files.\",\n\n  /**\n   * Allows you to translate the different units. Starting with `tb` for terabytes and going down to\n   * `b` for bytes.\n   */\n  dictFileSizeUnits: {\n    tb: \"TB\",\n    gb: \"GB\",\n    mb: \"MB\",\n    kb: \"KB\",\n    b: \"b\"\n  },\n\n  /**\n   * Called when dropzone initialized\n   * You can add event listeners here\n   */\n  init: function init() {},\n\n  /**\n   * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`\n   * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case\n   * of a function, this needs to return a map.\n   *\n   * The default implementation does nothing for normal uploads, but adds relevant information for\n   * chunked uploads.\n   *\n   * This is the same as adding hidden input fields in the form element.\n   */\n  params: function params(files, xhr, chunk) {\n    if (chunk) {\n      return {\n        dzuuid: chunk.file.upload.uuid,\n        dzchunkindex: chunk.index,\n        dztotalfilesize: chunk.file.size,\n        dzchunksize: this.options.chunkSize,\n        dztotalchunkcount: chunk.file.upload.totalChunkCount,\n        dzchunkbyteoffset: chunk.index * this.options.chunkSize\n      };\n    }\n  },\n\n  /**\n   * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)\n   * and a `done` function as parameters.\n   *\n   * If the done function is invoked without arguments, the file is \"accepted\" and will\n   * be processed. If you pass an error message, the file is rejected, and the error\n   * message will be displayed.\n   * This function will not be called if the file is too big or doesn't match the mime types.\n   */\n  accept: function accept(file, done) {\n    return done();\n  },\n\n  /**\n   * The callback that will be invoked when all chunks have been uploaded for a file.\n   * It gets the file for which the chunks have been uploaded as the first parameter,\n   * and the `done` function as second. `done()` needs to be invoked when everything\n   * needed to finish the upload process is done.\n   */\n  chunksUploaded: function chunksUploaded(file, done) {\n    done();\n  },\n\n  /**\n   * Gets called when the browser is not supported.\n   * The default implementation shows the fallback input field and adds\n   * a text.\n   */\n  fallback: function fallback() {\n    // This code should pass in IE7... :(\n    var messageElement;\n    this.element.className = \"\".concat(this.element.className, \" dz-browser-not-supported\");\n\n    var _iterator = options_createForOfIteratorHelper(this.element.getElementsByTagName(\"div\"), true),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var child = _step.value;\n\n        if (/(^| )dz-message($| )/.test(child.className)) {\n          messageElement = child;\n          child.className = \"dz-message\"; // Removes the 'dz-default' class\n\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (!messageElement) {\n      messageElement = Dropzone.createElement('<div class=\"dz-message\"><span></span></div>');\n      this.element.appendChild(messageElement);\n    }\n\n    var span = messageElement.getElementsByTagName(\"span\")[0];\n\n    if (span) {\n      if (span.textContent != null) {\n        span.textContent = this.options.dictFallbackMessage;\n      } else if (span.innerText != null) {\n        span.innerText = this.options.dictFallbackMessage;\n      }\n    }\n\n    return this.element.appendChild(this.getFallbackForm());\n  },\n\n  /**\n   * Gets called to calculate the thumbnail dimensions.\n   *\n   * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:\n   *\n   *  - `srcWidth` & `srcHeight` (required)\n   *  - `trgWidth` & `trgHeight` (required)\n   *  - `srcX` & `srcY` (optional, default `0`)\n   *  - `trgX` & `trgY` (optional, default `0`)\n   *\n   * Those values are going to be used by `ctx.drawImage()`.\n   */\n  resize: function resize(file, width, height, resizeMethod) {\n    var info = {\n      srcX: 0,\n      srcY: 0,\n      srcWidth: file.width,\n      srcHeight: file.height\n    };\n    var srcRatio = file.width / file.height; // Automatically calculate dimensions if not specified\n\n    if (width == null && height == null) {\n      width = info.srcWidth;\n      height = info.srcHeight;\n    } else if (width == null) {\n      width = height * srcRatio;\n    } else if (height == null) {\n      height = width / srcRatio;\n    } // Make sure images aren't upscaled\n\n\n    width = Math.min(width, info.srcWidth);\n    height = Math.min(height, info.srcHeight);\n    var trgRatio = width / height;\n\n    if (info.srcWidth > width || info.srcHeight > height) {\n      // Image is bigger and needs rescaling\n      if (resizeMethod === \"crop\") {\n        if (srcRatio > trgRatio) {\n          info.srcHeight = file.height;\n          info.srcWidth = info.srcHeight * trgRatio;\n        } else {\n          info.srcWidth = file.width;\n          info.srcHeight = info.srcWidth / trgRatio;\n        }\n      } else if (resizeMethod === \"contain\") {\n        // Method 'contain'\n        if (srcRatio > trgRatio) {\n          height = width / srcRatio;\n        } else {\n          width = height * srcRatio;\n        }\n      } else {\n        throw new Error(\"Unknown resizeMethod '\".concat(resizeMethod, \"'\"));\n      }\n    }\n\n    info.srcX = (file.width - info.srcWidth) / 2;\n    info.srcY = (file.height - info.srcHeight) / 2;\n    info.trgWidth = width;\n    info.trgHeight = height;\n    return info;\n  },\n\n  /**\n   * Can be used to transform the file (for example, resize an image if necessary).\n   *\n   * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes\n   * images according to those dimensions.\n   *\n   * Gets the `file` as the first parameter, and a `done()` function as the second, that needs\n   * to be invoked with the file when the transformation is done.\n   */\n  transformFile: function transformFile(file, done) {\n    if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) {\n      return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);\n    } else {\n      return done(file);\n    }\n  },\n\n  /**\n   * A string that contains the template used for each dropped\n   * file. Change it to fulfill your needs but make sure to properly\n   * provide all elements.\n   *\n   * If you want to use an actual HTML element instead of providing a String\n   * as a config option, you could create a div with the id `tpl`,\n   * put the template inside it and provide the element like this:\n   *\n   *     document\n   *       .querySelector('#tpl')\n   *       .innerHTML\n   *\n   */\n  previewTemplate: preview_template,\n\n  /*\n   Those functions register themselves to the events on init and handle all\n   the user interface specific stuff. Overwriting them won't break the upload\n   but can break the way it's displayed.\n   You can overwrite them if you don't like the default behavior. If you just\n   want to add an additional event handler, register it on the dropzone object\n   and don't overwrite those options.\n   */\n  // Those are self explanatory and simply concern the DragnDrop.\n  drop: function drop(e) {\n    return this.element.classList.remove(\"dz-drag-hover\");\n  },\n  dragstart: function dragstart(e) {},\n  dragend: function dragend(e) {\n    return this.element.classList.remove(\"dz-drag-hover\");\n  },\n  dragenter: function dragenter(e) {\n    return this.element.classList.add(\"dz-drag-hover\");\n  },\n  dragover: function dragover(e) {\n    return this.element.classList.add(\"dz-drag-hover\");\n  },\n  dragleave: function dragleave(e) {\n    return this.element.classList.remove(\"dz-drag-hover\");\n  },\n  paste: function paste(e) {},\n  // Called whenever there are no files left in the dropzone anymore, and the\n  // dropzone should be displayed as if in the initial state.\n  reset: function reset() {\n    return this.element.classList.remove(\"dz-started\");\n  },\n  // Called when a file is added to the queue\n  // Receives `file`\n  addedfile: function addedfile(file) {\n    var _this = this;\n\n    if (this.element === this.previewsContainer) {\n      this.element.classList.add(\"dz-started\");\n    }\n\n    if (this.previewsContainer && !this.options.disablePreviews) {\n      file.previewElement = Dropzone.createElement(this.options.previewTemplate.trim());\n      file.previewTemplate = file.previewElement; // Backwards compatibility\n\n      this.previewsContainer.appendChild(file.previewElement);\n\n      var _iterator2 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll(\"[data-dz-name]\"), true),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var node = _step2.value;\n          node.textContent = file.name;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll(\"[data-dz-size]\"), true),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          node = _step3.value;\n          node.innerHTML = this.filesize(file.size);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      if (this.options.addRemoveLinks) {\n        file._removeLink = Dropzone.createElement(\"<a class=\\\"dz-remove\\\" href=\\\"javascript:undefined;\\\" data-dz-remove>\".concat(this.options.dictRemoveFile, \"</a>\"));\n        file.previewElement.appendChild(file._removeLink);\n      }\n\n      var removeFileEvent = function removeFileEvent(e) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        if (file.status === Dropzone.UPLOADING) {\n          return Dropzone.confirm(_this.options.dictCancelUploadConfirmation, function () {\n            return _this.removeFile(file);\n          });\n        } else {\n          if (_this.options.dictRemoveFileConfirmation) {\n            return Dropzone.confirm(_this.options.dictRemoveFileConfirmation, function () {\n              return _this.removeFile(file);\n            });\n          } else {\n            return _this.removeFile(file);\n          }\n        }\n      };\n\n      var _iterator4 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll(\"[data-dz-remove]\"), true),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var removeLink = _step4.value;\n          removeLink.addEventListener(\"click\", removeFileEvent);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  },\n  // Called whenever a file is removed.\n  removedfile: function removedfile(file) {\n    if (file.previewElement != null && file.previewElement.parentNode != null) {\n      file.previewElement.parentNode.removeChild(file.previewElement);\n    }\n\n    return this._updateMaxFilesReachedClass();\n  },\n  // Called when a thumbnail has been generated\n  // Receives `file` and `dataUrl`\n  thumbnail: function thumbnail(file, dataUrl) {\n    if (file.previewElement) {\n      file.previewElement.classList.remove(\"dz-file-preview\");\n\n      var _iterator5 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll(\"[data-dz-thumbnail]\"), true),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var thumbnailElement = _step5.value;\n          thumbnailElement.alt = file.name;\n          thumbnailElement.src = dataUrl;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return setTimeout(function () {\n        return file.previewElement.classList.add(\"dz-image-preview\");\n      }, 1);\n    }\n  },\n  // Called whenever an error occurs\n  // Receives `file` and `message`\n  error: function error(file, message) {\n    if (file.previewElement) {\n      file.previewElement.classList.add(\"dz-error\");\n\n      if (typeof message !== \"string\" && message.error) {\n        message = message.error;\n      }\n\n      var _iterator6 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll(\"[data-dz-errormessage]\"), true),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var node = _step6.value;\n          node.textContent = message;\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  },\n  errormultiple: function errormultiple() {},\n  // Called when a file gets processed. Since there is a cue, not all added\n  // files are processed immediately.\n  // Receives `file`\n  processing: function processing(file) {\n    if (file.previewElement) {\n      file.previewElement.classList.add(\"dz-processing\");\n\n      if (file._removeLink) {\n        return file._removeLink.innerHTML = this.options.dictCancelUpload;\n      }\n    }\n  },\n  processingmultiple: function processingmultiple() {},\n  // Called whenever the upload progress gets updated.\n  // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.\n  // To get the total number of bytes of the file, use `file.size`\n  uploadprogress: function uploadprogress(file, progress, bytesSent) {\n    if (file.previewElement) {\n      var _iterator7 = options_createForOfIteratorHelper(file.previewElement.querySelectorAll(\"[data-dz-uploadprogress]\"), true),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var node = _step7.value;\n          node.nodeName === \"PROGRESS\" ? node.value = progress : node.style.width = \"\".concat(progress, \"%\");\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  },\n  // Called whenever the total upload progress gets updated.\n  // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent\n  totaluploadprogress: function totaluploadprogress() {},\n  // Called just before the file is sent. Gets the `xhr` object as second\n  // parameter, so you can modify it (for example to add a CSRF token) and a\n  // `formData` object to add additional information.\n  sending: function sending() {},\n  sendingmultiple: function sendingmultiple() {},\n  // When the complete upload is finished and successful\n  // Receives `file`\n  success: function success(file) {\n    if (file.previewElement) {\n      return file.previewElement.classList.add(\"dz-success\");\n    }\n  },\n  successmultiple: function successmultiple() {},\n  // When the upload is canceled.\n  canceled: function canceled(file) {\n    return this.emit(\"error\", file, this.options.dictUploadCanceled);\n  },\n  canceledmultiple: function canceledmultiple() {},\n  // When the upload is finished, either with success or an error.\n  // Receives `file`\n  complete: function complete(file) {\n    if (file._removeLink) {\n      file._removeLink.innerHTML = this.options.dictRemoveFile;\n    }\n\n    if (file.previewElement) {\n      return file.previewElement.classList.add(\"dz-complete\");\n    }\n  },\n  completemultiple: function completemultiple() {},\n  maxfilesexceeded: function maxfilesexceeded() {},\n  maxfilesreached: function maxfilesreached() {},\n  queuecomplete: function queuecomplete() {},\n  addedfiles: function addedfiles() {}\n};\n/* harmony default export */ var src_options = (defaultOptions);\n;// CONCATENATED MODULE: ./src/dropzone.js\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction dropzone_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = dropzone_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction dropzone_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return dropzone_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dropzone_arrayLikeToArray(o, minLen); }\n\nfunction dropzone_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction dropzone_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction dropzone_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction dropzone_createClass(Constructor, protoProps, staticProps) { if (protoProps) dropzone_defineProperties(Constructor.prototype, protoProps); if (staticProps) dropzone_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar Dropzone = /*#__PURE__*/function (_Emitter) {\n  _inherits(Dropzone, _Emitter);\n\n  var _super = _createSuper(Dropzone);\n\n  function Dropzone(el, options) {\n    var _this;\n\n    dropzone_classCallCheck(this, Dropzone);\n\n    _this = _super.call(this);\n    var fallback, left;\n    _this.element = el; // For backwards compatibility since the version was in the prototype previously\n\n    _this.version = Dropzone.version;\n    _this.clickableElements = [];\n    _this.listeners = [];\n    _this.files = []; // All files\n\n    if (typeof _this.element === \"string\") {\n      _this.element = document.querySelector(_this.element);\n    } // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.\n\n\n    if (!_this.element || _this.element.nodeType == null) {\n      throw new Error(\"Invalid dropzone element.\");\n    }\n\n    if (_this.element.dropzone) {\n      throw new Error(\"Dropzone already attached.\");\n    } // Now add this dropzone to the instances.\n\n\n    Dropzone.instances.push(_assertThisInitialized(_this)); // Put the dropzone inside the element itself.\n\n    _this.element.dropzone = _assertThisInitialized(_this);\n    var elementOptions = (left = Dropzone.optionsForElement(_this.element)) != null ? left : {};\n    _this.options = Dropzone.extend({}, src_options, elementOptions, options != null ? options : {});\n    _this.options.previewTemplate = _this.options.previewTemplate.replace(/\\n*/g, \"\"); // If the browser failed, just call the fallback and leave\n\n    if (_this.options.forceFallback || !Dropzone.isBrowserSupported()) {\n      return _possibleConstructorReturn(_this, _this.options.fallback.call(_assertThisInitialized(_this)));\n    } // @options.url = @element.getAttribute \"action\" unless @options.url?\n\n\n    if (_this.options.url == null) {\n      _this.options.url = _this.element.getAttribute(\"action\");\n    }\n\n    if (!_this.options.url) {\n      throw new Error(\"No URL provided.\");\n    }\n\n    if (_this.options.acceptedFiles && _this.options.acceptedMimeTypes) {\n      throw new Error(\"You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.\");\n    }\n\n    if (_this.options.uploadMultiple && _this.options.chunking) {\n      throw new Error(\"You cannot set both: uploadMultiple and chunking.\");\n    } // Backwards compatibility\n\n\n    if (_this.options.acceptedMimeTypes) {\n      _this.options.acceptedFiles = _this.options.acceptedMimeTypes;\n      delete _this.options.acceptedMimeTypes;\n    } // Backwards compatibility\n\n\n    if (_this.options.renameFilename != null) {\n      _this.options.renameFile = function (file) {\n        return _this.options.renameFilename.call(_assertThisInitialized(_this), file.name, file);\n      };\n    }\n\n    if (typeof _this.options.method === \"string\") {\n      _this.options.method = _this.options.method.toUpperCase();\n    }\n\n    if ((fallback = _this.getExistingFallback()) && fallback.parentNode) {\n      // Remove the fallback\n      fallback.parentNode.removeChild(fallback);\n    } // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false\n\n\n    if (_this.options.previewsContainer !== false) {\n      if (_this.options.previewsContainer) {\n        _this.previewsContainer = Dropzone.getElement(_this.options.previewsContainer, \"previewsContainer\");\n      } else {\n        _this.previewsContainer = _this.element;\n      }\n    }\n\n    if (_this.options.clickable) {\n      if (_this.options.clickable === true) {\n        _this.clickableElements = [_this.element];\n      } else {\n        _this.clickableElements = Dropzone.getElements(_this.options.clickable, \"clickable\");\n      }\n    }\n\n    _this.init();\n\n    return _this;\n  } // Returns all files that have been accepted\n\n\n  dropzone_createClass(Dropzone, [{\n    key: \"getAcceptedFiles\",\n    value: function getAcceptedFiles() {\n      return this.files.filter(function (file) {\n        return file.accepted;\n      }).map(function (file) {\n        return file;\n      });\n    } // Returns all files that have been rejected\n    // Not sure when that's going to be useful, but added for completeness.\n\n  }, {\n    key: \"getRejectedFiles\",\n    value: function getRejectedFiles() {\n      return this.files.filter(function (file) {\n        return !file.accepted;\n      }).map(function (file) {\n        return file;\n      });\n    }\n  }, {\n    key: \"getFilesWithStatus\",\n    value: function getFilesWithStatus(status) {\n      return this.files.filter(function (file) {\n        return file.status === status;\n      }).map(function (file) {\n        return file;\n      });\n    } // Returns all files that are in the queue\n\n  }, {\n    key: \"getQueuedFiles\",\n    value: function getQueuedFiles() {\n      return this.getFilesWithStatus(Dropzone.QUEUED);\n    }\n  }, {\n    key: \"getUploadingFiles\",\n    value: function getUploadingFiles() {\n      return this.getFilesWithStatus(Dropzone.UPLOADING);\n    }\n  }, {\n    key: \"getAddedFiles\",\n    value: function getAddedFiles() {\n      return this.getFilesWithStatus(Dropzone.ADDED);\n    } // Files that are either queued or uploading\n\n  }, {\n    key: \"getActiveFiles\",\n    value: function getActiveFiles() {\n      return this.files.filter(function (file) {\n        return file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED;\n      }).map(function (file) {\n        return file;\n      });\n    } // The function that gets called when Dropzone is initialized. You\n    // can (and should) setup event listeners inside this function.\n\n  }, {\n    key: \"init\",\n    value: function init() {\n      var _this2 = this;\n\n      // In case it isn't set already\n      if (this.element.tagName === \"form\") {\n        this.element.setAttribute(\"enctype\", \"multipart/form-data\");\n      }\n\n      if (this.element.classList.contains(\"dropzone\") && !this.element.querySelector(\".dz-message\")) {\n        this.element.appendChild(Dropzone.createElement(\"<div class=\\\"dz-default dz-message\\\"><button class=\\\"dz-button\\\" type=\\\"button\\\">\".concat(this.options.dictDefaultMessage, \"</button></div>\")));\n      }\n\n      if (this.clickableElements.length) {\n        var setupHiddenFileInput = function setupHiddenFileInput() {\n          if (_this2.hiddenFileInput) {\n            _this2.hiddenFileInput.parentNode.removeChild(_this2.hiddenFileInput);\n          }\n\n          _this2.hiddenFileInput = document.createElement(\"input\");\n\n          _this2.hiddenFileInput.setAttribute(\"type\", \"file\");\n\n          if (_this2.options.maxFiles === null || _this2.options.maxFiles > 1) {\n            _this2.hiddenFileInput.setAttribute(\"multiple\", \"multiple\");\n          }\n\n          _this2.hiddenFileInput.className = \"dz-hidden-input\";\n\n          if (_this2.options.acceptedFiles !== null) {\n            _this2.hiddenFileInput.setAttribute(\"accept\", _this2.options.acceptedFiles);\n          }\n\n          if (_this2.options.capture !== null) {\n            _this2.hiddenFileInput.setAttribute(\"capture\", _this2.options.capture);\n          } // Making sure that no one can \"tab\" into this field.\n\n\n          _this2.hiddenFileInput.setAttribute(\"tabindex\", \"-1\"); // Not setting `display=\"none\"` because some browsers don't accept clicks\n          // on elements that aren't displayed.\n\n\n          _this2.hiddenFileInput.style.visibility = \"hidden\";\n          _this2.hiddenFileInput.style.position = \"absolute\";\n          _this2.hiddenFileInput.style.top = \"0\";\n          _this2.hiddenFileInput.style.left = \"0\";\n          _this2.hiddenFileInput.style.height = \"0\";\n          _this2.hiddenFileInput.style.width = \"0\";\n          Dropzone.getElement(_this2.options.hiddenInputContainer, \"hiddenInputContainer\").appendChild(_this2.hiddenFileInput);\n\n          _this2.hiddenFileInput.addEventListener(\"change\", function () {\n            var files = _this2.hiddenFileInput.files;\n\n            if (files.length) {\n              var _iterator = dropzone_createForOfIteratorHelper(files, true),\n                  _step;\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var file = _step.value;\n\n                  _this2.addFile(file);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n            }\n\n            _this2.emit(\"addedfiles\", files);\n\n            setupHiddenFileInput();\n          });\n        };\n\n        setupHiddenFileInput();\n      }\n\n      this.URL = window.URL !== null ? window.URL : window.webkitURL; // Setup all event listeners on the Dropzone object itself.\n      // They're not in @setupEventListeners() because they shouldn't be removed\n      // again when the dropzone gets disabled.\n\n      var _iterator2 = dropzone_createForOfIteratorHelper(this.events, true),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var eventName = _step2.value;\n          this.on(eventName, this.options[eventName]);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this.on(\"uploadprogress\", function () {\n        return _this2.updateTotalUploadProgress();\n      });\n      this.on(\"removedfile\", function () {\n        return _this2.updateTotalUploadProgress();\n      });\n      this.on(\"canceled\", function (file) {\n        return _this2.emit(\"complete\", file);\n      }); // Emit a `queuecomplete` event if all files finished uploading.\n\n      this.on(\"complete\", function (file) {\n        if (_this2.getAddedFiles().length === 0 && _this2.getUploadingFiles().length === 0 && _this2.getQueuedFiles().length === 0) {\n          // This needs to be deferred so that `queuecomplete` really triggers after `complete`\n          return setTimeout(function () {\n            return _this2.emit(\"queuecomplete\");\n          }, 0);\n        }\n      });\n\n      var containsFiles = function containsFiles(e) {\n        if (e.dataTransfer.types) {\n          // Because e.dataTransfer.types is an Object in\n          // IE, we need to iterate like this instead of\n          // using e.dataTransfer.types.some()\n          for (var i = 0; i < e.dataTransfer.types.length; i++) {\n            if (e.dataTransfer.types[i] === \"Files\") return true;\n          }\n        }\n\n        return false;\n      };\n\n      var noPropagation = function noPropagation(e) {\n        // If there are no files, we don't want to stop\n        // propagation so we don't interfere with other\n        // drag and drop behaviour.\n        if (!containsFiles(e)) return;\n        e.stopPropagation();\n\n        if (e.preventDefault) {\n          return e.preventDefault();\n        } else {\n          return e.returnValue = false;\n        }\n      }; // Create the listeners\n\n\n      this.listeners = [{\n        element: this.element,\n        events: {\n          dragstart: function dragstart(e) {\n            return _this2.emit(\"dragstart\", e);\n          },\n          dragenter: function dragenter(e) {\n            noPropagation(e);\n            return _this2.emit(\"dragenter\", e);\n          },\n          dragover: function dragover(e) {\n            // Makes it possible to drag files from chrome's download bar\n            // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar\n            // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)\n            var efct;\n\n            try {\n              efct = e.dataTransfer.effectAllowed;\n            } catch (error) {}\n\n            e.dataTransfer.dropEffect = \"move\" === efct || \"linkMove\" === efct ? \"move\" : \"copy\";\n            noPropagation(e);\n            return _this2.emit(\"dragover\", e);\n          },\n          dragleave: function dragleave(e) {\n            return _this2.emit(\"dragleave\", e);\n          },\n          drop: function drop(e) {\n            noPropagation(e);\n            return _this2.drop(e);\n          },\n          dragend: function dragend(e) {\n            return _this2.emit(\"dragend\", e);\n          }\n        } // This is disabled right now, because the browsers don't implement it properly.\n        // \"paste\": (e) =>\n        //   noPropagation e\n        //   @paste e\n\n      }];\n      this.clickableElements.forEach(function (clickableElement) {\n        return _this2.listeners.push({\n          element: clickableElement,\n          events: {\n            click: function click(evt) {\n              // Only the actual dropzone or the message element should trigger file selection\n              if (clickableElement !== _this2.element || evt.target === _this2.element || Dropzone.elementInside(evt.target, _this2.element.querySelector(\".dz-message\"))) {\n                _this2.hiddenFileInput.click(); // Forward the click\n\n              }\n\n              return true;\n            }\n          }\n        });\n      });\n      this.enable();\n      return this.options.init.call(this);\n    } // Not fully tested yet\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.disable();\n      this.removeAllFiles(true);\n\n      if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined) {\n        this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);\n        this.hiddenFileInput = null;\n      }\n\n      delete this.element.dropzone;\n      return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);\n    }\n  }, {\n    key: \"updateTotalUploadProgress\",\n    value: function updateTotalUploadProgress() {\n      var totalUploadProgress;\n      var totalBytesSent = 0;\n      var totalBytes = 0;\n      var activeFiles = this.getActiveFiles();\n\n      if (activeFiles.length) {\n        var _iterator3 = dropzone_createForOfIteratorHelper(this.getActiveFiles(), true),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var file = _step3.value;\n            totalBytesSent += file.upload.bytesSent;\n            totalBytes += file.upload.total;\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        totalUploadProgress = 100 * totalBytesSent / totalBytes;\n      } else {\n        totalUploadProgress = 100;\n      }\n\n      return this.emit(\"totaluploadprogress\", totalUploadProgress, totalBytes, totalBytesSent);\n    } // @options.paramName can be a function taking one parameter rather than a string.\n    // A parameter name for a file is obtained simply by calling this with an index number.\n\n  }, {\n    key: \"_getParamName\",\n    value: function _getParamName(n) {\n      if (typeof this.options.paramName === \"function\") {\n        return this.options.paramName(n);\n      } else {\n        return \"\".concat(this.options.paramName).concat(this.options.uploadMultiple ? \"[\".concat(n, \"]\") : \"\");\n      }\n    } // If @options.renameFile is a function,\n    // the function will be used to rename the file.name before appending it to the formData\n\n  }, {\n    key: \"_renameFile\",\n    value: function _renameFile(file) {\n      if (typeof this.options.renameFile !== \"function\") {\n        return file.name;\n      }\n\n      return this.options.renameFile(file);\n    } // Returns a form that can be used as fallback if the browser does not support DragnDrop\n    //\n    // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.\n    // This code has to pass in IE7 :(\n\n  }, {\n    key: \"getFallbackForm\",\n    value: function getFallbackForm() {\n      var existingFallback, form;\n\n      if (existingFallback = this.getExistingFallback()) {\n        return existingFallback;\n      }\n\n      var fieldsString = '<div class=\"dz-fallback\">';\n\n      if (this.options.dictFallbackText) {\n        fieldsString += \"<p>\".concat(this.options.dictFallbackText, \"</p>\");\n      }\n\n      fieldsString += \"<input type=\\\"file\\\" name=\\\"\".concat(this._getParamName(0), \"\\\" \").concat(this.options.uploadMultiple ? 'multiple=\"multiple\"' : undefined, \" /><input type=\\\"submit\\\" value=\\\"Upload!\\\"></div>\");\n      var fields = Dropzone.createElement(fieldsString);\n\n      if (this.element.tagName !== \"FORM\") {\n        form = Dropzone.createElement(\"<form action=\\\"\".concat(this.options.url, \"\\\" enctype=\\\"multipart/form-data\\\" method=\\\"\").concat(this.options.method, \"\\\"></form>\"));\n        form.appendChild(fields);\n      } else {\n        // Make sure that the enctype and method attributes are set properly\n        this.element.setAttribute(\"enctype\", \"multipart/form-data\");\n        this.element.setAttribute(\"method\", this.options.method);\n      }\n\n      return form != null ? form : fields;\n    } // Returns the fallback elements if they exist already\n    //\n    // This code has to pass in IE7 :(\n\n  }, {\n    key: \"getExistingFallback\",\n    value: function getExistingFallback() {\n      var getFallback = function getFallback(elements) {\n        var _iterator4 = dropzone_createForOfIteratorHelper(elements, true),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var el = _step4.value;\n\n            if (/(^| )fallback($| )/.test(el.className)) {\n              return el;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      };\n\n      for (var _i = 0, _arr = [\"div\", \"form\"]; _i < _arr.length; _i++) {\n        var tagName = _arr[_i];\n        var fallback;\n\n        if (fallback = getFallback(this.element.getElementsByTagName(tagName))) {\n          return fallback;\n        }\n      }\n    } // Activates all listeners stored in @listeners\n\n  }, {\n    key: \"setupEventListeners\",\n    value: function setupEventListeners() {\n      return this.listeners.map(function (elementListeners) {\n        return function () {\n          var result = [];\n\n          for (var event in elementListeners.events) {\n            var listener = elementListeners.events[event];\n            result.push(elementListeners.element.addEventListener(event, listener, false));\n          }\n\n          return result;\n        }();\n      });\n    } // Deactivates all listeners stored in @listeners\n\n  }, {\n    key: \"removeEventListeners\",\n    value: function removeEventListeners() {\n      return this.listeners.map(function (elementListeners) {\n        return function () {\n          var result = [];\n\n          for (var event in elementListeners.events) {\n            var listener = elementListeners.events[event];\n            result.push(elementListeners.element.removeEventListener(event, listener, false));\n          }\n\n          return result;\n        }();\n      });\n    } // Removes all event listeners and cancels all files in the queue or being processed.\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      var _this3 = this;\n\n      this.clickableElements.forEach(function (element) {\n        return element.classList.remove(\"dz-clickable\");\n      });\n      this.removeEventListeners();\n      this.disabled = true;\n      return this.files.map(function (file) {\n        return _this3.cancelUpload(file);\n      });\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      delete this.disabled;\n      this.clickableElements.forEach(function (element) {\n        return element.classList.add(\"dz-clickable\");\n      });\n      return this.setupEventListeners();\n    } // Returns a nicely formatted filesize\n\n  }, {\n    key: \"filesize\",\n    value: function filesize(size) {\n      var selectedSize = 0;\n      var selectedUnit = \"b\";\n\n      if (size > 0) {\n        var units = [\"tb\", \"gb\", \"mb\", \"kb\", \"b\"];\n\n        for (var i = 0; i < units.length; i++) {\n          var unit = units[i];\n          var cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;\n\n          if (size >= cutoff) {\n            selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);\n            selectedUnit = unit;\n            break;\n          }\n        }\n\n        selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits\n      }\n\n      return \"<strong>\".concat(selectedSize, \"</strong> \").concat(this.options.dictFileSizeUnits[selectedUnit]);\n    } // Adds or removes the `dz-max-files-reached` class from the form.\n\n  }, {\n    key: \"_updateMaxFilesReachedClass\",\n    value: function _updateMaxFilesReachedClass() {\n      if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {\n        if (this.getAcceptedFiles().length === this.options.maxFiles) {\n          this.emit(\"maxfilesreached\", this.files);\n        }\n\n        return this.element.classList.add(\"dz-max-files-reached\");\n      } else {\n        return this.element.classList.remove(\"dz-max-files-reached\");\n      }\n    }\n  }, {\n    key: \"drop\",\n    value: function drop(e) {\n      if (!e.dataTransfer) {\n        return;\n      }\n\n      this.emit(\"drop\", e); // Convert the FileList to an Array\n      // This is necessary for IE11\n\n      var files = [];\n\n      for (var i = 0; i < e.dataTransfer.files.length; i++) {\n        files[i] = e.dataTransfer.files[i];\n      } // Even if it's a folder, files.length will contain the folders.\n\n\n      if (files.length) {\n        var items = e.dataTransfer.items;\n\n        if (items && items.length && items[0].webkitGetAsEntry != null) {\n          // The browser supports dropping of folders, so handle items instead of files\n          this._addFilesFromItems(items);\n        } else {\n          this.handleFiles(files);\n        }\n      }\n\n      this.emit(\"addedfiles\", files);\n    }\n  }, {\n    key: \"paste\",\n    value: function paste(e) {\n      if (__guard__(e != null ? e.clipboardData : undefined, function (x) {\n        return x.items;\n      }) == null) {\n        return;\n      }\n\n      this.emit(\"paste\", e);\n      var items = e.clipboardData.items;\n\n      if (items.length) {\n        return this._addFilesFromItems(items);\n      }\n    }\n  }, {\n    key: \"handleFiles\",\n    value: function handleFiles(files) {\n      var _iterator5 = dropzone_createForOfIteratorHelper(files, true),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var file = _step5.value;\n          this.addFile(file);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    } // When a folder is dropped (or files are pasted), items must be handled\n    // instead of files.\n\n  }, {\n    key: \"_addFilesFromItems\",\n    value: function _addFilesFromItems(items) {\n      var _this4 = this;\n\n      return function () {\n        var result = [];\n\n        var _iterator6 = dropzone_createForOfIteratorHelper(items, true),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var item = _step6.value;\n            var entry;\n\n            if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {\n              if (entry.isFile) {\n                result.push(_this4.addFile(item.getAsFile()));\n              } else if (entry.isDirectory) {\n                // Append all files from that directory to files\n                result.push(_this4._addFilesFromDirectory(entry, entry.name));\n              } else {\n                result.push(undefined);\n              }\n            } else if (item.getAsFile != null) {\n              if (item.kind == null || item.kind === \"file\") {\n                result.push(_this4.addFile(item.getAsFile()));\n              } else {\n                result.push(undefined);\n              }\n            } else {\n              result.push(undefined);\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        return result;\n      }();\n    } // Goes through the directory, and adds each file it finds recursively\n\n  }, {\n    key: \"_addFilesFromDirectory\",\n    value: function _addFilesFromDirectory(directory, path) {\n      var _this5 = this;\n\n      var dirReader = directory.createReader();\n\n      var errorHandler = function errorHandler(error) {\n        return __guardMethod__(console, \"log\", function (o) {\n          return o.log(error);\n        });\n      };\n\n      var readEntries = function readEntries() {\n        return dirReader.readEntries(function (entries) {\n          if (entries.length > 0) {\n            var _iterator7 = dropzone_createForOfIteratorHelper(entries, true),\n                _step7;\n\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var entry = _step7.value;\n\n                if (entry.isFile) {\n                  entry.file(function (file) {\n                    if (_this5.options.ignoreHiddenFiles && file.name.substring(0, 1) === \".\") {\n                      return;\n                    }\n\n                    file.fullPath = \"\".concat(path, \"/\").concat(file.name);\n                    return _this5.addFile(file);\n                  });\n                } else if (entry.isDirectory) {\n                  _this5._addFilesFromDirectory(entry, \"\".concat(path, \"/\").concat(entry.name));\n                }\n              } // Recursively call readEntries() again, since browser only handle\n              // the first 100 entries.\n              // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries\n\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n\n            readEntries();\n          }\n\n          return null;\n        }, errorHandler);\n      };\n\n      return readEntries();\n    } // If `done()` is called without argument the file is accepted\n    // If you call it with an error message, the file is rejected\n    // (This allows for asynchronous validation)\n    //\n    // This function checks the filesize, and if the file.type passes the\n    // `acceptedFiles` check.\n\n  }, {\n    key: \"accept\",\n    value: function accept(file, done) {\n      if (this.options.maxFilesize && file.size > this.options.maxFilesize * 1024 * 1024) {\n        done(this.options.dictFileTooBig.replace(\"{{filesize}}\", Math.round(file.size / 1024 / 10.24) / 100).replace(\"{{maxFilesize}}\", this.options.maxFilesize));\n      } else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {\n        done(this.options.dictInvalidFileType);\n      } else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {\n        done(this.options.dictMaxFilesExceeded.replace(\"{{maxFiles}}\", this.options.maxFiles));\n        this.emit(\"maxfilesexceeded\", file);\n      } else {\n        this.options.accept.call(this, file, done);\n      }\n    }\n  }, {\n    key: \"addFile\",\n    value: function addFile(file) {\n      var _this6 = this;\n\n      file.upload = {\n        uuid: Dropzone.uuidv4(),\n        progress: 0,\n        // Setting the total upload size to file.size for the beginning\n        // It's actual different than the size to be transmitted.\n        total: file.size,\n        bytesSent: 0,\n        filename: this._renameFile(file) // Not setting chunking information here, because the acutal data — and\n        // thus the chunks — might change if `options.transformFile` is set\n        // and does something to the data.\n\n      };\n      this.files.push(file);\n      file.status = Dropzone.ADDED;\n      this.emit(\"addedfile\", file);\n\n      this._enqueueThumbnail(file);\n\n      this.accept(file, function (error) {\n        if (error) {\n          file.accepted = false;\n\n          _this6._errorProcessing([file], error); // Will set the file.status\n\n        } else {\n          file.accepted = true;\n\n          if (_this6.options.autoQueue) {\n            _this6.enqueueFile(file);\n          } // Will set .accepted = true\n\n        }\n\n        _this6._updateMaxFilesReachedClass();\n      });\n    } // Wrapper for enqueueFile\n\n  }, {\n    key: \"enqueueFiles\",\n    value: function enqueueFiles(files) {\n      var _iterator8 = dropzone_createForOfIteratorHelper(files, true),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var file = _step8.value;\n          this.enqueueFile(file);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"enqueueFile\",\n    value: function enqueueFile(file) {\n      var _this7 = this;\n\n      if (file.status === Dropzone.ADDED && file.accepted === true) {\n        file.status = Dropzone.QUEUED;\n\n        if (this.options.autoProcessQueue) {\n          return setTimeout(function () {\n            return _this7.processQueue();\n          }, 0); // Deferring the call\n        }\n      } else {\n        throw new Error(\"This file can't be queued because it has already been processed or was rejected.\");\n      }\n    }\n  }, {\n    key: \"_enqueueThumbnail\",\n    value: function _enqueueThumbnail(file) {\n      var _this8 = this;\n\n      if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1024 * 1024) {\n        this._thumbnailQueue.push(file);\n\n        return setTimeout(function () {\n          return _this8._processThumbnailQueue();\n        }, 0); // Deferring the call\n      }\n    }\n  }, {\n    key: \"_processThumbnailQueue\",\n    value: function _processThumbnailQueue() {\n      var _this9 = this;\n\n      if (this._processingThumbnail || this._thumbnailQueue.length === 0) {\n        return;\n      }\n\n      this._processingThumbnail = true;\n\n      var file = this._thumbnailQueue.shift();\n\n      return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, function (dataUrl) {\n        _this9.emit(\"thumbnail\", file, dataUrl);\n\n        _this9._processingThumbnail = false;\n        return _this9._processThumbnailQueue();\n      });\n    } // Can be called by the user to remove a file\n\n  }, {\n    key: \"removeFile\",\n    value: function removeFile(file) {\n      if (file.status === Dropzone.UPLOADING) {\n        this.cancelUpload(file);\n      }\n\n      this.files = without(this.files, file);\n      this.emit(\"removedfile\", file);\n\n      if (this.files.length === 0) {\n        return this.emit(\"reset\");\n      }\n    } // Removes all files that aren't currently processed from the list\n\n  }, {\n    key: \"removeAllFiles\",\n    value: function removeAllFiles(cancelIfNecessary) {\n      // Create a copy of files since removeFile() changes the @files array.\n      if (cancelIfNecessary == null) {\n        cancelIfNecessary = false;\n      }\n\n      var _iterator9 = dropzone_createForOfIteratorHelper(this.files.slice(), true),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var file = _step9.value;\n\n          if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {\n            this.removeFile(file);\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      return null;\n    } // Resizes an image before it gets sent to the server. This function is the default behavior of\n    // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with\n    // the resized blob.\n\n  }, {\n    key: \"resizeImage\",\n    value: function resizeImage(file, width, height, resizeMethod, callback) {\n      var _this10 = this;\n\n      return this.createThumbnail(file, width, height, resizeMethod, true, function (dataUrl, canvas) {\n        if (canvas == null) {\n          // The image has not been resized\n          return callback(file);\n        } else {\n          var resizeMimeType = _this10.options.resizeMimeType;\n\n          if (resizeMimeType == null) {\n            resizeMimeType = file.type;\n          }\n\n          var resizedDataURL = canvas.toDataURL(resizeMimeType, _this10.options.resizeQuality);\n\n          if (resizeMimeType === \"image/jpeg\" || resizeMimeType === \"image/jpg\") {\n            // Now add the original EXIF information\n            resizedDataURL = ExifRestore.restore(file.dataURL, resizedDataURL);\n          }\n\n          return callback(Dropzone.dataURItoBlob(resizedDataURL));\n        }\n      });\n    }\n  }, {\n    key: \"createThumbnail\",\n    value: function createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {\n      var _this11 = this;\n\n      var fileReader = new FileReader();\n\n      fileReader.onload = function () {\n        file.dataURL = fileReader.result; // Don't bother creating a thumbnail for SVG images since they're vector\n\n        if (file.type === \"image/svg+xml\") {\n          if (callback != null) {\n            callback(fileReader.result);\n          }\n\n          return;\n        }\n\n        _this11.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);\n      };\n\n      fileReader.readAsDataURL(file);\n    } // `mockFile` needs to have these attributes:\n    //\n    //     { name: 'name', size: 12345, imageUrl: '' }\n    //\n    // `callback` will be invoked when the image has been downloaded and displayed.\n    // `crossOrigin` will be added to the `img` tag when accessing the file.\n\n  }, {\n    key: \"displayExistingFile\",\n    value: function displayExistingFile(mockFile, imageUrl, callback, crossOrigin) {\n      var _this12 = this;\n\n      var resizeThumbnail = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      this.emit(\"addedfile\", mockFile);\n      this.emit(\"complete\", mockFile);\n\n      if (!resizeThumbnail) {\n        this.emit(\"thumbnail\", mockFile, imageUrl);\n        if (callback) callback();\n      } else {\n        var onDone = function onDone(thumbnail) {\n          _this12.emit(\"thumbnail\", mockFile, thumbnail);\n\n          if (callback) callback();\n        };\n\n        mockFile.dataURL = imageUrl;\n        this.createThumbnailFromUrl(mockFile, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.resizeMethod, this.options.fixOrientation, onDone, crossOrigin);\n      }\n    }\n  }, {\n    key: \"createThumbnailFromUrl\",\n    value: function createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {\n      var _this13 = this;\n\n      // Not using `new Image` here because of a bug in latest Chrome versions.\n      // See https://github.com/enyo/dropzone/pull/226\n      var img = document.createElement(\"img\");\n\n      if (crossOrigin) {\n        img.crossOrigin = crossOrigin;\n      } // fixOrientation is not needed anymore with browsers handling imageOrientation\n\n\n      fixOrientation = getComputedStyle(document.body)[\"imageOrientation\"] == \"from-image\" ? false : fixOrientation;\n\n      img.onload = function () {\n        var loadExif = function loadExif(callback) {\n          return callback(1);\n        };\n\n        if (typeof EXIF !== \"undefined\" && EXIF !== null && fixOrientation) {\n          loadExif = function loadExif(callback) {\n            return EXIF.getData(img, function () {\n              return callback(EXIF.getTag(this, \"Orientation\"));\n            });\n          };\n        }\n\n        return loadExif(function (orientation) {\n          file.width = img.width;\n          file.height = img.height;\n\n          var resizeInfo = _this13.options.resize.call(_this13, file, width, height, resizeMethod);\n\n          var canvas = document.createElement(\"canvas\");\n          var ctx = canvas.getContext(\"2d\");\n          canvas.width = resizeInfo.trgWidth;\n          canvas.height = resizeInfo.trgHeight;\n\n          if (orientation > 4) {\n            canvas.width = resizeInfo.trgHeight;\n            canvas.height = resizeInfo.trgWidth;\n          }\n\n          switch (orientation) {\n            case 2:\n              // horizontal flip\n              ctx.translate(canvas.width, 0);\n              ctx.scale(-1, 1);\n              break;\n\n            case 3:\n              // 180° rotate left\n              ctx.translate(canvas.width, canvas.height);\n              ctx.rotate(Math.PI);\n              break;\n\n            case 4:\n              // vertical flip\n              ctx.translate(0, canvas.height);\n              ctx.scale(1, -1);\n              break;\n\n            case 5:\n              // vertical flip + 90 rotate right\n              ctx.rotate(0.5 * Math.PI);\n              ctx.scale(1, -1);\n              break;\n\n            case 6:\n              // 90° rotate right\n              ctx.rotate(0.5 * Math.PI);\n              ctx.translate(0, -canvas.width);\n              break;\n\n            case 7:\n              // horizontal flip + 90 rotate right\n              ctx.rotate(0.5 * Math.PI);\n              ctx.translate(canvas.height, -canvas.width);\n              ctx.scale(-1, 1);\n              break;\n\n            case 8:\n              // 90° rotate left\n              ctx.rotate(-0.5 * Math.PI);\n              ctx.translate(-canvas.height, 0);\n              break;\n          } // This is a bugfix for iOS' scaling bug.\n\n\n          drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);\n          var thumbnail = canvas.toDataURL(\"image/png\");\n\n          if (callback != null) {\n            return callback(thumbnail, canvas);\n          }\n        });\n      };\n\n      if (callback != null) {\n        img.onerror = callback;\n      }\n\n      return img.src = file.dataURL;\n    } // Goes through the queue and processes files if there aren't too many already.\n\n  }, {\n    key: \"processQueue\",\n    value: function processQueue() {\n      var parallelUploads = this.options.parallelUploads;\n      var processingLength = this.getUploadingFiles().length;\n      var i = processingLength; // There are already at least as many files uploading than should be\n\n      if (processingLength >= parallelUploads) {\n        return;\n      }\n\n      var queuedFiles = this.getQueuedFiles();\n\n      if (!(queuedFiles.length > 0)) {\n        return;\n      }\n\n      if (this.options.uploadMultiple) {\n        // The files should be uploaded in one request\n        return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));\n      } else {\n        while (i < parallelUploads) {\n          if (!queuedFiles.length) {\n            return;\n          } // Nothing left to process\n\n\n          this.processFile(queuedFiles.shift());\n          i++;\n        }\n      }\n    } // Wrapper for `processFiles`\n\n  }, {\n    key: \"processFile\",\n    value: function processFile(file) {\n      return this.processFiles([file]);\n    } // Loads the file, then calls finishedLoading()\n\n  }, {\n    key: \"processFiles\",\n    value: function processFiles(files) {\n      var _iterator10 = dropzone_createForOfIteratorHelper(files, true),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var file = _step10.value;\n          file.processing = true; // Backwards compatibility\n\n          file.status = Dropzone.UPLOADING;\n          this.emit(\"processing\", file);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      if (this.options.uploadMultiple) {\n        this.emit(\"processingmultiple\", files);\n      }\n\n      return this.uploadFiles(files);\n    }\n  }, {\n    key: \"_getFilesWithXhr\",\n    value: function _getFilesWithXhr(xhr) {\n      var files;\n      return files = this.files.filter(function (file) {\n        return file.xhr === xhr;\n      }).map(function (file) {\n        return file;\n      });\n    } // Cancels the file upload and sets the status to CANCELED\n    // **if** the file is actually being uploaded.\n    // If it's still in the queue, the file is being removed from it and the status\n    // set to CANCELED.\n\n  }, {\n    key: \"cancelUpload\",\n    value: function cancelUpload(file) {\n      if (file.status === Dropzone.UPLOADING) {\n        var groupedFiles = this._getFilesWithXhr(file.xhr);\n\n        var _iterator11 = dropzone_createForOfIteratorHelper(groupedFiles, true),\n            _step11;\n\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var groupedFile = _step11.value;\n            groupedFile.status = Dropzone.CANCELED;\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n\n        if (typeof file.xhr !== \"undefined\") {\n          file.xhr.abort();\n        }\n\n        var _iterator12 = dropzone_createForOfIteratorHelper(groupedFiles, true),\n            _step12;\n\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var _groupedFile = _step12.value;\n            this.emit(\"canceled\", _groupedFile);\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n\n        if (this.options.uploadMultiple) {\n          this.emit(\"canceledmultiple\", groupedFiles);\n        }\n      } else if (file.status === Dropzone.ADDED || file.status === Dropzone.QUEUED) {\n        file.status = Dropzone.CANCELED;\n        this.emit(\"canceled\", file);\n\n        if (this.options.uploadMultiple) {\n          this.emit(\"canceledmultiple\", [file]);\n        }\n      }\n\n      if (this.options.autoProcessQueue) {\n        return this.processQueue();\n      }\n    }\n  }, {\n    key: \"resolveOption\",\n    value: function resolveOption(option) {\n      if (typeof option === \"function\") {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        return option.apply(this, args);\n      }\n\n      return option;\n    }\n  }, {\n    key: \"uploadFile\",\n    value: function uploadFile(file) {\n      return this.uploadFiles([file]);\n    }\n  }, {\n    key: \"uploadFiles\",\n    value: function uploadFiles(files) {\n      var _this14 = this;\n\n      this._transformFiles(files, function (transformedFiles) {\n        if (_this14.options.chunking) {\n          // Chunking is not allowed to be used with `uploadMultiple` so we know\n          // that there is only __one__file.\n          var transformedFile = transformedFiles[0];\n          files[0].upload.chunked = _this14.options.chunking && (_this14.options.forceChunking || transformedFile.size > _this14.options.chunkSize);\n          files[0].upload.totalChunkCount = Math.ceil(transformedFile.size / _this14.options.chunkSize);\n        }\n\n        if (files[0].upload.chunked) {\n          // This file should be sent in chunks!\n          // If the chunking option is set, we **know** that there can only be **one** file, since\n          // uploadMultiple is not allowed with this option.\n          var file = files[0];\n          var _transformedFile = transformedFiles[0];\n          var startedChunkCount = 0;\n          file.upload.chunks = [];\n\n          var handleNextChunk = function handleNextChunk() {\n            var chunkIndex = 0; // Find the next item in file.upload.chunks that is not defined yet.\n\n            while (file.upload.chunks[chunkIndex] !== undefined) {\n              chunkIndex++;\n            } // This means, that all chunks have already been started.\n\n\n            if (chunkIndex >= file.upload.totalChunkCount) return;\n            startedChunkCount++;\n            var start = chunkIndex * _this14.options.chunkSize;\n            var end = Math.min(start + _this14.options.chunkSize, _transformedFile.size);\n            var dataBlock = {\n              name: _this14._getParamName(0),\n              data: _transformedFile.webkitSlice ? _transformedFile.webkitSlice(start, end) : _transformedFile.slice(start, end),\n              filename: file.upload.filename,\n              chunkIndex: chunkIndex\n            };\n            file.upload.chunks[chunkIndex] = {\n              file: file,\n              index: chunkIndex,\n              dataBlock: dataBlock,\n              // In case we want to retry.\n              status: Dropzone.UPLOADING,\n              progress: 0,\n              retries: 0 // The number of times this block has been retried.\n\n            };\n\n            _this14._uploadData(files, [dataBlock]);\n          };\n\n          file.upload.finishedChunkUpload = function (chunk, response) {\n            var allFinished = true;\n            chunk.status = Dropzone.SUCCESS; // Clear the data from the chunk\n\n            chunk.dataBlock = null; // Leaving this reference to xhr intact here will cause memory leaks in some browsers\n\n            chunk.xhr = null;\n\n            for (var i = 0; i < file.upload.totalChunkCount; i++) {\n              if (file.upload.chunks[i] === undefined) {\n                return handleNextChunk();\n              }\n\n              if (file.upload.chunks[i].status !== Dropzone.SUCCESS) {\n                allFinished = false;\n              }\n            }\n\n            if (allFinished) {\n              _this14.options.chunksUploaded(file, function () {\n                _this14._finished(files, response, null);\n              });\n            }\n          };\n\n          if (_this14.options.parallelChunkUploads) {\n            for (var i = 0; i < file.upload.totalChunkCount; i++) {\n              handleNextChunk();\n            }\n          } else {\n            handleNextChunk();\n          }\n        } else {\n          var dataBlocks = [];\n\n          for (var _i2 = 0; _i2 < files.length; _i2++) {\n            dataBlocks[_i2] = {\n              name: _this14._getParamName(_i2),\n              data: transformedFiles[_i2],\n              filename: files[_i2].upload.filename\n            };\n          }\n\n          _this14._uploadData(files, dataBlocks);\n        }\n      });\n    } /// Returns the right chunk for given file and xhr\n\n  }, {\n    key: \"_getChunk\",\n    value: function _getChunk(file, xhr) {\n      for (var i = 0; i < file.upload.totalChunkCount; i++) {\n        if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].xhr === xhr) {\n          return file.upload.chunks[i];\n        }\n      }\n    } // This function actually uploads the file(s) to the server.\n    // If dataBlocks contains the actual data to upload (meaning, that this could either be transformed\n    // files, or individual chunks for chunked upload).\n\n  }, {\n    key: \"_uploadData\",\n    value: function _uploadData(files, dataBlocks) {\n      var _this15 = this;\n\n      var xhr = new XMLHttpRequest(); // Put the xhr object in the file objects to be able to reference it later.\n\n      var _iterator13 = dropzone_createForOfIteratorHelper(files, true),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var file = _step13.value;\n          file.xhr = xhr;\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      if (files[0].upload.chunked) {\n        // Put the xhr object in the right chunk object, so it can be associated later, and found with _getChunk\n        files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;\n      }\n\n      var method = this.resolveOption(this.options.method, files);\n      var url = this.resolveOption(this.options.url, files);\n      xhr.open(method, url, true); // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8\n\n      var timeout = this.resolveOption(this.options.timeout, files);\n      if (timeout) xhr.timeout = this.resolveOption(this.options.timeout, files); // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179\n\n      xhr.withCredentials = !!this.options.withCredentials;\n\n      xhr.onload = function (e) {\n        _this15._finishedUploading(files, xhr, e);\n      };\n\n      xhr.ontimeout = function () {\n        _this15._handleUploadError(files, xhr, \"Request timedout after \".concat(_this15.options.timeout / 1000, \" seconds\"));\n      };\n\n      xhr.onerror = function () {\n        _this15._handleUploadError(files, xhr);\n      }; // Some browsers do not have the .upload property\n\n\n      var progressObj = xhr.upload != null ? xhr.upload : xhr;\n\n      progressObj.onprogress = function (e) {\n        return _this15._updateFilesUploadProgress(files, xhr, e);\n      };\n\n      var headers = {\n        Accept: \"application/json\",\n        \"Cache-Control\": \"no-cache\",\n        \"X-Requested-With\": \"XMLHttpRequest\"\n      };\n\n      if (this.options.headers) {\n        Dropzone.extend(headers, this.options.headers);\n      }\n\n      for (var headerName in headers) {\n        var headerValue = headers[headerName];\n\n        if (headerValue) {\n          xhr.setRequestHeader(headerName, headerValue);\n        }\n      }\n\n      var formData = new FormData(); // Adding all @options parameters\n\n      if (this.options.params) {\n        var additionalParams = this.options.params;\n\n        if (typeof additionalParams === \"function\") {\n          additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);\n        }\n\n        for (var key in additionalParams) {\n          var value = additionalParams[key];\n\n          if (Array.isArray(value)) {\n            // The additional parameter contains an array,\n            // so lets iterate over it to attach each value\n            // individually.\n            for (var i = 0; i < value.length; i++) {\n              formData.append(key, value[i]);\n            }\n          } else {\n            formData.append(key, value);\n          }\n        }\n      } // Let the user add additional data if necessary\n\n\n      var _iterator14 = dropzone_createForOfIteratorHelper(files, true),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _file = _step14.value;\n          this.emit(\"sending\", _file, xhr, formData);\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      if (this.options.uploadMultiple) {\n        this.emit(\"sendingmultiple\", files, xhr, formData);\n      }\n\n      this._addFormElementData(formData); // Finally add the files\n      // Has to be last because some servers (eg: S3) expect the file to be the last parameter\n\n\n      for (var _i3 = 0; _i3 < dataBlocks.length; _i3++) {\n        var dataBlock = dataBlocks[_i3];\n        formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);\n      }\n\n      this.submitRequest(xhr, formData, files);\n    } // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.\n\n  }, {\n    key: \"_transformFiles\",\n    value: function _transformFiles(files, done) {\n      var _this16 = this;\n\n      var transformedFiles = []; // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.\n\n      var doneCounter = 0;\n\n      var _loop = function _loop(i) {\n        _this16.options.transformFile.call(_this16, files[i], function (transformedFile) {\n          transformedFiles[i] = transformedFile;\n\n          if (++doneCounter === files.length) {\n            done(transformedFiles);\n          }\n        });\n      };\n\n      for (var i = 0; i < files.length; i++) {\n        _loop(i);\n      }\n    } // Takes care of adding other input elements of the form to the AJAX request\n\n  }, {\n    key: \"_addFormElementData\",\n    value: function _addFormElementData(formData) {\n      // Take care of other input elements\n      if (this.element.tagName === \"FORM\") {\n        var _iterator15 = dropzone_createForOfIteratorHelper(this.element.querySelectorAll(\"input, textarea, select, button\"), true),\n            _step15;\n\n        try {\n          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n            var input = _step15.value;\n            var inputName = input.getAttribute(\"name\");\n            var inputType = input.getAttribute(\"type\");\n            if (inputType) inputType = inputType.toLowerCase(); // If the input doesn't have a name, we can't use it.\n\n            if (typeof inputName === \"undefined\" || inputName === null) continue;\n\n            if (input.tagName === \"SELECT\" && input.hasAttribute(\"multiple\")) {\n              // Possibly multiple values\n              var _iterator16 = dropzone_createForOfIteratorHelper(input.options, true),\n                  _step16;\n\n              try {\n                for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                  var option = _step16.value;\n\n                  if (option.selected) {\n                    formData.append(inputName, option.value);\n                  }\n                }\n              } catch (err) {\n                _iterator16.e(err);\n              } finally {\n                _iterator16.f();\n              }\n            } else if (!inputType || inputType !== \"checkbox\" && inputType !== \"radio\" || input.checked) {\n              formData.append(inputName, input.value);\n            }\n          }\n        } catch (err) {\n          _iterator15.e(err);\n        } finally {\n          _iterator15.f();\n        }\n      }\n    } // Invoked when there is new progress information about given files.\n    // If e is not provided, it is assumed that the upload is finished.\n\n  }, {\n    key: \"_updateFilesUploadProgress\",\n    value: function _updateFilesUploadProgress(files, xhr, e) {\n      if (!files[0].upload.chunked) {\n        // Handle file uploads without chunking\n        var _iterator17 = dropzone_createForOfIteratorHelper(files, true),\n            _step17;\n\n        try {\n          for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n            var file = _step17.value;\n\n            if (file.upload.total && file.upload.bytesSent && file.upload.bytesSent == file.upload.total) {\n              // If both, the `total` and `bytesSent` have already been set, and\n              // they are equal (meaning progress is at 100%), we can skip this\n              // file, since an upload progress shouldn't go down.\n              continue;\n            }\n\n            if (e) {\n              file.upload.progress = 100 * e.loaded / e.total;\n              file.upload.total = e.total;\n              file.upload.bytesSent = e.loaded;\n            } else {\n              // No event, so we're at 100%\n              file.upload.progress = 100;\n              file.upload.bytesSent = file.upload.total;\n            }\n\n            this.emit(\"uploadprogress\", file, file.upload.progress, file.upload.bytesSent);\n          }\n        } catch (err) {\n          _iterator17.e(err);\n        } finally {\n          _iterator17.f();\n        }\n      } else {\n        // Handle chunked file uploads\n        // Chunked upload is not compatible with uploading multiple files in one\n        // request, so we know there's only one file.\n        var _file2 = files[0]; // Since this is a chunked upload, we need to update the appropriate chunk\n        // progress.\n\n        var chunk = this._getChunk(_file2, xhr);\n\n        if (e) {\n          chunk.progress = 100 * e.loaded / e.total;\n          chunk.total = e.total;\n          chunk.bytesSent = e.loaded;\n        } else {\n          // No event, so we're at 100%\n          chunk.progress = 100;\n          chunk.bytesSent = chunk.total;\n        } // Now tally the *file* upload progress from its individual chunks\n\n\n        _file2.upload.progress = 0;\n        _file2.upload.total = 0;\n        _file2.upload.bytesSent = 0;\n\n        for (var i = 0; i < _file2.upload.totalChunkCount; i++) {\n          if (_file2.upload.chunks[i] && typeof _file2.upload.chunks[i].progress !== \"undefined\") {\n            _file2.upload.progress += _file2.upload.chunks[i].progress;\n            _file2.upload.total += _file2.upload.chunks[i].total;\n            _file2.upload.bytesSent += _file2.upload.chunks[i].bytesSent;\n          }\n        } // Since the process is a percentage, we need to divide by the amount of\n        // chunks we've used.\n\n\n        _file2.upload.progress = _file2.upload.progress / _file2.upload.totalChunkCount;\n        this.emit(\"uploadprogress\", _file2, _file2.upload.progress, _file2.upload.bytesSent);\n      }\n    }\n  }, {\n    key: \"_finishedUploading\",\n    value: function _finishedUploading(files, xhr, e) {\n      var response;\n\n      if (files[0].status === Dropzone.CANCELED) {\n        return;\n      }\n\n      if (xhr.readyState !== 4) {\n        return;\n      }\n\n      if (xhr.responseType !== \"arraybuffer\" && xhr.responseType !== \"blob\") {\n        response = xhr.responseText;\n\n        if (xhr.getResponseHeader(\"content-type\") && ~xhr.getResponseHeader(\"content-type\").indexOf(\"application/json\")) {\n          try {\n            response = JSON.parse(response);\n          } catch (error) {\n            e = error;\n            response = \"Invalid JSON response from server.\";\n          }\n        }\n      }\n\n      this._updateFilesUploadProgress(files, xhr);\n\n      if (!(200 <= xhr.status && xhr.status < 300)) {\n        this._handleUploadError(files, xhr, response);\n      } else {\n        if (files[0].upload.chunked) {\n          files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr), response);\n        } else {\n          this._finished(files, response, e);\n        }\n      }\n    }\n  }, {\n    key: \"_handleUploadError\",\n    value: function _handleUploadError(files, xhr, response) {\n      if (files[0].status === Dropzone.CANCELED) {\n        return;\n      }\n\n      if (files[0].upload.chunked && this.options.retryChunks) {\n        var chunk = this._getChunk(files[0], xhr);\n\n        if (chunk.retries++ < this.options.retryChunksLimit) {\n          this._uploadData(files, [chunk.dataBlock]);\n\n          return;\n        } else {\n          console.warn(\"Retried this chunk too often. Giving up.\");\n        }\n      }\n\n      this._errorProcessing(files, response || this.options.dictResponseError.replace(\"{{statusCode}}\", xhr.status), xhr);\n    }\n  }, {\n    key: \"submitRequest\",\n    value: function submitRequest(xhr, formData, files) {\n      if (xhr.readyState != 1) {\n        console.warn(\"Cannot send this request because the XMLHttpRequest.readyState is not OPENED.\");\n        return;\n      }\n\n      xhr.send(formData);\n    } // Called internally when processing is finished.\n    // Individual callbacks have to be called in the appropriate sections.\n\n  }, {\n    key: \"_finished\",\n    value: function _finished(files, responseText, e) {\n      var _iterator18 = dropzone_createForOfIteratorHelper(files, true),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var file = _step18.value;\n          file.status = Dropzone.SUCCESS;\n          this.emit(\"success\", file, responseText, e);\n          this.emit(\"complete\", file);\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n\n      if (this.options.uploadMultiple) {\n        this.emit(\"successmultiple\", files, responseText, e);\n        this.emit(\"completemultiple\", files);\n      }\n\n      if (this.options.autoProcessQueue) {\n        return this.processQueue();\n      }\n    } // Called internally when processing is finished.\n    // Individual callbacks have to be called in the appropriate sections.\n\n  }, {\n    key: \"_errorProcessing\",\n    value: function _errorProcessing(files, message, xhr) {\n      var _iterator19 = dropzone_createForOfIteratorHelper(files, true),\n          _step19;\n\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var file = _step19.value;\n          file.status = Dropzone.ERROR;\n          this.emit(\"error\", file, message, xhr);\n          this.emit(\"complete\", file);\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n\n      if (this.options.uploadMultiple) {\n        this.emit(\"errormultiple\", files, message, xhr);\n        this.emit(\"completemultiple\", files);\n      }\n\n      if (this.options.autoProcessQueue) {\n        return this.processQueue();\n      }\n    }\n  }], [{\n    key: \"initClass\",\n    value: function initClass() {\n      // Exposing the emitter class, mainly for tests\n      this.prototype.Emitter = Emitter;\n      /*\n       This is a list of all available events you can register on a dropzone object.\n        You can register an event handler like this:\n        dropzone.on(\"dragEnter\", function() { });\n        */\n\n      this.prototype.events = [\"drop\", \"dragstart\", \"dragend\", \"dragenter\", \"dragover\", \"dragleave\", \"addedfile\", \"addedfiles\", \"removedfile\", \"thumbnail\", \"error\", \"errormultiple\", \"processing\", \"processingmultiple\", \"uploadprogress\", \"totaluploadprogress\", \"sending\", \"sendingmultiple\", \"success\", \"successmultiple\", \"canceled\", \"canceledmultiple\", \"complete\", \"completemultiple\", \"reset\", \"maxfilesexceeded\", \"maxfilesreached\", \"queuecomplete\"];\n      this.prototype._thumbnailQueue = [];\n      this.prototype._processingThumbnail = false;\n    } // global utility\n\n  }, {\n    key: \"extend\",\n    value: function extend(target) {\n      for (var _len2 = arguments.length, objects = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        objects[_key2 - 1] = arguments[_key2];\n      }\n\n      for (var _i4 = 0, _objects = objects; _i4 < _objects.length; _i4++) {\n        var object = _objects[_i4];\n\n        for (var key in object) {\n          var val = object[key];\n          target[key] = val;\n        }\n      }\n\n      return target;\n    }\n  }, {\n    key: \"uuidv4\",\n    value: function uuidv4() {\n      return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0,\n            v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n      });\n    }\n  }]);\n\n  return Dropzone;\n}(Emitter);\n\n\nDropzone.initClass();\nDropzone.version = \"5.9.2\"; // This is a map of options for your different dropzones. Add configurations\n// to this object for your different dropzone elemens.\n//\n// Example:\n//\n//     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };\n//\n// To disable autoDiscover for a specific element, you can set `false` as an option:\n//\n//     Dropzone.options.myDisabledElementId = false;\n//\n// And in html:\n//\n//     <form action=\"/upload\" id=\"my-dropzone-element-id\" class=\"dropzone\"></form>\n\nDropzone.options = {}; // Returns the options for an element or undefined if none available.\n\nDropzone.optionsForElement = function (element) {\n  // Get the `Dropzone.options.elementId` for this element if it exists\n  if (element.getAttribute(\"id\")) {\n    return Dropzone.options[camelize(element.getAttribute(\"id\"))];\n  } else {\n    return undefined;\n  }\n}; // Holds a list of all dropzone instances\n\n\nDropzone.instances = []; // Returns the dropzone for given element if any\n\nDropzone.forElement = function (element) {\n  if (typeof element === \"string\") {\n    element = document.querySelector(element);\n  }\n\n  if ((element != null ? element.dropzone : undefined) == null) {\n    throw new Error(\"No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.\");\n  }\n\n  return element.dropzone;\n}; // Set to false if you don't want Dropzone to automatically find and attach to .dropzone elements.\n\n\nDropzone.autoDiscover = true; // Looks for all .dropzone elements and creates a dropzone for them\n\nDropzone.discover = function () {\n  var dropzones;\n\n  if (document.querySelectorAll) {\n    dropzones = document.querySelectorAll(\".dropzone\");\n  } else {\n    dropzones = []; // IE :(\n\n    var checkElements = function checkElements(elements) {\n      return function () {\n        var result = [];\n\n        var _iterator20 = dropzone_createForOfIteratorHelper(elements, true),\n            _step20;\n\n        try {\n          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n            var el = _step20.value;\n\n            if (/(^| )dropzone($| )/.test(el.className)) {\n              result.push(dropzones.push(el));\n            } else {\n              result.push(undefined);\n            }\n          }\n        } catch (err) {\n          _iterator20.e(err);\n        } finally {\n          _iterator20.f();\n        }\n\n        return result;\n      }();\n    };\n\n    checkElements(document.getElementsByTagName(\"div\"));\n    checkElements(document.getElementsByTagName(\"form\"));\n  }\n\n  return function () {\n    var result = [];\n\n    var _iterator21 = dropzone_createForOfIteratorHelper(dropzones, true),\n        _step21;\n\n    try {\n      for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n        var dropzone = _step21.value;\n\n        // Create a dropzone unless auto discover has been disabled for specific element\n        if (Dropzone.optionsForElement(dropzone) !== false) {\n          result.push(new Dropzone(dropzone));\n        } else {\n          result.push(undefined);\n        }\n      }\n    } catch (err) {\n      _iterator21.e(err);\n    } finally {\n      _iterator21.f();\n    }\n\n    return result;\n  }();\n}; // Some browsers support drag and drog functionality, but not correctly.\n//\n// So I created a blocklist of userAgents. Yes, yes. Browser sniffing, I know.\n// But what to do when browsers *theoretically* support an API, but crash\n// when using it.\n//\n// This is a list of regular expressions tested against navigator.userAgent\n//\n// ** It should only be used on browser that *do* support the API, but\n// incorrectly **\n\n\nDropzone.blockedBrowsers = [// The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.\n/opera.*(Macintosh|Windows Phone).*version\\/12/i]; // Checks if the browser is supported\n\nDropzone.isBrowserSupported = function () {\n  var capableBrowser = true;\n\n  if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {\n    if (!(\"classList\" in document.createElement(\"a\"))) {\n      capableBrowser = false;\n    } else {\n      if (Dropzone.blacklistedBrowsers !== undefined) {\n        // Since this has been renamed, this makes sure we don't break older\n        // configuration.\n        Dropzone.blockedBrowsers = Dropzone.blacklistedBrowsers;\n      } // The browser supports the API, but may be blocked.\n\n\n      var _iterator22 = dropzone_createForOfIteratorHelper(Dropzone.blockedBrowsers, true),\n          _step22;\n\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var regex = _step22.value;\n\n          if (regex.test(navigator.userAgent)) {\n            capableBrowser = false;\n            continue;\n          }\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n    }\n  } else {\n    capableBrowser = false;\n  }\n\n  return capableBrowser;\n};\n\nDropzone.dataURItoBlob = function (dataURI) {\n  // convert base64 to raw binary data held in a string\n  // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this\n  var byteString = atob(dataURI.split(\",\")[1]); // separate out the mime component\n\n  var mimeString = dataURI.split(\",\")[0].split(\":\")[1].split(\";\")[0]; // write the bytes of the string to an ArrayBuffer\n\n  var ab = new ArrayBuffer(byteString.length);\n  var ia = new Uint8Array(ab);\n\n  for (var i = 0, end = byteString.length, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {\n    ia[i] = byteString.charCodeAt(i);\n  } // write the ArrayBuffer to a blob\n\n\n  return new Blob([ab], {\n    type: mimeString\n  });\n}; // Returns an array without the rejected item\n\n\nvar without = function without(list, rejectedItem) {\n  return list.filter(function (item) {\n    return item !== rejectedItem;\n  }).map(function (item) {\n    return item;\n  });\n}; // abc-def_ghi -> abcDefGhi\n\n\nvar camelize = function camelize(str) {\n  return str.replace(/[\\-_](\\w)/g, function (match) {\n    return match.charAt(1).toUpperCase();\n  });\n}; // Creates an element from string\n\n\nDropzone.createElement = function (string) {\n  var div = document.createElement(\"div\");\n  div.innerHTML = string;\n  return div.childNodes[0];\n}; // Tests if given element is inside (or simply is) the container\n\n\nDropzone.elementInside = function (element, container) {\n  if (element === container) {\n    return true;\n  } // Coffeescript doesn't support do/while loops\n\n\n  while (element = element.parentNode) {\n    if (element === container) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nDropzone.getElement = function (el, name) {\n  var element;\n\n  if (typeof el === \"string\") {\n    element = document.querySelector(el);\n  } else if (el.nodeType != null) {\n    element = el;\n  }\n\n  if (element == null) {\n    throw new Error(\"Invalid `\".concat(name, \"` option provided. Please provide a CSS selector or a plain HTML element.\"));\n  }\n\n  return element;\n};\n\nDropzone.getElements = function (els, name) {\n  var el, elements;\n\n  if (els instanceof Array) {\n    elements = [];\n\n    try {\n      var _iterator23 = dropzone_createForOfIteratorHelper(els, true),\n          _step23;\n\n      try {\n        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n          el = _step23.value;\n          elements.push(this.getElement(el, name));\n        }\n      } catch (err) {\n        _iterator23.e(err);\n      } finally {\n        _iterator23.f();\n      }\n    } catch (e) {\n      elements = null;\n    }\n  } else if (typeof els === \"string\") {\n    elements = [];\n\n    var _iterator24 = dropzone_createForOfIteratorHelper(document.querySelectorAll(els), true),\n        _step24;\n\n    try {\n      for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n        el = _step24.value;\n        elements.push(el);\n      }\n    } catch (err) {\n      _iterator24.e(err);\n    } finally {\n      _iterator24.f();\n    }\n  } else if (els.nodeType != null) {\n    elements = [els];\n  }\n\n  if (elements == null || !elements.length) {\n    throw new Error(\"Invalid `\".concat(name, \"` option provided. Please provide a CSS selector, a plain HTML element or a list of those.\"));\n  }\n\n  return elements;\n}; // Asks the user the question and calls accepted or rejected accordingly\n//\n// The default implementation just uses `window.confirm` and then calls the\n// appropriate callback.\n\n\nDropzone.confirm = function (question, accepted, rejected) {\n  if (window.confirm(question)) {\n    return accepted();\n  } else if (rejected != null) {\n    return rejected();\n  }\n}; // Validates the mime type like this:\n//\n// https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept\n\n\nDropzone.isValidFile = function (file, acceptedFiles) {\n  if (!acceptedFiles) {\n    return true;\n  } // If there are no accepted mime types, it's OK\n\n\n  acceptedFiles = acceptedFiles.split(\",\");\n  var mimeType = file.type;\n  var baseMimeType = mimeType.replace(/\\/.*$/, \"\");\n\n  var _iterator25 = dropzone_createForOfIteratorHelper(acceptedFiles, true),\n      _step25;\n\n  try {\n    for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n      var validType = _step25.value;\n      validType = validType.trim();\n\n      if (validType.charAt(0) === \".\") {\n        if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) {\n          return true;\n        }\n      } else if (/\\/\\*$/.test(validType)) {\n        // This is something like a image/* mime type\n        if (baseMimeType === validType.replace(/\\/.*$/, \"\")) {\n          return true;\n        }\n      } else {\n        if (mimeType === validType) {\n          return true;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator25.e(err);\n  } finally {\n    _iterator25.f();\n  }\n\n  return false;\n}; // Augment jQuery\n\n\nif (typeof jQuery !== \"undefined\" && jQuery !== null) {\n  jQuery.fn.dropzone = function (options) {\n    return this.each(function () {\n      return new Dropzone(this, options);\n    });\n  };\n} // Dropzone file status codes\n\n\nDropzone.ADDED = \"added\";\nDropzone.QUEUED = \"queued\"; // For backwards compatibility. Now, if a file is accepted, it's either queued\n// or uploading.\n\nDropzone.ACCEPTED = Dropzone.QUEUED;\nDropzone.UPLOADING = \"uploading\";\nDropzone.PROCESSING = Dropzone.UPLOADING; // alias\n\nDropzone.CANCELED = \"canceled\";\nDropzone.ERROR = \"error\";\nDropzone.SUCCESS = \"success\";\n/*\n\n Bugfix for iOS 6 and 7\n Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios\n based on the work of https://github.com/stomita/ios-imagefile-megapixel\n\n */\n// Detecting vertical squash in loaded image.\n// Fixes a bug which squash image vertically while drawing into canvas for some images.\n// This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel\n\nvar detectVerticalSquash = function detectVerticalSquash(img) {\n  var iw = img.naturalWidth;\n  var ih = img.naturalHeight;\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = 1;\n  canvas.height = ih;\n  var ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(img, 0, 0);\n\n  var _ctx$getImageData = ctx.getImageData(1, 0, 1, ih),\n      data = _ctx$getImageData.data; // search image edge pixel position in case it is squashed vertically.\n\n\n  var sy = 0;\n  var ey = ih;\n  var py = ih;\n\n  while (py > sy) {\n    var alpha = data[(py - 1) * 4 + 3];\n\n    if (alpha === 0) {\n      ey = py;\n    } else {\n      sy = py;\n    }\n\n    py = ey + sy >> 1;\n  }\n\n  var ratio = py / ih;\n\n  if (ratio === 0) {\n    return 1;\n  } else {\n    return ratio;\n  }\n}; // A replacement for context.drawImage\n// (args are for source and destination).\n\n\nvar drawImageIOSFix = function drawImageIOSFix(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {\n  var vertSquashRatio = detectVerticalSquash(img);\n  return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);\n}; // Based on MinifyJpeg\n// Source: http://www.perry.cz/files/ExifRestorer.js\n// http://elicon.blog57.fc2.com/blog-entry-206.html\n\n\nvar ExifRestore = /*#__PURE__*/function () {\n  function ExifRestore() {\n    dropzone_classCallCheck(this, ExifRestore);\n  }\n\n  dropzone_createClass(ExifRestore, null, [{\n    key: \"initClass\",\n    value: function initClass() {\n      this.KEY_STR = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    }\n  }, {\n    key: \"encode64\",\n    value: function encode64(input) {\n      var output = \"\";\n      var chr1 = undefined;\n      var chr2 = undefined;\n      var chr3 = \"\";\n      var enc1 = undefined;\n      var enc2 = undefined;\n      var enc3 = undefined;\n      var enc4 = \"\";\n      var i = 0;\n\n      while (true) {\n        chr1 = input[i++];\n        chr2 = input[i++];\n        chr3 = input[i++];\n        enc1 = chr1 >> 2;\n        enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n        enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n        enc4 = chr3 & 63;\n\n        if (isNaN(chr2)) {\n          enc3 = enc4 = 64;\n        } else if (isNaN(chr3)) {\n          enc4 = 64;\n        }\n\n        output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);\n        chr1 = chr2 = chr3 = \"\";\n        enc1 = enc2 = enc3 = enc4 = \"\";\n\n        if (!(i < input.length)) {\n          break;\n        }\n      }\n\n      return output;\n    }\n  }, {\n    key: \"restore\",\n    value: function restore(origFileBase64, resizedFileBase64) {\n      if (!origFileBase64.match(\"data:image/jpeg;base64,\")) {\n        return resizedFileBase64;\n      }\n\n      var rawImage = this.decode64(origFileBase64.replace(\"data:image/jpeg;base64,\", \"\"));\n      var segments = this.slice2Segments(rawImage);\n      var image = this.exifManipulation(resizedFileBase64, segments);\n      return \"data:image/jpeg;base64,\".concat(this.encode64(image));\n    }\n  }, {\n    key: \"exifManipulation\",\n    value: function exifManipulation(resizedFileBase64, segments) {\n      var exifArray = this.getExifArray(segments);\n      var newImageArray = this.insertExif(resizedFileBase64, exifArray);\n      var aBuffer = new Uint8Array(newImageArray);\n      return aBuffer;\n    }\n  }, {\n    key: \"getExifArray\",\n    value: function getExifArray(segments) {\n      var seg = undefined;\n      var x = 0;\n\n      while (x < segments.length) {\n        seg = segments[x];\n\n        if (seg[0] === 255 & seg[1] === 225) {\n          return seg;\n        }\n\n        x++;\n      }\n\n      return [];\n    }\n  }, {\n    key: \"insertExif\",\n    value: function insertExif(resizedFileBase64, exifArray) {\n      var imageData = resizedFileBase64.replace(\"data:image/jpeg;base64,\", \"\");\n      var buf = this.decode64(imageData);\n      var separatePoint = buf.indexOf(255, 3);\n      var mae = buf.slice(0, separatePoint);\n      var ato = buf.slice(separatePoint);\n      var array = mae;\n      array = array.concat(exifArray);\n      array = array.concat(ato);\n      return array;\n    }\n  }, {\n    key: \"slice2Segments\",\n    value: function slice2Segments(rawImageArray) {\n      var head = 0;\n      var segments = [];\n\n      while (true) {\n        var length;\n\n        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {\n          break;\n        }\n\n        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {\n          head += 2;\n        } else {\n          length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];\n          var endPoint = head + length + 2;\n          var seg = rawImageArray.slice(head, endPoint);\n          segments.push(seg);\n          head = endPoint;\n        }\n\n        if (head > rawImageArray.length) {\n          break;\n        }\n      }\n\n      return segments;\n    }\n  }, {\n    key: \"decode64\",\n    value: function decode64(input) {\n      var output = \"\";\n      var chr1 = undefined;\n      var chr2 = undefined;\n      var chr3 = \"\";\n      var enc1 = undefined;\n      var enc2 = undefined;\n      var enc3 = undefined;\n      var enc4 = \"\";\n      var i = 0;\n      var buf = []; // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n\n      var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n\n      if (base64test.exec(input)) {\n        console.warn(\"There were invalid base64 characters in the input text.\\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\\nExpect errors in decoding.\");\n      }\n\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n      while (true) {\n        enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n        enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n        buf.push(chr1);\n\n        if (enc3 !== 64) {\n          buf.push(chr2);\n        }\n\n        if (enc4 !== 64) {\n          buf.push(chr3);\n        }\n\n        chr1 = chr2 = chr3 = \"\";\n        enc1 = enc2 = enc3 = enc4 = \"\";\n\n        if (!(i < input.length)) {\n          break;\n        }\n      }\n\n      return buf;\n    }\n  }]);\n\n  return ExifRestore;\n}();\n\nExifRestore.initClass();\n/*\n * contentloaded.js\n *\n * Author: Diego Perini (diego.perini at gmail.com)\n * Summary: cross-browser wrapper for DOMContentLoaded\n * Updated: 20101020\n * License: MIT\n * Version: 1.2\n *\n * URL:\n * http://javascript.nwbox.com/ContentLoaded/\n * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE\n */\n// @win window reference\n// @fn function reference\n\nvar contentLoaded = function contentLoaded(win, fn) {\n  var done = false;\n  var top = true;\n  var doc = win.document;\n  var root = doc.documentElement;\n  var add = doc.addEventListener ? \"addEventListener\" : \"attachEvent\";\n  var rem = doc.addEventListener ? \"removeEventListener\" : \"detachEvent\";\n  var pre = doc.addEventListener ? \"\" : \"on\";\n\n  var init = function init(e) {\n    if (e.type === \"readystatechange\" && doc.readyState !== \"complete\") {\n      return;\n    }\n\n    (e.type === \"load\" ? win : doc)[rem](pre + e.type, init, false);\n\n    if (!done && (done = true)) {\n      return fn.call(win, e.type || e);\n    }\n  };\n\n  var poll = function poll() {\n    try {\n      root.doScroll(\"left\");\n    } catch (e) {\n      setTimeout(poll, 50);\n      return;\n    }\n\n    return init(\"poll\");\n  };\n\n  if (doc.readyState !== \"complete\") {\n    if (doc.createEventObject && root.doScroll) {\n      try {\n        top = !win.frameElement;\n      } catch (error) {}\n\n      if (top) {\n        poll();\n      }\n    }\n\n    doc[add](pre + \"DOMContentLoaded\", init, false);\n    doc[add](pre + \"readystatechange\", init, false);\n    return win[add](pre + \"load\", init, false);\n  }\n}; // As a single function to be able to write tests.\n\n\nDropzone._autoDiscoverFunction = function () {\n  if (Dropzone.autoDiscover) {\n    return Dropzone.discover();\n  }\n};\n\ncontentLoaded(window, Dropzone._autoDiscoverFunction);\n\nfunction __guard__(value, transform) {\n  return typeof value !== \"undefined\" && value !== null ? transform(value) : undefined;\n}\n\nfunction __guardMethod__(obj, methodName, transform) {\n  if (typeof obj !== \"undefined\" && obj !== null && typeof obj[methodName] === \"function\") {\n    return transform(obj, methodName);\n  } else {\n    return undefined;\n  }\n}\n\n\n;// CONCATENATED MODULE: ./tool/dropzone.dist.js\n /// Make Dropzone a global variable.\n\nwindow.Dropzone = Dropzone;\n/* harmony default export */ var dropzone_dist = (Dropzone);\n\n}();\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n\n//# sourceURL=webpack:///./node_modules/dropzone/dist/dropzone.js?")},"./node_modules/feather-icons/dist/feather.js":function node_modulesFeatherIconsDistFeatherJs(module,exports,__webpack_require__){eval('(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(typeof self !== \'undefined\' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tObject.defineProperty(exports, \'__esModule\', { value: true });\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module[\'default\']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, \'a\', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ "./dist/icons.json":\n/*!*************************!*\\\n  !*** ./dist/icons.json ***!\n  \\*************************/\n/*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, aperture, archive, arrow-down-circle, arrow-down-left, arrow-down-right, arrow-down, arrow-left-circle, arrow-left, arrow-right-circle, arrow-right, arrow-up-circle, arrow-up-left, arrow-up-right, arrow-up, at-sign, award, bar-chart-2, bar-chart, battery-charging, battery, bell-off, bell, bluetooth, bold, book-open, book, bookmark, box, briefcase, calendar, camera-off, camera, cast, check-circle, check-square, check, chevron-down, chevron-left, chevron-right, chevron-up, chevrons-down, chevrons-left, chevrons-right, chevrons-up, chrome, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-off, cloud-rain, cloud-snow, cloud, code, codepen, codesandbox, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, divide-circle, divide-square, divide, dollar-sign, download-cloud, download, dribbble, droplet, edit-2, edit-3, edit, external-link, eye-off, eye, facebook, fast-forward, feather, figma, file-minus, file-plus, file-text, file, film, filter, flag, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, grid, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, info, instagram, italic, key, layers, layout, life-buoy, link-2, link, linkedin, list, loader, lock, log-in, log-out, mail, map-pin, map, maximize-2, maximize, meh, menu, message-circle, message-square, mic-off, mic, minimize-2, minimize, minus-circle, minus-square, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation-2, navigation, octagon, package, paperclip, pause-circle, pause, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, pie-chart, play-circle, play, plus-circle, plus-square, plus, pocket, power, printer, radio, refresh-ccw, refresh-cw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, server, settings, share-2, share, shield-off, shield, shopping-bag, shopping-cart, shuffle, sidebar, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, square, star, stop-circle, sun, sunrise, sunset, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, tool, trash-2, trash, trello, trending-down, trending-up, triangle, truck, tv, twitch, twitter, type, umbrella, underline, unlock, upload-cloud, upload, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume-1, volume-2, volume-x, volume, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default */\n/***/ (function(module) {\n\nmodule.exports = {"activity":"<polyline points=\\"22 12 18 12 15 21 9 3 6 12 2 12\\"></polyline>","airplay":"<path d=\\"M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1\\"></path><polygon points=\\"12 15 17 21 7 21 12 15\\"></polygon>","alert-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"16\\" x2=\\"12.01\\" y2=\\"16\\"></line>","alert-octagon":"<polygon points=\\"7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2\\"></polygon><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"16\\" x2=\\"12.01\\" y2=\\"16\\"></line>","alert-triangle":"<path d=\\"M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z\\"></path><line x1=\\"12\\" y1=\\"9\\" x2=\\"12\\" y2=\\"13\\"></line><line x1=\\"12\\" y1=\\"17\\" x2=\\"12.01\\" y2=\\"17\\"></line>","align-center":"<line x1=\\"18\\" y1=\\"10\\" x2=\\"6\\" y2=\\"10\\"></line><line x1=\\"21\\" y1=\\"6\\" x2=\\"3\\" y2=\\"6\\"></line><line x1=\\"21\\" y1=\\"14\\" x2=\\"3\\" y2=\\"14\\"></line><line x1=\\"18\\" y1=\\"18\\" x2=\\"6\\" y2=\\"18\\"></line>","align-justify":"<line x1=\\"21\\" y1=\\"10\\" x2=\\"3\\" y2=\\"10\\"></line><line x1=\\"21\\" y1=\\"6\\" x2=\\"3\\" y2=\\"6\\"></line><line x1=\\"21\\" y1=\\"14\\" x2=\\"3\\" y2=\\"14\\"></line><line x1=\\"21\\" y1=\\"18\\" x2=\\"3\\" y2=\\"18\\"></line>","align-left":"<line x1=\\"17\\" y1=\\"10\\" x2=\\"3\\" y2=\\"10\\"></line><line x1=\\"21\\" y1=\\"6\\" x2=\\"3\\" y2=\\"6\\"></line><line x1=\\"21\\" y1=\\"14\\" x2=\\"3\\" y2=\\"14\\"></line><line x1=\\"17\\" y1=\\"18\\" x2=\\"3\\" y2=\\"18\\"></line>","align-right":"<line x1=\\"21\\" y1=\\"10\\" x2=\\"7\\" y2=\\"10\\"></line><line x1=\\"21\\" y1=\\"6\\" x2=\\"3\\" y2=\\"6\\"></line><line x1=\\"21\\" y1=\\"14\\" x2=\\"3\\" y2=\\"14\\"></line><line x1=\\"21\\" y1=\\"18\\" x2=\\"7\\" y2=\\"18\\"></line>","anchor":"<circle cx=\\"12\\" cy=\\"5\\" r=\\"3\\"></circle><line x1=\\"12\\" y1=\\"22\\" x2=\\"12\\" y2=\\"8\\"></line><path d=\\"M5 12H2a10 10 0 0 0 20 0h-3\\"></path>","aperture":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"14.31\\" y1=\\"8\\" x2=\\"20.05\\" y2=\\"17.94\\"></line><line x1=\\"9.69\\" y1=\\"8\\" x2=\\"21.17\\" y2=\\"8\\"></line><line x1=\\"7.38\\" y1=\\"12\\" x2=\\"13.12\\" y2=\\"2.06\\"></line><line x1=\\"9.69\\" y1=\\"16\\" x2=\\"3.95\\" y2=\\"6.06\\"></line><line x1=\\"14.31\\" y1=\\"16\\" x2=\\"2.83\\" y2=\\"16\\"></line><line x1=\\"16.62\\" y1=\\"12\\" x2=\\"10.88\\" y2=\\"21.94\\"></line>","archive":"<polyline points=\\"21 8 21 21 3 21 3 8\\"></polyline><rect x=\\"1\\" y=\\"3\\" width=\\"22\\" height=\\"5\\"></rect><line x1=\\"10\\" y1=\\"12\\" x2=\\"14\\" y2=\\"12\\"></line>","arrow-down-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polyline points=\\"8 12 12 16 16 12\\"></polyline><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"16\\"></line>","arrow-down-left":"<line x1=\\"17\\" y1=\\"7\\" x2=\\"7\\" y2=\\"17\\"></line><polyline points=\\"17 17 7 17 7 7\\"></polyline>","arrow-down-right":"<line x1=\\"7\\" y1=\\"7\\" x2=\\"17\\" y2=\\"17\\"></line><polyline points=\\"17 7 17 17 7 17\\"></polyline>","arrow-down":"<line x1=\\"12\\" y1=\\"5\\" x2=\\"12\\" y2=\\"19\\"></line><polyline points=\\"19 12 12 19 5 12\\"></polyline>","arrow-left-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polyline points=\\"12 8 8 12 12 16\\"></polyline><line x1=\\"16\\" y1=\\"12\\" x2=\\"8\\" y2=\\"12\\"></line>","arrow-left":"<line x1=\\"19\\" y1=\\"12\\" x2=\\"5\\" y2=\\"12\\"></line><polyline points=\\"12 19 5 12 12 5\\"></polyline>","arrow-right-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polyline points=\\"12 16 16 12 12 8\\"></polyline><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line>","arrow-right":"<line x1=\\"5\\" y1=\\"12\\" x2=\\"19\\" y2=\\"12\\"></line><polyline points=\\"12 5 19 12 12 19\\"></polyline>","arrow-up-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polyline points=\\"16 12 12 8 8 12\\"></polyline><line x1=\\"12\\" y1=\\"16\\" x2=\\"12\\" y2=\\"8\\"></line>","arrow-up-left":"<line x1=\\"17\\" y1=\\"17\\" x2=\\"7\\" y2=\\"7\\"></line><polyline points=\\"7 17 7 7 17 7\\"></polyline>","arrow-up-right":"<line x1=\\"7\\" y1=\\"17\\" x2=\\"17\\" y2=\\"7\\"></line><polyline points=\\"7 7 17 7 17 17\\"></polyline>","arrow-up":"<line x1=\\"12\\" y1=\\"19\\" x2=\\"12\\" y2=\\"5\\"></line><polyline points=\\"5 12 12 5 19 12\\"></polyline>","at-sign":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"4\\"></circle><path d=\\"M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94\\"></path>","award":"<circle cx=\\"12\\" cy=\\"8\\" r=\\"7\\"></circle><polyline points=\\"8.21 13.89 7 23 12 20 17 23 15.79 13.88\\"></polyline>","bar-chart-2":"<line x1=\\"18\\" y1=\\"20\\" x2=\\"18\\" y2=\\"10\\"></line><line x1=\\"12\\" y1=\\"20\\" x2=\\"12\\" y2=\\"4\\"></line><line x1=\\"6\\" y1=\\"20\\" x2=\\"6\\" y2=\\"14\\"></line>","bar-chart":"<line x1=\\"12\\" y1=\\"20\\" x2=\\"12\\" y2=\\"10\\"></line><line x1=\\"18\\" y1=\\"20\\" x2=\\"18\\" y2=\\"4\\"></line><line x1=\\"6\\" y1=\\"20\\" x2=\\"6\\" y2=\\"16\\"></line>","battery-charging":"<path d=\\"M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19\\"></path><line x1=\\"23\\" y1=\\"13\\" x2=\\"23\\" y2=\\"11\\"></line><polyline points=\\"11 6 7 12 13 12 9 18\\"></polyline>","battery":"<rect x=\\"1\\" y=\\"6\\" width=\\"18\\" height=\\"12\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"23\\" y1=\\"13\\" x2=\\"23\\" y2=\\"11\\"></line>","bell-off":"<path d=\\"M13.73 21a2 2 0 0 1-3.46 0\\"></path><path d=\\"M18.63 13A17.89 17.89 0 0 1 18 8\\"></path><path d=\\"M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14\\"></path><path d=\\"M18 8a6 6 0 0 0-9.33-5\\"></path><line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line>","bell":"<path d=\\"M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9\\"></path><path d=\\"M13.73 21a2 2 0 0 1-3.46 0\\"></path>","bluetooth":"<polyline points=\\"6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5\\"></polyline>","bold":"<path d=\\"M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z\\"></path><path d=\\"M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z\\"></path>","book-open":"<path d=\\"M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z\\"></path><path d=\\"M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z\\"></path>","book":"<path d=\\"M4 19.5A2.5 2.5 0 0 1 6.5 17H20\\"></path><path d=\\"M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z\\"></path>","bookmark":"<path d=\\"M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z\\"></path>","box":"<path d=\\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\\"></path><polyline points=\\"3.27 6.96 12 12.01 20.73 6.96\\"></polyline><line x1=\\"12\\" y1=\\"22.08\\" x2=\\"12\\" y2=\\"12\\"></line>","briefcase":"<rect x=\\"2\\" y=\\"7\\" width=\\"20\\" height=\\"14\\" rx=\\"2\\" ry=\\"2\\"></rect><path d=\\"M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16\\"></path>","calendar":"<rect x=\\"3\\" y=\\"4\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"16\\" y1=\\"2\\" x2=\\"16\\" y2=\\"6\\"></line><line x1=\\"8\\" y1=\\"2\\" x2=\\"8\\" y2=\\"6\\"></line><line x1=\\"3\\" y1=\\"10\\" x2=\\"21\\" y2=\\"10\\"></line>","camera-off":"<line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line><path d=\\"M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56\\"></path>","camera":"<path d=\\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\\"></path><circle cx=\\"12\\" cy=\\"13\\" r=\\"4\\"></circle>","cast":"<path d=\\"M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6\\"></path><line x1=\\"2\\" y1=\\"20\\" x2=\\"2.01\\" y2=\\"20\\"></line>","check-circle":"<path d=\\"M22 11.08V12a10 10 0 1 1-5.93-9.14\\"></path><polyline points=\\"22 4 12 14.01 9 11.01\\"></polyline>","check-square":"<polyline points=\\"9 11 12 14 22 4\\"></polyline><path d=\\"M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11\\"></path>","check":"<polyline points=\\"20 6 9 17 4 12\\"></polyline>","chevron-down":"<polyline points=\\"6 9 12 15 18 9\\"></polyline>","chevron-left":"<polyline points=\\"15 18 9 12 15 6\\"></polyline>","chevron-right":"<polyline points=\\"9 18 15 12 9 6\\"></polyline>","chevron-up":"<polyline points=\\"18 15 12 9 6 15\\"></polyline>","chevrons-down":"<polyline points=\\"7 13 12 18 17 13\\"></polyline><polyline points=\\"7 6 12 11 17 6\\"></polyline>","chevrons-left":"<polyline points=\\"11 17 6 12 11 7\\"></polyline><polyline points=\\"18 17 13 12 18 7\\"></polyline>","chevrons-right":"<polyline points=\\"13 17 18 12 13 7\\"></polyline><polyline points=\\"6 17 11 12 6 7\\"></polyline>","chevrons-up":"<polyline points=\\"17 11 12 6 7 11\\"></polyline><polyline points=\\"17 18 12 13 7 18\\"></polyline>","chrome":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><circle cx=\\"12\\" cy=\\"12\\" r=\\"4\\"></circle><line x1=\\"21.17\\" y1=\\"8\\" x2=\\"12\\" y2=\\"8\\"></line><line x1=\\"3.95\\" y1=\\"6.06\\" x2=\\"8.54\\" y2=\\"14\\"></line><line x1=\\"10.88\\" y1=\\"21.94\\" x2=\\"15.46\\" y2=\\"14\\"></line>","circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle>","clipboard":"<path d=\\"M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2\\"></path><rect x=\\"8\\" y=\\"2\\" width=\\"8\\" height=\\"4\\" rx=\\"1\\" ry=\\"1\\"></rect>","clock":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polyline points=\\"12 6 12 12 16 14\\"></polyline>","cloud-drizzle":"<line x1=\\"8\\" y1=\\"19\\" x2=\\"8\\" y2=\\"21\\"></line><line x1=\\"8\\" y1=\\"13\\" x2=\\"8\\" y2=\\"15\\"></line><line x1=\\"16\\" y1=\\"19\\" x2=\\"16\\" y2=\\"21\\"></line><line x1=\\"16\\" y1=\\"13\\" x2=\\"16\\" y2=\\"15\\"></line><line x1=\\"12\\" y1=\\"21\\" x2=\\"12\\" y2=\\"23\\"></line><line x1=\\"12\\" y1=\\"15\\" x2=\\"12\\" y2=\\"17\\"></line><path d=\\"M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25\\"></path>","cloud-lightning":"<path d=\\"M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9\\"></path><polyline points=\\"13 11 9 17 15 17 11 23\\"></polyline>","cloud-off":"<path d=\\"M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3\\"></path><line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line>","cloud-rain":"<line x1=\\"16\\" y1=\\"13\\" x2=\\"16\\" y2=\\"21\\"></line><line x1=\\"8\\" y1=\\"13\\" x2=\\"8\\" y2=\\"21\\"></line><line x1=\\"12\\" y1=\\"15\\" x2=\\"12\\" y2=\\"23\\"></line><path d=\\"M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25\\"></path>","cloud-snow":"<path d=\\"M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25\\"></path><line x1=\\"8\\" y1=\\"16\\" x2=\\"8.01\\" y2=\\"16\\"></line><line x1=\\"8\\" y1=\\"20\\" x2=\\"8.01\\" y2=\\"20\\"></line><line x1=\\"12\\" y1=\\"18\\" x2=\\"12.01\\" y2=\\"18\\"></line><line x1=\\"12\\" y1=\\"22\\" x2=\\"12.01\\" y2=\\"22\\"></line><line x1=\\"16\\" y1=\\"16\\" x2=\\"16.01\\" y2=\\"16\\"></line><line x1=\\"16\\" y1=\\"20\\" x2=\\"16.01\\" y2=\\"20\\"></line>","cloud":"<path d=\\"M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z\\"></path>","code":"<polyline points=\\"16 18 22 12 16 6\\"></polyline><polyline points=\\"8 6 2 12 8 18\\"></polyline>","codepen":"<polygon points=\\"12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2\\"></polygon><line x1=\\"12\\" y1=\\"22\\" x2=\\"12\\" y2=\\"15.5\\"></line><polyline points=\\"22 8.5 12 15.5 2 8.5\\"></polyline><polyline points=\\"2 15.5 12 8.5 22 15.5\\"></polyline><line x1=\\"12\\" y1=\\"2\\" x2=\\"12\\" y2=\\"8.5\\"></line>","codesandbox":"<path d=\\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\\"></path><polyline points=\\"7.5 4.21 12 6.81 16.5 4.21\\"></polyline><polyline points=\\"7.5 19.79 7.5 14.6 3 12\\"></polyline><polyline points=\\"21 12 16.5 14.6 16.5 19.79\\"></polyline><polyline points=\\"3.27 6.96 12 12.01 20.73 6.96\\"></polyline><line x1=\\"12\\" y1=\\"22.08\\" x2=\\"12\\" y2=\\"12\\"></line>","coffee":"<path d=\\"M18 8h1a4 4 0 0 1 0 8h-1\\"></path><path d=\\"M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z\\"></path><line x1=\\"6\\" y1=\\"1\\" x2=\\"6\\" y2=\\"4\\"></line><line x1=\\"10\\" y1=\\"1\\" x2=\\"10\\" y2=\\"4\\"></line><line x1=\\"14\\" y1=\\"1\\" x2=\\"14\\" y2=\\"4\\"></line>","columns":"<path d=\\"M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18\\"></path>","command":"<path d=\\"M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z\\"></path>","compass":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polygon points=\\"16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76\\"></polygon>","copy":"<rect x=\\"9\\" y=\\"9\\" width=\\"13\\" height=\\"13\\" rx=\\"2\\" ry=\\"2\\"></rect><path d=\\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\\"></path>","corner-down-left":"<polyline points=\\"9 10 4 15 9 20\\"></polyline><path d=\\"M20 4v7a4 4 0 0 1-4 4H4\\"></path>","corner-down-right":"<polyline points=\\"15 10 20 15 15 20\\"></polyline><path d=\\"M4 4v7a4 4 0 0 0 4 4h12\\"></path>","corner-left-down":"<polyline points=\\"14 15 9 20 4 15\\"></polyline><path d=\\"M20 4h-7a4 4 0 0 0-4 4v12\\"></path>","corner-left-up":"<polyline points=\\"14 9 9 4 4 9\\"></polyline><path d=\\"M20 20h-7a4 4 0 0 1-4-4V4\\"></path>","corner-right-down":"<polyline points=\\"10 15 15 20 20 15\\"></polyline><path d=\\"M4 4h7a4 4 0 0 1 4 4v12\\"></path>","corner-right-up":"<polyline points=\\"10 9 15 4 20 9\\"></polyline><path d=\\"M4 20h7a4 4 0 0 0 4-4V4\\"></path>","corner-up-left":"<polyline points=\\"9 14 4 9 9 4\\"></polyline><path d=\\"M20 20v-7a4 4 0 0 0-4-4H4\\"></path>","corner-up-right":"<polyline points=\\"15 14 20 9 15 4\\"></polyline><path d=\\"M4 20v-7a4 4 0 0 1 4-4h12\\"></path>","cpu":"<rect x=\\"4\\" y=\\"4\\" width=\\"16\\" height=\\"16\\" rx=\\"2\\" ry=\\"2\\"></rect><rect x=\\"9\\" y=\\"9\\" width=\\"6\\" height=\\"6\\"></rect><line x1=\\"9\\" y1=\\"1\\" x2=\\"9\\" y2=\\"4\\"></line><line x1=\\"15\\" y1=\\"1\\" x2=\\"15\\" y2=\\"4\\"></line><line x1=\\"9\\" y1=\\"20\\" x2=\\"9\\" y2=\\"23\\"></line><line x1=\\"15\\" y1=\\"20\\" x2=\\"15\\" y2=\\"23\\"></line><line x1=\\"20\\" y1=\\"9\\" x2=\\"23\\" y2=\\"9\\"></line><line x1=\\"20\\" y1=\\"14\\" x2=\\"23\\" y2=\\"14\\"></line><line x1=\\"1\\" y1=\\"9\\" x2=\\"4\\" y2=\\"9\\"></line><line x1=\\"1\\" y1=\\"14\\" x2=\\"4\\" y2=\\"14\\"></line>","credit-card":"<rect x=\\"1\\" y=\\"4\\" width=\\"22\\" height=\\"16\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"1\\" y1=\\"10\\" x2=\\"23\\" y2=\\"10\\"></line>","crop":"<path d=\\"M6.13 1L6 16a2 2 0 0 0 2 2h15\\"></path><path d=\\"M1 6.13L16 6a2 2 0 0 1 2 2v15\\"></path>","crosshair":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"22\\" y1=\\"12\\" x2=\\"18\\" y2=\\"12\\"></line><line x1=\\"6\\" y1=\\"12\\" x2=\\"2\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"6\\" x2=\\"12\\" y2=\\"2\\"></line><line x1=\\"12\\" y1=\\"22\\" x2=\\"12\\" y2=\\"18\\"></line>","database":"<ellipse cx=\\"12\\" cy=\\"5\\" rx=\\"9\\" ry=\\"3\\"></ellipse><path d=\\"M21 12c0 1.66-4 3-9 3s-9-1.34-9-3\\"></path><path d=\\"M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5\\"></path>","delete":"<path d=\\"M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z\\"></path><line x1=\\"18\\" y1=\\"9\\" x2=\\"12\\" y2=\\"15\\"></line><line x1=\\"12\\" y1=\\"9\\" x2=\\"18\\" y2=\\"15\\"></line>","disc":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><circle cx=\\"12\\" cy=\\"12\\" r=\\"3\\"></circle>","divide-circle":"<line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"16\\" x2=\\"12\\" y2=\\"16\\"></line><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"8\\"></line><circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle>","divide-square":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"16\\" x2=\\"12\\" y2=\\"16\\"></line><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"8\\"></line>","divide":"<circle cx=\\"12\\" cy=\\"6\\" r=\\"2\\"></circle><line x1=\\"5\\" y1=\\"12\\" x2=\\"19\\" y2=\\"12\\"></line><circle cx=\\"12\\" cy=\\"18\\" r=\\"2\\"></circle>","dollar-sign":"<line x1=\\"12\\" y1=\\"1\\" x2=\\"12\\" y2=\\"23\\"></line><path d=\\"M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6\\"></path>","download-cloud":"<polyline points=\\"8 17 12 21 16 17\\"></polyline><line x1=\\"12\\" y1=\\"12\\" x2=\\"12\\" y2=\\"21\\"></line><path d=\\"M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29\\"></path>","download":"<path d=\\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\\"></path><polyline points=\\"7 10 12 15 17 10\\"></polyline><line x1=\\"12\\" y1=\\"15\\" x2=\\"12\\" y2=\\"3\\"></line>","dribbble":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><path d=\\"M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32\\"></path>","droplet":"<path d=\\"M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z\\"></path>","edit-2":"<path d=\\"M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z\\"></path>","edit-3":"<path d=\\"M12 20h9\\"></path><path d=\\"M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z\\"></path>","edit":"<path d=\\"M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7\\"></path><path d=\\"M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z\\"></path>","external-link":"<path d=\\"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\\"></path><polyline points=\\"15 3 21 3 21 9\\"></polyline><line x1=\\"10\\" y1=\\"14\\" x2=\\"21\\" y2=\\"3\\"></line>","eye-off":"<path d=\\"M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24\\"></path><line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line>","eye":"<path d=\\"M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z\\"></path><circle cx=\\"12\\" cy=\\"12\\" r=\\"3\\"></circle>","facebook":"<path d=\\"M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z\\"></path>","fast-forward":"<polygon points=\\"13 19 22 12 13 5 13 19\\"></polygon><polygon points=\\"2 19 11 12 2 5 2 19\\"></polygon>","feather":"<path d=\\"M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z\\"></path><line x1=\\"16\\" y1=\\"8\\" x2=\\"2\\" y2=\\"22\\"></line><line x1=\\"17.5\\" y1=\\"15\\" x2=\\"9\\" y2=\\"15\\"></line>","figma":"<path d=\\"M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z\\"></path><path d=\\"M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z\\"></path><path d=\\"M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z\\"></path><path d=\\"M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z\\"></path><path d=\\"M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z\\"></path>","file-minus":"<path d=\\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\\"></path><polyline points=\\"14 2 14 8 20 8\\"></polyline><line x1=\\"9\\" y1=\\"15\\" x2=\\"15\\" y2=\\"15\\"></line>","file-plus":"<path d=\\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\\"></path><polyline points=\\"14 2 14 8 20 8\\"></polyline><line x1=\\"12\\" y1=\\"18\\" x2=\\"12\\" y2=\\"12\\"></line><line x1=\\"9\\" y1=\\"15\\" x2=\\"15\\" y2=\\"15\\"></line>","file-text":"<path d=\\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\\"></path><polyline points=\\"14 2 14 8 20 8\\"></polyline><line x1=\\"16\\" y1=\\"13\\" x2=\\"8\\" y2=\\"13\\"></line><line x1=\\"16\\" y1=\\"17\\" x2=\\"8\\" y2=\\"17\\"></line><polyline points=\\"10 9 9 9 8 9\\"></polyline>","file":"<path d=\\"M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z\\"></path><polyline points=\\"13 2 13 9 20 9\\"></polyline>","film":"<rect x=\\"2\\" y=\\"2\\" width=\\"20\\" height=\\"20\\" rx=\\"2.18\\" ry=\\"2.18\\"></rect><line x1=\\"7\\" y1=\\"2\\" x2=\\"7\\" y2=\\"22\\"></line><line x1=\\"17\\" y1=\\"2\\" x2=\\"17\\" y2=\\"22\\"></line><line x1=\\"2\\" y1=\\"12\\" x2=\\"22\\" y2=\\"12\\"></line><line x1=\\"2\\" y1=\\"7\\" x2=\\"7\\" y2=\\"7\\"></line><line x1=\\"2\\" y1=\\"17\\" x2=\\"7\\" y2=\\"17\\"></line><line x1=\\"17\\" y1=\\"17\\" x2=\\"22\\" y2=\\"17\\"></line><line x1=\\"17\\" y1=\\"7\\" x2=\\"22\\" y2=\\"7\\"></line>","filter":"<polygon points=\\"22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3\\"></polygon>","flag":"<path d=\\"M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z\\"></path><line x1=\\"4\\" y1=\\"22\\" x2=\\"4\\" y2=\\"15\\"></line>","folder-minus":"<path d=\\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\\"></path><line x1=\\"9\\" y1=\\"14\\" x2=\\"15\\" y2=\\"14\\"></line>","folder-plus":"<path d=\\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\\"></path><line x1=\\"12\\" y1=\\"11\\" x2=\\"12\\" y2=\\"17\\"></line><line x1=\\"9\\" y1=\\"14\\" x2=\\"15\\" y2=\\"14\\"></line>","folder":"<path d=\\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\\"></path>","framer":"<path d=\\"M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7\\"></path>","frown":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><path d=\\"M16 16s-1.5-2-4-2-4 2-4 2\\"></path><line x1=\\"9\\" y1=\\"9\\" x2=\\"9.01\\" y2=\\"9\\"></line><line x1=\\"15\\" y1=\\"9\\" x2=\\"15.01\\" y2=\\"9\\"></line>","gift":"<polyline points=\\"20 12 20 22 4 22 4 12\\"></polyline><rect x=\\"2\\" y=\\"7\\" width=\\"20\\" height=\\"5\\"></rect><line x1=\\"12\\" y1=\\"22\\" x2=\\"12\\" y2=\\"7\\"></line><path d=\\"M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z\\"></path><path d=\\"M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z\\"></path>","git-branch":"<line x1=\\"6\\" y1=\\"3\\" x2=\\"6\\" y2=\\"15\\"></line><circle cx=\\"18\\" cy=\\"6\\" r=\\"3\\"></circle><circle cx=\\"6\\" cy=\\"18\\" r=\\"3\\"></circle><path d=\\"M18 9a9 9 0 0 1-9 9\\"></path>","git-commit":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"4\\"></circle><line x1=\\"1.05\\" y1=\\"12\\" x2=\\"7\\" y2=\\"12\\"></line><line x1=\\"17.01\\" y1=\\"12\\" x2=\\"22.96\\" y2=\\"12\\"></line>","git-merge":"<circle cx=\\"18\\" cy=\\"18\\" r=\\"3\\"></circle><circle cx=\\"6\\" cy=\\"6\\" r=\\"3\\"></circle><path d=\\"M6 21V9a9 9 0 0 0 9 9\\"></path>","git-pull-request":"<circle cx=\\"18\\" cy=\\"18\\" r=\\"3\\"></circle><circle cx=\\"6\\" cy=\\"6\\" r=\\"3\\"></circle><path d=\\"M13 6h3a2 2 0 0 1 2 2v7\\"></path><line x1=\\"6\\" y1=\\"9\\" x2=\\"6\\" y2=\\"21\\"></line>","github":"<path d=\\"M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22\\"></path>","gitlab":"<path d=\\"M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z\\"></path>","globe":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"2\\" y1=\\"12\\" x2=\\"22\\" y2=\\"12\\"></line><path d=\\"M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z\\"></path>","grid":"<rect x=\\"3\\" y=\\"3\\" width=\\"7\\" height=\\"7\\"></rect><rect x=\\"14\\" y=\\"3\\" width=\\"7\\" height=\\"7\\"></rect><rect x=\\"14\\" y=\\"14\\" width=\\"7\\" height=\\"7\\"></rect><rect x=\\"3\\" y=\\"14\\" width=\\"7\\" height=\\"7\\"></rect>","hard-drive":"<line x1=\\"22\\" y1=\\"12\\" x2=\\"2\\" y2=\\"12\\"></line><path d=\\"M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z\\"></path><line x1=\\"6\\" y1=\\"16\\" x2=\\"6.01\\" y2=\\"16\\"></line><line x1=\\"10\\" y1=\\"16\\" x2=\\"10.01\\" y2=\\"16\\"></line>","hash":"<line x1=\\"4\\" y1=\\"9\\" x2=\\"20\\" y2=\\"9\\"></line><line x1=\\"4\\" y1=\\"15\\" x2=\\"20\\" y2=\\"15\\"></line><line x1=\\"10\\" y1=\\"3\\" x2=\\"8\\" y2=\\"21\\"></line><line x1=\\"16\\" y1=\\"3\\" x2=\\"14\\" y2=\\"21\\"></line>","headphones":"<path d=\\"M3 18v-6a9 9 0 0 1 18 0v6\\"></path><path d=\\"M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z\\"></path>","heart":"<path d=\\"M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z\\"></path>","help-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><path d=\\"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\\"></path><line x1=\\"12\\" y1=\\"17\\" x2=\\"12.01\\" y2=\\"17\\"></line>","hexagon":"<path d=\\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\\"></path>","home":"<path d=\\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\\"></path><polyline points=\\"9 22 9 12 15 12 15 22\\"></polyline>","image":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><circle cx=\\"8.5\\" cy=\\"8.5\\" r=\\"1.5\\"></circle><polyline points=\\"21 15 16 10 5 21\\"></polyline>","inbox":"<polyline points=\\"22 12 16 12 14 15 10 15 8 12 2 12\\"></polyline><path d=\\"M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z\\"></path>","info":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"12\\" y1=\\"16\\" x2=\\"12\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"8\\" x2=\\"12.01\\" y2=\\"8\\"></line>","instagram":"<rect x=\\"2\\" y=\\"2\\" width=\\"20\\" height=\\"20\\" rx=\\"5\\" ry=\\"5\\"></rect><path d=\\"M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z\\"></path><line x1=\\"17.5\\" y1=\\"6.5\\" x2=\\"17.51\\" y2=\\"6.5\\"></line>","italic":"<line x1=\\"19\\" y1=\\"4\\" x2=\\"10\\" y2=\\"4\\"></line><line x1=\\"14\\" y1=\\"20\\" x2=\\"5\\" y2=\\"20\\"></line><line x1=\\"15\\" y1=\\"4\\" x2=\\"9\\" y2=\\"20\\"></line>","key":"<path d=\\"M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4\\"></path>","layers":"<polygon points=\\"12 2 2 7 12 12 22 7 12 2\\"></polygon><polyline points=\\"2 17 12 22 22 17\\"></polyline><polyline points=\\"2 12 12 17 22 12\\"></polyline>","layout":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"3\\" y1=\\"9\\" x2=\\"21\\" y2=\\"9\\"></line><line x1=\\"9\\" y1=\\"21\\" x2=\\"9\\" y2=\\"9\\"></line>","life-buoy":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><circle cx=\\"12\\" cy=\\"12\\" r=\\"4\\"></circle><line x1=\\"4.93\\" y1=\\"4.93\\" x2=\\"9.17\\" y2=\\"9.17\\"></line><line x1=\\"14.83\\" y1=\\"14.83\\" x2=\\"19.07\\" y2=\\"19.07\\"></line><line x1=\\"14.83\\" y1=\\"9.17\\" x2=\\"19.07\\" y2=\\"4.93\\"></line><line x1=\\"14.83\\" y1=\\"9.17\\" x2=\\"18.36\\" y2=\\"5.64\\"></line><line x1=\\"4.93\\" y1=\\"19.07\\" x2=\\"9.17\\" y2=\\"14.83\\"></line>","link-2":"<path d=\\"M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3\\"></path><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line>","link":"<path d=\\"M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71\\"></path><path d=\\"M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71\\"></path>","linkedin":"<path d=\\"M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z\\"></path><rect x=\\"2\\" y=\\"9\\" width=\\"4\\" height=\\"12\\"></rect><circle cx=\\"4\\" cy=\\"4\\" r=\\"2\\"></circle>","list":"<line x1=\\"8\\" y1=\\"6\\" x2=\\"21\\" y2=\\"6\\"></line><line x1=\\"8\\" y1=\\"12\\" x2=\\"21\\" y2=\\"12\\"></line><line x1=\\"8\\" y1=\\"18\\" x2=\\"21\\" y2=\\"18\\"></line><line x1=\\"3\\" y1=\\"6\\" x2=\\"3.01\\" y2=\\"6\\"></line><line x1=\\"3\\" y1=\\"12\\" x2=\\"3.01\\" y2=\\"12\\"></line><line x1=\\"3\\" y1=\\"18\\" x2=\\"3.01\\" y2=\\"18\\"></line>","loader":"<line x1=\\"12\\" y1=\\"2\\" x2=\\"12\\" y2=\\"6\\"></line><line x1=\\"12\\" y1=\\"18\\" x2=\\"12\\" y2=\\"22\\"></line><line x1=\\"4.93\\" y1=\\"4.93\\" x2=\\"7.76\\" y2=\\"7.76\\"></line><line x1=\\"16.24\\" y1=\\"16.24\\" x2=\\"19.07\\" y2=\\"19.07\\"></line><line x1=\\"2\\" y1=\\"12\\" x2=\\"6\\" y2=\\"12\\"></line><line x1=\\"18\\" y1=\\"12\\" x2=\\"22\\" y2=\\"12\\"></line><line x1=\\"4.93\\" y1=\\"19.07\\" x2=\\"7.76\\" y2=\\"16.24\\"></line><line x1=\\"16.24\\" y1=\\"7.76\\" x2=\\"19.07\\" y2=\\"4.93\\"></line>","lock":"<rect x=\\"3\\" y=\\"11\\" width=\\"18\\" height=\\"11\\" rx=\\"2\\" ry=\\"2\\"></rect><path d=\\"M7 11V7a5 5 0 0 1 10 0v4\\"></path>","log-in":"<path d=\\"M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4\\"></path><polyline points=\\"10 17 15 12 10 7\\"></polyline><line x1=\\"15\\" y1=\\"12\\" x2=\\"3\\" y2=\\"12\\"></line>","log-out":"<path d=\\"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4\\"></path><polyline points=\\"16 17 21 12 16 7\\"></polyline><line x1=\\"21\\" y1=\\"12\\" x2=\\"9\\" y2=\\"12\\"></line>","mail":"<path d=\\"M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z\\"></path><polyline points=\\"22,6 12,13 2,6\\"></polyline>","map-pin":"<path d=\\"M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z\\"></path><circle cx=\\"12\\" cy=\\"10\\" r=\\"3\\"></circle>","map":"<polygon points=\\"1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6\\"></polygon><line x1=\\"8\\" y1=\\"2\\" x2=\\"8\\" y2=\\"18\\"></line><line x1=\\"16\\" y1=\\"6\\" x2=\\"16\\" y2=\\"22\\"></line>","maximize-2":"<polyline points=\\"15 3 21 3 21 9\\"></polyline><polyline points=\\"9 21 3 21 3 15\\"></polyline><line x1=\\"21\\" y1=\\"3\\" x2=\\"14\\" y2=\\"10\\"></line><line x1=\\"3\\" y1=\\"21\\" x2=\\"10\\" y2=\\"14\\"></line>","maximize":"<path d=\\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\\"></path>","meh":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"8\\" y1=\\"15\\" x2=\\"16\\" y2=\\"15\\"></line><line x1=\\"9\\" y1=\\"9\\" x2=\\"9.01\\" y2=\\"9\\"></line><line x1=\\"15\\" y1=\\"9\\" x2=\\"15.01\\" y2=\\"9\\"></line>","menu":"<line x1=\\"3\\" y1=\\"12\\" x2=\\"21\\" y2=\\"12\\"></line><line x1=\\"3\\" y1=\\"6\\" x2=\\"21\\" y2=\\"6\\"></line><line x1=\\"3\\" y1=\\"18\\" x2=\\"21\\" y2=\\"18\\"></line>","message-circle":"<path d=\\"M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z\\"></path>","message-square":"<path d=\\"M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z\\"></path>","mic-off":"<line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line><path d=\\"M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6\\"></path><path d=\\"M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23\\"></path><line x1=\\"12\\" y1=\\"19\\" x2=\\"12\\" y2=\\"23\\"></line><line x1=\\"8\\" y1=\\"23\\" x2=\\"16\\" y2=\\"23\\"></line>","mic":"<path d=\\"M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z\\"></path><path d=\\"M19 10v2a7 7 0 0 1-14 0v-2\\"></path><line x1=\\"12\\" y1=\\"19\\" x2=\\"12\\" y2=\\"23\\"></line><line x1=\\"8\\" y1=\\"23\\" x2=\\"16\\" y2=\\"23\\"></line>","minimize-2":"<polyline points=\\"4 14 10 14 10 20\\"></polyline><polyline points=\\"20 10 14 10 14 4\\"></polyline><line x1=\\"14\\" y1=\\"10\\" x2=\\"21\\" y2=\\"3\\"></line><line x1=\\"3\\" y1=\\"21\\" x2=\\"10\\" y2=\\"14\\"></line>","minimize":"<path d=\\"M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3\\"></path>","minus-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line>","minus-square":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line>","minus":"<line x1=\\"5\\" y1=\\"12\\" x2=\\"19\\" y2=\\"12\\"></line>","monitor":"<rect x=\\"2\\" y=\\"3\\" width=\\"20\\" height=\\"14\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"8\\" y1=\\"21\\" x2=\\"16\\" y2=\\"21\\"></line><line x1=\\"12\\" y1=\\"17\\" x2=\\"12\\" y2=\\"21\\"></line>","moon":"<path d=\\"M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z\\"></path>","more-horizontal":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"1\\"></circle><circle cx=\\"19\\" cy=\\"12\\" r=\\"1\\"></circle><circle cx=\\"5\\" cy=\\"12\\" r=\\"1\\"></circle>","more-vertical":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"1\\"></circle><circle cx=\\"12\\" cy=\\"5\\" r=\\"1\\"></circle><circle cx=\\"12\\" cy=\\"19\\" r=\\"1\\"></circle>","mouse-pointer":"<path d=\\"M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z\\"></path><path d=\\"M13 13l6 6\\"></path>","move":"<polyline points=\\"5 9 2 12 5 15\\"></polyline><polyline points=\\"9 5 12 2 15 5\\"></polyline><polyline points=\\"15 19 12 22 9 19\\"></polyline><polyline points=\\"19 9 22 12 19 15\\"></polyline><line x1=\\"2\\" y1=\\"12\\" x2=\\"22\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"2\\" x2=\\"12\\" y2=\\"22\\"></line>","music":"<path d=\\"M9 18V5l12-2v13\\"></path><circle cx=\\"6\\" cy=\\"18\\" r=\\"3\\"></circle><circle cx=\\"18\\" cy=\\"16\\" r=\\"3\\"></circle>","navigation-2":"<polygon points=\\"12 2 19 21 12 17 5 21 12 2\\"></polygon>","navigation":"<polygon points=\\"3 11 22 2 13 21 11 13 3 11\\"></polygon>","octagon":"<polygon points=\\"7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2\\"></polygon>","package":"<line x1=\\"16.5\\" y1=\\"9.4\\" x2=\\"7.5\\" y2=\\"4.21\\"></line><path d=\\"M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z\\"></path><polyline points=\\"3.27 6.96 12 12.01 20.73 6.96\\"></polyline><line x1=\\"12\\" y1=\\"22.08\\" x2=\\"12\\" y2=\\"12\\"></line>","paperclip":"<path d=\\"M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48\\"></path>","pause-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"10\\" y1=\\"15\\" x2=\\"10\\" y2=\\"9\\"></line><line x1=\\"14\\" y1=\\"15\\" x2=\\"14\\" y2=\\"9\\"></line>","pause":"<rect x=\\"6\\" y=\\"4\\" width=\\"4\\" height=\\"16\\"></rect><rect x=\\"14\\" y=\\"4\\" width=\\"4\\" height=\\"16\\"></rect>","pen-tool":"<path d=\\"M12 19l7-7 3 3-7 7-3-3z\\"></path><path d=\\"M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z\\"></path><path d=\\"M2 2l7.586 7.586\\"></path><circle cx=\\"11\\" cy=\\"11\\" r=\\"2\\"></circle>","percent":"<line x1=\\"19\\" y1=\\"5\\" x2=\\"5\\" y2=\\"19\\"></line><circle cx=\\"6.5\\" cy=\\"6.5\\" r=\\"2.5\\"></circle><circle cx=\\"17.5\\" cy=\\"17.5\\" r=\\"2.5\\"></circle>","phone-call":"<path d=\\"M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\\"></path>","phone-forwarded":"<polyline points=\\"19 1 23 5 19 9\\"></polyline><line x1=\\"15\\" y1=\\"5\\" x2=\\"23\\" y2=\\"5\\"></line><path d=\\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\\"></path>","phone-incoming":"<polyline points=\\"16 2 16 8 22 8\\"></polyline><line x1=\\"23\\" y1=\\"1\\" x2=\\"16\\" y2=\\"8\\"></line><path d=\\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\\"></path>","phone-missed":"<line x1=\\"23\\" y1=\\"1\\" x2=\\"17\\" y2=\\"7\\"></line><line x1=\\"17\\" y1=\\"1\\" x2=\\"23\\" y2=\\"7\\"></line><path d=\\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\\"></path>","phone-off":"<path d=\\"M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91\\"></path><line x1=\\"23\\" y1=\\"1\\" x2=\\"1\\" y2=\\"23\\"></line>","phone-outgoing":"<polyline points=\\"23 7 23 1 17 1\\"></polyline><line x1=\\"16\\" y1=\\"8\\" x2=\\"23\\" y2=\\"1\\"></line><path d=\\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\\"></path>","phone":"<path d=\\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\\"></path>","pie-chart":"<path d=\\"M21.21 15.89A10 10 0 1 1 8 2.83\\"></path><path d=\\"M22 12A10 10 0 0 0 12 2v10z\\"></path>","play-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><polygon points=\\"10 8 16 12 10 16 10 8\\"></polygon>","play":"<polygon points=\\"5 3 19 12 5 21 5 3\\"></polygon>","plus-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"16\\"></line><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line>","plus-square":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"16\\"></line><line x1=\\"8\\" y1=\\"12\\" x2=\\"16\\" y2=\\"12\\"></line>","plus":"<line x1=\\"12\\" y1=\\"5\\" x2=\\"12\\" y2=\\"19\\"></line><line x1=\\"5\\" y1=\\"12\\" x2=\\"19\\" y2=\\"12\\"></line>","pocket":"<path d=\\"M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z\\"></path><polyline points=\\"8 10 12 14 16 10\\"></polyline>","power":"<path d=\\"M18.36 6.64a9 9 0 1 1-12.73 0\\"></path><line x1=\\"12\\" y1=\\"2\\" x2=\\"12\\" y2=\\"12\\"></line>","printer":"<polyline points=\\"6 9 6 2 18 2 18 9\\"></polyline><path d=\\"M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2\\"></path><rect x=\\"6\\" y=\\"14\\" width=\\"12\\" height=\\"8\\"></rect>","radio":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"2\\"></circle><path d=\\"M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14\\"></path>","refresh-ccw":"<polyline points=\\"1 4 1 10 7 10\\"></polyline><polyline points=\\"23 20 23 14 17 14\\"></polyline><path d=\\"M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15\\"></path>","refresh-cw":"<polyline points=\\"23 4 23 10 17 10\\"></polyline><polyline points=\\"1 20 1 14 7 14\\"></polyline><path d=\\"M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15\\"></path>","repeat":"<polyline points=\\"17 1 21 5 17 9\\"></polyline><path d=\\"M3 11V9a4 4 0 0 1 4-4h14\\"></path><polyline points=\\"7 23 3 19 7 15\\"></polyline><path d=\\"M21 13v2a4 4 0 0 1-4 4H3\\"></path>","rewind":"<polygon points=\\"11 19 2 12 11 5 11 19\\"></polygon><polygon points=\\"22 19 13 12 22 5 22 19\\"></polygon>","rotate-ccw":"<polyline points=\\"1 4 1 10 7 10\\"></polyline><path d=\\"M3.51 15a9 9 0 1 0 2.13-9.36L1 10\\"></path>","rotate-cw":"<polyline points=\\"23 4 23 10 17 10\\"></polyline><path d=\\"M20.49 15a9 9 0 1 1-2.12-9.36L23 10\\"></path>","rss":"<path d=\\"M4 11a9 9 0 0 1 9 9\\"></path><path d=\\"M4 4a16 16 0 0 1 16 16\\"></path><circle cx=\\"5\\" cy=\\"19\\" r=\\"1\\"></circle>","save":"<path d=\\"M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z\\"></path><polyline points=\\"17 21 17 13 7 13 7 21\\"></polyline><polyline points=\\"7 3 7 8 15 8\\"></polyline>","scissors":"<circle cx=\\"6\\" cy=\\"6\\" r=\\"3\\"></circle><circle cx=\\"6\\" cy=\\"18\\" r=\\"3\\"></circle><line x1=\\"20\\" y1=\\"4\\" x2=\\"8.12\\" y2=\\"15.88\\"></line><line x1=\\"14.47\\" y1=\\"14.48\\" x2=\\"20\\" y2=\\"20\\"></line><line x1=\\"8.12\\" y1=\\"8.12\\" x2=\\"12\\" y2=\\"12\\"></line>","search":"<circle cx=\\"11\\" cy=\\"11\\" r=\\"8\\"></circle><line x1=\\"21\\" y1=\\"21\\" x2=\\"16.65\\" y2=\\"16.65\\"></line>","send":"<line x1=\\"22\\" y1=\\"2\\" x2=\\"11\\" y2=\\"13\\"></line><polygon points=\\"22 2 15 22 11 13 2 9 22 2\\"></polygon>","server":"<rect x=\\"2\\" y=\\"2\\" width=\\"20\\" height=\\"8\\" rx=\\"2\\" ry=\\"2\\"></rect><rect x=\\"2\\" y=\\"14\\" width=\\"20\\" height=\\"8\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"6\\" y1=\\"6\\" x2=\\"6.01\\" y2=\\"6\\"></line><line x1=\\"6\\" y1=\\"18\\" x2=\\"6.01\\" y2=\\"18\\"></line>","settings":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"3\\"></circle><path d=\\"M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z\\"></path>","share-2":"<circle cx=\\"18\\" cy=\\"5\\" r=\\"3\\"></circle><circle cx=\\"6\\" cy=\\"12\\" r=\\"3\\"></circle><circle cx=\\"18\\" cy=\\"19\\" r=\\"3\\"></circle><line x1=\\"8.59\\" y1=\\"13.51\\" x2=\\"15.42\\" y2=\\"17.49\\"></line><line x1=\\"15.41\\" y1=\\"6.51\\" x2=\\"8.59\\" y2=\\"10.49\\"></line>","share":"<path d=\\"M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8\\"></path><polyline points=\\"16 6 12 2 8 6\\"></polyline><line x1=\\"12\\" y1=\\"2\\" x2=\\"12\\" y2=\\"15\\"></line>","shield-off":"<path d=\\"M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18\\"></path><path d=\\"M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38\\"></path><line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line>","shield":"<path d=\\"M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z\\"></path>","shopping-bag":"<path d=\\"M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z\\"></path><line x1=\\"3\\" y1=\\"6\\" x2=\\"21\\" y2=\\"6\\"></line><path d=\\"M16 10a4 4 0 0 1-8 0\\"></path>","shopping-cart":"<circle cx=\\"9\\" cy=\\"21\\" r=\\"1\\"></circle><circle cx=\\"20\\" cy=\\"21\\" r=\\"1\\"></circle><path d=\\"M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6\\"></path>","shuffle":"<polyline points=\\"16 3 21 3 21 8\\"></polyline><line x1=\\"4\\" y1=\\"20\\" x2=\\"21\\" y2=\\"3\\"></line><polyline points=\\"21 16 21 21 16 21\\"></polyline><line x1=\\"15\\" y1=\\"15\\" x2=\\"21\\" y2=\\"21\\"></line><line x1=\\"4\\" y1=\\"4\\" x2=\\"9\\" y2=\\"9\\"></line>","sidebar":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"9\\" y1=\\"3\\" x2=\\"9\\" y2=\\"21\\"></line>","skip-back":"<polygon points=\\"19 20 9 12 19 4 19 20\\"></polygon><line x1=\\"5\\" y1=\\"19\\" x2=\\"5\\" y2=\\"5\\"></line>","skip-forward":"<polygon points=\\"5 4 15 12 5 20 5 4\\"></polygon><line x1=\\"19\\" y1=\\"5\\" x2=\\"19\\" y2=\\"19\\"></line>","slack":"<path d=\\"M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z\\"></path><path d=\\"M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z\\"></path><path d=\\"M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z\\"></path><path d=\\"M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z\\"></path><path d=\\"M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z\\"></path><path d=\\"M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z\\"></path><path d=\\"M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z\\"></path><path d=\\"M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z\\"></path>","slash":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"4.93\\" y1=\\"4.93\\" x2=\\"19.07\\" y2=\\"19.07\\"></line>","sliders":"<line x1=\\"4\\" y1=\\"21\\" x2=\\"4\\" y2=\\"14\\"></line><line x1=\\"4\\" y1=\\"10\\" x2=\\"4\\" y2=\\"3\\"></line><line x1=\\"12\\" y1=\\"21\\" x2=\\"12\\" y2=\\"12\\"></line><line x1=\\"12\\" y1=\\"8\\" x2=\\"12\\" y2=\\"3\\"></line><line x1=\\"20\\" y1=\\"21\\" x2=\\"20\\" y2=\\"16\\"></line><line x1=\\"20\\" y1=\\"12\\" x2=\\"20\\" y2=\\"3\\"></line><line x1=\\"1\\" y1=\\"14\\" x2=\\"7\\" y2=\\"14\\"></line><line x1=\\"9\\" y1=\\"8\\" x2=\\"15\\" y2=\\"8\\"></line><line x1=\\"17\\" y1=\\"16\\" x2=\\"23\\" y2=\\"16\\"></line>","smartphone":"<rect x=\\"5\\" y=\\"2\\" width=\\"14\\" height=\\"20\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"12\\" y1=\\"18\\" x2=\\"12.01\\" y2=\\"18\\"></line>","smile":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><path d=\\"M8 14s1.5 2 4 2 4-2 4-2\\"></path><line x1=\\"9\\" y1=\\"9\\" x2=\\"9.01\\" y2=\\"9\\"></line><line x1=\\"15\\" y1=\\"9\\" x2=\\"15.01\\" y2=\\"9\\"></line>","speaker":"<rect x=\\"4\\" y=\\"2\\" width=\\"16\\" height=\\"20\\" rx=\\"2\\" ry=\\"2\\"></rect><circle cx=\\"12\\" cy=\\"14\\" r=\\"4\\"></circle><line x1=\\"12\\" y1=\\"6\\" x2=\\"12.01\\" y2=\\"6\\"></line>","square":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect>","star":"<polygon points=\\"12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2\\"></polygon>","stop-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><rect x=\\"9\\" y=\\"9\\" width=\\"6\\" height=\\"6\\"></rect>","sun":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"5\\"></circle><line x1=\\"12\\" y1=\\"1\\" x2=\\"12\\" y2=\\"3\\"></line><line x1=\\"12\\" y1=\\"21\\" x2=\\"12\\" y2=\\"23\\"></line><line x1=\\"4.22\\" y1=\\"4.22\\" x2=\\"5.64\\" y2=\\"5.64\\"></line><line x1=\\"18.36\\" y1=\\"18.36\\" x2=\\"19.78\\" y2=\\"19.78\\"></line><line x1=\\"1\\" y1=\\"12\\" x2=\\"3\\" y2=\\"12\\"></line><line x1=\\"21\\" y1=\\"12\\" x2=\\"23\\" y2=\\"12\\"></line><line x1=\\"4.22\\" y1=\\"19.78\\" x2=\\"5.64\\" y2=\\"18.36\\"></line><line x1=\\"18.36\\" y1=\\"5.64\\" x2=\\"19.78\\" y2=\\"4.22\\"></line>","sunrise":"<path d=\\"M17 18a5 5 0 0 0-10 0\\"></path><line x1=\\"12\\" y1=\\"2\\" x2=\\"12\\" y2=\\"9\\"></line><line x1=\\"4.22\\" y1=\\"10.22\\" x2=\\"5.64\\" y2=\\"11.64\\"></line><line x1=\\"1\\" y1=\\"18\\" x2=\\"3\\" y2=\\"18\\"></line><line x1=\\"21\\" y1=\\"18\\" x2=\\"23\\" y2=\\"18\\"></line><line x1=\\"18.36\\" y1=\\"11.64\\" x2=\\"19.78\\" y2=\\"10.22\\"></line><line x1=\\"23\\" y1=\\"22\\" x2=\\"1\\" y2=\\"22\\"></line><polyline points=\\"8 6 12 2 16 6\\"></polyline>","sunset":"<path d=\\"M17 18a5 5 0 0 0-10 0\\"></path><line x1=\\"12\\" y1=\\"9\\" x2=\\"12\\" y2=\\"2\\"></line><line x1=\\"4.22\\" y1=\\"10.22\\" x2=\\"5.64\\" y2=\\"11.64\\"></line><line x1=\\"1\\" y1=\\"18\\" x2=\\"3\\" y2=\\"18\\"></line><line x1=\\"21\\" y1=\\"18\\" x2=\\"23\\" y2=\\"18\\"></line><line x1=\\"18.36\\" y1=\\"11.64\\" x2=\\"19.78\\" y2=\\"10.22\\"></line><line x1=\\"23\\" y1=\\"22\\" x2=\\"1\\" y2=\\"22\\"></line><polyline points=\\"16 5 12 9 8 5\\"></polyline>","tablet":"<rect x=\\"4\\" y=\\"2\\" width=\\"16\\" height=\\"20\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"12\\" y1=\\"18\\" x2=\\"12.01\\" y2=\\"18\\"></line>","tag":"<path d=\\"M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z\\"></path><line x1=\\"7\\" y1=\\"7\\" x2=\\"7.01\\" y2=\\"7\\"></line>","target":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><circle cx=\\"12\\" cy=\\"12\\" r=\\"6\\"></circle><circle cx=\\"12\\" cy=\\"12\\" r=\\"2\\"></circle>","terminal":"<polyline points=\\"4 17 10 11 4 5\\"></polyline><line x1=\\"12\\" y1=\\"19\\" x2=\\"20\\" y2=\\"19\\"></line>","thermometer":"<path d=\\"M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z\\"></path>","thumbs-down":"<path d=\\"M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17\\"></path>","thumbs-up":"<path d=\\"M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3\\"></path>","toggle-left":"<rect x=\\"1\\" y=\\"5\\" width=\\"22\\" height=\\"14\\" rx=\\"7\\" ry=\\"7\\"></rect><circle cx=\\"8\\" cy=\\"12\\" r=\\"3\\"></circle>","toggle-right":"<rect x=\\"1\\" y=\\"5\\" width=\\"22\\" height=\\"14\\" rx=\\"7\\" ry=\\"7\\"></rect><circle cx=\\"16\\" cy=\\"12\\" r=\\"3\\"></circle>","tool":"<path d=\\"M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z\\"></path>","trash-2":"<polyline points=\\"3 6 5 6 21 6\\"></polyline><path d=\\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\\"></path><line x1=\\"10\\" y1=\\"11\\" x2=\\"10\\" y2=\\"17\\"></line><line x1=\\"14\\" y1=\\"11\\" x2=\\"14\\" y2=\\"17\\"></line>","trash":"<polyline points=\\"3 6 5 6 21 6\\"></polyline><path d=\\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\\"></path>","trello":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><rect x=\\"7\\" y=\\"7\\" width=\\"3\\" height=\\"9\\"></rect><rect x=\\"14\\" y=\\"7\\" width=\\"3\\" height=\\"5\\"></rect>","trending-down":"<polyline points=\\"23 18 13.5 8.5 8.5 13.5 1 6\\"></polyline><polyline points=\\"17 18 23 18 23 12\\"></polyline>","trending-up":"<polyline points=\\"23 6 13.5 15.5 8.5 10.5 1 18\\"></polyline><polyline points=\\"17 6 23 6 23 12\\"></polyline>","triangle":"<path d=\\"M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z\\"></path>","truck":"<rect x=\\"1\\" y=\\"3\\" width=\\"15\\" height=\\"13\\"></rect><polygon points=\\"16 8 20 8 23 11 23 16 16 16 16 8\\"></polygon><circle cx=\\"5.5\\" cy=\\"18.5\\" r=\\"2.5\\"></circle><circle cx=\\"18.5\\" cy=\\"18.5\\" r=\\"2.5\\"></circle>","tv":"<rect x=\\"2\\" y=\\"7\\" width=\\"20\\" height=\\"15\\" rx=\\"2\\" ry=\\"2\\"></rect><polyline points=\\"17 2 12 7 7 2\\"></polyline>","twitch":"<path d=\\"M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7\\"></path>","twitter":"<path d=\\"M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z\\"></path>","type":"<polyline points=\\"4 7 4 4 20 4 20 7\\"></polyline><line x1=\\"9\\" y1=\\"20\\" x2=\\"15\\" y2=\\"20\\"></line><line x1=\\"12\\" y1=\\"4\\" x2=\\"12\\" y2=\\"20\\"></line>","umbrella":"<path d=\\"M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7\\"></path>","underline":"<path d=\\"M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3\\"></path><line x1=\\"4\\" y1=\\"21\\" x2=\\"20\\" y2=\\"21\\"></line>","unlock":"<rect x=\\"3\\" y=\\"11\\" width=\\"18\\" height=\\"11\\" rx=\\"2\\" ry=\\"2\\"></rect><path d=\\"M7 11V7a5 5 0 0 1 9.9-1\\"></path>","upload-cloud":"<polyline points=\\"16 16 12 12 8 16\\"></polyline><line x1=\\"12\\" y1=\\"12\\" x2=\\"12\\" y2=\\"21\\"></line><path d=\\"M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3\\"></path><polyline points=\\"16 16 12 12 8 16\\"></polyline>","upload":"<path d=\\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\\"></path><polyline points=\\"17 8 12 3 7 8\\"></polyline><line x1=\\"12\\" y1=\\"3\\" x2=\\"12\\" y2=\\"15\\"></line>","user-check":"<path d=\\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\\"></path><circle cx=\\"8.5\\" cy=\\"7\\" r=\\"4\\"></circle><polyline points=\\"17 11 19 13 23 9\\"></polyline>","user-minus":"<path d=\\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\\"></path><circle cx=\\"8.5\\" cy=\\"7\\" r=\\"4\\"></circle><line x1=\\"23\\" y1=\\"11\\" x2=\\"17\\" y2=\\"11\\"></line>","user-plus":"<path d=\\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\\"></path><circle cx=\\"8.5\\" cy=\\"7\\" r=\\"4\\"></circle><line x1=\\"20\\" y1=\\"8\\" x2=\\"20\\" y2=\\"14\\"></line><line x1=\\"23\\" y1=\\"11\\" x2=\\"17\\" y2=\\"11\\"></line>","user-x":"<path d=\\"M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\\"></path><circle cx=\\"8.5\\" cy=\\"7\\" r=\\"4\\"></circle><line x1=\\"18\\" y1=\\"8\\" x2=\\"23\\" y2=\\"13\\"></line><line x1=\\"23\\" y1=\\"8\\" x2=\\"18\\" y2=\\"13\\"></line>","user":"<path d=\\"M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2\\"></path><circle cx=\\"12\\" cy=\\"7\\" r=\\"4\\"></circle>","users":"<path d=\\"M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2\\"></path><circle cx=\\"9\\" cy=\\"7\\" r=\\"4\\"></circle><path d=\\"M23 21v-2a4 4 0 0 0-3-3.87\\"></path><path d=\\"M16 3.13a4 4 0 0 1 0 7.75\\"></path>","video-off":"<path d=\\"M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10\\"></path><line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line>","video":"<polygon points=\\"23 7 16 12 23 17 23 7\\"></polygon><rect x=\\"1\\" y=\\"5\\" width=\\"15\\" height=\\"14\\" rx=\\"2\\" ry=\\"2\\"></rect>","voicemail":"<circle cx=\\"5.5\\" cy=\\"11.5\\" r=\\"4.5\\"></circle><circle cx=\\"18.5\\" cy=\\"11.5\\" r=\\"4.5\\"></circle><line x1=\\"5.5\\" y1=\\"16\\" x2=\\"18.5\\" y2=\\"16\\"></line>","volume-1":"<polygon points=\\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\\"></polygon><path d=\\"M15.54 8.46a5 5 0 0 1 0 7.07\\"></path>","volume-2":"<polygon points=\\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\\"></polygon><path d=\\"M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07\\"></path>","volume-x":"<polygon points=\\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\\"></polygon><line x1=\\"23\\" y1=\\"9\\" x2=\\"17\\" y2=\\"15\\"></line><line x1=\\"17\\" y1=\\"9\\" x2=\\"23\\" y2=\\"15\\"></line>","volume":"<polygon points=\\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\\"></polygon>","watch":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"7\\"></circle><polyline points=\\"12 9 12 12 13.5 13.5\\"></polyline><path d=\\"M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83\\"></path>","wifi-off":"<line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line><path d=\\"M16.72 11.06A10.94 10.94 0 0 1 19 12.55\\"></path><path d=\\"M5 12.55a10.94 10.94 0 0 1 5.17-2.39\\"></path><path d=\\"M10.71 5.05A16 16 0 0 1 22.58 9\\"></path><path d=\\"M1.42 9a15.91 15.91 0 0 1 4.7-2.88\\"></path><path d=\\"M8.53 16.11a6 6 0 0 1 6.95 0\\"></path><line x1=\\"12\\" y1=\\"20\\" x2=\\"12.01\\" y2=\\"20\\"></line>","wifi":"<path d=\\"M5 12.55a11 11 0 0 1 14.08 0\\"></path><path d=\\"M1.42 9a16 16 0 0 1 21.16 0\\"></path><path d=\\"M8.53 16.11a6 6 0 0 1 6.95 0\\"></path><line x1=\\"12\\" y1=\\"20\\" x2=\\"12.01\\" y2=\\"20\\"></line>","wind":"<path d=\\"M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2\\"></path>","x-circle":"<circle cx=\\"12\\" cy=\\"12\\" r=\\"10\\"></circle><line x1=\\"15\\" y1=\\"9\\" x2=\\"9\\" y2=\\"15\\"></line><line x1=\\"9\\" y1=\\"9\\" x2=\\"15\\" y2=\\"15\\"></line>","x-octagon":"<polygon points=\\"7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2\\"></polygon><line x1=\\"15\\" y1=\\"9\\" x2=\\"9\\" y2=\\"15\\"></line><line x1=\\"9\\" y1=\\"9\\" x2=\\"15\\" y2=\\"15\\"></line>","x-square":"<rect x=\\"3\\" y=\\"3\\" width=\\"18\\" height=\\"18\\" rx=\\"2\\" ry=\\"2\\"></rect><line x1=\\"9\\" y1=\\"9\\" x2=\\"15\\" y2=\\"15\\"></line><line x1=\\"15\\" y1=\\"9\\" x2=\\"9\\" y2=\\"15\\"></line>","x":"<line x1=\\"18\\" y1=\\"6\\" x2=\\"6\\" y2=\\"18\\"></line><line x1=\\"6\\" y1=\\"6\\" x2=\\"18\\" y2=\\"18\\"></line>","youtube":"<path d=\\"M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z\\"></path><polygon points=\\"9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02\\"></polygon>","zap-off":"<polyline points=\\"12.41 6.75 13 2 10.57 4.92\\"></polyline><polyline points=\\"18.57 12.91 21 10 15.66 10\\"></polyline><polyline points=\\"8 8 3 14 12 14 11 22 16 16\\"></polyline><line x1=\\"1\\" y1=\\"1\\" x2=\\"23\\" y2=\\"23\\"></line>","zap":"<polygon points=\\"13 2 3 14 12 14 11 22 21 10 12 10 13 2\\"></polygon>","zoom-in":"<circle cx=\\"11\\" cy=\\"11\\" r=\\"8\\"></circle><line x1=\\"21\\" y1=\\"21\\" x2=\\"16.65\\" y2=\\"16.65\\"></line><line x1=\\"11\\" y1=\\"8\\" x2=\\"11\\" y2=\\"14\\"></line><line x1=\\"8\\" y1=\\"11\\" x2=\\"14\\" y2=\\"11\\"></line>","zoom-out":"<circle cx=\\"11\\" cy=\\"11\\" r=\\"8\\"></circle><line x1=\\"21\\" y1=\\"21\\" x2=\\"16.65\\" y2=\\"16.65\\"></line><line x1=\\"8\\" y1=\\"11\\" x2=\\"14\\" y2=\\"11\\"></line>"};\n\n/***/ }),\n\n/***/ "./node_modules/classnames/dedupe.js":\n/*!*******************************************!*\\\n  !*** ./node_modules/classnames/dedupe.js ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2016 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t\'use strict\';\n\n\tvar classNames = (function () {\n\t\t// don\'t inherit from Object so we can skip hasOwnProperty check later\n\t\t// http://stackoverflow.com/questions/15518328/creating-js-object-with-object-createnull#answer-21079232\n\t\tfunction StorageObject() {}\n\t\tStorageObject.prototype = Object.create(null);\n\n\t\tfunction _parseArray (resultSet, array) {\n\t\t\tvar length = array.length;\n\n\t\t\tfor (var i = 0; i < length; ++i) {\n\t\t\t\t_parse(resultSet, array[i]);\n\t\t\t}\n\t\t}\n\n\t\tvar hasOwn = {}.hasOwnProperty;\n\n\t\tfunction _parseNumber (resultSet, num) {\n\t\t\tresultSet[num] = true;\n\t\t}\n\n\t\tfunction _parseObject (resultSet, object) {\n\t\t\tfor (var k in object) {\n\t\t\t\tif (hasOwn.call(object, k)) {\n\t\t\t\t\t// set value to false instead of deleting it to avoid changing object structure\n\t\t\t\t\t// https://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/#de-referencing-misconceptions\n\t\t\t\t\tresultSet[k] = !!object[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar SPACE = /\\s+/;\n\t\tfunction _parseString (resultSet, str) {\n\t\t\tvar array = str.split(SPACE);\n\t\t\tvar length = array.length;\n\n\t\t\tfor (var i = 0; i < length; ++i) {\n\t\t\t\tresultSet[array[i]] = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction _parse (resultSet, arg) {\n\t\t\tif (!arg) return;\n\t\t\tvar argType = typeof arg;\n\n\t\t\t// \'foo bar\'\n\t\t\tif (argType === \'string\') {\n\t\t\t\t_parseString(resultSet, arg);\n\n\t\t\t// [\'foo\', \'bar\', ...]\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\t_parseArray(resultSet, arg);\n\n\t\t\t// { \'foo\': true, ... }\n\t\t\t} else if (argType === \'object\') {\n\t\t\t\t_parseObject(resultSet, arg);\n\n\t\t\t// \'130\'\n\t\t\t} else if (argType === \'number\') {\n\t\t\t\t_parseNumber(resultSet, arg);\n\t\t\t}\n\t\t}\n\n\t\tfunction _classNames () {\n\t\t\t// don\'t leak arguments\n\t\t\t// https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments\n\t\t\tvar len = arguments.length;\n\t\t\tvar args = Array(len);\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\targs[i] = arguments[i];\n\t\t\t}\n\n\t\t\tvar classSet = new StorageObject();\n\t\t\t_parseArray(classSet, args);\n\n\t\t\tvar list = [];\n\n\t\t\tfor (var k in classSet) {\n\t\t\t\tif (classSet[k]) {\n\t\t\t\t\tlist.push(k)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn list.join(\' \');\n\t\t}\n\n\t\treturn _classNames;\n\t})();\n\n\tif (typeof module !== \'undefined\' && module.exports) {\n\t\tmodule.exports = classNames;\n\t} else if (true) {\n\t\t// register as \'classnames\', consistent with npm package name\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn classNames;\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}());\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/es/array/from.js":\n/*!***********************************************!*\\\n  !*** ./node_modules/core-js/es/array/from.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(/*! ../../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");\n__webpack_require__(/*! ../../modules/es.array.from */ "./node_modules/core-js/modules/es.array.from.js");\nvar path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js/internals/path.js");\n\nmodule.exports = path.Array.from;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/a-function.js":\n/*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/a-function.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  if (typeof it != \'function\') {\n    throw TypeError(String(it) + \' is not a function\');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/an-object.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/an-object.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\n\nmodule.exports = function (it) {\n  if (!isObject(it)) {\n    throw TypeError(String(it) + \' is not an object\');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/array-from.js":\n/*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-from.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");\nvar isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");\nvar toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");\nvar createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");\nvar getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");\n\n// `Array.from` method\n// https://tc39.github.io/ecma262/#sec-array.from\nmodule.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n  var O = toObject(arrayLike);\n  var C = typeof this == \'function\' ? this : Array;\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  var index = 0;\n  var iteratorMethod = getIteratorMethod(O);\n  var length, result, step, iterator;\n  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);\n  // if the target is not iterable or it\'s an array with the default iterator - use a simple case\n  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n    iterator = iteratorMethod.call(O);\n    result = new C();\n    for (;!(step = iterator.next()).done; index++) {\n      createProperty(result, index, mapping\n        ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true)\n        : step.value\n      );\n    }\n  } else {\n    length = toLength(O.length);\n    result = new C(length);\n    for (;length > index; index++) {\n      createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n    }\n  }\n  result.length = index;\n  return result;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/array-includes.js":\n/*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-includes.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");\nvar toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\n// false -> Array#indexOf\n// https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n// true  -> Array#includes\n// https://tc39.github.io/ecma262/#sec-array.prototype.includes\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/bind-context.js":\n/*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/bind-context.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");\n\n// optional / simple context binding\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 0: return function () {\n      return fn.call(that);\n    };\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js":\n/*!****************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!\n  \\****************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\n\n// call something on iterator step with safe closing on error\nmodule.exports = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (error) {\n    var returnMethod = iterator[\'return\'];\n    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));\n    throw error;\n  }\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/check-correctness-of-iteration.js":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!\n  \\**************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    \'return\': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR] = function () {\n    return this;\n  };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nmodule.exports = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/classof-raw.js":\n/*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/classof-raw.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/classof.js":\n/*!***************************************************!*\\\n  !*** ./node_modules/core-js/internals/classof.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar TO_STRING_TAG = wellKnownSymbol(\'toStringTag\');\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == \'Arguments\';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = function (it) {\n  var O, tag, result;\n  return it === undefined ? \'Undefined\' : it === null ? \'Null\'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == \'string\' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == \'Object\' && typeof O.callee == \'function\' ? \'Arguments\' : result;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");\nvar getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":\n/*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\nmodule.exports = !fails(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/create-iterator-constructor.js":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;\nvar create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\nvar setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (IteratorConstructor, NAME, next) {\n  var TO_STRING_TAG = NAME + \' Iterator\';\n  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });\n  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n  Iterators[TO_STRING_TAG] = returnThis;\n  return IteratorConstructor;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/create-property-descriptor.js":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/create-property.js":\n/*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-property.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPrimitive(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/define-iterator.js":\n/*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/define-iterator.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");\nvar getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");\nvar setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");\nvar setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");\nvar hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");\nvar redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\nvar IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");\n\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar KEYS = \'keys\';\nvar VALUES = \'values\';\nvar ENTRIES = \'entries\';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + \' Iterator\';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR]\n    || IterablePrototype[\'@@iterator\']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == \'Array\' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf) {\n          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (typeof CurrentIteratorPrototype[ITERATOR] != \'function\') {\n          hide(CurrentIteratorPrototype, ITERATOR, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\n    }\n  }\n\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    INCORRECT_VALUES_NAME = true;\n    defaultIterator = function values() { return nativeIterator.call(this); };\n  }\n\n  // define iterator\n  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n    hide(IterablePrototype, ITERATOR, defaultIterator);\n  }\n  Iterators[NAME] = defaultIterator;\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        redefine(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  return methods;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/descriptors.js":\n/*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/descriptors.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\n// Thank\'s IE8 for his funny defineProperty\nmodule.exports = !fails(function () {\n  return Object.defineProperty({}, \'a\', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/document-create-element.js":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/document-create-element.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\n\nvar document = global.document;\n// typeof document.createElement is \'object\' in old IE\nvar exist = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return exist ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/enum-bug-keys.js":\n/*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n// IE8- don\'t enum bug keys\nmodule.exports = [\n  \'constructor\',\n  \'hasOwnProperty\',\n  \'isPrototypeOf\',\n  \'propertyIsEnumerable\',\n  \'toLocaleString\',\n  \'toString\',\n  \'valueOf\'\n];\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/export.js":\n/*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/export.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;\nvar hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");\nvar redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");\nvar setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");\nvar copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");\nvar isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \'.\' : \'#\') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty === typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      hide(sourceProperty, \'sham\', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/fails.js":\n/*!*************************************************!*\\\n  !*** ./node_modules/core-js/internals/fails.js ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/function-to-string.js":\n/*!**************************************************************!*\\\n  !*** ./node_modules/core-js/internals/function-to-string.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\n\nmodule.exports = shared(\'native-function-to-string\', Function.toString);\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/get-iterator-method.js":\n/*!***************************************************************!*\\\n  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\n\nmodule.exports = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it[\'@@iterator\']\n    || Iterators[classof(it)];\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/global.js":\n/*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/global.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var O = \'object\';\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line no-undef\n  check(typeof globalThis == O && globalThis) ||\n  check(typeof window == O && window) ||\n  check(typeof self == O && self) ||\n  check(typeof global == O && global) ||\n  // eslint-disable-next-line no-new-func\n  Function(\'return this\')();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/has.js":\n/*!***********************************************!*\\\n  !*** ./node_modules/core-js/internals/has.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/hidden-keys.js":\n/*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/hidden-keys.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/hide.js":\n/*!************************************************!*\\\n  !*** ./node_modules/core-js/internals/hide.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/html.js":\n/*!************************************************!*\\\n  !*** ./node_modules/core-js/internals/html.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\n\nvar document = global.document;\n\nmodule.exports = document && document.documentElement;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/ie8-dom-define.js":\n/*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");\n\n// Thank\'s IE8 for his funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  return Object.defineProperty(createElement(\'div\'), \'a\', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/indexed-object.js":\n/*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/indexed-object.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\nvar classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");\n\nvar split = \'\'.split;\n\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins\n  return !Object(\'z\').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == \'String\' ? split.call(it, \'\') : Object(it);\n} : Object;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/internal-state.js":\n/*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/internal-state.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");\nvar objectHas = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\n\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError(\'Incompatible receiver, \' + TYPE + \' required\');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP) {\n  var store = new WeakMap();\n  var wmget = store.get;\n  var wmhas = store.has;\n  var wmset = store.set;\n  set = function (it, metadata) {\n    wmset.call(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget.call(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas.call(store, it);\n  };\n} else {\n  var STATE = sharedKey(\'state\');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    hide(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return objectHas(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return objectHas(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/is-array-iterator-method.js":\n/*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/is-forced.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-forced.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : typeof detection == \'function\' ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, \'.\').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = \'N\';\nvar POLYFILL = isForced.POLYFILL = \'P\';\n\nmodule.exports = isForced;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/is-object.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-object.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  return typeof it === \'object\' ? it !== null : typeof it === \'function\';\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/is-pure.js":\n/*!***************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-pure.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = false;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/iterators-core.js":\n/*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/iterators-core.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");\nvar hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");\n\nvar ITERATOR = wellKnownSymbol(\'iterator\');\nvar BUGGY_SAFARI_ITERATORS = false;\n\nvar returnThis = function () { return this; };\n\n// `%IteratorPrototype%` object\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!(\'next\' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nif (IteratorPrototype == undefined) IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nif (!IS_PURE && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n\nmodule.exports = {\n  IteratorPrototype: IteratorPrototype,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/iterators.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/iterators.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/native-symbol.js":\n/*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/native-symbol.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");\n\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  // Chrome 38 Symbol has incorrect toString conversion\n  // eslint-disable-next-line no-undef\n  return !String(Symbol());\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/native-weak-map.js":\n/*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/native-weak-map.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ "./node_modules/core-js/internals/function-to-string.js");\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = typeof WeakMap === \'function\' && /native code/.test(nativeFunctionToString.call(WeakMap));\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-create.js":\n/*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-create.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\nvar html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");\nvar documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");\nvar IE_PROTO = sharedKey(\'IE_PROTO\');\n\nvar PROTOTYPE = \'prototype\';\nvar Empty = function () { /* empty */ };\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement(\'iframe\');\n  var length = enumBugKeys.length;\n  var lt = \'<\';\n  var script = \'script\';\n  var gt = \'>\';\n  var js = \'java\' + script + \':\';\n  var iframeDocument;\n  iframe.style.display = \'none\';\n  html.appendChild(iframe);\n  iframe.src = String(js);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + script + gt + \'document.F=Object\' + lt + \'/\' + script + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];\n  return createDict();\n};\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add "__proto__" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : defineProperties(result, Properties);\n};\n\nhiddenKeys[IE_PROTO] = true;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-define-properties.js":\n/*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-define-properties.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");\n\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var key;\n  while (length > i) definePropertyModule.f(O, key = keys[i++], Properties[key]);\n  return O;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-define-property.js":\n/*!******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-define-property.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\nvar toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");\n\nvar nativeDefineProperty = Object.defineProperty;\n\nexports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return nativeDefineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if (\'get\' in Attributes || \'set\' in Attributes) throw TypeError(\'Accessors not supported\');\n  if (\'value\' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":\n/*!******************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!\n  \\******************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");\nvar propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");\n\nvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\nexports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return nativeGetOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!\n  \\*************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");\n\nvar hiddenKeys = enumBugKeys.concat(\'length\', \'prototype\');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":\n/*!***************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!\n  \\***************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nexports.f = Object.getOwnPropertySymbols;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");\nvar CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");\n\nvar IE_PROTO = sharedKey(\'IE_PROTO\');\nvar ObjectPrototype = Object.prototype;\n\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == \'function\' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectPrototype : null;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-keys-internal.js":\n/*!****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");\nvar arrayIncludes = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");\n\nvar arrayIndexOf = arrayIncludes(false);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n  // Don\'t enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-keys.js":\n/*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-keys.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!\n  \\*************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : nativePropertyIsEnumerable;\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar validateSetPrototypeOfArguments = __webpack_require__(/*! ../internals/validate-set-prototype-of-arguments */ "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js");\n\n// Works with __proto__ only. Old v8 can\'t work with null proto objects.\n/* eslint-disable no-proto */\nmodule.exports = Object.setPrototypeOf || (\'__proto__\' in {} ? function () {\n  var correctSetter = false;\n  var test = {};\n  var setter;\n  try {\n    setter = Object.getOwnPropertyDescriptor(Object.prototype, \'__proto__\').set;\n    setter.call(test, []);\n    correctSetter = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    validateSetPrototypeOfArguments(O, proto);\n    if (correctSetter) setter.call(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/own-keys.js":\n/*!****************************************************!*\\\n  !*** ./node_modules/core-js/internals/own-keys.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");\nvar getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\n\nvar Reflect = global.Reflect;\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/path.js":\n/*!************************************************!*\\\n  !*** ./node_modules/core-js/internals/path.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/redefine.js":\n/*!****************************************************!*\\\n  !*** ./node_modules/core-js/internals/redefine.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");\nvar nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ "./node_modules/core-js/internals/function-to-string.js");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");\n\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(nativeFunctionToString).split(\'toString\');\n\nshared(\'inspectSource\', function (it) {\n  return nativeFunctionToString.call(it);\n});\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  if (typeof value == \'function\') {\n    if (typeof key == \'string\' && !has(value, \'name\')) hide(value, \'name\', key);\n    enforceInternalState(value).source = TEMPLATE.join(typeof key == \'string\' ? key : \'\');\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else hide(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, \'toString\', function toString() {\n  return typeof this == \'function\' && getInternalState(this).source || nativeFunctionToString.call(this);\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/require-object-coercible.js":\n/*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.github.io/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError("Can\'t call method on " + it);\n  return it;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/set-global.js":\n/*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/set-global.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");\n\nmodule.exports = function (key, value) {\n  try {\n    hide(global, key, value);\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/set-to-string-tag.js":\n/*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;\nvar has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");\n\nvar TO_STRING_TAG = wellKnownSymbol(\'toStringTag\');\n\nmodule.exports = function (it, TAG, STATIC) {\n  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });\n  }\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/shared-key.js":\n/*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/shared-key.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\n\nvar keys = shared(\'keys\');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/shared.js":\n/*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/shared.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");\n\nvar SHARED = \'__core-js_shared__\';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})(\'versions\', []).push({\n  version: \'3.1.3\',\n  mode: IS_PURE ? \'pure\' : \'global\',\n  copyright: \'© 2019 Denis Pushkarev (zloirock.ru)\'\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/string-at.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/string-at.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\n// CONVERT_TO_STRING: true  -> String#at\n// CONVERT_TO_STRING: false -> String#codePointAt\nmodule.exports = function (that, pos, CONVERT_TO_STRING) {\n  var S = String(requireObjectCoercible(that));\n  var position = toInteger(pos);\n  var size = S.length;\n  var first, second;\n  if (position < 0 || position >= size) return CONVERT_TO_STRING ? \'\' : undefined;\n  first = S.charCodeAt(position);\n  return first < 0xD800 || first > 0xDBFF || position + 1 === size\n    || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF\n      ? CONVERT_TO_STRING ? S.charAt(position) : first\n      : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/to-absolute-index.js":\n/*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).\nmodule.exports = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/to-indexed-object.js":\n/*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/to-integer.js":\n/*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-integer.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToInteger` abstract operation\n// https://tc39.github.io/ecma262/#sec-tointeger\nmodule.exports = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/to-length.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-length.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.github.io/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/to-object.js":\n/*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-object.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");\n\n// `ToObject` abstract operation\n// https://tc39.github.io/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/to-primitive.js":\n/*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-primitive.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\n// instead of the ES6 spec version, we didn\'t implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == \'function\' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == \'function\' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == \'function\' && !isObject(val = fn.call(it))) return val;\n  throw TypeError("Can\'t convert object to primitive value");\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/uid.js":\n/*!***********************************************!*\\\n  !*** ./node_modules/core-js/internals/uid.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar id = 0;\nvar postfix = Math.random();\n\nmodule.exports = function (key) {\n  return \'Symbol(\'.concat(key === undefined ? \'\' : key, \')_\', (++id + postfix).toString(36));\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js":\n/*!*******************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/validate-set-prototype-of-arguments.js ***!\n  \\*******************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");\n\nmodule.exports = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) {\n    throw TypeError("Can\'t set " + String(proto) + \' as a prototype\');\n  }\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/internals/well-known-symbol.js":\n/*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");\nvar shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");\nvar uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");\nvar NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");\n\nvar Symbol = global.Symbol;\nvar store = shared(\'wks\');\n\nmodule.exports = function (name) {\n  return store[name] || (store[name] = NATIVE_SYMBOL && Symbol[name]\n    || (NATIVE_SYMBOL ? Symbol : uid)(\'Symbol.\' + name));\n};\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/modules/es.array.from.js":\n/*!*******************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.from.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");\nvar from = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");\nvar checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");\n\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n  Array.from(iterable);\n});\n\n// `Array.from` method\n// https://tc39.github.io/ecma262/#sec-array.from\n$({ target: \'Array\', stat: true, forced: INCORRECT_ITERATION }, {\n  from: from\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/core-js/modules/es.string.iterator.js":\n/*!************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\nvar codePointAt = __webpack_require__(/*! ../internals/string-at */ "./node_modules/core-js/internals/string-at.js");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");\nvar defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");\n\nvar STRING_ITERATOR = \'String Iterator\';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\n\n// `String.prototype[@@iterator]` method\n// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator\ndefineIterator(String, \'String\', function (iterated) {\n  setInternalState(this, {\n    type: STRING_ITERATOR,\n    string: String(iterated),\n    index: 0\n  });\n// `%StringIteratorPrototype%.next` method\n// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return { value: undefined, done: true };\n  point = codePointAt(string, index, true);\n  state.index += point.length;\n  return { value: point, done: false };\n});\n\n\n/***/ }),\n\n/***/ "./node_modules/webpack/buildin/global.js":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/global.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1, eval)("this");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === "object") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n\n/***/ "./src/default-attrs.json":\n/*!********************************!*\\\n  !*** ./src/default-attrs.json ***!\n  \\********************************/\n/*! exports provided: xmlns, width, height, viewBox, fill, stroke, stroke-width, stroke-linecap, stroke-linejoin, default */\n/***/ (function(module) {\n\nmodule.exports = {"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","stroke-width":2,"stroke-linecap":"round","stroke-linejoin":"round"};\n\n/***/ }),\n\n/***/ "./src/icon.js":\n/*!*********************!*\\\n  !*** ./src/icon.js ***!\n  \\*********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _dedupe = __webpack_require__(/*! classnames/dedupe */ "./node_modules/classnames/dedupe.js");\n\nvar _dedupe2 = _interopRequireDefault(_dedupe);\n\nvar _defaultAttrs = __webpack_require__(/*! ./default-attrs.json */ "./src/default-attrs.json");\n\nvar _defaultAttrs2 = _interopRequireDefault(_defaultAttrs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar Icon = function () {\n  function Icon(name, contents) {\n    var tags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    _classCallCheck(this, Icon);\n\n    this.name = name;\n    this.contents = contents;\n    this.tags = tags;\n    this.attrs = _extends({}, _defaultAttrs2.default, { class: \'feather feather-\' + name });\n  }\n\n  /**\n   * Create an SVG string.\n   * @param {Object} attrs\n   * @returns {string}\n   */\n\n\n  _createClass(Icon, [{\n    key: \'toSvg\',\n    value: function toSvg() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var combinedAttrs = _extends({}, this.attrs, attrs, { class: (0, _dedupe2.default)(this.attrs.class, attrs.class) });\n\n      return \'<svg \' + attrsToString(combinedAttrs) + \'>\' + this.contents + \'</svg>\';\n    }\n\n    /**\n     * Return string representation of an `Icon`.\n     *\n     * Added for backward compatibility. If old code expects `feather.icons.<name>`\n     * to be a string, `toString()` will get implicitly called.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: \'toString\',\n    value: function toString() {\n      return this.contents;\n    }\n  }]);\n\n  return Icon;\n}();\n\n/**\n * Convert attributes object to string of HTML attributes.\n * @param {Object} attrs\n * @returns {string}\n */\n\n\nfunction attrsToString(attrs) {\n  return Object.keys(attrs).map(function (key) {\n    return key + \'="\' + attrs[key] + \'"\';\n  }).join(\' \');\n}\n\nexports.default = Icon;\n\n/***/ }),\n\n/***/ "./src/icons.js":\n/*!**********************!*\\\n  !*** ./src/icons.js ***!\n  \\**********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _icon = __webpack_require__(/*! ./icon */ "./src/icon.js");\n\nvar _icon2 = _interopRequireDefault(_icon);\n\nvar _icons = __webpack_require__(/*! ../dist/icons.json */ "./dist/icons.json");\n\nvar _icons2 = _interopRequireDefault(_icons);\n\nvar _tags = __webpack_require__(/*! ./tags.json */ "./src/tags.json");\n\nvar _tags2 = _interopRequireDefault(_tags);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = Object.keys(_icons2.default).map(function (key) {\n  return new _icon2.default(key, _icons2.default[key], _tags2.default[key]);\n}).reduce(function (object, icon) {\n  object[icon.name] = icon;\n  return object;\n}, {});\n\n/***/ }),\n\n/***/ "./src/index.js":\n/*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nvar _icons = __webpack_require__(/*! ./icons */ "./src/icons.js");\n\nvar _icons2 = _interopRequireDefault(_icons);\n\nvar _toSvg = __webpack_require__(/*! ./to-svg */ "./src/to-svg.js");\n\nvar _toSvg2 = _interopRequireDefault(_toSvg);\n\nvar _replace = __webpack_require__(/*! ./replace */ "./src/replace.js");\n\nvar _replace2 = _interopRequireDefault(_replace);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = { icons: _icons2.default, toSvg: _toSvg2.default, replace: _replace2.default };\n\n/***/ }),\n\n/***/ "./src/replace.js":\n/*!************************!*\\\n  !*** ./src/replace.js ***!\n  \\************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint-env browser */\n\n\nvar _dedupe = __webpack_require__(/*! classnames/dedupe */ "./node_modules/classnames/dedupe.js");\n\nvar _dedupe2 = _interopRequireDefault(_dedupe);\n\nvar _icons = __webpack_require__(/*! ./icons */ "./src/icons.js");\n\nvar _icons2 = _interopRequireDefault(_icons);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Replace all HTML elements that have a `data-feather` attribute with SVG markup\n * corresponding to the element\'s `data-feather` attribute value.\n * @param {Object} attrs\n */\nfunction replace() {\n  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (typeof document === \'undefined\') {\n    throw new Error(\'`feather.replace()` only works in a browser environment.\');\n  }\n\n  var elementsToReplace = document.querySelectorAll(\'[data-feather]\');\n\n  Array.from(elementsToReplace).forEach(function (element) {\n    return replaceElement(element, attrs);\n  });\n}\n\n/**\n * Replace a single HTML element with SVG markup\n * corresponding to the element\'s `data-feather` attribute value.\n * @param {HTMLElement} element\n * @param {Object} attrs\n */\nfunction replaceElement(element) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var elementAttrs = getAttrs(element);\n  var name = elementAttrs[\'data-feather\'];\n  delete elementAttrs[\'data-feather\'];\n\n  var svgString = _icons2.default[name].toSvg(_extends({}, attrs, elementAttrs, { class: (0, _dedupe2.default)(attrs.class, elementAttrs.class) }));\n  var svgDocument = new DOMParser().parseFromString(svgString, \'image/svg+xml\');\n  var svgElement = svgDocument.querySelector(\'svg\');\n\n  element.parentNode.replaceChild(svgElement, element);\n}\n\n/**\n * Get the attributes of an HTML element.\n * @param {HTMLElement} element\n * @returns {Object}\n */\nfunction getAttrs(element) {\n  return Array.from(element.attributes).reduce(function (attrs, attr) {\n    attrs[attr.name] = attr.value;\n    return attrs;\n  }, {});\n}\n\nexports.default = replace;\n\n/***/ }),\n\n/***/ "./src/tags.json":\n/*!***********************!*\\\n  !*** ./src/tags.json ***!\n  \\***********************/\n/*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, archive, at-sign, award, aperture, bar-chart, bar-chart-2, battery, battery-charging, bell, bell-off, bluetooth, book-open, book, bookmark, box, briefcase, calendar, camera, cast, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-rain, cloud-snow, cloud, codepen, codesandbox, code, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, dollar-sign, droplet, edit, edit-2, edit-3, eye, eye-off, external-link, facebook, fast-forward, figma, file-minus, file-plus, file-text, film, filter, flag, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, instagram, key, layers, layout, life-bouy, link, link-2, linkedin, list, lock, log-in, log-out, mail, map-pin, map, maximize, maximize-2, meh, menu, message-circle, message-square, mic-off, mic, minimize, minimize-2, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation, navigation-2, octagon, package, paperclip, pause, pause-circle, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, play, pie-chart, play-circle, plus, plus-circle, plus-square, pocket, power, printer, radio, refresh-cw, refresh-ccw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, settings, share-2, shield, shield-off, shopping-bag, shopping-cart, shuffle, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, star, stop-circle, sun, sunrise, sunset, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, tool, trash, trash-2, triangle, truck, tv, twitch, twitter, type, umbrella, unlock, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume, volume-1, volume-2, volume-x, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default */\n/***/ (function(module) {\n\nmodule.exports = {"activity":["pulse","health","action","motion"],"airplay":["stream","cast","mirroring"],"alert-circle":["warning","alert","danger"],"alert-octagon":["warning","alert","danger"],"alert-triangle":["warning","alert","danger"],"align-center":["text alignment","center"],"align-justify":["text alignment","justified"],"align-left":["text alignment","left"],"align-right":["text alignment","right"],"anchor":[],"archive":["index","box"],"at-sign":["mention","at","email","message"],"award":["achievement","badge"],"aperture":["camera","photo"],"bar-chart":["statistics","diagram","graph"],"bar-chart-2":["statistics","diagram","graph"],"battery":["power","electricity"],"battery-charging":["power","electricity"],"bell":["alarm","notification","sound"],"bell-off":["alarm","notification","silent"],"bluetooth":["wireless"],"book-open":["read","library"],"book":["read","dictionary","booklet","magazine","library"],"bookmark":["read","clip","marker","tag"],"box":["cube"],"briefcase":["work","bag","baggage","folder"],"calendar":["date"],"camera":["photo"],"cast":["chromecast","airplay"],"circle":["off","zero","record"],"clipboard":["copy"],"clock":["time","watch","alarm"],"cloud-drizzle":["weather","shower"],"cloud-lightning":["weather","bolt"],"cloud-rain":["weather"],"cloud-snow":["weather","blizzard"],"cloud":["weather"],"codepen":["logo"],"codesandbox":["logo"],"code":["source","programming"],"coffee":["drink","cup","mug","tea","cafe","hot","beverage"],"columns":["layout"],"command":["keyboard","cmd","terminal","prompt"],"compass":["navigation","safari","travel","direction"],"copy":["clone","duplicate"],"corner-down-left":["arrow","return"],"corner-down-right":["arrow"],"corner-left-down":["arrow"],"corner-left-up":["arrow"],"corner-right-down":["arrow"],"corner-right-up":["arrow"],"corner-up-left":["arrow"],"corner-up-right":["arrow"],"cpu":["processor","technology"],"credit-card":["purchase","payment","cc"],"crop":["photo","image"],"crosshair":["aim","target"],"database":["storage","memory"],"delete":["remove"],"disc":["album","cd","dvd","music"],"dollar-sign":["currency","money","payment"],"droplet":["water"],"edit":["pencil","change"],"edit-2":["pencil","change"],"edit-3":["pencil","change"],"eye":["view","watch"],"eye-off":["view","watch","hide","hidden"],"external-link":["outbound"],"facebook":["logo","social"],"fast-forward":["music"],"figma":["logo","design","tool"],"file-minus":["delete","remove","erase"],"file-plus":["add","create","new"],"file-text":["data","txt","pdf"],"film":["movie","video"],"filter":["funnel","hopper"],"flag":["report"],"folder-minus":["directory"],"folder-plus":["directory"],"folder":["directory"],"framer":["logo","design","tool"],"frown":["emoji","face","bad","sad","emotion"],"gift":["present","box","birthday","party"],"git-branch":["code","version control"],"git-commit":["code","version control"],"git-merge":["code","version control"],"git-pull-request":["code","version control"],"github":["logo","version control"],"gitlab":["logo","version control"],"globe":["world","browser","language","translate"],"hard-drive":["computer","server","memory","data"],"hash":["hashtag","number","pound"],"headphones":["music","audio","sound"],"heart":["like","love","emotion"],"help-circle":["question mark"],"hexagon":["shape","node.js","logo"],"home":["house","living"],"image":["picture"],"inbox":["email"],"instagram":["logo","camera"],"key":["password","login","authentication","secure"],"layers":["stack"],"layout":["window","webpage"],"life-bouy":["help","life ring","support"],"link":["chain","url"],"link-2":["chain","url"],"linkedin":["logo","social media"],"list":["options"],"lock":["security","password","secure"],"log-in":["sign in","arrow","enter"],"log-out":["sign out","arrow","exit"],"mail":["email","message"],"map-pin":["location","navigation","travel","marker"],"map":["location","navigation","travel"],"maximize":["fullscreen"],"maximize-2":["fullscreen","arrows","expand"],"meh":["emoji","face","neutral","emotion"],"menu":["bars","navigation","hamburger"],"message-circle":["comment","chat"],"message-square":["comment","chat"],"mic-off":["record","sound","mute"],"mic":["record","sound","listen"],"minimize":["exit fullscreen","close"],"minimize-2":["exit fullscreen","arrows","close"],"minus":["subtract"],"monitor":["tv","screen","display"],"moon":["dark","night"],"more-horizontal":["ellipsis"],"more-vertical":["ellipsis"],"mouse-pointer":["arrow","cursor"],"move":["arrows"],"music":["note"],"navigation":["location","travel"],"navigation-2":["location","travel"],"octagon":["stop"],"package":["box","container"],"paperclip":["attachment"],"pause":["music","stop"],"pause-circle":["music","audio","stop"],"pen-tool":["vector","drawing"],"percent":["discount"],"phone-call":["ring"],"phone-forwarded":["call"],"phone-incoming":["call"],"phone-missed":["call"],"phone-off":["call","mute"],"phone-outgoing":["call"],"phone":["call"],"play":["music","start"],"pie-chart":["statistics","diagram"],"play-circle":["music","start"],"plus":["add","new"],"plus-circle":["add","new"],"plus-square":["add","new"],"pocket":["logo","save"],"power":["on","off"],"printer":["fax","office","device"],"radio":["signal"],"refresh-cw":["synchronise","arrows"],"refresh-ccw":["arrows"],"repeat":["loop","arrows"],"rewind":["music"],"rotate-ccw":["arrow"],"rotate-cw":["arrow"],"rss":["feed","subscribe"],"save":["floppy disk"],"scissors":["cut"],"search":["find","magnifier","magnifying glass"],"send":["message","mail","email","paper airplane","paper aeroplane"],"settings":["cog","edit","gear","preferences"],"share-2":["network","connections"],"shield":["security","secure"],"shield-off":["security","insecure"],"shopping-bag":["ecommerce","cart","purchase","store"],"shopping-cart":["ecommerce","cart","purchase","store"],"shuffle":["music"],"skip-back":["music"],"skip-forward":["music"],"slack":["logo"],"slash":["ban","no"],"sliders":["settings","controls"],"smartphone":["cellphone","device"],"smile":["emoji","face","happy","good","emotion"],"speaker":["audio","music"],"star":["bookmark","favorite","like"],"stop-circle":["media","music"],"sun":["brightness","weather","light"],"sunrise":["weather","time","morning","day"],"sunset":["weather","time","evening","night"],"tablet":["device"],"tag":["label"],"target":["logo","bullseye"],"terminal":["code","command line","prompt"],"thermometer":["temperature","celsius","fahrenheit","weather"],"thumbs-down":["dislike","bad","emotion"],"thumbs-up":["like","good","emotion"],"toggle-left":["on","off","switch"],"toggle-right":["on","off","switch"],"tool":["settings","spanner"],"trash":["garbage","delete","remove","bin"],"trash-2":["garbage","delete","remove","bin"],"triangle":["delta"],"truck":["delivery","van","shipping","transport","lorry"],"tv":["television","stream"],"twitch":["logo"],"twitter":["logo","social"],"type":["text"],"umbrella":["rain","weather"],"unlock":["security"],"user-check":["followed","subscribed"],"user-minus":["delete","remove","unfollow","unsubscribe"],"user-plus":["new","add","create","follow","subscribe"],"user-x":["delete","remove","unfollow","unsubscribe","unavailable"],"user":["person","account"],"users":["group"],"video-off":["camera","movie","film"],"video":["camera","movie","film"],"voicemail":["phone"],"volume":["music","sound","mute"],"volume-1":["music","sound"],"volume-2":["music","sound"],"volume-x":["music","sound","mute"],"watch":["clock","time"],"wifi-off":["disabled"],"wifi":["connection","signal","wireless"],"wind":["weather","air"],"x-circle":["cancel","close","delete","remove","times","clear"],"x-octagon":["delete","stop","alert","warning","times","clear"],"x-square":["cancel","close","delete","remove","times","clear"],"x":["cancel","close","delete","remove","times","clear"],"youtube":["logo","video","play"],"zap-off":["flash","camera","lightning"],"zap":["flash","camera","lightning"],"zoom-in":["magnifying glass"],"zoom-out":["magnifying glass"]};\n\n/***/ }),\n\n/***/ "./src/to-svg.js":\n/*!***********************!*\\\n  !*** ./src/to-svg.js ***!\n  \\***********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _icons = __webpack_require__(/*! ./icons */ "./src/icons.js");\n\nvar _icons2 = _interopRequireDefault(_icons);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Create an SVG string.\n * @deprecated\n * @param {string} name\n * @param {Object} attrs\n * @returns {string}\n */\nfunction toSvg(name) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  console.warn(\'feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead.\');\n\n  if (!name) {\n    throw new Error(\'The required `key` (icon name) parameter is missing.\');\n  }\n\n  if (!_icons2.default[name]) {\n    throw new Error(\'No icon matching \\\'\' + name + \'\\\'. See the complete list of icons at https://feathericons.com\');\n  }\n\n  return _icons2.default[name].toSvg(attrs);\n}\n\nexports.default = toSvg;\n\n/***/ }),\n\n/***/ 0:\n/*!**************************************************!*\\\n  !*** multi core-js/es/array/from ./src/index.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(/*! core-js/es/array/from */"./node_modules/core-js/es/array/from.js");\nmodule.exports = __webpack_require__(/*! /home/travis/build/feathericons/feather/src/index.js */"./src/index.js");\n\n\n/***/ })\n\n/******/ });\n});\n//# sourceMappingURL=feather.js.map\n\n//# sourceURL=webpack:///./node_modules/feather-icons/dist/feather.js?')},"./src/js/app.js":function srcJsAppJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_bootstrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/bootstrap */ "./src/js/modules/bootstrap.js");\n/* harmony import */ var _modules_feather_icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/feather-icons */ "./src/js/modules/feather-icons.js");\n/* harmony import */ var _modules_dropzone__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/dropzone */ "./src/js/modules/dropzone.js");\n/*\n * -----------------------------------------\n *  REQUIREDS\n * - - - - - - - - - - - - - - - - - - - - -\n */\n\n\n\n\n/*\n * -----------------------------------------\n *  READY\n * - - - - - - - - - - - - - - - - - - - - -\n */\ndocument.addEventListener(\'DOMContentLoaded\', () => {\n\n  console.log(\'APP READY!\');\n\n});\n\n\n//# sourceURL=webpack:///./src/js/app.js?')},"./src/js/modules/bootstrap.js":function srcJsModulesBootstrapJs(module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");\n/*\n * -----------------------------------------\n *  REQUIRED\n * - - - - - - - - - - - - - - - - - - - - -\n */\n\n\n/*\n * -----------------------------------------\n *  GLOBAL\n * - - - - - - - - - - - - - - - - - - - - -\n *  Note: If you want to make bootstrap globally available, e.g. for using `bootstrap.modal`\n * - - - - - - - - - - - - - - - - - - - - -\n */\nwindow.bootstrap = bootstrap__WEBPACK_IMPORTED_MODULE_0__;\n\n/*\n * -----------------------------------------\n *  POPOVERS\n * - - - - - - - - - - - - - - - - - - - - -\n *  Note: Disable this if you\'re not using Bootstrap\'s Popovers\n * - - - - - - - - - - - - - - - - - - - - -\n */\nconst popoverTriggerList = []\n  .slice.call(document.querySelectorAll(\'[data-bs-toggle="popover"]\'));\npopoverTriggerList.map((popoverTriggerEl) => {\n  return new bootstrap__WEBPACK_IMPORTED_MODULE_0__["Popover"](popoverTriggerEl);\n});\n\n/*\n * -----------------------------------------\n *  TOOLTIPS\n * - - - - - - - - - - - - - - - - - - - - -\n *  Note: Disable this if you\'re not using Bootstrap\'s Tooltips\n * - - - - - - - - - - - - - - - - - - - - -\n */\nconst tooltipTriggerList = [].slice\n  .call(document.querySelectorAll(\'[data-bs-toggle="tooltip"]\'));\ntooltipTriggerList.map((tooltipTriggerEl) => {\n  return new bootstrap__WEBPACK_IMPORTED_MODULE_0__["Tooltip"](tooltipTriggerEl);\n});\n\n\n//# sourceURL=webpack:///./src/js/modules/bootstrap.js?')},"./src/js/modules/dropzone.js":function srcJsModulesDropzoneJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var dropzone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dropzone */ \"./node_modules/dropzone/dist/dropzone.js\");\n/* harmony import */ var dropzone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dropzone__WEBPACK_IMPORTED_MODULE_0__);\n/*\n * -----------------------------------------\n *  REQUIRED\n * https://dropzone.gitbook.io/dropzone/getting-started/installation/webpack-recommended\n * - - - - - - - - - - - - - - - - - - - - -\n */\n\n\n// ???\n// Make sure Dropzone doesn't try to attach itself to the\n// element automatically.\n// This behaviour will change in future versions.\ndropzone__WEBPACK_IMPORTED_MODULE_0___default.a.autoDiscover = false;\n\n/*\n * -----------------------------------------\n *  INIT\n * - - - - - - - - - - - - - - - - - - - - -\n */\ndocument.addEventListener('DOMContentLoaded', () => {\n  //\n});\n\n\n//# sourceURL=webpack:///./src/js/modules/dropzone.js?")},"./src/js/modules/feather-icons.js":function srcJsModulesFeatherIconsJs(module,__webpack_exports__,__webpack_require__){eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var feather_icons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! feather-icons */ \"./node_modules/feather-icons/dist/feather.js\");\n/* harmony import */ var feather_icons__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(feather_icons__WEBPACK_IMPORTED_MODULE_0__);\n/*\n * -----------------------------------------\n *  REQUIRED\n * - - - - - - - - - - - - - - - - - - - - -\n */\n\nwindow.feather = feather_icons__WEBPACK_IMPORTED_MODULE_0___default.a;\n\n/*\n * -----------------------------------------\n *  INIT\n * - - - - - - - - - - - - - - - - - - - - -\n */\ndocument.addEventListener('DOMContentLoaded', () => {\n  feather_icons__WEBPACK_IMPORTED_MODULE_0___default.a.replace();\n});\n\n\n//# sourceURL=webpack:///./src/js/modules/feather-icons.js?")}});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwLmpzIiwic291cmNlcyI6WyJhcHAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX3R5cGVvZihvYmope1wiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtpZih0eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT09XCJzeW1ib2xcIil7X3R5cGVvZj1mdW5jdGlvbiBfdHlwZW9mKG9iail7cmV0dXJuIHR5cGVvZiBvYmo7fTt9ZWxzZXtfdHlwZW9mPWZ1bmN0aW9uIF90eXBlb2Yob2JqKXtyZXR1cm4gb2JqJiZ0eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZvYmouY29uc3RydWN0b3I9PT1TeW1ib2wmJm9iaiE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2Ygb2JqO307fXJldHVybiBfdHlwZW9mKG9iaik7fS8qKioqKiovKGZ1bmN0aW9uKG1vZHVsZXMpey8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovdmFyIGluc3RhbGxlZE1vZHVsZXM9e307LyoqKioqKi8gLyoqKioqKi8gLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCl7LyoqKioqKi8gLyoqKioqKi8gLy8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqL2lmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKXsvKioqKioqL3JldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzOy8qKioqKiovfS8qKioqKiovIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqL3ZhciBtb2R1bGU9aW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF09ey8qKioqKiovaTptb2R1bGVJZCwvKioqKioqL2w6ZmFsc2UsLyoqKioqKi9leHBvcnRzOnt9LyoqKioqKi99Oy8qKioqKiovIC8qKioqKiovIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi9tb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLG1vZHVsZSxtb2R1bGUuZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKTsvKioqKioqLyAvKioqKioqLyAvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqL21vZHVsZS5sPXRydWU7LyoqKioqKi8gLyoqKioqKi8gLy8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovcmV0dXJuIG1vZHVsZS5leHBvcnRzOy8qKioqKiovfS8qKioqKiovIC8qKioqKiovIC8qKioqKiovIC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqL19fd2VicGFja19yZXF1aXJlX18ubT1tb2R1bGVzOy8qKioqKiovIC8qKioqKiovIC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqL19fd2VicGFja19yZXF1aXJlX18uYz1pbnN0YWxsZWRNb2R1bGVzOy8qKioqKiovIC8qKioqKiovIC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQ9ZnVuY3Rpb24oZXhwb3J0cyxuYW1lLGdldHRlcil7LyoqKioqKi9pZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsbmFtZSkpey8qKioqKiovT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsbmFtZSx7ZW51bWVyYWJsZTp0cnVlLGdldDpnZXR0ZXJ9KTsvKioqKioqL30vKioqKioqL307LyoqKioqKi8gLyoqKioqKi8gLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi9fX3dlYnBhY2tfcmVxdWlyZV9fLnI9ZnVuY3Rpb24oZXhwb3J0cyl7LyoqKioqKi9pZih0eXBlb2YgU3ltYm9sIT09J3VuZGVmaW5lZCcmJlN5bWJvbC50b1N0cmluZ1RhZyl7LyoqKioqKi9PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOidNb2R1bGUnfSk7LyoqKioqKi99LyoqKioqKi9PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnX19lc01vZHVsZScse3ZhbHVlOnRydWV9KTsvKioqKioqL307LyoqKioqKi8gLyoqKioqKi8gLy8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyAvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gLy8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyAvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqL19fd2VicGFja19yZXF1aXJlX18udD1mdW5jdGlvbih2YWx1ZSxtb2RlKXsvKioqKioqL2lmKG1vZGUmMSl2YWx1ZT1fX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTsvKioqKioqL2lmKG1vZGUmOClyZXR1cm4gdmFsdWU7LyoqKioqKi9pZihtb2RlJjQmJl90eXBlb2YodmFsdWUpPT09J29iamVjdCcmJnZhbHVlJiZ2YWx1ZS5fX2VzTW9kdWxlKXJldHVybiB2YWx1ZTsvKioqKioqL3ZhciBucz1PYmplY3QuY3JlYXRlKG51bGwpOy8qKioqKiovX193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTsvKioqKioqL09iamVjdC5kZWZpbmVQcm9wZXJ0eShucywnZGVmYXVsdCcse2VudW1lcmFibGU6dHJ1ZSx2YWx1ZTp2YWx1ZX0pOy8qKioqKiovaWYobW9kZSYyJiZ0eXBlb2YgdmFsdWUhPSdzdHJpbmcnKWZvcih2YXIga2V5IGluIHZhbHVlKXtfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsa2V5LGZ1bmN0aW9uKGtleSl7cmV0dXJuIHZhbHVlW2tleV07fS5iaW5kKG51bGwsa2V5KSk7fS8qKioqKiovcmV0dXJuIG5zOy8qKioqKiovfTsvKioqKioqLyAvKioqKioqLyAvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm49ZnVuY3Rpb24obW9kdWxlKXsvKioqKioqL3ZhciBnZXR0ZXI9bW9kdWxlJiZtb2R1bGUuX19lc01vZHVsZT8vKioqKioqL2Z1bmN0aW9uIGdldERlZmF1bHQoKXtyZXR1cm4gbW9kdWxlWydkZWZhdWx0J107fTovKioqKioqL2Z1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKXtyZXR1cm4gbW9kdWxlO307LyoqKioqKi9fX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCdhJyxnZXR0ZXIpOy8qKioqKiovcmV0dXJuIGdldHRlcjsvKioqKioqL307LyoqKioqKi8gLyoqKioqKi8gLy8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqL19fd2VicGFja19yZXF1aXJlX18ubz1mdW5jdGlvbihvYmplY3QscHJvcGVydHkpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LHByb3BlcnR5KTt9Oy8qKioqKiovIC8qKioqKiovIC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqL19fd2VicGFja19yZXF1aXJlX18ucD1cIlwiOy8qKioqKiovIC8qKioqKiovIC8qKioqKiovIC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi9yZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnM9XCIuL3NyYy9qcy9hcHAuanNcIik7LyoqKioqKi99KSgvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKioqKioqL3svKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvY3JlYXRlUG9wcGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBwb3BwZXJHZW5lcmF0b3IsIGNyZWF0ZVBvcHBlciwgZGV0ZWN0T3ZlcmZsb3cgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJDcmVhdGVQb3BwZXJKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInBvcHBlckdlbmVyYXRvclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcG9wcGVyR2VuZXJhdG9yOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJjcmVhdGVQb3BwZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZVBvcHBlcjsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0Q29tcG9zaXRlUmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0TGF5b3V0UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfbGlzdFNjcm9sbFBhcmVudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0T2Zmc2V0UGFyZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0Q29tcHV0ZWRTdHlsZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19vcmRlck1vZGlmaWVyc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9vcmRlck1vZGlmaWVycy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19kZWJvdW5jZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9kZWJvdW5jZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc192YWxpZGF0ZU1vZGlmaWVyc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc191bmlxdWVCeV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy91bmlxdWVCeS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3VuaXF1ZUJ5LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tZXJnZUJ5TmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvbWVyZ2VCeU5hbWUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZGV0ZWN0T3ZlcmZsb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRldGVjdE92ZXJmbG93XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdXRpbHNfZGV0ZWN0T3ZlcmZsb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXFxcImRlZmF1bHRcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VudW1zLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG52YXIgSU5WQUxJRF9FTEVNRU5UX0VSUk9SID0gJ1BvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50Lic7XFxudmFyIElORklOSVRFX0xPT1BfRVJST1IgPSAnUG9wcGVyOiBBbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtb2RpZmllcnMgY3ljbGUgaGFzIGJlZW4gZGV0ZWN0ZWQhIFRoZSBjeWNsZSBoYXMgYmVlbiBpbnRlcnJ1cHRlZCB0byBwcmV2ZW50IGEgYnJvd3NlciBjcmFzaC4nO1xcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XFxuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxcbiAgbW9kaWZpZXJzOiBbXSxcXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXFxufTtcXG5cXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XFxuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XFxuICB9XFxuXFxuICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XFxuICB9KTtcXG59XFxuXFxuZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcXG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcXG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xcbiAgfVxcblxcbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XFxuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XFxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcXG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XFxuICAgIH1cXG5cXG4gICAgdmFyIHN0YXRlID0ge1xcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXFxuICAgICAgZWxlbWVudHM6IHtcXG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxcbiAgICAgICAgcG9wcGVyOiBwb3BwZXJcXG4gICAgICB9LFxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxcbiAgICAgIHN0eWxlczoge31cXG4gICAgfTtcXG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcXG4gICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XFxuICAgIHZhciBpbnN0YW5jZSA9IHtcXG4gICAgICBzdGF0ZTogc3RhdGUsXFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XFxuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XFxuICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcXG4gICAgICAgICAgcmVmZXJlbmNlOiBPYmplY3QoX2RvbV91dGlsc19pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fW1xcXCJpc0VsZW1lbnRcXFwiXSkocmVmZXJlbmNlKSA/IE9iamVjdChfZG9tX3V0aWxzX2xpc3RTY3JvbGxQYXJlbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IE9iamVjdChfZG9tX3V0aWxzX2xpc3RTY3JvbGxQYXJlbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxcbiAgICAgICAgICBwb3BwZXI6IE9iamVjdChfZG9tX3V0aWxzX2xpc3RTY3JvbGxQYXJlbnRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkocG9wcGVyKVxcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXFxuXFxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IE9iamVjdChfdXRpbHNfb3JkZXJNb2RpZmllcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiZGVmYXVsdFxcXCJdKShPYmplY3QoX3V0aWxzX21lcmdlQnlOYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1xcXCJkZWZhdWx0XFxcIl0pKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xcblxcbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XFxuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XFxuICAgICAgICB9KTsgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIG1vZGlmaWVycyBzbyB0aGF0IHRoZSBjb25zdW1lciB3aWxsIGdldCB3YXJuZWRcXG4gICAgICAgIC8vIGlmIG9uZSBvZiB0aGUgbW9kaWZpZXJzIGlzIGludmFsaWQgZm9yIGFueSByZWFzb25cXG5cXG4gICAgICAgIGlmICh0cnVlKSB7XFxuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSBPYmplY3QoX3V0aWxzX3VuaXF1ZUJ5X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXFxcImRlZmF1bHRcXFwiXSkoW10uY29uY2F0KG9yZGVyZWRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSwgZnVuY3Rpb24gKF9yZWYpIHtcXG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdChfdXRpbHNfdmFsaWRhdGVNb2RpZmllcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcXFwiZGVmYXVsdFxcXCJdKShtb2RpZmllcnMpO1xcblxcbiAgICAgICAgICBpZiAoT2JqZWN0KF91dGlsc19nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bXFxcImF1dG9cXFwiXSkge1xcbiAgICAgICAgICAgIHZhciBmbGlwTW9kaWZpZXIgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKF9yZWYyKSB7XFxuICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XFxuICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gJ2ZsaXAnO1xcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIGlmICghZmxpcE1vZGlmaWVyKSB7XFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcXFwiYXV0b1xcXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcXFwiZmxpcFxcXCIgbW9kaWZpZXIgYmUnLCAncHJlc2VudCBhbmQgZW5hYmxlZCB0byB3b3JrLiddLmpvaW4oJyAnKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IE9iamVjdChfZG9tX3V0aWxzX2dldENvbXB1dGVkU3R5bGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVmYXVsdFxcXCJdKShwb3BwZXIpLFxcbiAgICAgICAgICAgICAgbWFyZ2luVG9wID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luVG9wLFxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5SaWdodCxcXG4gICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpbkJvdHRvbSxcXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5MZWZ0OyAvLyBXZSBubyBsb25nZXIgdGFrZSBpbnRvIGFjY291bnQgYG1hcmdpbnNgIG9uIHRoZSBwb3BwZXIsIGFuZCBpdCBjYW5cXG4gICAgICAgICAgLy8gY2F1c2UgYnVncyB3aXRoIHBvc2l0aW9uaW5nLCBzbyB3ZSdsbCB3YXJuIHRoZSBjb25zdW1lclxcblxcblxcbiAgICAgICAgICBpZiAoW21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdF0uc29tZShmdW5jdGlvbiAobWFyZ2luKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWFyZ2luKTtcXG4gICAgICAgICAgfSkpIHtcXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcXFwibWFyZ2luXFxcIiBzdHlsZXMgY2Fubm90IGJlIHVzZWQgdG8gYXBwbHkgcGFkZGluZycsICdiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudCBvciBib3VuZGFyeS4nLCAnVG8gcmVwbGljYXRlIG1hcmdpbiwgdXNlIHRoZSBgb2Zmc2V0YCBtb2RpZmllciwgYXMgd2VsbCBhcycsICd0aGUgYHBhZGRpbmdgIG9wdGlvbiBpbiB0aGUgYHByZXZlbnRPdmVyZmxvd2AgYW5kIGBmbGlwYCcsICdtb2RpZmllcnMuJ10uam9pbignICcpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XFxuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XFxuICAgICAgfSxcXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcXG4gICAgICAvLyBsb2dpYy5cXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXFxuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcXG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcXG4gICAgICAgIC8vIGFueW1vcmVcXG5cXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcXG4gICAgICAgICAgaWYgKHRydWUpIHtcXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcXG5cXG5cXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xcbiAgICAgICAgICByZWZlcmVuY2U6IE9iamVjdChfZG9tX3V0aWxzX2dldENvbXBvc2l0ZVJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShyZWZlcmVuY2UsIE9iamVjdChfZG9tX3V0aWxzX2dldE9mZnNldFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl0pKHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxcbiAgICAgICAgICBwb3BwZXI6IE9iamVjdChfZG9tX3V0aWxzX2dldExheW91dFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShwb3BwZXIpXFxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXFxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XFxuXFxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXFxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXFxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcXG5cXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdmFyIF9fZGVidWdfbG9vcHNfXyA9IDA7XFxuXFxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcXG4gICAgICAgICAgaWYgKHRydWUpIHtcXG4gICAgICAgICAgICBfX2RlYnVnX2xvb3BzX18gKz0gMTtcXG5cXG4gICAgICAgICAgICBpZiAoX19kZWJ1Z19sb29wc19fID4gMTAwKSB7XFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKElORklOSVRFX0xPT1BfRVJST1IpO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XFxuICAgICAgICAgICAgaW5kZXggPSAtMTtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXFxuICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcXG4gICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxcbiAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xcblxcbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgc3RhdGUgPSBmbih7XFxuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXFxuICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcXG4gICAgICAgICAgICB9KSB8fCBzdGF0ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXFxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXFxuICAgICAgdXBkYXRlOiBPYmplY3QoX3V0aWxzX2RlYm91bmNlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcImRlZmF1bHRcXFwiXSkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XFxuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XFxuICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSksXFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcXG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcXG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcXG4gICAgICBpZiAodHJ1ZSkge1xcbiAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XFxuICAgIH1cXG5cXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XFxuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xcbiAgICAgIH1cXG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcXG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XFxuICAgIC8vIG9uZS5cXG5cXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcXG4gICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSxcXG4gICAgICAgICAgICBfcmVmMyRvcHRpb25zID0gX3JlZjMub3B0aW9ucyxcXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZjMkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyRvcHRpb25zLFxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYzLmVmZmVjdDtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSBlZmZlY3Qoe1xcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXFxuICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XFxuXFxuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcXG4gICAgICAgIHJldHVybiBmbigpO1xcbiAgICAgIH0pO1xcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gaW5zdGFuY2U7XFxuICB9O1xcbn1cXG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9jcmVhdGVQb3BwZXIuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNDb250YWluc0pzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29udGFpbnM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnN0YW5jZU9mLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XFxuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXFxuXFxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcXG4gIGVsc2UgaWYgKHJvb3ROb2RlICYmIE9iamVjdChfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJpc1NoYWRvd1Jvb3RcXFwiXSkocm9vdE5vZGUpKSB7XFxuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcXG5cXG4gICAgICBkbyB7XFxuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxcblxcblxcbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XFxuICAgICAgfSB3aGlsZSAobmV4dCk7XFxuICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxcblxcblxcbiAgcmV0dXJuIGZhbHNlO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRCb3VuZGluZ0NsaWVudFJlY3RKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdDsgfSk7XFxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcXG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gIHJldHVybiB7XFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxcbiAgICB0b3A6IHJlY3QudG9wLFxcbiAgICByaWdodDogcmVjdC5yaWdodCxcXG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSxcXG4gICAgbGVmdDogcmVjdC5sZWZ0LFxcbiAgICB4OiByZWN0LmxlZnQsXFxuICAgIHk6IHJlY3QudG9wXFxuICB9O1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0Q2xpcHBpbmdSZWN0SnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRDbGlwcGluZ1JlY3Q7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2VudW1zLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFZpZXdwb3J0UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRWaWV3cG9ydFJlY3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXREb2N1bWVudFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0RG9jdW1lbnRSZWN0LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGlzdFNjcm9sbFBhcmVudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGlzdFNjcm9sbFBhcmVudHMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldE9mZnNldFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRPZmZzZXRQYXJlbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXREb2N1bWVudEVsZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRDb21wdXRlZFN0eWxlLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW5zdGFuY2VPZi5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRCb3VuZGluZ0NsaWVudFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0UGFyZW50Tm9kZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRQYXJlbnROb2RlLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRhaW5zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250YWlucy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0Tm9kZU5hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldE5vZGVOYW1lLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19yZWN0VG9DbGllbnRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tYXRoLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qc1xcXCIpO1xcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcXG4gIHZhciByZWN0ID0gT2JqZWN0KF9nZXRCb3VuZGluZ0NsaWVudFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KTtcXG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcXG4gIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcXG4gIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcXG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xcbiAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XFxuICByZWN0LmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xcbiAgcmVjdC55ID0gcmVjdC50b3A7XFxuICByZXR1cm4gcmVjdDtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpIHtcXG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInZpZXdwb3J0XFxcIl0gPyBPYmplY3QoX3V0aWxzX3JlY3RUb0NsaWVudFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXFxcImRlZmF1bHRcXFwiXSkoT2JqZWN0KF9nZXRWaWV3cG9ydFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KSkgOiBPYmplY3QoX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcXFwiaXNIVE1MRWxlbWVudFxcXCJdKShjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCkgOiBPYmplY3QoX3V0aWxzX3JlY3RUb0NsaWVudFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXFxcImRlZmF1bHRcXFwiXSkoT2JqZWN0KF9nZXREb2N1bWVudFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKShPYmplY3QoX2dldERvY3VtZW50RWxlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpKSk7XFxufSAvLyBBIFxcXCJjbGlwcGluZyBwYXJlbnRcXFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2ZcXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cXG4vLyBgaW5pdGlhbGBcXG5cXG5cXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IE9iamVjdChfbGlzdFNjcm9sbFBhcmVudHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdKShPYmplY3QoX2dldFBhcmVudE5vZGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KSk7XFxuICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihPYmplY3QoX2dldENvbXB1dGVkU3R5bGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcXG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIE9iamVjdChfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJpc0hUTUxFbGVtZW50XFxcIl0pKGVsZW1lbnQpID8gT2JqZWN0KF9nZXRPZmZzZXRQYXJlbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KSA6IGVsZW1lbnQ7XFxuXFxuICBpZiAoIU9iamVjdChfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJpc0VsZW1lbnRcXFwiXSkoY2xpcHBlckVsZW1lbnQpKSB7XFxuICAgIHJldHVybiBbXTtcXG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzE0MTRcXG5cXG5cXG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xcbiAgICByZXR1cm4gT2JqZWN0KF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcImlzRWxlbWVudFxcXCJdKShjbGlwcGluZ1BhcmVudCkgJiYgT2JqZWN0KF9jb250YWluc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcXFwiZGVmYXVsdFxcXCJdKShjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIE9iamVjdChfZ2V0Tm9kZU5hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXFxcImRlZmF1bHRcXFwiXSkoY2xpcHBpbmdQYXJlbnQpICE9PSAnYm9keSc7XFxuICB9KTtcXG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2ZcXG4vLyBjbGlwcGluZyBwYXJlbnRzXFxuXFxuXFxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KGVsZW1lbnQsIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpIHtcXG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcXG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XFxuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcXG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCk7XFxuICAgIGFjY1JlY3QudG9wID0gT2JqZWN0KF91dGlsc19tYXRoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1xcXCJtYXhcXFwiXSkocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcXG4gICAgYWNjUmVjdC5yaWdodCA9IE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcXFwibWluXFxcIl0pKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xcbiAgICBhY2NSZWN0LmJvdHRvbSA9IE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcXFwibWluXFxcIl0pKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XFxuICAgIGFjY1JlY3QubGVmdCA9IE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcXFwibWF4XFxcIl0pKHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcXG4gICAgcmV0dXJuIGFjY1JlY3Q7XFxuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50KSk7XFxuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcXG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcXG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XFxuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XFxuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldENvbXBvc2l0ZVJlY3RKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldENvbXBvc2l0ZVJlY3Q7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0Qm91bmRpbmdDbGllbnRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldE5vZGVTY3JvbGxfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0Tm9kZVNjcm9sbC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXROb2RlTmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXROb2RlTmFtZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnN0YW5jZU9mLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFdpbmRvd1Njcm9sbEJhclhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXREb2N1bWVudEVsZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaXNTY3JvbGxQYXJlbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNTY3JvbGxQYXJlbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG4gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50Llxcbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cXG5cXG5mdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcXG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcXG4gICAgaXNGaXhlZCA9IGZhbHNlO1xcbiAgfVxcblxcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IE9iamVjdChfZ2V0RG9jdW1lbnRFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcImRlZmF1bHRcXFwiXSkob2Zmc2V0UGFyZW50KTtcXG4gIHZhciByZWN0ID0gT2JqZWN0KF9nZXRCb3VuZGluZ0NsaWVudFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCk7XFxuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBPYmplY3QoX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiaXNIVE1MRWxlbWVudFxcXCJdKShvZmZzZXRQYXJlbnQpO1xcbiAgdmFyIHNjcm9sbCA9IHtcXG4gICAgc2Nyb2xsTGVmdDogMCxcXG4gICAgc2Nyb2xsVG9wOiAwXFxuICB9O1xcbiAgdmFyIG9mZnNldHMgPSB7XFxuICAgIHg6IDAsXFxuICAgIHk6IDBcXG4gIH07XFxuXFxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XFxuICAgIGlmIChPYmplY3QoX2dldE5vZGVOYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxcbiAgICBPYmplY3QoX2lzU2Nyb2xsUGFyZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcImRlZmF1bHRcXFwiXSkoZG9jdW1lbnRFbGVtZW50KSkge1xcbiAgICAgIHNjcm9sbCA9IE9iamVjdChfZ2V0Tm9kZVNjcm9sbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKG9mZnNldFBhcmVudCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKE9iamVjdChfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJpc0hUTUxFbGVtZW50XFxcIl0pKG9mZnNldFBhcmVudCkpIHtcXG4gICAgICBvZmZzZXRzID0gT2JqZWN0KF9nZXRCb3VuZGluZ0NsaWVudFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShvZmZzZXRQYXJlbnQpO1xcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcXG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcXG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcXG4gICAgICBvZmZzZXRzLnggPSBPYmplY3QoX2dldFdpbmRvd1Njcm9sbEJhclhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVmYXVsdFxcXCJdKShkb2N1bWVudEVsZW1lbnQpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4ge1xcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxcbiAgfTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0Q29tcHV0ZWRTdHlsZUpzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZTsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRXaW5kb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0V2luZG93LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xcbiAgcmV0dXJuIE9iamVjdChfZ2V0V2luZG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXREb2N1bWVudEVsZW1lbnRKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldERvY3VtZW50RWxlbWVudDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2luc3RhbmNlT2YuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XFxuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXFxuICByZXR1cm4gKChPYmplY3QoX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiaXNFbGVtZW50XFxcIl0pKGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXFxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldERvY3VtZW50UmVjdEpzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0RG9jdW1lbnRSZWN0OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldERvY3VtZW50RWxlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXREb2N1bWVudEVsZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRDb21wdXRlZFN0eWxlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldENvbXB1dGVkU3R5bGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0V2luZG93U2Nyb2xsQmFyWF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFdpbmRvd1Njcm9sbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRXaW5kb3dTY3JvbGwuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19tYXRoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tYXRoLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qc1xcXCIpO1xcblxcblxcblxcblxcbiAvLyBHZXRzIHRoZSBlbnRpcmUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBkb2N1bWVudCBhcmVhLCBldmVuIGV4dGVuZGluZyBvdXRzaWRlXFxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxcblxcbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XFxuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xcblxcbiAgdmFyIGh0bWwgPSBPYmplY3QoX2dldERvY3VtZW50RWxlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpO1xcbiAgdmFyIHdpblNjcm9sbCA9IE9iamVjdChfZ2V0V2luZG93U2Nyb2xsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCk7XFxuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcXG4gIHZhciB3aWR0aCA9IE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJtYXhcXFwiXSkoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xcbiAgdmFyIGhlaWdodCA9IE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJtYXhcXFwiXSkoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcXG4gIHZhciB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgT2JqZWN0KF9nZXRXaW5kb3dTY3JvbGxCYXJYX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCk7XFxuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xcblxcbiAgaWYgKE9iamVjdChfZ2V0Q29tcHV0ZWRTdHlsZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xcbiAgICB4ICs9IE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJtYXhcXFwiXSkoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xcbiAgfVxcblxcbiAgcmV0dXJuIHtcXG4gICAgd2lkdGg6IHdpZHRoLFxcbiAgICBoZWlnaHQ6IGhlaWdodCxcXG4gICAgeDogeCxcXG4gICAgeTogeVxcbiAgfTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRIVE1MRWxlbWVudFNjcm9sbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0SFRNTEVsZW1lbnRTY3JvbGxKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsOyB9KTtcXG5mdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XFxuICByZXR1cm4ge1xcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcXG4gIH07XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRMYXlvdXRSZWN0SnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRMYXlvdXRSZWN0OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldEJvdW5kaW5nQ2xpZW50UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXFxcIik7XFxuIC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxcblxcbmZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xcbiAgdmFyIGNsaWVudFJlY3QgPSBPYmplY3QoX2dldEJvdW5kaW5nQ2xpZW50UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpOyAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xcblxcbiAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcXG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcXG5cXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LndpZHRoIC0gd2lkdGgpIDw9IDEpIHtcXG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xcbiAgfVxcblxcbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XFxuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xcbiAgfVxcblxcbiAgcmV0dXJuIHtcXG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcXG4gICAgd2lkdGg6IHdpZHRoLFxcbiAgICBoZWlnaHQ6IGhlaWdodFxcbiAgfTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldE5vZGVOYW1lSnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXROb2RlTmFtZTsgfSk7XFxuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZVNjcm9sbC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZVNjcm9sbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXROb2RlU2Nyb2xsSnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXROb2RlU2Nyb2xsOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFdpbmRvd1Njcm9sbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRXaW5kb3dTY3JvbGwuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRXaW5kb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0V2luZG93LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnN0YW5jZU9mLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldEhUTUxFbGVtZW50U2Nyb2xsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XFxuICBpZiAobm9kZSA9PT0gT2JqZWN0KF9nZXRXaW5kb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShub2RlKSB8fCAhT2JqZWN0KF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImlzSFRNTEVsZW1lbnRcXFwiXSkobm9kZSkpIHtcXG4gICAgcmV0dXJuIE9iamVjdChfZ2V0V2luZG93U2Nyb2xsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkobm9kZSk7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gT2JqZWN0KF9nZXRIVE1MRWxlbWVudFNjcm9sbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl0pKG5vZGUpO1xcbiAgfVxcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldE9mZnNldFBhcmVudEpzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRXaW5kb3cuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXROb2RlTmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXROb2RlTmFtZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRDb21wdXRlZFN0eWxlLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW5zdGFuY2VPZi5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc1RhYmxlRWxlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1RhYmxlRWxlbWVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0UGFyZW50Tm9kZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRQYXJlbnROb2RlLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcXG4gIGlmICghT2JqZWN0KF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImlzSFRNTEVsZW1lbnRcXFwiXSkoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcXG4gIE9iamVjdChfZ2V0Q29tcHV0ZWRTdHlsZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XFxuICAgIHJldHVybiBudWxsO1xcbiAgfVxcblxcbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xcbn0gLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcXG5cXG5cXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xcbiAgdmFyIGlzRmlyZWZveCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xO1xcbiAgdmFyIGlzSUUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSAhPT0gLTE7XFxuXFxuICBpZiAoaXNJRSAmJiBPYmplY3QoX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiaXNIVE1MRWxlbWVudFxcXCJdKShlbGVtZW50KSkge1xcbiAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XFxuICAgIHZhciBlbGVtZW50Q3NzID0gT2JqZWN0KF9nZXRDb21wdXRlZFN0eWxlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCk7XFxuXFxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBjdXJyZW50Tm9kZSA9IE9iamVjdChfZ2V0UGFyZW50Tm9kZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpO1xcblxcbiAgd2hpbGUgKE9iamVjdChfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJpc0hUTUxFbGVtZW50XFxcIl0pKGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoT2JqZWN0KF9nZXROb2RlTmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKGN1cnJlbnROb2RlKSkgPCAwKSB7XFxuICAgIHZhciBjc3MgPSBPYmplY3QoX2dldENvbXB1dGVkU3R5bGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxcbiAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xcblxcbiAgICBpZiAoY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8IGNzcy5jb250YWluID09PSAncGFpbnQnIHx8IFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5kZXhPZihjc3Mud2lsbENoYW5nZSkgIT09IC0xIHx8IGlzRmlyZWZveCAmJiBjc3Mud2lsbENoYW5nZSA9PT0gJ2ZpbHRlcicgfHwgaXNGaXJlZm94ICYmIGNzcy5maWx0ZXIgJiYgY3NzLmZpbHRlciAhPT0gJ25vbmUnKSB7XFxuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIG51bGw7XFxufSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cXG5cXG5cXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xcbiAgdmFyIHdpbmRvdyA9IE9iamVjdChfZ2V0V2luZG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCk7XFxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcXG5cXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgT2JqZWN0KF9pc1RhYmxlRWxlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl0pKG9mZnNldFBhcmVudCkgJiYgT2JqZWN0KF9nZXRDb21wdXRlZFN0eWxlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcXG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xcbiAgfVxcblxcbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoT2JqZWN0KF9nZXROb2RlTmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBPYmplY3QoX2dldE5vZGVOYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIE9iamVjdChfZ2V0Q29tcHV0ZWRTdHlsZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xcbiAgICByZXR1cm4gd2luZG93O1xcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldFBhcmVudE5vZGVKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFBhcmVudE5vZGU7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0Tm9kZU5hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0Tm9kZU5hbWUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldERvY3VtZW50RWxlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXREb2N1bWVudEVsZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2luc3RhbmNlT2YuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1xcXCIpO1xcblxcblxcblxcbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xcbiAgaWYgKE9iamVjdChfZ2V0Tm9kZU5hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XFxuICAgIHJldHVybiBlbGVtZW50O1xcbiAgfVxcblxcbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXFxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxcbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxcbiAgICBPYmplY3QoX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiaXNTaGFkb3dSb290XFxcIl0pKGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXFxuICAgIE9iamVjdChfZ2V0RG9jdW1lbnRFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCkgLy8gZmFsbGJhY2tcXG5cXG4gICk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0U2Nyb2xsUGFyZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0U2Nyb2xsUGFyZW50SnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRTY3JvbGxQYXJlbnQ7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0UGFyZW50Tm9kZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRQYXJlbnROb2RlLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2lzU2Nyb2xsUGFyZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzU2Nyb2xsUGFyZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXROb2RlTmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXROb2RlTmFtZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbnN0YW5jZU9mLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoT2JqZWN0KF9nZXROb2RlTmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKG5vZGUpKSA+PSAwKSB7XFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xcbiAgfVxcblxcbiAgaWYgKE9iamVjdChfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJpc0hUTUxFbGVtZW50XFxcIl0pKG5vZGUpICYmIE9iamVjdChfaXNTY3JvbGxQYXJlbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShub2RlKSkge1xcbiAgICByZXR1cm4gbm9kZTtcXG4gIH1cXG5cXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoT2JqZWN0KF9nZXRQYXJlbnROb2RlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkobm9kZSkpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0Vmlld3BvcnRSZWN0SnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRWaWV3cG9ydFJlY3Q7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0V2luZG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldFdpbmRvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldERvY3VtZW50RWxlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXREb2N1bWVudEVsZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRXaW5kb3dTY3JvbGxCYXJYX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldFdpbmRvd1Njcm9sbEJhclguanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1xcXCIpO1xcblxcblxcblxcbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSB7XFxuICB2YXIgd2luID0gT2JqZWN0KF9nZXRXaW5kb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KTtcXG4gIHZhciBodG1sID0gT2JqZWN0KF9nZXREb2N1bWVudEVsZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KTtcXG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcXG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XFxuICB2YXIgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XFxuICB2YXIgeCA9IDA7XFxuICB2YXIgeSA9IDA7IC8vIE5COiBUaGlzIGlzbid0IHN1cHBvcnRlZCBvbiBpT1MgPD0gMTIuIElmIHRoZSBrZXlib2FyZCBpcyBvcGVuLCB0aGUgcG9wcGVyXFxuICAvLyBjYW4gYmUgb2JzY3VyZWQgdW5kZXJuZWF0aCBpdC5cXG4gIC8vIEFsc28sIGBodG1sLmNsaWVudEhlaWdodGAgYWRkcyB0aGUgYm90dG9tIGJhciBoZWlnaHQgaW4gU2FmYXJpIGlPUywgZXZlblxcbiAgLy8gaWYgaXQgaXNuJ3Qgb3Blbiwgc28gaWYgdGhpcyBpc24ndCBhdmFpbGFibGUsIHRoZSBwb3BwZXIgd2lsbCBiZSBkZXRlY3RlZFxcbiAgLy8gdG8gb3ZlcmZsb3cgdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIHRvbyBlYXJseS5cXG5cXG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7IC8vIFVzZXMgTGF5b3V0IFZpZXdwb3J0IChsaWtlIENocm9tZTsgU2FmYXJpIGRvZXMgbm90IGN1cnJlbnRseSlcXG4gICAgLy8gSW4gQ2hyb21lLCBpdCByZXR1cm5zIGEgdmFsdWUgdmVyeSBjbG9zZSB0byAwICgrLy0pIGJ1dCBjb250YWlucyByb3VuZGluZ1xcbiAgICAvLyBlcnJvcnMgZHVlIHRvIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIHNvIHdlIG5lZWQgdG8gY2hlY2sgcHJlY2lzaW9uLlxcbiAgICAvLyBTYWZhcmkgcmV0dXJucyBhIG51bWJlciA8PSAwLCB1c3VhbGx5IDwgLTEgd2hlbiBwaW5jaC16b29tZWRcXG4gICAgLy8gRmVhdHVyZSBkZXRlY3Rpb24gZmFpbHMgaW4gbW9iaWxlIGVtdWxhdGlvbiBtb2RlIGluIENocm9tZS5cXG4gICAgLy8gTWF0aC5hYnMod2luLmlubmVyV2lkdGggLyB2aXN1YWxWaWV3cG9ydC5zY2FsZSAtIHZpc3VhbFZpZXdwb3J0LndpZHRoKSA8XFxuICAgIC8vIDAuMDAxXFxuICAgIC8vIEZhbGxiYWNrIGhlcmU6IFxcXCJOb3QgU2FmYXJpXFxcIiB1c2VyQWdlbnRcXG5cXG4gICAgaWYgKCEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XFxuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XFxuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHtcXG4gICAgd2lkdGg6IHdpZHRoLFxcbiAgICBoZWlnaHQ6IGhlaWdodCxcXG4gICAgeDogeCArIE9iamVjdChfZ2V0V2luZG93U2Nyb2xsQmFyWF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpLFxcbiAgICB5OiB5XFxuICB9O1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0V2luZG93SnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRXaW5kb3c7IH0pO1xcbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XFxuICBpZiAobm9kZSA9PSBudWxsKSB7XFxuICAgIHJldHVybiB3aW5kb3c7XFxuICB9XFxuXFxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcXG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcXG4gIH1cXG5cXG4gIHJldHVybiBub2RlO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0V2luZG93U2Nyb2xsSnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRXaW5kb3dTY3JvbGw7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0V2luZG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldFdpbmRvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xcbiAgdmFyIHdpbiA9IE9iamVjdChfZ2V0V2luZG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkobm9kZSk7XFxuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcXG4gIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XFxuICByZXR1cm4ge1xcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxcbiAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxcbiAgfTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRXaW5kb3dTY3JvbGxCYXJYSnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRXaW5kb3dTY3JvbGxCYXJYOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldEJvdW5kaW5nQ2xpZW50UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXREb2N1bWVudEVsZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0V2luZG93U2Nyb2xsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldFdpbmRvd1Njcm9sbC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanNcXFwiKTtcXG5cXG5cXG5cXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcXG4gIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxcbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcXG4gIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cXG4gIC8vIGFueXdheS5cXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXFxuICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxcbiAgcmV0dXJuIE9iamVjdChfZ2V0Qm91bmRpbmdDbGllbnRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoT2JqZWN0KF9nZXREb2N1bWVudEVsZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KSkubGVmdCArIE9iamVjdChfZ2V0V2luZG93U2Nyb2xsX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCkuc2Nyb2xsTGVmdDtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0luc3RhbmNlT2ZKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImlzRWxlbWVudFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNFbGVtZW50OyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJpc0hUTUxFbGVtZW50XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc0hUTUxFbGVtZW50OyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJpc1NoYWRvd1Jvb3RcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzU2hhZG93Um9vdDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRXaW5kb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0V2luZG93LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XFxuICB2YXIgT3duRWxlbWVudCA9IE9iamVjdChfZ2V0V2luZG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkobm9kZSkuRWxlbWVudDtcXG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcXG59XFxuXFxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XFxuICB2YXIgT3duRWxlbWVudCA9IE9iamVjdChfZ2V0V2luZG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkobm9kZSkuSFRNTEVsZW1lbnQ7XFxuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xcbn1cXG5cXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcXG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgdmFyIE93bkVsZW1lbnQgPSBPYmplY3QoX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKG5vZGUpLlNoYWRvd1Jvb3Q7XFxuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XFxufVxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNJc1Njcm9sbFBhcmVudEpzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNTY3JvbGxQYXJlbnQ7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRDb21wdXRlZFN0eWxlLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBpc1Njcm9sbFBhcmVudChlbGVtZW50KSB7XFxuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBPYmplY3QoX2dldENvbXB1dGVkU3R5bGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShlbGVtZW50KSxcXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1k7XFxuXFxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNJc1RhYmxlRWxlbWVudEpzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNUYWJsZUVsZW1lbnQ7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0Tm9kZU5hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0Tm9kZU5hbWUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XFxuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoT2JqZWN0KF9nZXROb2RlTmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpKSA+PSAwO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0xpc3RTY3JvbGxQYXJlbnRzSnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsaXN0U2Nyb2xsUGFyZW50czsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRTY3JvbGxQYXJlbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0U2Nyb2xsUGFyZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0UGFyZW50Tm9kZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRQYXJlbnROb2RlLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRXaW5kb3cuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pc1Njcm9sbFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1Njcm9sbFBhcmVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qc1xcXCIpO1xcblxcblxcblxcblxcbi8qXFxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcXG51bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxcbiovXFxuXFxuZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcXG5cXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcXG4gICAgbGlzdCA9IFtdO1xcbiAgfVxcblxcbiAgdmFyIHNjcm9sbFBhcmVudCA9IE9iamVjdChfZ2V0U2Nyb2xsUGFyZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCk7XFxuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcXG4gIHZhciB3aW4gPSBPYmplY3QoX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKHNjcm9sbFBhcmVudCk7XFxuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgT2JqZWN0KF9pc1Njcm9sbFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl0pKHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XFxuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXFxuICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoT2JqZWN0KF9nZXRQYXJlbnROb2RlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkodGFyZ2V0KSkpO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0LCBhdXRvLCBiYXNlUGxhY2VtZW50cywgc3RhcnQsIGVuZCwgY2xpcHBpbmdQYXJlbnRzLCB2aWV3cG9ydCwgcG9wcGVyLCByZWZlcmVuY2UsIHZhcmlhdGlvblBsYWNlbWVudHMsIHBsYWNlbWVudHMsIGJlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGUsIG1vZGlmaWVyUGhhc2VzICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRW51bXNKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInRvcFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdG9wOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJib3R0b21cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJvdHRvbTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmlnaHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJpZ2h0OyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJsZWZ0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsZWZ0OyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhdXRvXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhdXRvOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJiYXNlUGxhY2VtZW50c1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmFzZVBsYWNlbWVudHM7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInN0YXJ0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzdGFydDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZW5kXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBlbmQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNsaXBwaW5nUGFyZW50c1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2xpcHBpbmdQYXJlbnRzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ2aWV3cG9ydFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdmlld3BvcnQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInBvcHBlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcG9wcGVyOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyZWZlcmVuY2VcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlZmVyZW5jZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidmFyaWF0aW9uUGxhY2VtZW50c1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdmFyaWF0aW9uUGxhY2VtZW50czsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicGxhY2VtZW50c1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGxhY2VtZW50czsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYmVmb3JlUmVhZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmVmb3JlUmVhZDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicmVhZFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVhZDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYWZ0ZXJSZWFkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhZnRlclJlYWQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImJlZm9yZU1haW5cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJlZm9yZU1haW47IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm1haW5cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1haW47IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFmdGVyTWFpblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYWZ0ZXJNYWluOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJiZWZvcmVXcml0ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYmVmb3JlV3JpdGU7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIndyaXRlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB3cml0ZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYWZ0ZXJXcml0ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYWZ0ZXJXcml0ZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibW9kaWZpZXJQaGFzZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1vZGlmaWVyUGhhc2VzOyB9KTtcXG52YXIgdG9wID0gJ3RvcCc7XFxudmFyIGJvdHRvbSA9ICdib3R0b20nO1xcbnZhciByaWdodCA9ICdyaWdodCc7XFxudmFyIGxlZnQgPSAnbGVmdCc7XFxudmFyIGF1dG8gPSAnYXV0byc7XFxudmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XFxudmFyIHN0YXJ0ID0gJ3N0YXJ0JztcXG52YXIgZW5kID0gJ2VuZCc7XFxudmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xcbnZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XFxudmFyIHBvcHBlciA9ICdwb3BwZXInO1xcbnZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcXG52YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XFxuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXFxcIi1cXFwiICsgc3RhcnQsIHBsYWNlbWVudCArIFxcXCItXFxcIiArIGVuZF0pO1xcbn0sIFtdKTtcXG52YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXFxcIi1cXFwiICsgc3RhcnQsIHBsYWNlbWVudCArIFxcXCItXFxcIiArIGVuZF0pO1xcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cXG5cXG52YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcXG52YXIgcmVhZCA9ICdyZWFkJztcXG52YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXFxuXFxudmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XFxudmFyIG1haW4gPSAnbWFpbic7XFxudmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXFxuXFxudmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcXG52YXIgd3JpdGUgPSAnd3JpdGUnO1xcbnZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xcbnZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9pbmRleC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiB0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnQsIGF1dG8sIGJhc2VQbGFjZW1lbnRzLCBzdGFydCwgZW5kLCBjbGlwcGluZ1BhcmVudHMsIHZpZXdwb3J0LCBwb3BwZXIsIHJlZmVyZW5jZSwgdmFyaWF0aW9uUGxhY2VtZW50cywgcGxhY2VtZW50cywgYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZSwgbW9kaWZpZXJQaGFzZXMsIGFwcGx5U3R5bGVzLCBhcnJvdywgY29tcHV0ZVN0eWxlcywgZXZlbnRMaXN0ZW5lcnMsIGZsaXAsIGhpZGUsIG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcHJldmVudE92ZXJmbG93LCBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93LCBjcmVhdGVQb3BwZXJCYXNlLCBjcmVhdGVQb3BwZXIsIGNyZWF0ZVBvcHBlckxpdGUgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJJbmRleEpzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lbnVtcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ0b3BcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ0b3BcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJib3R0b21cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJib3R0b21cXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJyaWdodFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInJpZ2h0XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibGVmdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImxlZnRcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhdXRvXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiYXV0b1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImJhc2VQbGFjZW1lbnRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiYmFzZVBsYWNlbWVudHNcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJzdGFydFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInN0YXJ0XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZW5kXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZW5kXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY2xpcHBpbmdQYXJlbnRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiY2xpcHBpbmdQYXJlbnRzXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwidmlld3BvcnRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ2aWV3cG9ydFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInBvcHBlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInBvcHBlclxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJlZmVyZW5jZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInJlZmVyZW5jZVxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInZhcmlhdGlvblBsYWNlbWVudHNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJ2YXJpYXRpb25QbGFjZW1lbnRzXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicGxhY2VtZW50c1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInBsYWNlbWVudHNcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJiZWZvcmVSZWFkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiYmVmb3JlUmVhZFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInJlYWRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJyZWFkXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYWZ0ZXJSZWFkXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiYWZ0ZXJSZWFkXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYmVmb3JlTWFpblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImJlZm9yZU1haW5cXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJtYWluXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwibWFpblxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImFmdGVyTWFpblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImFmdGVyTWFpblxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImJlZm9yZVdyaXRlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiYmVmb3JlV3JpdGVcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJ3cml0ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIndyaXRlXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYWZ0ZXJXcml0ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImFmdGVyV3JpdGVcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJtb2RpZmllclBoYXNlc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIm1vZGlmaWVyUGhhc2VzXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGlmaWVycy9pbmRleC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYXBwbHlTdHlsZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tb2RpZmllcnNfaW5kZXhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiYXBwbHlTdHlsZXNcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhcnJvd1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21vZGlmaWVyc19pbmRleF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJhcnJvd1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNvbXB1dGVTdHlsZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tb2RpZmllcnNfaW5kZXhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiY29tcHV0ZVN0eWxlc1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImV2ZW50TGlzdGVuZXJzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImV2ZW50TGlzdGVuZXJzXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZmxpcFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21vZGlmaWVyc19pbmRleF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJmbGlwXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaGlkZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21vZGlmaWVyc19pbmRleF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJoaWRlXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwib2Zmc2V0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIm9mZnNldFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInBvcHBlck9mZnNldHNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tb2RpZmllcnNfaW5kZXhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwicG9wcGVyT2Zmc2V0c1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInByZXZlbnRPdmVyZmxvd1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21vZGlmaWVyc19pbmRleF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJwcmV2ZW50T3ZlcmZsb3dcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jcmVhdGVQb3BwZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY3JlYXRlUG9wcGVyLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvY3JlYXRlUG9wcGVyLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJwb3BwZXJHZW5lcmF0b3JcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9jcmVhdGVQb3BwZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwicG9wcGVyR2VuZXJhdG9yXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGV0ZWN0T3ZlcmZsb3dcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9jcmVhdGVQb3BwZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGV0ZWN0T3ZlcmZsb3dcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJjcmVhdGVQb3BwZXJCYXNlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfY3JlYXRlUG9wcGVyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImNyZWF0ZVBvcHBlclxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BvcHBlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wb3BwZXIuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNyZWF0ZVBvcHBlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3BvcHBlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJjcmVhdGVQb3BwZXJcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wb3BwZXJfbGl0ZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wb3BwZXItbGl0ZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci1saXRlLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJjcmVhdGVQb3BwZXJMaXRlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfcG9wcGVyX2xpdGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiY3JlYXRlUG9wcGVyXFxcIl07IH0pO1xcblxcblxcbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxuIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG4gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvaW5kZXguanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzQXBwbHlTdHlsZXNKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldE5vZGVOYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RvbV91dGlsc19pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXFxcIik7XFxuXFxuIC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXFxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xcblxcbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XFxuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XFxuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcXG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXFxuXFxuICAgIGlmICghT2JqZWN0KF9kb21fdXRpbHNfaW5zdGFuY2VPZl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJpc0hUTUxFbGVtZW50XFxcIl0pKGVsZW1lbnQpIHx8ICFPYmplY3QoX2RvbV91dGlsc19nZXROb2RlTmFtZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKGVsZW1lbnQpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cXG5cXG5cXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XFxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcXG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xcblxcbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9KTtcXG59XFxuXFxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XFxuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcXG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xcbiAgICBwb3BwZXI6IHtcXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcXG4gICAgICBsZWZ0OiAnMCcsXFxuICAgICAgdG9wOiAnMCcsXFxuICAgICAgbWFyZ2luOiAnMCdcXG4gICAgfSxcXG4gICAgYXJyb3c6IHtcXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xcbiAgICB9LFxcbiAgICByZWZlcmVuY2U6IHt9XFxuICB9O1xcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcXG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XFxuXFxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcXG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XFxuICB9XFxuXFxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XFxuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xcbiAgICAgIHZhciBzdHlsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBzdGF0ZS5zdHlsZXNbbmFtZV0gOiBpbml0aWFsU3R5bGVzW25hbWVdKTsgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cXG5cXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcXG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXFxuXFxuICAgICAgaWYgKCFPYmplY3QoX2RvbV91dGlsc19pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImlzSFRNTEVsZW1lbnRcXFwiXSkoZWxlbWVudCkgfHwgIU9iamVjdChfZG9tX3V0aWxzX2dldE5vZGVOYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoZWxlbWVudCkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XFxuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XFxuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xcbiAgICAgIH0pO1xcbiAgICB9KTtcXG4gIH07XFxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1xcXCJkZWZhdWx0XFxcIl0gPSAoe1xcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcXG4gIGVuYWJsZWQ6IHRydWUsXFxuICBwaGFzZTogJ3dyaXRlJyxcXG4gIGZuOiBhcHBseVN0eWxlcyxcXG4gIGVmZmVjdDogZWZmZWN0LFxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzQXJyb3dKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZ2V0QmFzZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RvbV91dGlsc19nZXRMYXlvdXRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfY29udGFpbnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RvbS11dGlscy9jb250YWlucy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldE9mZnNldFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2dldE1haW5BeGlzRnJvbVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc193aXRoaW5fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL3dpdGhpbi5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbWVyZ2VQYWRkaW5nT2JqZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2V4cGFuZFRvSGFzaE1hcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZW51bXMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xcblxcbnZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcXG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcXG4gIH0pKSA6IHBhZGRpbmc7XFxuICByZXR1cm4gT2JqZWN0KF91dGlsc19tZXJnZVBhZGRpbmdPYmplY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiZGVmYXVsdFxcXCJdKSh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogT2JqZWN0KF91dGlsc19leHBhbmRUb0hhc2hNYXBfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcXFwiZGVmYXVsdFxcXCJdKShwYWRkaW5nLCBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcXFwiYmFzZVBsYWNlbWVudHNcXFwiXSkpO1xcbn07XFxuXFxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcXG5cXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XFxuICB2YXIgYmFzZVBsYWNlbWVudCA9IE9iamVjdChfdXRpbHNfZ2V0QmFzZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKHN0YXRlLnBsYWNlbWVudCk7XFxuICB2YXIgYXhpcyA9IE9iamVjdChfdXRpbHNfZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXSkoYmFzZVBsYWNlbWVudCk7XFxuICB2YXIgaXNWZXJ0aWNhbCA9IFtfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcXFwibGVmdFxcXCJdLCBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcXFwicmlnaHRcXFwiXV0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XFxuXFxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcXG4gIHZhciBhcnJvd1JlY3QgPSBPYmplY3QoX2RvbV91dGlsc19nZXRMYXlvdXRSZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoYXJyb3dFbGVtZW50KTtcXG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXFxcInRvcFxcXCJdIDogX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXFxcImxlZnRcXFwiXTtcXG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXFxcImJvdHRvbVxcXCJdIDogX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXFxcInJpZ2h0XFxcIl07XFxuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XFxuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBPYmplY3QoX2RvbV91dGlsc19nZXRPZmZzZXRQYXJlbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdKShhcnJvd0VsZW1lbnQpO1xcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XFxuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcXG5cXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XFxuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcXG4gIHZhciBvZmZzZXQgPSBPYmplY3QoX3V0aWxzX3dpdGhpbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJkZWZhdWx0XFxcIl0pKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXFxuXFxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcXG59XFxuXFxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XFxuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcXG4gIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxcbiAgICAgIGFycm93RWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/ICdbZGF0YS1wb3BwZXItYXJyb3ddJyA6IF9vcHRpb25zJGVsZW1lbnQ7XFxuXFxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcXG4gICAgcmV0dXJuO1xcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcXG5cXG5cXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xcblxcbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKHRydWUpIHtcXG4gICAgaWYgKCFPYmplY3QoX2RvbV91dGlsc19pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXFxcImlzSFRNTEVsZW1lbnRcXFwiXSkoYXJyb3dFbGVtZW50KSkge1xcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFxcXCJhcnJvd1xcXCIgZWxlbWVudCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50IChub3QgYW4gU1ZHRWxlbWVudCkuJywgJ1RvIHVzZSBhbiBTVkcgYXJyb3csIHdyYXAgaXQgaW4gYW4gSFRNTEVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMnLCAndGhlIGFycm93LiddLmpvaW4oJyAnKSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmICghT2JqZWN0KF9kb21fdXRpbHNfY29udGFpbnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKShzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcXG4gICAgaWYgKHRydWUpIHtcXG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcXFwiYXJyb3dcXFwiIG1vZGlmaWVyXFxcXCdzIGBlbGVtZW50YCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIHBvcHBlcicsICdlbGVtZW50LiddLmpvaW4oJyAnKSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XFxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1xcXCJkZWZhdWx0XFxcIl0gPSAoe1xcbiAgbmFtZTogJ2Fycm93JyxcXG4gIGVuYWJsZWQ6IHRydWUsXFxuICBwaGFzZTogJ21haW4nLFxcbiAgZm46IGFycm93LFxcbiAgZWZmZWN0OiBlZmZlY3QsXFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXJyb3cuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IG1hcFRvU3R5bGVzLCBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzQ29tcHV0ZVN0eWxlc0pzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwibWFwVG9TdHlsZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1hcFRvU3R5bGVzOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lbnVtcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0T2Zmc2V0UGFyZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RvbV91dGlsc19nZXREb2N1bWVudEVsZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0Q29tcHV0ZWRTdHlsZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZ2V0QmFzZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL21hdGguanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tYXRoLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuXFxuIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG52YXIgdW5zZXRTaWRlcyA9IHtcXG4gIHRvcDogJ2F1dG8nLFxcbiAgcmlnaHQ6ICdhdXRvJyxcXG4gIGJvdHRvbTogJ2F1dG8nLFxcbiAgbGVmdDogJ2F1dG8nXFxufTsgLy8gUm91bmQgdGhlIG9mZnNldHMgdG8gdGhlIG5lYXJlc3Qgc3VpdGFibGUgc3VicGl4ZWwgYmFzZWQgb24gdGhlIERQUi5cXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxcblxcbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYpIHtcXG4gIHZhciB4ID0gX3JlZi54LFxcbiAgICAgIHkgPSBfcmVmLnk7XFxuICB2YXIgd2luID0gd2luZG93O1xcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XFxuICByZXR1cm4ge1xcbiAgICB4OiBPYmplY3QoX3V0aWxzX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwicm91bmRcXFwiXSkoT2JqZWN0KF91dGlsc19tYXRoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcInJvdW5kXFxcIl0pKHggKiBkcHIpIC8gZHByKSB8fCAwLFxcbiAgICB5OiBPYmplY3QoX3V0aWxzX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwicm91bmRcXFwiXSkoT2JqZWN0KF91dGlsc19tYXRoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXFxcInJvdW5kXFxcIl0pKHkgKiBkcHIpIC8gZHByKSB8fCAwXFxuICB9O1xcbn1cXG5cXG5mdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcXG5cXG4gIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxcbiAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxcbiAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzO1xcblxcbiAgdmFyIF9yZWYzID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIob2Zmc2V0cykgOiB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKG9mZnNldHMpIDogb2Zmc2V0cyxcXG4gICAgICBfcmVmMyR4ID0gX3JlZjMueCxcXG4gICAgICB4ID0gX3JlZjMkeCA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJHgsXFxuICAgICAgX3JlZjMkeSA9IF9yZWYzLnksXFxuICAgICAgeSA9IF9yZWYzJHkgPT09IHZvaWQgMCA/IDAgOiBfcmVmMyR5O1xcblxcbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XFxuICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcXG4gIHZhciBzaWRlWCA9IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJsZWZ0XFxcIl07XFxuICB2YXIgc2lkZVkgPSBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwidG9wXFxcIl07XFxuICB2YXIgd2luID0gd2luZG93O1xcblxcbiAgaWYgKGFkYXB0aXZlKSB7XFxuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBPYmplY3QoX2RvbV91dGlsc19nZXRPZmZzZXRQYXJlbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShwb3BwZXIpO1xcbiAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcXG5cXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gT2JqZWN0KF9kb21fdXRpbHNfZ2V0V2luZG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkocG9wcGVyKSkge1xcbiAgICAgIG9mZnNldFBhcmVudCA9IE9iamVjdChfZG9tX3V0aWxzX2dldERvY3VtZW50RWxlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl0pKHBvcHBlcik7XFxuXFxuICAgICAgaWYgKE9iamVjdChfZG9tX3V0aWxzX2dldENvbXB1dGVkU3R5bGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVmYXVsdFxcXCJdKShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJykge1xcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xcbiAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcXG4gICAgICB9XFxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XFxuXFxuXFxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcXG5cXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInRvcFxcXCJdKSB7XFxuICAgICAgc2lkZVkgPSBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiYm90dG9tXFxcIl07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxcblxcbiAgICAgIHkgLT0gb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XFxuICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XFxuICAgIH1cXG5cXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImxlZnRcXFwiXSkge1xcbiAgICAgIHNpZGVYID0gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInJpZ2h0XFxcIl07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxcblxcbiAgICAgIHggLT0gb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF0gLSBwb3BwZXJSZWN0LndpZHRoO1xcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XFxuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxcbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XFxuXFxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XFxuICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcXG5cXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPCAyID8gXFxcInRyYW5zbGF0ZShcXFwiICsgeCArIFxcXCJweCwgXFxcIiArIHkgKyBcXFwicHgpXFxcIiA6IFxcXCJ0cmFuc2xhdGUzZChcXFwiICsgeCArIFxcXCJweCwgXFxcIiArIHkgKyBcXFwicHgsIDApXFxcIiwgX09iamVjdCRhc3NpZ24pKTtcXG4gIH1cXG5cXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXFxcInB4XFxcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcXFwicHhcXFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XFxufVxcblxcbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjQpIHtcXG4gIHZhciBzdGF0ZSA9IF9yZWY0LnN0YXRlLFxcbiAgICAgIG9wdGlvbnMgPSBfcmVmNC5vcHRpb25zO1xcbiAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXFxuICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlLFxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdW5kT2Zmc2V0cztcXG5cXG4gIGlmICh0cnVlKSB7XFxuICAgIHZhciB0cmFuc2l0aW9uUHJvcGVydHkgPSBPYmplY3QoX2RvbV91dGlsc19nZXRDb21wdXRlZFN0eWxlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgJyc7XFxuXFxuICAgIGlmIChhZGFwdGl2ZSAmJiBbJ3RyYW5zZm9ybScsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5zb21lKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uUHJvcGVydHkuaW5kZXhPZihwcm9wZXJ0eSkgPj0gMDtcXG4gICAgfSkpIHtcXG4gICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZycsICdDU1MgcHJvcGVydGllczogXFxcInRyYW5zZm9ybVxcXCIsIFxcXCJ0b3BcXFwiLCBcXFwicmlnaHRcXFwiLCBcXFwiYm90dG9tXFxcIiwgXFxcImxlZnRcXFwiLicsICdcXFxcblxcXFxuJywgJ0Rpc2FibGUgdGhlIFxcXCJjb21wdXRlU3R5bGVzXFxcIiBtb2RpZmllclxcXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsICdmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1MnLCAndHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nJywgJ29wYWNpdHkgb3IgYmFja2dyb3VuZC1jb2xvciBmb3IgZXhhbXBsZS4nLCAnXFxcXG5cXFxcbicsICdXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXInLCAnZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLiddLmpvaW4oJyAnKSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBjb21tb25TdHlsZXMgPSB7XFxuICAgIHBsYWNlbWVudDogT2JqZWN0KF91dGlsc19nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUucGxhY2VtZW50KSxcXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb25cXG4gIH07XFxuXFxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcXG4gICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcXG4gICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcXG4gICAgfSkpKTtcXG4gIH1cXG5cXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcXG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcXG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxcbiAgICAgIGFkYXB0aXZlOiBmYWxzZSxcXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xcbiAgICB9KSkpO1xcbiAgfVxcblxcbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XFxuICB9KTtcXG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9ICh7XFxuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXFxuICBlbmFibGVkOiB0cnVlLFxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXFxuICBmbjogY29tcHV0ZVN0eWxlcyxcXG4gIGRhdGE6IHt9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJNb2RpZmllcnNFdmVudExpc3RlbmVyc0pzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0V2luZG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qc1xcXCIpO1xcbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxudmFyIHBhc3NpdmUgPSB7XFxuICBwYXNzaXZlOiB0cnVlXFxufTtcXG5cXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcXG4gIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXFxuICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xcbiAgdmFyIHdpbmRvdyA9IE9iamVjdChfZG9tX3V0aWxzX2dldFdpbmRvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XFxuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xcblxcbiAgaWYgKHNjcm9sbCkge1xcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGlmIChyZXNpemUpIHtcXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XFxuICB9XFxuXFxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoc2Nyb2xsKSB7XFxuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcXG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGlmIChyZXNpemUpIHtcXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcXG4gICAgfVxcbiAgfTtcXG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9ICh7XFxuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxcbiAgZW5hYmxlZDogdHJ1ZSxcXG4gIHBoYXNlOiAnd3JpdGUnLFxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXFxuICBlZmZlY3Q6IGVmZmVjdCxcXG4gIGRhdGE6IHt9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJNb2RpZmllcnNGbGlwSnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2dldE9wcG9zaXRlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2RldGVjdE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb21wdXRlQXV0b1BsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2VudW1zLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2dldFZhcmlhdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuXFxuIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5mdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcXG4gIGlmIChPYmplY3QoX3V0aWxzX2dldEJhc2VQbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShwbGFjZW1lbnQpID09PSBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiYXV0b1xcXCJdKSB7XFxuICAgIHJldHVybiBbXTtcXG4gIH1cXG5cXG4gIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IE9iamVjdChfdXRpbHNfZ2V0T3Bwb3NpdGVQbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShwbGFjZW1lbnQpO1xcbiAgcmV0dXJuIFtPYmplY3QoX3V0aWxzX2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIE9iamVjdChfdXRpbHNfZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKShvcHBvc2l0ZVBsYWNlbWVudCldO1xcbn1cXG5cXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xcblxcbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXApIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBPYmplY3QoX3V0aWxzX2dldEJhc2VQbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShwcmVmZXJyZWRQbGFjZW1lbnQpO1xcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcXG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbT2JqZWN0KF91dGlsc19nZXRPcHBvc2l0ZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKHByZWZlcnJlZFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XFxuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcXG4gICAgcmV0dXJuIGFjYy5jb25jYXQoT2JqZWN0KF91dGlsc19nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkocGxhY2VtZW50KSA9PT0gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcImF1dG9cXFwiXSA/IE9iamVjdChfdXRpbHNfY29tcHV0ZUF1dG9QbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVmYXVsdFxcXCJdKShzdGF0ZSwge1xcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxcbiAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xcbiAgICB9KSA6IHBsYWNlbWVudCk7XFxuICB9LCBbXSk7XFxuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcXG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xcbiAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcXG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XFxuXFxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IE9iamVjdChfdXRpbHNfZ2V0QmFzZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKHBsYWNlbWVudCk7XFxuXFxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gT2JqZWN0KF91dGlsc19nZXRWYXJpYXRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiZGVmYXVsdFxcXCJdKShwbGFjZW1lbnQpID09PSBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwic3RhcnRcXFwiXTtcXG4gICAgdmFyIGlzVmVydGljYWwgPSBbX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcInRvcFxcXCJdLCBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiYm90dG9tXFxcIl1dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XFxuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xcbiAgICB2YXIgb3ZlcmZsb3cgPSBPYmplY3QoX3V0aWxzX2RldGVjdE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUsIHtcXG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcXG4gICAgfSk7XFxuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcInJpZ2h0XFxcIl0gOiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwibGVmdFxcXCJdIDogaXNTdGFydFZhcmlhdGlvbiA/IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJib3R0b21cXFwiXSA6IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJ0b3BcXFwiXTtcXG5cXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gT2JqZWN0KF91dGlsc19nZXRPcHBvc2l0ZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKG1haW5WYXJpYXRpb25TaWRlKTtcXG4gICAgfVxcblxcbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IE9iamVjdChfdXRpbHNfZ2V0T3Bwb3NpdGVQbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShtYWluVmFyaWF0aW9uU2lkZSk7XFxuICAgIHZhciBjaGVja3MgPSBbXTtcXG5cXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcXG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcXG4gICAgfVxcblxcbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xcbiAgICAgIHJldHVybiBjaGVjaztcXG4gICAgfSkpIHtcXG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XFxuICAgICAgbWFrZUZhbGxiYWNrQ2hlY2tzID0gZmFsc2U7XFxuICAgICAgYnJlYWs7XFxuICAgIH1cXG5cXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XFxuICB9XFxuXFxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XFxuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxcbiAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xcblxcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xcbiAgICAgIHZhciBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcXG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XFxuXFxuICAgICAgICBpZiAoY2hlY2tzKSB7XFxuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcXG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XFxuICAgICAgICByZXR1cm4gXFxcImJyZWFrXFxcIjtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xcblxcbiAgICAgIGlmIChfcmV0ID09PSBcXFwiYnJlYWtcXFwiKSBicmVhaztcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XFxuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xcbiAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XFxuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcXG4gIH1cXG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9ICh7XFxuICBuYW1lOiAnZmxpcCcsXFxuICBlbmFibGVkOiB0cnVlLFxcbiAgcGhhc2U6ICdtYWluJyxcXG4gIGZuOiBmbGlwLFxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcXG4gIGRhdGE6IHtcXG4gICAgX3NraXA6IGZhbHNlXFxuICB9XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZmxpcC5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2hpZGUuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2hpZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYk1vZGlmaWVyc0hpZGVKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2VudW1zLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2RldGVjdE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXFxcIik7XFxuXFxuXFxuXFxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcXG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcXG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcXG4gICAgICB4OiAwLFxcbiAgICAgIHk6IDBcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54XFxuICB9O1xcbn1cXG5cXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcXG4gIHJldHVybiBbX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInRvcFxcXCJdLCBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicmlnaHRcXFwiXSwgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImJvdHRvbVxcXCJdLCBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwibGVmdFxcXCJdXS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XFxuICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xcbiAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XFxuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcXG4gIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XFxuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBPYmplY3QoX3V0aWxzX2RldGVjdE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUsIHtcXG4gICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXFxuICB9KTtcXG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IE9iamVjdChfdXRpbHNfZGV0ZWN0T3ZlcmZsb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShzdGF0ZSwge1xcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxcbiAgfSk7XFxuICB2YXIgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocmVmZXJlbmNlT3ZlcmZsb3csIHJlZmVyZW5jZVJlY3QpO1xcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XFxuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcXG4gIHZhciBoYXNQb3BwZXJFc2NhcGVkID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHBvcHBlckVzY2FwZU9mZnNldHMpO1xcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcXG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHBvcHBlckVzY2FwZU9mZnNldHMsXFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxcbiAgfTtcXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcXG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkXFxuICB9KTtcXG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9ICh7XFxuICBuYW1lOiAnaGlkZScsXFxuICBlbmFibGVkOiB0cnVlLFxcbiAgcGhhc2U6ICdtYWluJyxcXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXFxuICBmbjogaGlkZVxcbn0pO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2hpZGUuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9pbmRleC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBhcHBseVN0eWxlcywgYXJyb3csIGNvbXB1dGVTdHlsZXMsIGV2ZW50TGlzdGVuZXJzLCBmbGlwLCBoaWRlLCBvZmZzZXQsIHBvcHBlck9mZnNldHMsIHByZXZlbnRPdmVyZmxvdyAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYk1vZGlmaWVyc0luZGV4SnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2FwcGx5U3R5bGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FwcGx5U3R5bGVzLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJhcHBseVN0eWxlc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2FwcGx5U3R5bGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hcnJvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hcnJvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYXJyb3dcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9hcnJvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tcHV0ZVN0eWxlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb21wdXRlU3R5bGVzLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNvbXB1dGVTdHlsZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9jb21wdXRlU3R5bGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ldmVudExpc3RlbmVyc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldmVudExpc3RlbmVycy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZXZlbnRMaXN0ZW5lcnNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9ldmVudExpc3RlbmVyc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZmxpcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mbGlwLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImZsaXBcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9mbGlwX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9oaWRlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hpZGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiaGlkZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2hpZGVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiZGVmYXVsdFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX29mZnNldF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9vZmZzZXQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJvZmZzZXRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9vZmZzZXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiZGVmYXVsdFxcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BvcHBlck9mZnNldHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcG9wcGVyT2Zmc2V0cy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJwb3BwZXJPZmZzZXRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfcG9wcGVyT2Zmc2V0c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJkZWZhdWx0XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcHJldmVudE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ByZXZlbnRPdmVyZmxvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInByZXZlbnRPdmVyZmxvd1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3ByZXZlbnRPdmVyZmxvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1xcXCJkZWZhdWx0XFxcIl07IH0pO1xcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2luZGV4LmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL29mZnNldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZLCBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzT2Zmc2V0SnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkaXN0YW5jZUFuZFNraWRkaW5nVG9YWVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFk7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZ2V0QmFzZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lbnVtcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzXFxcIik7XFxuXFxuXFxuZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XFxuICB2YXIgYmFzZVBsYWNlbWVudCA9IE9iamVjdChfdXRpbHNfZ2V0QmFzZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKHBsYWNlbWVudCk7XFxuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImxlZnRcXFwiXSwgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInRvcFxcXCJdXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XFxuXFxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcXG4gIH0pKSA6IG9mZnNldCxcXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xcblxcbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcXG4gIHJldHVybiBbX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImxlZnRcXFwiXSwgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInJpZ2h0XFxcIl1dLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcXG4gICAgeDogZGlzdGFuY2UsXFxuICAgIHk6IHNraWRkaW5nXFxuICB9IDoge1xcbiAgICB4OiBza2lkZGluZyxcXG4gICAgeTogZGlzdGFuY2VcXG4gIH07XFxufVxcblxcbmZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XFxuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XFxuICB2YXIgZGF0YSA9IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJwbGFjZW1lbnRzXFxcIl0ucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XFxuICAgIHJldHVybiBhY2M7XFxuICB9LCB7fSk7XFxuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcXG4gICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XFxuXFxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcXG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcXG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcXG4gIH1cXG5cXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xcblxcblxcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcXFwiZGVmYXVsdFxcXCJdID0gKHtcXG4gIG5hbWU6ICdvZmZzZXQnLFxcbiAgZW5hYmxlZDogdHJ1ZSxcXG4gIHBoYXNlOiAnbWFpbicsXFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXFxuICBmbjogb2Zmc2V0XFxufSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzUG9wcGVyT2Zmc2V0c0pzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb21wdXRlT2Zmc2V0c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcXG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gT2JqZWN0KF91dGlsc19jb21wdXRlT2Zmc2V0c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKHtcXG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XFxuICB9KTtcXG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9ICh7XFxuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXFxuICBlbmFibGVkOiB0cnVlLFxcbiAgcGhhc2U6ICdyZWFkJyxcXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxcbiAgZGF0YToge31cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJNb2RpZmllcnNQcmV2ZW50T3ZlcmZsb3dKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2VudW1zLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2dldEJhc2VQbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZ2V0QWx0QXhpc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvZ2V0QWx0QXhpcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3dpdGhpbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMvd2l0aGluLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0TGF5b3V0UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldE9mZnNldFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2RldGVjdE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19nZXRWYXJpYXRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzL2dldFZhcmlhdGlvbi5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfZ2V0RnJlc2hTaWRlT2JqZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscy9tYXRoLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qc1xcXCIpO1xcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XFxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxcbiAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XFxuICB2YXIgb3ZlcmZsb3cgPSBPYmplY3QoX3V0aWxzX2RldGVjdE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUsIHtcXG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxcbiAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcXG4gICAgcGFkZGluZzogcGFkZGluZyxcXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XFxuICB9KTtcXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gT2JqZWN0KF91dGlsc19nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUucGxhY2VtZW50KTtcXG4gIHZhciB2YXJpYXRpb24gPSBPYmplY3QoX3V0aWxzX2dldFZhcmlhdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1xcXCJkZWZhdWx0XFxcIl0pKHN0YXRlLnBsYWNlbWVudCk7XFxuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcXG4gIHZhciBtYWluQXhpcyA9IE9iamVjdChfdXRpbHNfZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoYmFzZVBsYWNlbWVudCk7XFxuICB2YXIgYWx0QXhpcyA9IE9iamVjdChfdXRpbHNfZ2V0QWx0QXhpc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl0pKG1haW5BeGlzKTtcXG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XFxuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcXG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcXG4gIH0pKSA6IHRldGhlck9mZnNldDtcXG4gIHZhciBkYXRhID0ge1xcbiAgICB4OiAwLFxcbiAgICB5OiAwXFxuICB9O1xcblxcbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmIChjaGVja01haW5BeGlzIHx8IGNoZWNrQWx0QXhpcykge1xcbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInRvcFxcXCJdIDogX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImxlZnRcXFwiXTtcXG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImJvdHRvbVxcXCJdIDogX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInJpZ2h0XFxcIl07XFxuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XFxuICAgIHZhciBtaW4gPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG92ZXJmbG93W21haW5TaWRlXTtcXG4gICAgdmFyIG1heCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdIC0gb3ZlcmZsb3dbYWx0U2lkZV07XFxuICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcXG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcInN0YXJ0XFxcIl0gPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XFxuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJzdGFydFxcXCJdID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXFxuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcXG5cXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xcbiAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IE9iamVjdChfZG9tX3V0aWxzX2dldExheW91dFJlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiZGVmYXVsdFxcXCJdKShhcnJvd0VsZW1lbnQpIDoge1xcbiAgICAgIHdpZHRoOiAwLFxcbiAgICAgIGhlaWdodDogMFxcbiAgICB9O1xcbiAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBPYmplY3QoX3V0aWxzX2dldEZyZXNoU2lkZU9iamVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1xcXCJkZWZhdWx0XFxcIl0pKCk7XFxuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXFxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxcblxcbiAgICB2YXIgYXJyb3dMZW4gPSBPYmplY3QoX3V0aWxzX3dpdGhpbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl0pKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSB0ZXRoZXJPZmZzZXRWYWx1ZSA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gdGV0aGVyT2Zmc2V0VmFsdWU7XFxuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyB0ZXRoZXJPZmZzZXRWYWx1ZSA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgdGV0aGVyT2Zmc2V0VmFsdWU7XFxuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIE9iamVjdChfZG9tX3V0aWxzX2dldE9mZnNldFBhcmVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJkZWZhdWx0XFxcIl0pKHN0YXRlLmVsZW1lbnRzLmFycm93KTtcXG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcXG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF1bbWFpbkF4aXNdIDogMDtcXG4gICAgdmFyIHRldGhlck1pbiA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcXG4gICAgdmFyIHRldGhlck1heCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcXG5cXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcXG4gICAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gT2JqZWN0KF91dGlsc193aXRoaW5fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVmYXVsdFxcXCJdKSh0ZXRoZXIgPyBPYmplY3QoX3V0aWxzX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXFxcIm1pblxcXCJdKShtaW4sIHRldGhlck1pbikgOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gT2JqZWN0KF91dGlsc19tYXRoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1xcXCJtYXhcXFwiXSkobWF4LCB0ZXRoZXJNYXgpIDogbWF4KTtcXG4gICAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcXG4gICAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcXG4gICAgfVxcblxcbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XFxuICAgICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwidG9wXFxcIl0gOiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwibGVmdFxcXCJdO1xcblxcbiAgICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiYm90dG9tXFxcIl0gOiBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicmlnaHRcXFwiXTtcXG5cXG4gICAgICB2YXIgX29mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XFxuXFxuICAgICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcXG5cXG4gICAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XFxuXFxuICAgICAgdmFyIF9wcmV2ZW50ZWRPZmZzZXQgPSBPYmplY3QoX3V0aWxzX3dpdGhpbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl0pKHRldGhlciA/IE9iamVjdChfdXRpbHNfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcXFwibWluXFxcIl0pKF9taW4sIHRldGhlck1pbikgOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBPYmplY3QoX3V0aWxzX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXFxcIm1heFxcXCJdKShfbWF4LCB0ZXRoZXJNYXgpIDogX21heCk7XFxuXFxuICAgICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XFxuICAgICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xcbiAgICB9XFxuICB9XFxuXFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcXG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5cXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXFxcImRlZmF1bHRcXFwiXSA9ICh7XFxuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcXG4gIGVuYWJsZWQ6IHRydWUsXFxuICBwaGFzZTogJ21haW4nLFxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci1saXRlLmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci1saXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlBvcHBlckxpdGVKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImNyZWF0ZVBvcHBlclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlUG9wcGVyOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0TW9kaWZpZXJzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZWZhdWx0TW9kaWZpZXJzOyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NyZWF0ZVBvcHBlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jcmVhdGVQb3BwZXIuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9jcmVhdGVQb3BwZXIuanNcXFwiKTtcXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcInBvcHBlckdlbmVyYXRvclxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2NyZWF0ZVBvcHBlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJwb3BwZXJHZW5lcmF0b3JcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZXRlY3RPdmVyZmxvd1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2NyZWF0ZVBvcHBlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZXRlY3RPdmVyZmxvd1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21vZGlmaWVyc19ldmVudExpc3RlbmVyc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21vZGlmaWVyc19wb3BwZXJPZmZzZXRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21vZGlmaWVyc19jb21wdXRlU3R5bGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21vZGlmaWVyc19hcHBseVN0eWxlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtfbW9kaWZpZXJzX2V2ZW50TGlzdGVuZXJzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSwgX21vZGlmaWVyc19wb3BwZXJPZmZzZXRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSwgX21vZGlmaWVyc19jb21wdXRlU3R5bGVzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImRlZmF1bHRcXFwiXSwgX21vZGlmaWVyc19hcHBseVN0eWxlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl1dO1xcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0KF9jcmVhdGVQb3BwZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicG9wcGVyR2VuZXJhdG9yXFxcIl0pKHtcXG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLWxpdGUuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3csIGNyZWF0ZVBvcHBlckxpdGUsIGFwcGx5U3R5bGVzLCBhcnJvdywgY29tcHV0ZVN0eWxlcywgZXZlbnRMaXN0ZW5lcnMsIGZsaXAsIGhpZGUsIG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcHJldmVudE92ZXJmbG93ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliUG9wcGVySnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJjcmVhdGVQb3BwZXJcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZVBvcHBlcjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdE1vZGlmaWVyc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVmYXVsdE1vZGlmaWVyczsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jcmVhdGVQb3BwZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY3JlYXRlUG9wcGVyLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvY3JlYXRlUG9wcGVyLmpzXFxcIik7XFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJwb3BwZXJHZW5lcmF0b3JcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9jcmVhdGVQb3BwZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicG9wcGVyR2VuZXJhdG9yXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGV0ZWN0T3ZlcmZsb3dcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9jcmVhdGVQb3BwZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGV0ZWN0T3ZlcmZsb3dcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2RpZmllcnNfZXZlbnRMaXN0ZW5lcnNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2RpZmllcnNfcG9wcGVyT2Zmc2V0c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2RpZmllcnNfY29tcHV0ZVN0eWxlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2RpZmllcnNfYXBwbHlTdHlsZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2RpZmllcnNfb2Zmc2V0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGlmaWVycy9vZmZzZXQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2RpZmllcnNfZmxpcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2RpZmllcnMvZmxpcC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2RpZmllcnNfcHJldmVudE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2RpZmllcnNfYXJyb3dfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kaWZpZXJzL2Fycm93LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2RpZmllcnNfaGlkZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2RpZmllcnMvaGlkZS5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wb3BwZXJfbGl0ZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcG9wcGVyLWxpdGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXItbGl0ZS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY3JlYXRlUG9wcGVyTGl0ZVxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3BvcHBlcl9saXRlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1xcXCJjcmVhdGVQb3BwZXJcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2RpZmllcnNfaW5kZXhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21vZGlmaWVycy9pbmRleC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYXBwbHlTdHlsZXNcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tb2RpZmllcnNfaW5kZXhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXFxcImFwcGx5U3R5bGVzXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiYXJyb3dcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tb2RpZmllcnNfaW5kZXhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXFxcImFycm93XFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiY29tcHV0ZVN0eWxlc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21vZGlmaWVyc19pbmRleF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1tcXFwiY29tcHV0ZVN0eWxlc1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImV2ZW50TGlzdGVuZXJzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1xcXCJldmVudExpc3RlbmVyc1xcXCJdOyB9KTtcXG5cXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImZsaXBcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9tb2RpZmllcnNfaW5kZXhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXFxcImZsaXBcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJoaWRlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1xcXCJoaWRlXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwib2Zmc2V0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1xcXCJvZmZzZXRcXFwiXTsgfSk7XFxuXFxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJwb3BwZXJPZmZzZXRzXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1xcXCJwb3BwZXJPZmZzZXRzXFxcIl07IH0pO1xcblxcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicHJldmVudE92ZXJmbG93XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfbW9kaWZpZXJzX2luZGV4X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1xcXCJwcmV2ZW50T3ZlcmZsb3dcXFwiXTsgfSk7XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbX21vZGlmaWVyc19ldmVudExpc3RlbmVyc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0sIF9tb2RpZmllcnNfcG9wcGVyT2Zmc2V0c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0sIF9tb2RpZmllcnNfY29tcHV0ZVN0eWxlc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl0sIF9tb2RpZmllcnNfYXBwbHlTdHlsZXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcXFwiZGVmYXVsdFxcXCJdLCBfbW9kaWZpZXJzX29mZnNldF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJkZWZhdWx0XFxcIl0sIF9tb2RpZmllcnNfZmxpcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1xcXCJkZWZhdWx0XFxcIl0sIF9tb2RpZmllcnNfcHJldmVudE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcImRlZmF1bHRcXFwiXSwgX21vZGlmaWVyc19hcnJvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1xcXCJkZWZhdWx0XFxcIl0sIF9tb2RpZmllcnNfaGlkZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1xcXCJkZWZhdWx0XFxcIl1dO1xcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0KF9jcmVhdGVQb3BwZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwicG9wcGVyR2VuZXJhdG9yXFxcIl0pKHtcXG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xcblxcbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXFxuXFxuIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzQ29tcHV0ZUF1dG9QbGFjZW1lbnRKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbXB1dGVBdXRvUGxhY2VtZW50OyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2dldFZhcmlhdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRWYXJpYXRpb24uanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lbnVtcy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kZXRlY3RPdmVyZmxvd19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kZXRlY3RPdmVyZmxvdy5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldEJhc2VQbGFjZW1lbnQuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcXG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcXG4gICAgb3B0aW9ucyA9IHt9O1xcbiAgfVxcblxcbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcXG4gICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwicGxhY2VtZW50c1xcXCJdIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xcbiAgdmFyIHZhcmlhdGlvbiA9IE9iamVjdChfZ2V0VmFyaWF0aW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkocGxhY2VtZW50KTtcXG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwidmFyaWF0aW9uUGxhY2VtZW50c1xcXCJdIDogX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcInZhcmlhdGlvblBsYWNlbWVudHNcXFwiXS5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xcbiAgICByZXR1cm4gT2JqZWN0KF9nZXRWYXJpYXRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShwbGFjZW1lbnQpID09PSB2YXJpYXRpb247XFxuICB9KSA6IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJiYXNlUGxhY2VtZW50c1xcXCJdO1xcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xcbiAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xcbiAgfSk7XFxuXFxuICBpZiAoYWxsb3dlZFBsYWNlbWVudHMubGVuZ3RoID09PSAwKSB7XFxuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcXG5cXG4gICAgaWYgKHRydWUpIHtcXG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBUaGUgYGFsbG93ZWRBdXRvUGxhY2VtZW50c2Agb3B0aW9uIGRpZCBub3QgYWxsb3cgYW55JywgJ3BsYWNlbWVudHMuIEVuc3VyZSB0aGUgYHBsYWNlbWVudGAgb3B0aW9uIG1hdGNoZXMgdGhlIHZhcmlhdGlvbicsICdvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnRzLicsICdGb3IgZXhhbXBsZSwgXFxcImF1dG9cXFwiIGNhbm5vdCBiZSB1c2VkIHRvIGFsbG93IFxcXCJib3R0b20tc3RhcnRcXFwiLicsICdVc2UgXFxcImF1dG8tc3RhcnRcXFwiIGluc3RlYWQuJ10uam9pbignICcpKTtcXG4gICAgfVxcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxcblxcblxcbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcXG4gICAgYWNjW3BsYWNlbWVudF0gPSBPYmplY3QoX2RldGVjdE92ZXJmbG93X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUsIHtcXG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xcbiAgICB9KVtPYmplY3QoX2dldEJhc2VQbGFjZW1lbnRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdKShwbGFjZW1lbnQpXTtcXG4gICAgcmV0dXJuIGFjYztcXG4gIH0sIHt9KTtcXG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcXG4gIH0pO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNDb21wdXRlT2Zmc2V0c0pzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29tcHV0ZU9mZnNldHM7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0QmFzZVBsYWNlbWVudF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXRCYXNlUGxhY2VtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0VmFyaWF0aW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldFZhcmlhdGlvbi5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2VudW1zLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanNcXFwiKTtcXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XFxuICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXFxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gT2JqZWN0KF9nZXRCYXNlUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkocGxhY2VtZW50KSA6IG51bGw7XFxuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gT2JqZWN0KF9nZXRWYXJpYXRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcXFwiZGVmYXVsdFxcXCJdKShwbGFjZW1lbnQpIDogbnVsbDtcXG4gIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XFxuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XFxuICB2YXIgb2Zmc2V0cztcXG5cXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xcbiAgICBjYXNlIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJ0b3BcXFwiXTpcXG4gICAgICBvZmZzZXRzID0ge1xcbiAgICAgICAgeDogY29tbW9uWCxcXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcXG4gICAgICB9O1xcbiAgICAgIGJyZWFrO1xcblxcbiAgICBjYXNlIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJib3R0b21cXFwiXTpcXG4gICAgICBvZmZzZXRzID0ge1xcbiAgICAgICAgeDogY29tbW9uWCxcXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxcbiAgICAgIH07XFxuICAgICAgYnJlYWs7XFxuXFxuICAgIGNhc2UgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcInJpZ2h0XFxcIl06XFxuICAgICAgb2Zmc2V0cyA9IHtcXG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxcbiAgICAgICAgeTogY29tbW9uWVxcbiAgICAgIH07XFxuICAgICAgYnJlYWs7XFxuXFxuICAgIGNhc2UgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImxlZnRcXFwiXTpcXG4gICAgICBvZmZzZXRzID0ge1xcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxcbiAgICAgICAgeTogY29tbW9uWVxcbiAgICAgIH07XFxuICAgICAgYnJlYWs7XFxuXFxuICAgIGRlZmF1bHQ6XFxuICAgICAgb2Zmc2V0cyA9IHtcXG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcXG4gICAgICB9O1xcbiAgfVxcblxcbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IE9iamVjdChfZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xcblxcbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcXG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XFxuXFxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XFxuICAgICAgY2FzZSBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwic3RhcnRcXFwiXTpcXG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XFxuICAgICAgICBicmVhaztcXG5cXG4gICAgICBjYXNlIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJlbmRcXFwiXTpcXG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XFxuICAgICAgICBicmVhaztcXG5cXG4gICAgICBkZWZhdWx0OlxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gb2Zmc2V0cztcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzRGVib3VuY2VKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlYm91bmNlOyB9KTtcXG5mdW5jdGlvbiBkZWJvdW5jZShmbikge1xcbiAgdmFyIHBlbmRpbmc7XFxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoIXBlbmRpbmcpIHtcXG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHBlbmRpbmc7XFxuICB9O1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNEZXRlY3RPdmVyZmxvd0pzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGV0ZWN0T3ZlcmZsb3c7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZG9tX3V0aWxzX2dldEJvdW5kaW5nQ2xpZW50UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RvbV91dGlsc19nZXRDbGlwcGluZ1JlY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kb21fdXRpbHNfZ2V0RG9jdW1lbnRFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tcHV0ZU9mZnNldHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29tcHV0ZU9mZnNldHMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmVjdFRvQ2xpZW50UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZWN0VG9DbGllbnRSZWN0LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2VudW1zLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RvbV91dGlsc19pbnN0YW5jZU9mX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tZXJnZVBhZGRpbmdPYmplY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWVyZ2VQYWRkaW5nT2JqZWN0LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9leHBhbmRUb0hhc2hNYXBfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXhwYW5kVG9IYXNoTWFwLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcXG5cXG5mdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xcbiAgICBvcHRpb25zID0ge307XFxuICB9XFxuXFxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxcbiAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJjbGlwcGluZ1BhcmVudHNcXFwiXSA6IF9vcHRpb25zJGJvdW5kYXJ5LFxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJ2aWV3cG9ydFxcXCJdIDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwicG9wcGVyXFxcIl0gOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gT2JqZWN0KF9tZXJnZVBhZGRpbmdPYmplY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcXFwiZGVmYXVsdFxcXCJdKSh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogT2JqZWN0KF9leHBhbmRUb0hhc2hNYXBfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcXFwiZGVmYXVsdFxcXCJdKShwYWRkaW5nLCBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiYmFzZVBsYWNlbWVudHNcXFwiXSkpO1xcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcInBvcHBlclxcXCJdID8gX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcInJlZmVyZW5jZVxcXCJdIDogX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcInBvcHBlclxcXCJdO1xcbiAgdmFyIHJlZmVyZW5jZUVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2U7XFxuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcXG4gIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IE9iamVjdChfZG9tX3V0aWxzX2dldENsaXBwaW5nUmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKE9iamVjdChfZG9tX3V0aWxzX2luc3RhbmNlT2ZfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcXFwiaXNFbGVtZW50XFxcIl0pKGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgT2JqZWN0KF9kb21fdXRpbHNfZ2V0RG9jdW1lbnRFbGVtZW50X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSk7XFxuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IE9iamVjdChfZG9tX3V0aWxzX2dldEJvdW5kaW5nQ2xpZW50UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKHJlZmVyZW5jZUVsZW1lbnQpO1xcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBPYmplY3QoX2NvbXB1dGVPZmZzZXRzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImRlZmF1bHRcXFwiXSkoe1xcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxcbiAgfSk7XFxuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IE9iamVjdChfcmVjdFRvQ2xpZW50UmVjdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl0pKE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcXG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwicG9wcGVyXFxcIl0gPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxcblxcbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcXG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXFxuICAgIGJvdHRvbTogZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tLFxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcXG4gIH07XFxuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XFxuXFxuICBpZiAoZWxlbWVudENvbnRleHQgPT09IF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJwb3BwZXJcXFwiXSAmJiBvZmZzZXREYXRhKSB7XFxuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XFxuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgdmFyIG11bHRpcGx5ID0gW19lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJyaWdodFxcXCJdLCBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcXFwiYm90dG9tXFxcIl1dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xcbiAgICAgIHZhciBheGlzID0gW19lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJ0b3BcXFwiXSwgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXFxcImJvdHRvbVxcXCJdXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcXG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9leHBhbmRUb0hhc2hNYXAuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzRXhwYW5kVG9IYXNoTWFwSnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBleHBhbmRUb0hhc2hNYXA7IH0pO1xcbmZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoTWFwLCBrZXkpIHtcXG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XFxuICAgIHJldHVybiBoYXNoTWFwO1xcbiAgfSwge30pO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZm9ybWF0LmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9mb3JtYXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0Zvcm1hdEpzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZm9ybWF0OyB9KTtcXG5mdW5jdGlvbiBmb3JtYXQoc3RyKSB7XFxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XFxuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xcbiAgfVxcblxcbiAgcmV0dXJuIFtdLmNvbmNhdChhcmdzKS5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHtcXG4gICAgcmV0dXJuIHAucmVwbGFjZSgvJXMvLCBjKTtcXG4gIH0sIHN0cik7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZm9ybWF0LmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRBbHRBeGlzLmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0dldEFsdEF4aXNKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEFsdEF4aXM7IH0pO1xcbmZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRBbHRBeGlzLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0dldEJhc2VQbGFjZW1lbnRKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEJhc2VQbGFjZW1lbnQ7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZW51bXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2VudW1zLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNHZXRGcmVzaFNpZGVPYmplY3RKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEZyZXNoU2lkZU9iamVjdDsgfSk7XFxuZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xcbiAgcmV0dXJuIHtcXG4gICAgdG9wOiAwLFxcbiAgICByaWdodDogMCxcXG4gICAgYm90dG9tOiAwLFxcbiAgICBsZWZ0OiAwXFxuICB9O1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0dldE1haW5BeGlzRnJvbVBsYWNlbWVudEpzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50OyB9KTtcXG5mdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XFxuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNHZXRPcHBvc2l0ZVBsYWNlbWVudEpzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQ7IH0pO1xcbnZhciBoYXNoID0ge1xcbiAgbGVmdDogJ3JpZ2h0JyxcXG4gIHJpZ2h0OiAnbGVmdCcsXFxuICBib3R0b206ICd0b3AnLFxcbiAgdG9wOiAnYm90dG9tJ1xcbn07XFxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XFxuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcXG4gIH0pO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNHZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudEpzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQ7IH0pO1xcbnZhciBoYXNoID0ge1xcbiAgc3RhcnQ6ICdlbmQnLFxcbiAgZW5kOiAnc3RhcnQnXFxufTtcXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcXG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XFxuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xcbiAgfSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNHZXRWYXJpYXRpb25Kcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFZhcmlhdGlvbjsgfSk7XFxuZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBtYXgsIG1pbiwgcm91bmQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc01hdGhKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIm1heFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWF4OyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJtaW5cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG1pbjsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwicm91bmRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJvdW5kOyB9KTtcXG52YXIgbWF4ID0gTWF0aC5tYXg7XFxudmFyIG1pbiA9IE1hdGgubWluO1xcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tYXRoLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNNZXJnZUJ5TmFtZUpzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVyZ2VCeU5hbWU7IH0pO1xcbmZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xcbiAgICB2YXIgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcXG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCBjdXJyZW50LmRhdGEpXFxuICAgIH0pIDogY3VycmVudDtcXG4gICAgcmV0dXJuIG1lcmdlZDtcXG4gIH0sIHt9KTsgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC52YWx1ZXNcXG5cXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XFxuICAgIHJldHVybiBtZXJnZWRba2V5XTtcXG4gIH0pO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlQnlOYW1lLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzTWVyZ2VQYWRkaW5nT2JqZWN0SnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3Q7IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ2V0RnJlc2hTaWRlT2JqZWN0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldEZyZXNoU2lkZU9iamVjdC5qcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XFxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgT2JqZWN0KF9nZXRGcmVzaFNpZGVPYmplY3RfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKSgpLCBwYWRkaW5nT2JqZWN0KTtcXG59XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc09yZGVyTW9kaWZpZXJzSnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvcmRlck1vZGlmaWVyczsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZW51bXMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qc1xcXCIpO1xcbiAvLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5ODc1MjU1XFxuXFxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XFxuICB2YXIgbWFwID0gbmV3IE1hcCgpO1xcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XFxuICB2YXIgcmVzdWx0ID0gW107XFxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcXG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XFxuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxcblxcbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcXG4gICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcXG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XFxuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XFxuICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XFxuXFxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcXG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xcbiAgfVxcblxcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XFxuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcXG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcXG4gICAgICBzb3J0KG1vZGlmaWVyKTtcXG4gICAgfVxcbiAgfSk7XFxuICByZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG5mdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcXG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xcbiAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxcblxcbiAgcmV0dXJuIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJtb2RpZmllclBoYXNlc1xcXCJdLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xcbiAgICByZXR1cm4gYWNjLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcXG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xcbiAgICB9KSk7XFxuICB9LCBbXSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvb3JkZXJNb2RpZmllcnMuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzUmVjdFRvQ2xpZW50UmVjdEpzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdDsgfSk7XFxuZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XFxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xcbiAgICBsZWZ0OiByZWN0LngsXFxuICAgIHRvcDogcmVjdC55LFxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxcbiAgfSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdW5pcXVlQnkuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdW5pcXVlQnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzVW5pcXVlQnlKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHVuaXF1ZUJ5OyB9KTtcXG5mdW5jdGlvbiB1bmlxdWVCeShhcnIsIGZuKSB7XFxuICB2YXIgaWRlbnRpZmllcnMgPSBuZXcgU2V0KCk7XFxuICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xcbiAgICB2YXIgaWRlbnRpZmllciA9IGZuKGl0ZW0pO1xcblxcbiAgICBpZiAoIWlkZW50aWZpZXJzLmhhcyhpZGVudGlmaWVyKSkge1xcbiAgICAgIGlkZW50aWZpZXJzLmFkZChpZGVudGlmaWVyKTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgfSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdW5pcXVlQnkuanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi8gLyoqKi9mdW5jdGlvbiBub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc1ZhbGlkYXRlTW9kaWZpZXJzSnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB2YWxpZGF0ZU1vZGlmaWVyczsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9mb3JtYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm9ybWF0LmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZm9ybWF0LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lbnVtc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZW51bXMuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qc1xcXCIpO1xcblxcblxcbnZhciBJTlZBTElEX01PRElGSUVSX0VSUk9SID0gJ1BvcHBlcjogbW9kaWZpZXIgXFxcIiVzXFxcIiBwcm92aWRlZCBhbiBpbnZhbGlkICVzIHByb3BlcnR5LCBleHBlY3RlZCAlcyBidXQgZ290ICVzJztcXG52YXIgTUlTU0lOR19ERVBFTkRFTkNZX0VSUk9SID0gJ1BvcHBlcjogbW9kaWZpZXIgXFxcIiVzXFxcIiByZXF1aXJlcyBcXFwiJXNcXFwiLCBidXQgXFxcIiVzXFxcIiBtb2RpZmllciBpcyBub3QgYXZhaWxhYmxlJztcXG52YXIgVkFMSURfUFJPUEVSVElFUyA9IFsnbmFtZScsICdlbmFibGVkJywgJ3BoYXNlJywgJ2ZuJywgJ2VmZmVjdCcsICdyZXF1aXJlcycsICdvcHRpb25zJ107XFxuZnVuY3Rpb24gdmFsaWRhdGVNb2RpZmllcnMobW9kaWZpZXJzKSB7XFxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcXG4gICAgT2JqZWN0LmtleXMobW9kaWZpZXIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xcbiAgICAgIHN3aXRjaCAoa2V5KSB7XFxuICAgICAgICBjYXNlICduYW1lJzpcXG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5uYW1lICE9PSAnc3RyaW5nJykge1xcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoT2JqZWN0KF9mb3JtYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShJTlZBTElEX01PRElGSUVSX0VSUk9SLCBTdHJpbmcobW9kaWZpZXIubmFtZSksICdcXFwibmFtZVxcXCInLCAnXFxcInN0cmluZ1xcXCInLCBcXFwiXFxcXFxcXCJcXFwiICsgU3RyaW5nKG1vZGlmaWVyLm5hbWUpICsgXFxcIlxcXFxcXFwiXFxcIikpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSAnZW5hYmxlZCc6XFxuICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIuZW5hYmxlZCAhPT0gJ2Jvb2xlYW4nKSB7XFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihPYmplY3QoX2Zvcm1hdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcXFwiZW5hYmxlZFxcXCInLCAnXFxcImJvb2xlYW5cXFwiJywgXFxcIlxcXFxcXFwiXFxcIiArIFN0cmluZyhtb2RpZmllci5lbmFibGVkKSArIFxcXCJcXFxcXFxcIlxcXCIpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgY2FzZSAncGhhc2UnOlxcbiAgICAgICAgICBpZiAoX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIm1vZGlmaWVyUGhhc2VzXFxcIl0uaW5kZXhPZihtb2RpZmllci5waGFzZSkgPCAwKSB7XFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihPYmplY3QoX2Zvcm1hdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcXFwicGhhc2VcXFwiJywgXFxcImVpdGhlciBcXFwiICsgX2VudW1zX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcIm1vZGlmaWVyUGhhc2VzXFxcIl0uam9pbignLCAnKSwgXFxcIlxcXFxcXFwiXFxcIiArIFN0cmluZyhtb2RpZmllci5waGFzZSkgKyBcXFwiXFxcXFxcXCJcXFwiKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdmbic6XFxuICAgICAgICAgIGlmICh0eXBlb2YgbW9kaWZpZXIuZm4gIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKE9iamVjdChfZm9ybWF0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1xcXCJmblxcXCInLCAnXFxcImZ1bmN0aW9uXFxcIicsIFxcXCJcXFxcXFxcIlxcXCIgKyBTdHJpbmcobW9kaWZpZXIuZm4pICsgXFxcIlxcXFxcXFwiXFxcIikpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSAnZWZmZWN0JzpcXG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5lZmZlY3QgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKE9iamVjdChfZm9ybWF0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1xcXCJlZmZlY3RcXFwiJywgJ1xcXCJmdW5jdGlvblxcXCInLCBcXFwiXFxcXFxcXCJcXFwiICsgU3RyaW5nKG1vZGlmaWVyLmZuKSArIFxcXCJcXFxcXFxcIlxcXCIpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgJ3JlcXVpcmVzJzpcXG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGlmaWVyLnJlcXVpcmVzKSkge1xcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoT2JqZWN0KF9mb3JtYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKShJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXFxcInJlcXVpcmVzXFxcIicsICdcXFwiYXJyYXlcXFwiJywgXFxcIlxcXFxcXFwiXFxcIiArIFN0cmluZyhtb2RpZmllci5yZXF1aXJlcykgKyBcXFwiXFxcXFxcXCJcXFwiKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdyZXF1aXJlc0lmRXhpc3RzJzpcXG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMpKSB7XFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihPYmplY3QoX2Zvcm1hdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKElOVkFMSURfTU9ESUZJRVJfRVJST1IsIG1vZGlmaWVyLm5hbWUsICdcXFwicmVxdWlyZXNJZkV4aXN0c1xcXCInLCAnXFxcImFycmF5XFxcIicsIFxcXCJcXFxcXFxcIlxcXCIgKyBTdHJpbmcobW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cykgKyBcXFwiXFxcXFxcXCJcXFwiKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdvcHRpb25zJzpcXG4gICAgICAgIGNhc2UgJ2RhdGEnOlxcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXFxcIlBvcHBlckpTOiBhbiBpbnZhbGlkIHByb3BlcnR5IGhhcyBiZWVuIHByb3ZpZGVkIHRvIHRoZSBcXFxcXFxcIlxcXCIgKyBtb2RpZmllci5uYW1lICsgXFxcIlxcXFxcXFwiIG1vZGlmaWVyLCB2YWxpZCBwcm9wZXJ0aWVzIGFyZSBcXFwiICsgVkFMSURfUFJPUEVSVElFUy5tYXAoZnVuY3Rpb24gKHMpIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcIlxcXFxcXFwiXFxcIiArIHMgKyBcXFwiXFxcXFxcXCJcXFwiO1xcbiAgICAgICAgICB9KS5qb2luKCcsICcpICsgXFxcIjsgYnV0IFxcXFxcXFwiXFxcIiArIGtleSArIFxcXCJcXFxcXFxcIiB3YXMgcHJvdmlkZWQuXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIG1vZGlmaWVyLnJlcXVpcmVzICYmIG1vZGlmaWVyLnJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVpcmVtZW50KSB7XFxuICAgICAgICBpZiAobW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKG1vZCkge1xcbiAgICAgICAgICByZXR1cm4gbW9kLm5hbWUgPT09IHJlcXVpcmVtZW50O1xcbiAgICAgICAgfSkgPT0gbnVsbCkge1xcbiAgICAgICAgICBjb25zb2xlLmVycm9yKE9iamVjdChfZm9ybWF0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkoTUlTU0lOR19ERVBFTkRFTkNZX0VSUk9SLCBTdHJpbmcobW9kaWZpZXIubmFtZSksIHJlcXVpcmVtZW50LCByZXF1aXJlbWVudCkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9KTtcXG4gIH0pO1xcbn1cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy93aXRoaW4uanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzV2l0aGluSnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB3aXRoaW47IH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWF0aF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tYXRoLmpzICovIFxcXCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpIHtcXG4gIHJldHVybiBPYmplY3QoX21hdGhfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwibWF4XFxcIl0pKG1pbiwgT2JqZWN0KF9tYXRoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIm1pblxcXCJdKSh2YWx1ZSwgbWF4KSk7XFxufVxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcC5lc20uanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmVzbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgZXhwb3J0cyBwcm92aWRlZDogQWxlcnQsIEJ1dHRvbiwgQ2Fyb3VzZWwsIENvbGxhcHNlLCBEcm9wZG93biwgTW9kYWwsIE9mZmNhbnZhcywgUG9wb3ZlciwgU2Nyb2xsU3B5LCBUYWIsIFRvYXN0LCBUb29sdGlwICovIC8qKiovZnVuY3Rpb24gbm9kZV9tb2R1bGVzQm9vdHN0cmFwRGlzdEpzQm9vdHN0cmFwRXNtSnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJBbGVydFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQWxlcnQ7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkJ1dHRvblxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQnV0dG9uOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJDYXJvdXNlbFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gQ2Fyb3VzZWw7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIkNvbGxhcHNlXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBDb2xsYXBzZTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiRHJvcGRvd25cXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIERyb3Bkb3duOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJNb2RhbFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gTW9kYWw7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIk9mZmNhbnZhc1xcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gT2ZmY2FudmFzOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJQb3BvdmVyXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBQb3BvdmVyOyB9KTtcXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFxcXCJTY3JvbGxTcHlcXFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFNjcm9sbFNweTsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiVGFiXFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUYWI7IH0pO1xcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXFxcIlRvYXN0XFxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBUb2FzdDsgfSk7XFxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcXFwiVG9vbHRpcFxcXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVG9vbHRpcDsgfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wb3BwZXJqc19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAcG9wcGVyanMvY29yZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2luZGV4LmpzXFxcIik7XFxuLyohXFxuICAqIEJvb3RzdHJhcCB2NS4wLjEgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS8pXFxuICAqIENvcHlyaWdodCAyMDExLTIwMjEgVGhlIEJvb3RzdHJhcCBBdXRob3JzIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvZ3JhcGhzL2NvbnRyaWJ1dG9ycylcXG4gICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAqL1xcblxcblxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQm9vdHN0cmFwICh2NS4wLjEpOiBkb20vc2VsZWN0b3ItZW5naW5lLmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5jb25zdCBOT0RFX1RFWFQgPSAzO1xcbmNvbnN0IFNlbGVjdG9yRW5naW5lID0ge1xcbiAgZmluZChzZWxlY3RvciwgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xcbiAgICByZXR1cm4gW10uY29uY2F0KC4uLkVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwuY2FsbChlbGVtZW50LCBzZWxlY3RvcikpO1xcbiAgfSxcXG5cXG4gIGZpbmRPbmUoc2VsZWN0b3IsIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcXG4gICAgcmV0dXJuIEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XFxuICB9LFxcblxcbiAgY2hpbGRyZW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcXG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5lbGVtZW50LmNoaWxkcmVuKS5maWx0ZXIoY2hpbGQgPT4gY2hpbGQubWF0Y2hlcyhzZWxlY3RvcikpO1xcbiAgfSxcXG5cXG4gIHBhcmVudHMoZWxlbWVudCwgc2VsZWN0b3IpIHtcXG4gICAgY29uc3QgcGFyZW50cyA9IFtdO1xcbiAgICBsZXQgYW5jZXN0b3IgPSBlbGVtZW50LnBhcmVudE5vZGU7XFxuXFxuICAgIHdoaWxlIChhbmNlc3RvciAmJiBhbmNlc3Rvci5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgYW5jZXN0b3Iubm9kZVR5cGUgIT09IE5PREVfVEVYVCkge1xcbiAgICAgIGlmIChhbmNlc3Rvci5tYXRjaGVzKHNlbGVjdG9yKSkge1xcbiAgICAgICAgcGFyZW50cy5wdXNoKGFuY2VzdG9yKTtcXG4gICAgICB9XFxuXFxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBwYXJlbnRzO1xcbiAgfSxcXG5cXG4gIHByZXYoZWxlbWVudCwgc2VsZWN0b3IpIHtcXG4gICAgbGV0IHByZXZpb3VzID0gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xcblxcbiAgICB3aGlsZSAocHJldmlvdXMpIHtcXG4gICAgICBpZiAocHJldmlvdXMubWF0Y2hlcyhzZWxlY3RvcikpIHtcXG4gICAgICAgIHJldHVybiBbcHJldmlvdXNdO1xcbiAgICAgIH1cXG5cXG4gICAgICBwcmV2aW91cyA9IHByZXZpb3VzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIFtdO1xcbiAgfSxcXG5cXG4gIG5leHQoZWxlbWVudCwgc2VsZWN0b3IpIHtcXG4gICAgbGV0IG5leHQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZztcXG5cXG4gICAgd2hpbGUgKG5leHQpIHtcXG4gICAgICBpZiAobmV4dC5tYXRjaGVzKHNlbGVjdG9yKSkge1xcbiAgICAgICAgcmV0dXJuIFtuZXh0XTtcXG4gICAgICB9XFxuXFxuICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBbXTtcXG4gIH1cXG5cXG59O1xcblxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQm9vdHN0cmFwICh2NS4wLjEpOiB1dGlsL2luZGV4LmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBNQVhfVUlEID0gMTAwMDAwMDtcXG5jb25zdCBNSUxMSVNFQ09ORFNfTVVMVElQTElFUiA9IDEwMDA7XFxuY29uc3QgVFJBTlNJVElPTl9FTkQgPSAndHJhbnNpdGlvbmVuZCc7IC8vIFNob3V0b3V0IEFuZ3VzQ3JvbGwgKGh0dHBzOi8vZ29vLmdsL3B4d1FHcClcXG5cXG5jb25zdCB0b1R5cGUgPSBvYmogPT4ge1xcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xcbiAgICByZXR1cm4gYCR7b2JqfWA7XFxuICB9XFxuXFxuICByZXR1cm4ge30udG9TdHJpbmcuY2FsbChvYmopLm1hdGNoKC9cXFxccyhbYS16XSspL2kpWzFdLnRvTG93ZXJDYXNlKCk7XFxufTtcXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIFB1YmxpYyBVdGlsIEFwaVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuXFxuY29uc3QgZ2V0VUlEID0gcHJlZml4ID0+IHtcXG4gIGRvIHtcXG4gICAgcHJlZml4ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1BWF9VSUQpO1xcbiAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSk7XFxuXFxuICByZXR1cm4gcHJlZml4O1xcbn07XFxuXFxuY29uc3QgZ2V0U2VsZWN0b3IgPSBlbGVtZW50ID0+IHtcXG4gIGxldCBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXRhcmdldCcpO1xcblxcbiAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gJyMnKSB7XFxuICAgIGxldCBocmVmQXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJyk7IC8vIFRoZSBvbmx5IHZhbGlkIGNvbnRlbnQgdGhhdCBjb3VsZCBkb3VibGUgYXMgYSBzZWxlY3RvciBhcmUgSURzIG9yIGNsYXNzZXMsXFxuICAgIC8vIHNvIGV2ZXJ5dGhpbmcgc3RhcnRpbmcgd2l0aCBgI2Agb3IgYC5gLiBJZiBhIFxcXCJyZWFsXFxcIiBVUkwgaXMgdXNlZCBhcyB0aGUgc2VsZWN0b3IsXFxuICAgIC8vIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yYCB3aWxsIHJpZ2h0ZnVsbHkgY29tcGxhaW4gaXQgaXMgaW52YWxpZC5cXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMzIyNzNcXG5cXG4gICAgaWYgKCFocmVmQXR0ciB8fCAhaHJlZkF0dHIuaW5jbHVkZXMoJyMnKSAmJiAhaHJlZkF0dHIuc3RhcnRzV2l0aCgnLicpKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH0gLy8gSnVzdCBpbiBjYXNlIHNvbWUgQ01TIHB1dHMgb3V0IGEgZnVsbCBVUkwgd2l0aCB0aGUgYW5jaG9yIGFwcGVuZGVkXFxuXFxuXFxuICAgIGlmIChocmVmQXR0ci5pbmNsdWRlcygnIycpICYmICFocmVmQXR0ci5zdGFydHNXaXRoKCcjJykpIHtcXG4gICAgICBocmVmQXR0ciA9IGAjJHtocmVmQXR0ci5zcGxpdCgnIycpWzFdfWA7XFxuICAgIH1cXG5cXG4gICAgc2VsZWN0b3IgPSBocmVmQXR0ciAmJiBocmVmQXR0ciAhPT0gJyMnID8gaHJlZkF0dHIudHJpbSgpIDogbnVsbDtcXG4gIH1cXG5cXG4gIHJldHVybiBzZWxlY3RvcjtcXG59O1xcblxcbmNvbnN0IGdldFNlbGVjdG9yRnJvbUVsZW1lbnQgPSBlbGVtZW50ID0+IHtcXG4gIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudCk7XFxuXFxuICBpZiAoc2VsZWN0b3IpIHtcXG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBudWxsO1xcbiAgfVxcblxcbiAgcmV0dXJuIG51bGw7XFxufTtcXG5cXG5jb25zdCBnZXRFbGVtZW50RnJvbVNlbGVjdG9yID0gZWxlbWVudCA9PiB7XFxuICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xcbiAgcmV0dXJuIHNlbGVjdG9yID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiBudWxsO1xcbn07XFxuXFxuY29uc3QgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQgPSBlbGVtZW50ID0+IHtcXG4gIGlmICghZWxlbWVudCkge1xcbiAgICByZXR1cm4gMDtcXG4gIH0gLy8gR2V0IHRyYW5zaXRpb24tZHVyYXRpb24gb2YgdGhlIGVsZW1lbnRcXG5cXG5cXG4gIGxldCB7XFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbixcXG4gICAgdHJhbnNpdGlvbkRlbGF5XFxuICB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XFxuICBjb25zdCBmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbik7XFxuICBjb25zdCBmbG9hdFRyYW5zaXRpb25EZWxheSA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSk7IC8vIFJldHVybiAwIGlmIGVsZW1lbnQgb3IgdHJhbnNpdGlvbiBkdXJhdGlvbiBpcyBub3QgZm91bmRcXG5cXG4gIGlmICghZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gJiYgIWZsb2F0VHJhbnNpdGlvbkRlbGF5KSB7XFxuICAgIHJldHVybiAwO1xcbiAgfSAvLyBJZiBtdWx0aXBsZSBkdXJhdGlvbnMgYXJlIGRlZmluZWQsIHRha2UgdGhlIGZpcnN0XFxuXFxuXFxuICB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb24uc3BsaXQoJywnKVswXTtcXG4gIHRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheS5zcGxpdCgnLCcpWzBdO1xcbiAgcmV0dXJuIChOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pICsgTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KSkgKiBNSUxMSVNFQ09ORFNfTVVMVElQTElFUjtcXG59O1xcblxcbmNvbnN0IHRyaWdnZXJUcmFuc2l0aW9uRW5kID0gZWxlbWVudCA9PiB7XFxuICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFRSQU5TSVRJT05fRU5EKSk7XFxufTtcXG5cXG5jb25zdCBpc0VsZW1lbnQgPSBvYmogPT4ge1xcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBvYmouanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xcbiAgICBvYmogPSBvYmpbMF07XFxuICB9XFxuXFxuICByZXR1cm4gdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCc7XFxufTtcXG5cXG5jb25zdCBnZXRFbGVtZW50ID0gb2JqID0+IHtcXG4gIGlmIChpc0VsZW1lbnQob2JqKSkge1xcbiAgICAvLyBpdCdzIGEgalF1ZXJ5IG9iamVjdCBvciBhIG5vZGUgZWxlbWVudFxcbiAgICByZXR1cm4gb2JqLmpxdWVyeSA/IG9ialswXSA6IG9iajtcXG4gIH1cXG5cXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyAmJiBvYmoubGVuZ3RoID4gMCkge1xcbiAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShvYmopO1xcbiAgfVxcblxcbiAgcmV0dXJuIG51bGw7XFxufTtcXG5cXG5jb25zdCBlbXVsYXRlVHJhbnNpdGlvbkVuZCA9IChlbGVtZW50LCBkdXJhdGlvbikgPT4ge1xcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xcbiAgY29uc3QgZHVyYXRpb25QYWRkaW5nID0gNTtcXG4gIGNvbnN0IGVtdWxhdGVkRHVyYXRpb24gPSBkdXJhdGlvbiArIGR1cmF0aW9uUGFkZGluZztcXG5cXG4gIGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xcbiAgICBjYWxsZWQgPSB0cnVlO1xcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTl9FTkQsIGxpc3RlbmVyKTtcXG4gIH1cXG5cXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgbGlzdGVuZXIpO1xcbiAgc2V0VGltZW91dCgoKSA9PiB7XFxuICAgIGlmICghY2FsbGVkKSB7XFxuICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQoZWxlbWVudCk7XFxuICAgIH1cXG4gIH0sIGVtdWxhdGVkRHVyYXRpb24pO1xcbn07XFxuXFxuY29uc3QgdHlwZUNoZWNrQ29uZmlnID0gKGNvbXBvbmVudE5hbWUsIGNvbmZpZywgY29uZmlnVHlwZXMpID0+IHtcXG4gIE9iamVjdC5rZXlzKGNvbmZpZ1R5cGVzKS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcXG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IGNvbmZpZ1R5cGVzW3Byb3BlcnR5XTtcXG4gICAgY29uc3QgdmFsdWUgPSBjb25maWdbcHJvcGVydHldO1xcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB2YWx1ZSAmJiBpc0VsZW1lbnQodmFsdWUpID8gJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKTtcXG5cXG4gICAgaWYgKCFuZXcgUmVnRXhwKGV4cGVjdGVkVHlwZXMpLnRlc3QodmFsdWVUeXBlKSkge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29tcG9uZW50TmFtZS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFxcXCIke3Byb3BlcnR5fVxcXCIgcHJvdmlkZWQgdHlwZSBcXFwiJHt2YWx1ZVR5cGV9XFxcIiBidXQgZXhwZWN0ZWQgdHlwZSBcXFwiJHtleHBlY3RlZFR5cGVzfVxcXCIuYCk7XFxuICAgIH1cXG4gIH0pO1xcbn07XFxuXFxuY29uc3QgaXNWaXNpYmxlID0gZWxlbWVudCA9PiB7XFxuICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgaWYgKGVsZW1lbnQuc3R5bGUgJiYgZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5zdHlsZSkge1xcbiAgICBjb25zdCBlbGVtZW50U3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xcbiAgICBjb25zdCBwYXJlbnROb2RlU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQucGFyZW50Tm9kZSk7XFxuICAgIHJldHVybiBlbGVtZW50U3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnICYmIHBhcmVudE5vZGVTdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScgJiYgZWxlbWVudFN0eWxlLnZpc2liaWxpdHkgIT09ICdoaWRkZW4nO1xcbiAgfVxcblxcbiAgcmV0dXJuIGZhbHNlO1xcbn07XFxuXFxuY29uc3QgaXNEaXNhYmxlZCA9IGVsZW1lbnQgPT4ge1xcbiAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBlbGVtZW50LmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xcbiAgICByZXR1cm4gZWxlbWVudC5kaXNhYmxlZDtcXG4gIH1cXG5cXG4gIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKSAhPT0gJ2ZhbHNlJztcXG59O1xcblxcbmNvbnN0IGZpbmRTaGFkb3dSb290ID0gZWxlbWVudCA9PiB7XFxuICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpIHtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9IC8vIENhbiBmaW5kIHRoZSBzaGFkb3cgcm9vdCBvdGhlcndpc2UgaXQnbGwgcmV0dXJuIHRoZSBkb2N1bWVudFxcblxcblxcbiAgaWYgKHR5cGVvZiBlbGVtZW50LmdldFJvb3ROb2RlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGNvbnN0IHJvb3QgPSBlbGVtZW50LmdldFJvb3ROb2RlKCk7XFxuICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsO1xcbiAgfVxcblxcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XFxuICAgIHJldHVybiBlbGVtZW50O1xcbiAgfSAvLyB3aGVuIHdlIGRvbid0IGZpbmQgYSBzaGFkb3cgcm9vdFxcblxcblxcbiAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuXFxuICByZXR1cm4gZmluZFNoYWRvd1Jvb3QoZWxlbWVudC5wYXJlbnROb2RlKTtcXG59O1xcblxcbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcXG5cXG5jb25zdCByZWZsb3cgPSBlbGVtZW50ID0+IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xcblxcbmNvbnN0IGdldGpRdWVyeSA9ICgpID0+IHtcXG4gIGNvbnN0IHtcXG4gICAgalF1ZXJ5XFxuICB9ID0gd2luZG93O1xcblxcbiAgaWYgKGpRdWVyeSAmJiAhZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoJ2RhdGEtYnMtbm8tanF1ZXJ5JykpIHtcXG4gICAgcmV0dXJuIGpRdWVyeTtcXG4gIH1cXG5cXG4gIHJldHVybiBudWxsO1xcbn07XFxuXFxuY29uc3Qgb25ET01Db250ZW50TG9hZGVkID0gY2FsbGJhY2sgPT4ge1xcbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2FsbGJhY2spO1xcbiAgfSBlbHNlIHtcXG4gICAgY2FsbGJhY2soKTtcXG4gIH1cXG59O1xcblxcbmNvbnN0IGlzUlRMID0gKCkgPT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpciA9PT0gJ3J0bCc7XFxuXFxuY29uc3QgZGVmaW5lSlF1ZXJ5UGx1Z2luID0gcGx1Z2luID0+IHtcXG4gIG9uRE9NQ29udGVudExvYWRlZCgoKSA9PiB7XFxuICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKTtcXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXFxuXFxuICAgIGlmICgkKSB7XFxuICAgICAgY29uc3QgbmFtZSA9IHBsdWdpbi5OQU1FO1xcbiAgICAgIGNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bbmFtZV07XFxuICAgICAgJC5mbltuYW1lXSA9IHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XFxuICAgICAgJC5mbltuYW1lXS5Db25zdHJ1Y3RvciA9IHBsdWdpbjtcXG5cXG4gICAgICAkLmZuW25hbWVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XFxuICAgICAgICAkLmZuW25hbWVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xcbiAgICAgICAgcmV0dXJuIHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSk7XFxufTtcXG5cXG5jb25zdCBleGVjdXRlID0gY2FsbGJhY2sgPT4ge1xcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBjYWxsYmFjaygpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGRvbS9kYXRhLmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5jb25zdCBlbGVtZW50TWFwID0gbmV3IE1hcCgpO1xcbnZhciBEYXRhID0ge1xcbiAgc2V0KGVsZW1lbnQsIGtleSwgaW5zdGFuY2UpIHtcXG4gICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xcbiAgICAgIGVsZW1lbnRNYXAuc2V0KGVsZW1lbnQsIG5ldyBNYXAoKSk7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KTsgLy8gbWFrZSBpdCBjbGVhciB3ZSBvbmx5IHdhbnQgb25lIGluc3RhbmNlIHBlciBlbGVtZW50XFxuICAgIC8vIGNhbiBiZSByZW1vdmVkIGxhdGVyIHdoZW4gbXVsdGlwbGUga2V5L2luc3RhbmNlcyBhcmUgZmluZSB0byBiZSB1c2VkXFxuXFxuICAgIGlmICghaW5zdGFuY2VNYXAuaGFzKGtleSkgJiYgaW5zdGFuY2VNYXAuc2l6ZSAhPT0gMCkge1xcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXFxuICAgICAgY29uc29sZS5lcnJvcihgQm9vdHN0cmFwIGRvZXNuJ3QgYWxsb3cgbW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudC4gQm91bmQgaW5zdGFuY2U6ICR7QXJyYXkuZnJvbShpbnN0YW5jZU1hcC5rZXlzKCkpWzBdfS5gKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaW5zdGFuY2VNYXAuc2V0KGtleSwgaW5zdGFuY2UpO1xcbiAgfSxcXG5cXG4gIGdldChlbGVtZW50LCBrZXkpIHtcXG4gICAgaWYgKGVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XFxuICAgICAgcmV0dXJuIGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpLmdldChrZXkpIHx8IG51bGw7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG51bGw7XFxuICB9LFxcblxcbiAgcmVtb3ZlKGVsZW1lbnQsIGtleSkge1xcbiAgICBpZiAoIWVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudCk7XFxuICAgIGluc3RhbmNlTWFwLmRlbGV0ZShrZXkpOyAvLyBmcmVlIHVwIGVsZW1lbnQgcmVmZXJlbmNlcyBpZiB0aGVyZSBhcmUgbm8gaW5zdGFuY2VzIGxlZnQgZm9yIGFuIGVsZW1lbnRcXG5cXG4gICAgaWYgKGluc3RhbmNlTWFwLnNpemUgPT09IDApIHtcXG4gICAgICBlbGVtZW50TWFwLmRlbGV0ZShlbGVtZW50KTtcXG4gICAgfVxcbiAgfVxcblxcbn07XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGRvbS9ldmVudC1oYW5kbGVyLmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBuYW1lc3BhY2VSZWdleCA9IC9bXi5dKig/PVxcXFwuLiopXFxcXC58LiovO1xcbmNvbnN0IHN0cmlwTmFtZVJlZ2V4ID0gL1xcXFwuLiovO1xcbmNvbnN0IHN0cmlwVWlkUmVnZXggPSAvOjpcXFxcZCskLztcXG5jb25zdCBldmVudFJlZ2lzdHJ5ID0ge307IC8vIEV2ZW50cyBzdG9yYWdlXFxuXFxubGV0IHVpZEV2ZW50ID0gMTtcXG5jb25zdCBjdXN0b21FdmVudHMgPSB7XFxuICBtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcXG4gIG1vdXNlbGVhdmU6ICdtb3VzZW91dCdcXG59O1xcbmNvbnN0IGN1c3RvbUV2ZW50c1JlZ2V4ID0gL14obW91c2VlbnRlcnxtb3VzZWxlYXZlKS9pO1xcbmNvbnN0IG5hdGl2ZUV2ZW50cyA9IG5ldyBTZXQoWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdjb250ZXh0bWVudScsICdtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAnc2VsZWN0c3RhcnQnLCAnc2VsZWN0ZW5kJywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnb3JpZW50YXRpb25jaGFuZ2UnLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlcm1vdmUnLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJsZWF2ZScsICdwb2ludGVyY2FuY2VsJywgJ2dlc3R1cmVzdGFydCcsICdnZXN0dXJlY2hhbmdlJywgJ2dlc3R1cmVlbmQnLCAnZm9jdXMnLCAnYmx1cicsICdjaGFuZ2UnLCAncmVzZXQnLCAnc2VsZWN0JywgJ3N1Ym1pdCcsICdmb2N1c2luJywgJ2ZvY3Vzb3V0JywgJ2xvYWQnLCAndW5sb2FkJywgJ2JlZm9yZXVubG9hZCcsICdyZXNpemUnLCAnbW92ZScsICdET01Db250ZW50TG9hZGVkJywgJ3JlYWR5c3RhdGVjaGFuZ2UnLCAnZXJyb3InLCAnYWJvcnQnLCAnc2Nyb2xsJ10pO1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIFByaXZhdGUgbWV0aG9kc1xcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmZ1bmN0aW9uIGdldFVpZEV2ZW50KGVsZW1lbnQsIHVpZCkge1xcbiAgcmV0dXJuIHVpZCAmJiBgJHt1aWR9Ojoke3VpZEV2ZW50Kyt9YCB8fCBlbGVtZW50LnVpZEV2ZW50IHx8IHVpZEV2ZW50Kys7XFxufVxcblxcbmZ1bmN0aW9uIGdldEV2ZW50KGVsZW1lbnQpIHtcXG4gIGNvbnN0IHVpZCA9IGdldFVpZEV2ZW50KGVsZW1lbnQpO1xcbiAgZWxlbWVudC51aWRFdmVudCA9IHVpZDtcXG4gIGV2ZW50UmVnaXN0cnlbdWlkXSA9IGV2ZW50UmVnaXN0cnlbdWlkXSB8fCB7fTtcXG4gIHJldHVybiBldmVudFJlZ2lzdHJ5W3VpZF07XFxufVxcblxcbmZ1bmN0aW9uIGJvb3RzdHJhcEhhbmRsZXIoZWxlbWVudCwgZm4pIHtcXG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XFxuICAgIGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gZWxlbWVudDtcXG5cXG4gICAgaWYgKGhhbmRsZXIub25lT2ZmKSB7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCBldmVudC50eXBlLCBmbik7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGZuLmFwcGx5KGVsZW1lbnQsIFtldmVudF0pO1xcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgc2VsZWN0b3IsIGZuKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xcbiAgICBjb25zdCBkb21FbGVtZW50cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XFxuXFxuICAgIGZvciAobGV0IHtcXG4gICAgICB0YXJnZXRcXG4gICAgfSA9IGV2ZW50OyB0YXJnZXQgJiYgdGFyZ2V0ICE9PSB0aGlzOyB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZSkge1xcbiAgICAgIGZvciAobGV0IGkgPSBkb21FbGVtZW50cy5sZW5ndGg7IGktLTspIHtcXG4gICAgICAgIGlmIChkb21FbGVtZW50c1tpXSA9PT0gdGFyZ2V0KSB7XFxuICAgICAgICAgIGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGFyZ2V0O1xcblxcbiAgICAgICAgICBpZiAoaGFuZGxlci5vbmVPZmYpIHtcXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9jb25zaXN0ZW50LWRlc3RydWN0dXJpbmdcXG4gICAgICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsIGV2ZW50LnR5cGUsIHNlbGVjdG9yLCBmbik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRhcmdldCwgW2V2ZW50XSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IC8vIFRvIHBsZWFzZSBFU0xpbnRcXG5cXG5cXG4gICAgcmV0dXJuIG51bGw7XFxuICB9O1xcbn1cXG5cXG5mdW5jdGlvbiBmaW5kSGFuZGxlcihldmVudHMsIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3RvciA9IG51bGwpIHtcXG4gIGNvbnN0IHVpZEV2ZW50TGlzdCA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XFxuXFxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gdWlkRXZlbnRMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW3VpZEV2ZW50TGlzdFtpXV07XFxuXFxuICAgIGlmIChldmVudC5vcmlnaW5hbEhhbmRsZXIgPT09IGhhbmRsZXIgJiYgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yID09PSBkZWxlZ2F0aW9uU2VsZWN0b3IpIHtcXG4gICAgICByZXR1cm4gZXZlbnQ7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBudWxsO1xcbn1cXG5cXG5mdW5jdGlvbiBub3JtYWxpemVQYXJhbXMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25Gbikge1xcbiAgY29uc3QgZGVsZWdhdGlvbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJztcXG4gIGNvbnN0IG9yaWdpbmFsSGFuZGxlciA9IGRlbGVnYXRpb24gPyBkZWxlZ2F0aW9uRm4gOiBoYW5kbGVyO1xcbiAgbGV0IHR5cGVFdmVudCA9IGdldFR5cGVFdmVudChvcmlnaW5hbFR5cGVFdmVudCk7XFxuICBjb25zdCBpc05hdGl2ZSA9IG5hdGl2ZUV2ZW50cy5oYXModHlwZUV2ZW50KTtcXG5cXG4gIGlmICghaXNOYXRpdmUpIHtcXG4gICAgdHlwZUV2ZW50ID0gb3JpZ2luYWxUeXBlRXZlbnQ7XFxuICB9XFxuXFxuICByZXR1cm4gW2RlbGVnYXRpb24sIG9yaWdpbmFsSGFuZGxlciwgdHlwZUV2ZW50XTtcXG59XFxuXFxuZnVuY3Rpb24gYWRkSGFuZGxlcihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuLCBvbmVPZmYpIHtcXG4gIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmICghaGFuZGxlcikge1xcbiAgICBoYW5kbGVyID0gZGVsZWdhdGlvbkZuO1xcbiAgICBkZWxlZ2F0aW9uRm4gPSBudWxsO1xcbiAgfSAvLyBpbiBjYXNlIG9mIG1vdXNlZW50ZXIgb3IgbW91c2VsZWF2ZSB3cmFwIHRoZSBoYW5kbGVyIHdpdGhpbiBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGZvciBpdHMgRE9NIHBvc2l0aW9uXFxuICAvLyB0aGlzIHByZXZlbnRzIHRoZSBoYW5kbGVyIGZyb20gYmVpbmcgZGlzcGF0Y2hlZCB0aGUgc2FtZSB3YXkgYXMgbW91c2VvdmVyIG9yIG1vdXNlb3V0IGRvZXNcXG5cXG5cXG4gIGlmIChjdXN0b21FdmVudHNSZWdleC50ZXN0KG9yaWdpbmFsVHlwZUV2ZW50KSkge1xcbiAgICBjb25zdCB3cmFwRm4gPSBmbiA9PiB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgaWYgKCFldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQgIT09IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmICFldmVudC5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xcbiAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfTtcXG5cXG4gICAgaWYgKGRlbGVnYXRpb25Gbikge1xcbiAgICAgIGRlbGVnYXRpb25GbiA9IHdyYXBGbihkZWxlZ2F0aW9uRm4pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGhhbmRsZXIgPSB3cmFwRm4oaGFuZGxlcik7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGNvbnN0IFtkZWxlZ2F0aW9uLCBvcmlnaW5hbEhhbmRsZXIsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbXMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25Gbik7XFxuICBjb25zdCBldmVudHMgPSBnZXRFdmVudChlbGVtZW50KTtcXG4gIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzW3R5cGVFdmVudF0gfHwgKGV2ZW50c1t0eXBlRXZlbnRdID0ge30pO1xcbiAgY29uc3QgcHJldmlvdXNGbiA9IGZpbmRIYW5kbGVyKGhhbmRsZXJzLCBvcmlnaW5hbEhhbmRsZXIsIGRlbGVnYXRpb24gPyBoYW5kbGVyIDogbnVsbCk7XFxuXFxuICBpZiAocHJldmlvdXNGbikge1xcbiAgICBwcmV2aW91c0ZuLm9uZU9mZiA9IHByZXZpb3VzRm4ub25lT2ZmICYmIG9uZU9mZjtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgY29uc3QgdWlkID0gZ2V0VWlkRXZlbnQob3JpZ2luYWxIYW5kbGVyLCBvcmlnaW5hbFR5cGVFdmVudC5yZXBsYWNlKG5hbWVzcGFjZVJlZ2V4LCAnJykpO1xcbiAgY29uc3QgZm4gPSBkZWxlZ2F0aW9uID8gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuKSA6IGJvb3RzdHJhcEhhbmRsZXIoZWxlbWVudCwgaGFuZGxlcik7XFxuICBmbi5kZWxlZ2F0aW9uU2VsZWN0b3IgPSBkZWxlZ2F0aW9uID8gaGFuZGxlciA6IG51bGw7XFxuICBmbi5vcmlnaW5hbEhhbmRsZXIgPSBvcmlnaW5hbEhhbmRsZXI7XFxuICBmbi5vbmVPZmYgPSBvbmVPZmY7XFxuICBmbi51aWRFdmVudCA9IHVpZDtcXG4gIGhhbmRsZXJzW3VpZF0gPSBmbjtcXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBkZWxlZ2F0aW9uKTtcXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvblNlbGVjdG9yKSB7XFxuICBjb25zdCBmbiA9IGZpbmRIYW5kbGVyKGV2ZW50c1t0eXBlRXZlbnRdLCBoYW5kbGVyLCBkZWxlZ2F0aW9uU2VsZWN0b3IpO1xcblxcbiAgaWYgKCFmbikge1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZUV2ZW50LCBmbiwgQm9vbGVhbihkZWxlZ2F0aW9uU2VsZWN0b3IpKTtcXG4gIGRlbGV0ZSBldmVudHNbdHlwZUV2ZW50XVtmbi51aWRFdmVudF07XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZU5hbWVzcGFjZWRIYW5kbGVycyhlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgbmFtZXNwYWNlKSB7XFxuICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xcbiAgT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpLmZvckVhY2goaGFuZGxlcktleSA9PiB7XFxuICAgIGlmIChoYW5kbGVyS2V5LmluY2x1ZGVzKG5hbWVzcGFjZSkpIHtcXG4gICAgICBjb25zdCBldmVudCA9IHN0b3JlRWxlbWVudEV2ZW50W2hhbmRsZXJLZXldO1xcbiAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGV2ZW50Lm9yaWdpbmFsSGFuZGxlciwgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yKTtcXG4gICAgfVxcbiAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIGdldFR5cGVFdmVudChldmVudCkge1xcbiAgLy8gYWxsb3cgdG8gZ2V0IHRoZSBuYXRpdmUgZXZlbnRzIGZyb20gbmFtZXNwYWNlZCBldmVudHMgKCdjbGljay5icy5idXR0b24nIC0tPiAnY2xpY2snKVxcbiAgZXZlbnQgPSBldmVudC5yZXBsYWNlKHN0cmlwTmFtZVJlZ2V4LCAnJyk7XFxuICByZXR1cm4gY3VzdG9tRXZlbnRzW2V2ZW50XSB8fCBldmVudDtcXG59XFxuXFxuY29uc3QgRXZlbnRIYW5kbGVyID0ge1xcbiAgb24oZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25Gbikge1xcbiAgICBhZGRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4sIGZhbHNlKTtcXG4gIH0sXFxuXFxuICBvbmUoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25Gbikge1xcbiAgICBhZGRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4sIHRydWUpO1xcbiAgfSxcXG5cXG4gIG9mZihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuKSB7XFxuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IFtkZWxlZ2F0aW9uLCBvcmlnaW5hbEhhbmRsZXIsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbXMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25Gbik7XFxuICAgIGNvbnN0IGluTmFtZXNwYWNlID0gdHlwZUV2ZW50ICE9PSBvcmlnaW5hbFR5cGVFdmVudDtcXG4gICAgY29uc3QgZXZlbnRzID0gZ2V0RXZlbnQoZWxlbWVudCk7XFxuICAgIGNvbnN0IGlzTmFtZXNwYWNlID0gb3JpZ2luYWxUeXBlRXZlbnQuc3RhcnRzV2l0aCgnLicpO1xcblxcbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsSGFuZGxlciAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAvLyBTaW1wbGVzdCBjYXNlOiBoYW5kbGVyIGlzIHBhc3NlZCwgcmVtb3ZlIHRoYXQgbGlzdGVuZXIgT05MWS5cXG4gICAgICBpZiAoIWV2ZW50cyB8fCAhZXZlbnRzW3R5cGVFdmVudF0pIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgb3JpZ2luYWxIYW5kbGVyLCBkZWxlZ2F0aW9uID8gaGFuZGxlciA6IG51bGwpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAoaXNOYW1lc3BhY2UpIHtcXG4gICAgICBPYmplY3Qua2V5cyhldmVudHMpLmZvckVhY2goZWxlbWVudEV2ZW50ID0+IHtcXG4gICAgICAgIHJlbW92ZU5hbWVzcGFjZWRIYW5kbGVycyhlbGVtZW50LCBldmVudHMsIGVsZW1lbnRFdmVudCwgb3JpZ2luYWxUeXBlRXZlbnQuc2xpY2UoMSkpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHN0b3JlRWxlbWVudEV2ZW50ID0gZXZlbnRzW3R5cGVFdmVudF0gfHwge307XFxuICAgIE9iamVjdC5rZXlzKHN0b3JlRWxlbWVudEV2ZW50KS5mb3JFYWNoKGtleUhhbmRsZXJzID0+IHtcXG4gICAgICBjb25zdCBoYW5kbGVyS2V5ID0ga2V5SGFuZGxlcnMucmVwbGFjZShzdHJpcFVpZFJlZ2V4LCAnJyk7XFxuXFxuICAgICAgaWYgKCFpbk5hbWVzcGFjZSB8fCBvcmlnaW5hbFR5cGVFdmVudC5pbmNsdWRlcyhoYW5kbGVyS2V5KSkge1xcbiAgICAgICAgY29uc3QgZXZlbnQgPSBzdG9yZUVsZW1lbnRFdmVudFtrZXlIYW5kbGVyc107XFxuICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBldmVudC5vcmlnaW5hbEhhbmRsZXIsIGV2ZW50LmRlbGVnYXRpb25TZWxlY3Rvcik7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH0sXFxuXFxuICB0cmlnZ2VyKGVsZW1lbnQsIGV2ZW50LCBhcmdzKSB7XFxuICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgJCA9IGdldGpRdWVyeSgpO1xcbiAgICBjb25zdCB0eXBlRXZlbnQgPSBnZXRUeXBlRXZlbnQoZXZlbnQpO1xcbiAgICBjb25zdCBpbk5hbWVzcGFjZSA9IGV2ZW50ICE9PSB0eXBlRXZlbnQ7XFxuICAgIGNvbnN0IGlzTmF0aXZlID0gbmF0aXZlRXZlbnRzLmhhcyh0eXBlRXZlbnQpO1xcbiAgICBsZXQgalF1ZXJ5RXZlbnQ7XFxuICAgIGxldCBidWJibGVzID0gdHJ1ZTtcXG4gICAgbGV0IG5hdGl2ZURpc3BhdGNoID0gdHJ1ZTtcXG4gICAgbGV0IGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcXG4gICAgbGV0IGV2dCA9IG51bGw7XFxuXFxuICAgIGlmIChpbk5hbWVzcGFjZSAmJiAkKSB7XFxuICAgICAgalF1ZXJ5RXZlbnQgPSAkLkV2ZW50KGV2ZW50LCBhcmdzKTtcXG4gICAgICAkKGVsZW1lbnQpLnRyaWdnZXIoalF1ZXJ5RXZlbnQpO1xcbiAgICAgIGJ1YmJsZXMgPSAhalF1ZXJ5RXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcXG4gICAgICBuYXRpdmVEaXNwYXRjaCA9ICFqUXVlcnlFdmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpO1xcbiAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSBqUXVlcnlFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcXG4gICAgfVxcblxcbiAgICBpZiAoaXNOYXRpdmUpIHtcXG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xcbiAgICAgIGV2dC5pbml0RXZlbnQodHlwZUV2ZW50LCBidWJibGVzLCB0cnVlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHtcXG4gICAgICAgIGJ1YmJsZXMsXFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXFxuICAgICAgfSk7XFxuICAgIH0gLy8gbWVyZ2UgY3VzdG9tIGluZm9ybWF0aW9uIGluIG91ciBldmVudFxcblxcblxcbiAgICBpZiAodHlwZW9mIGFyZ3MgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgT2JqZWN0LmtleXMoYXJncykuZm9yRWFjaChrZXkgPT4ge1xcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2dCwga2V5LCB7XFxuICAgICAgICAgIGdldCgpIHtcXG4gICAgICAgICAgICByZXR1cm4gYXJnc1trZXldO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICB9XFxuXFxuICAgIGlmIChuYXRpdmVEaXNwYXRjaCkge1xcbiAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldnQpO1xcbiAgICB9XFxuXFxuICAgIGlmIChldnQuZGVmYXVsdFByZXZlbnRlZCAmJiB0eXBlb2YgalF1ZXJ5RXZlbnQgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgalF1ZXJ5RXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZXZ0O1xcbiAgfVxcblxcbn07XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGJhc2UtY29tcG9uZW50LmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBWRVJTSU9OID0gJzUuMC4xJztcXG5cXG5jbGFzcyBCYXNlQ29tcG9uZW50IHtcXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcXG4gICAgZWxlbWVudCA9IGdldEVsZW1lbnQoZWxlbWVudCk7XFxuXFxuICAgIGlmICghZWxlbWVudCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcXG4gICAgRGF0YS5zZXQodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcyk7XFxuICB9XFxuXFxuICBkaXNwb3NlKCkge1xcbiAgICBEYXRhLnJlbW92ZSh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKTtcXG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSk7XFxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLmZvckVhY2gocHJvcGVydHlOYW1lID0+IHtcXG4gICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBudWxsO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIF9xdWV1ZUNhbGxiYWNrKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkID0gdHJ1ZSkge1xcbiAgICBpZiAoIWlzQW5pbWF0ZWQpIHtcXG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQoZWxlbWVudCk7XFxuICAgIEV2ZW50SGFuZGxlci5vbmUoZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCAoKSA9PiBleGVjdXRlKGNhbGxiYWNrKSk7XFxuICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGVsZW1lbnQsIHRyYW5zaXRpb25EdXJhdGlvbik7XFxuICB9XFxuICAvKiogU3RhdGljICovXFxuXFxuXFxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudCkge1xcbiAgICByZXR1cm4gRGF0YS5nZXQoZWxlbWVudCwgdGhpcy5EQVRBX0tFWSk7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XFxuICAgIHJldHVybiBWRVJTSU9OO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIHRvIGltcGxlbWVudCB0aGUgc3RhdGljIG1ldGhvZCBcXFwiTkFNRVxcXCIsIGZvciBlYWNoIGNvbXBvbmVudCEnKTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XFxuICAgIHJldHVybiBgYnMuJHt0aGlzLk5BTUV9YDtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xcbiAgICByZXR1cm4gYC4ke3RoaXMuREFUQV9LRVl9YDtcXG4gIH1cXG5cXG59XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGFsZXJ0LmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBOQU1FJGMgPSAnYWxlcnQnO1xcbmNvbnN0IERBVEFfS0VZJGIgPSAnYnMuYWxlcnQnO1xcbmNvbnN0IEVWRU5UX0tFWSRiID0gYC4ke0RBVEFfS0VZJGJ9YDtcXG5jb25zdCBEQVRBX0FQSV9LRVkkOCA9ICcuZGF0YS1hcGknO1xcbmNvbnN0IFNFTEVDVE9SX0RJU01JU1MgPSAnW2RhdGEtYnMtZGlzbWlzcz1cXFwiYWxlcnRcXFwiXSc7XFxuY29uc3QgRVZFTlRfQ0xPU0UgPSBgY2xvc2Uke0VWRU5UX0tFWSRifWA7XFxuY29uc3QgRVZFTlRfQ0xPU0VEID0gYGNsb3NlZCR7RVZFTlRfS0VZJGJ9YDtcXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ3ID0gYGNsaWNrJHtFVkVOVF9LRVkkYn0ke0RBVEFfQVBJX0tFWSQ4fWA7XFxuY29uc3QgQ0xBU1NfTkFNRV9BTEVSVCA9ICdhbGVydCc7XFxuY29uc3QgQ0xBU1NfTkFNRV9GQURFJDYgPSAnZmFkZSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDkgPSAnc2hvdyc7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIEFsZXJ0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XFxuICAvLyBHZXR0ZXJzXFxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgIHJldHVybiBOQU1FJGM7XFxuICB9IC8vIFB1YmxpY1xcblxcblxcbiAgY2xvc2UoZWxlbWVudCkge1xcbiAgICBjb25zdCByb290RWxlbWVudCA9IGVsZW1lbnQgPyB0aGlzLl9nZXRSb290RWxlbWVudChlbGVtZW50KSA6IHRoaXMuX2VsZW1lbnQ7XFxuXFxuICAgIGNvbnN0IGN1c3RvbUV2ZW50ID0gdGhpcy5fdHJpZ2dlckNsb3NlRXZlbnQocm9vdEVsZW1lbnQpO1xcblxcbiAgICBpZiAoY3VzdG9tRXZlbnQgPT09IG51bGwgfHwgY3VzdG9tRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9yZW1vdmVFbGVtZW50KHJvb3RFbGVtZW50KTtcXG4gIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgX2dldFJvb3RFbGVtZW50KGVsZW1lbnQpIHtcXG4gICAgcmV0dXJuIGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkgfHwgZWxlbWVudC5jbG9zZXN0KGAuJHtDTEFTU19OQU1FX0FMRVJUfWApO1xcbiAgfVxcblxcbiAgX3RyaWdnZXJDbG9zZUV2ZW50KGVsZW1lbnQpIHtcXG4gICAgcmV0dXJuIEV2ZW50SGFuZGxlci50cmlnZ2VyKGVsZW1lbnQsIEVWRU5UX0NMT1NFKTtcXG4gIH1cXG5cXG4gIF9yZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcXG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ5KTtcXG4gICAgY29uc3QgaXNBbmltYXRlZCA9IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQ2KTtcXG5cXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudChlbGVtZW50KSwgZWxlbWVudCwgaXNBbmltYXRlZCk7XFxuICB9XFxuXFxuICBfZGVzdHJveUVsZW1lbnQoZWxlbWVudCkge1xcbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XFxuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xcbiAgICB9XFxuXFxuICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKGVsZW1lbnQsIEVWRU5UX0NMT1NFRCk7XFxuICB9IC8vIFN0YXRpY1xcblxcblxcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgbGV0IGRhdGEgPSBEYXRhLmdldCh0aGlzLCBEQVRBX0tFWSRiKTtcXG5cXG4gICAgICBpZiAoIWRhdGEpIHtcXG4gICAgICAgIGRhdGEgPSBuZXcgQWxlcnQodGhpcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjb25maWcgPT09ICdjbG9zZScpIHtcXG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgc3RhdGljIGhhbmRsZURpc21pc3MoYWxlcnRJbnN0YW5jZSkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgaWYgKGV2ZW50KSB7XFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBhbGVydEluc3RhbmNlLmNsb3NlKHRoaXMpO1xcbiAgICB9O1xcbiAgfVxcblxcbn1cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcblxcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNywgU0VMRUNUT1JfRElTTUlTUywgQWxlcnQuaGFuZGxlRGlzbWlzcyhuZXcgQWxlcnQoKSkpO1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGpRdWVyeVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGFkZCAuQWxlcnQgdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcXG4gKi9cXG5cXG5kZWZpbmVKUXVlcnlQbHVnaW4oQWxlcnQpO1xcblxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQm9vdHN0cmFwICh2NS4wLjEpOiBidXR0b24uanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIENvbnN0YW50c1xcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNvbnN0IE5BTUUkYiA9ICdidXR0b24nO1xcbmNvbnN0IERBVEFfS0VZJGEgPSAnYnMuYnV0dG9uJztcXG5jb25zdCBFVkVOVF9LRVkkYSA9IGAuJHtEQVRBX0tFWSRhfWA7XFxuY29uc3QgREFUQV9BUElfS0VZJDcgPSAnLmRhdGEtYXBpJztcXG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSQzID0gJ2FjdGl2ZSc7XFxuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkNSA9ICdbZGF0YS1icy10b2dnbGU9XFxcImJ1dHRvblxcXCJdJztcXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ2ID0gYGNsaWNrJHtFVkVOVF9LRVkkYX0ke0RBVEFfQVBJX0tFWSQ3fWA7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIEJ1dHRvbiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgLy8gR2V0dGVyc1xcbiAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICByZXR1cm4gTkFNRSRiO1xcbiAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gIHRvZ2dsZSgpIHtcXG4gICAgLy8gVG9nZ2xlIGNsYXNzIGFuZCBzeW5jIHRoZSBgYXJpYS1wcmVzc2VkYCBhdHRyaWJ1dGUgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBgLnRvZ2dsZSgpYCBtZXRob2RcXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX0FDVElWRSQzKSk7XFxuICB9IC8vIFN0YXRpY1xcblxcblxcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgbGV0IGRhdGEgPSBEYXRhLmdldCh0aGlzLCBEQVRBX0tFWSRhKTtcXG5cXG4gICAgICBpZiAoIWRhdGEpIHtcXG4gICAgICAgIGRhdGEgPSBuZXcgQnV0dG9uKHRoaXMpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY29uZmlnID09PSAndG9nZ2xlJykge1xcbiAgICAgICAgZGF0YVtjb25maWddKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG5cXG59XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5cXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDYsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUsIGV2ZW50ID0+IHtcXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICBjb25zdCBidXR0b24gPSBldmVudC50YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1KTtcXG4gIGxldCBkYXRhID0gRGF0YS5nZXQoYnV0dG9uLCBEQVRBX0tFWSRhKTtcXG5cXG4gIGlmICghZGF0YSkge1xcbiAgICBkYXRhID0gbmV3IEJ1dHRvbihidXR0b24pO1xcbiAgfVxcblxcbiAgZGF0YS50b2dnbGUoKTtcXG59KTtcXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBqUXVlcnlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBhZGQgLkJ1dHRvbiB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxcbiAqL1xcblxcbmRlZmluZUpRdWVyeVBsdWdpbihCdXR0b24pO1xcblxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQm9vdHN0cmFwICh2NS4wLjEpOiBkb20vbWFuaXB1bGF0b3IuanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcbmZ1bmN0aW9uIG5vcm1hbGl6ZURhdGEodmFsKSB7XFxuICBpZiAodmFsID09PSAndHJ1ZScpIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICBpZiAodmFsID09PSAnZmFsc2UnKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIGlmICh2YWwgPT09IE51bWJlcih2YWwpLnRvU3RyaW5nKCkpIHtcXG4gICAgcmV0dXJuIE51bWJlcih2YWwpO1xcbiAgfVxcblxcbiAgaWYgKHZhbCA9PT0gJycgfHwgdmFsID09PSAnbnVsbCcpIHtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuXFxuICByZXR1cm4gdmFsO1xcbn1cXG5cXG5mdW5jdGlvbiBub3JtYWxpemVEYXRhS2V5KGtleSkge1xcbiAgcmV0dXJuIGtleS5yZXBsYWNlKC9bQS1aXS9nLCBjaHIgPT4gYC0ke2Noci50b0xvd2VyQ2FzZSgpfWApO1xcbn1cXG5cXG5jb25zdCBNYW5pcHVsYXRvciA9IHtcXG4gIHNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5LCB2YWx1ZSkge1xcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gLCB2YWx1ZSk7XFxuICB9LFxcblxcbiAgcmVtb3ZlRGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcXG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCk7XFxuICB9LFxcblxcbiAgZ2V0RGF0YUF0dHJpYnV0ZXMoZWxlbWVudCkge1xcbiAgICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgICByZXR1cm4ge307XFxuICAgIH1cXG5cXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xcbiAgICBPYmplY3Qua2V5cyhlbGVtZW50LmRhdGFzZXQpLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2JzJykpLmZvckVhY2goa2V5ID0+IHtcXG4gICAgICBsZXQgcHVyZUtleSA9IGtleS5yZXBsYWNlKC9eYnMvLCAnJyk7XFxuICAgICAgcHVyZUtleSA9IHB1cmVLZXkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBwdXJlS2V5LnNsaWNlKDEsIHB1cmVLZXkubGVuZ3RoKTtcXG4gICAgICBhdHRyaWJ1dGVzW3B1cmVLZXldID0gbm9ybWFsaXplRGF0YShlbGVtZW50LmRhdGFzZXRba2V5XSk7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gYXR0cmlidXRlcztcXG4gIH0sXFxuXFxuICBnZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSkge1xcbiAgICByZXR1cm4gbm9ybWFsaXplRGF0YShlbGVtZW50LmdldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gKSk7XFxuICB9LFxcblxcbiAgb2Zmc2V0KGVsZW1lbnQpIHtcXG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgIHJldHVybiB7XFxuICAgICAgdG9wOiByZWN0LnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLFxcbiAgICAgIGxlZnQ6IHJlY3QubGVmdCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdFxcbiAgICB9O1xcbiAgfSxcXG5cXG4gIHBvc2l0aW9uKGVsZW1lbnQpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICB0b3A6IGVsZW1lbnQub2Zmc2V0VG9wLFxcbiAgICAgIGxlZnQ6IGVsZW1lbnQub2Zmc2V0TGVmdFxcbiAgICB9O1xcbiAgfVxcblxcbn07XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGNhcm91c2VsLmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBOQU1FJGEgPSAnY2Fyb3VzZWwnO1xcbmNvbnN0IERBVEFfS0VZJDkgPSAnYnMuY2Fyb3VzZWwnO1xcbmNvbnN0IEVWRU5UX0tFWSQ5ID0gYC4ke0RBVEFfS0VZJDl9YDtcXG5jb25zdCBEQVRBX0FQSV9LRVkkNiA9ICcuZGF0YS1hcGknO1xcbmNvbnN0IEFSUk9XX0xFRlRfS0VZID0gJ0Fycm93TGVmdCc7XFxuY29uc3QgQVJST1dfUklHSFRfS0VZID0gJ0Fycm93UmlnaHQnO1xcbmNvbnN0IFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgPSA1MDA7IC8vIFRpbWUgZm9yIG1vdXNlIGNvbXBhdCBldmVudHMgdG8gZmlyZSBhZnRlciB0b3VjaFxcblxcbmNvbnN0IFNXSVBFX1RIUkVTSE9MRCA9IDQwO1xcbmNvbnN0IERlZmF1bHQkOSA9IHtcXG4gIGludGVydmFsOiA1MDAwLFxcbiAga2V5Ym9hcmQ6IHRydWUsXFxuICBzbGlkZTogZmFsc2UsXFxuICBwYXVzZTogJ2hvdmVyJyxcXG4gIHdyYXA6IHRydWUsXFxuICB0b3VjaDogdHJ1ZVxcbn07XFxuY29uc3QgRGVmYXVsdFR5cGUkOSA9IHtcXG4gIGludGVydmFsOiAnKG51bWJlcnxib29sZWFuKScsXFxuICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxcbiAgc2xpZGU6ICcoYm9vbGVhbnxzdHJpbmcpJyxcXG4gIHBhdXNlOiAnKHN0cmluZ3xib29sZWFuKScsXFxuICB3cmFwOiAnYm9vbGVhbicsXFxuICB0b3VjaDogJ2Jvb2xlYW4nXFxufTtcXG5jb25zdCBPUkRFUl9ORVhUID0gJ25leHQnO1xcbmNvbnN0IE9SREVSX1BSRVYgPSAncHJldic7XFxuY29uc3QgRElSRUNUSU9OX0xFRlQgPSAnbGVmdCc7XFxuY29uc3QgRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcXG5jb25zdCBFVkVOVF9TTElERSA9IGBzbGlkZSR7RVZFTlRfS0VZJDl9YDtcXG5jb25zdCBFVkVOVF9TTElEID0gYHNsaWQke0VWRU5UX0tFWSQ5fWA7XFxuY29uc3QgRVZFTlRfS0VZRE9XTiA9IGBrZXlkb3duJHtFVkVOVF9LRVkkOX1gO1xcbmNvbnN0IEVWRU5UX01PVVNFRU5URVIgPSBgbW91c2VlbnRlciR7RVZFTlRfS0VZJDl9YDtcXG5jb25zdCBFVkVOVF9NT1VTRUxFQVZFID0gYG1vdXNlbGVhdmUke0VWRU5UX0tFWSQ5fWA7XFxuY29uc3QgRVZFTlRfVE9VQ0hTVEFSVCA9IGB0b3VjaHN0YXJ0JHtFVkVOVF9LRVkkOX1gO1xcbmNvbnN0IEVWRU5UX1RPVUNITU9WRSA9IGB0b3VjaG1vdmUke0VWRU5UX0tFWSQ5fWA7XFxuY29uc3QgRVZFTlRfVE9VQ0hFTkQgPSBgdG91Y2hlbmQke0VWRU5UX0tFWSQ5fWA7XFxuY29uc3QgRVZFTlRfUE9JTlRFUkRPV04gPSBgcG9pbnRlcmRvd24ke0VWRU5UX0tFWSQ5fWA7XFxuY29uc3QgRVZFTlRfUE9JTlRFUlVQID0gYHBvaW50ZXJ1cCR7RVZFTlRfS0VZJDl9YDtcXG5jb25zdCBFVkVOVF9EUkFHX1NUQVJUID0gYGRyYWdzdGFydCR7RVZFTlRfS0VZJDl9YDtcXG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDIgPSBgbG9hZCR7RVZFTlRfS0VZJDl9JHtEQVRBX0FQSV9LRVkkNn1gO1xcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDUgPSBgY2xpY2ske0VWRU5UX0tFWSQ5fSR7REFUQV9BUElfS0VZJDZ9YDtcXG5jb25zdCBDTEFTU19OQU1FX0NBUk9VU0VMID0gJ2Nhcm91c2VsJztcXG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSQyID0gJ2FjdGl2ZSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9TTElERSA9ICdzbGlkZSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9FTkQgPSAnY2Fyb3VzZWwtaXRlbS1lbmQnO1xcbmNvbnN0IENMQVNTX05BTUVfU1RBUlQgPSAnY2Fyb3VzZWwtaXRlbS1zdGFydCc7XFxuY29uc3QgQ0xBU1NfTkFNRV9ORVhUID0gJ2Nhcm91c2VsLWl0ZW0tbmV4dCc7XFxuY29uc3QgQ0xBU1NfTkFNRV9QUkVWID0gJ2Nhcm91c2VsLWl0ZW0tcHJldic7XFxuY29uc3QgQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UID0gJ3BvaW50ZXItZXZlbnQnO1xcbmNvbnN0IFNFTEVDVE9SX0FDVElWRSQxID0gJy5hY3RpdmUnO1xcbmNvbnN0IFNFTEVDVE9SX0FDVElWRV9JVEVNID0gJy5hY3RpdmUuY2Fyb3VzZWwtaXRlbSc7XFxuY29uc3QgU0VMRUNUT1JfSVRFTSA9ICcuY2Fyb3VzZWwtaXRlbSc7XFxuY29uc3QgU0VMRUNUT1JfSVRFTV9JTUcgPSAnLmNhcm91c2VsLWl0ZW0gaW1nJztcXG5jb25zdCBTRUxFQ1RPUl9ORVhUX1BSRVYgPSAnLmNhcm91c2VsLWl0ZW0tbmV4dCwgLmNhcm91c2VsLWl0ZW0tcHJldic7XFxuY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SUyA9ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycyc7XFxuY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SID0gJ1tkYXRhLWJzLXRhcmdldF0nO1xcbmNvbnN0IFNFTEVDVE9SX0RBVEFfU0xJREUgPSAnW2RhdGEtYnMtc2xpZGVdLCBbZGF0YS1icy1zbGlkZS10b10nO1xcbmNvbnN0IFNFTEVDVE9SX0RBVEFfUklERSA9ICdbZGF0YS1icy1yaWRlPVxcXCJjYXJvdXNlbFxcXCJdJztcXG5jb25zdCBQT0lOVEVSX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xcbmNvbnN0IFBPSU5URVJfVFlQRV9QRU4gPSAncGVuJztcXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDbGFzcyBEZWZpbml0aW9uXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuY2xhc3MgQ2Fyb3VzZWwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xcbiAgICBzdXBlcihlbGVtZW50KTtcXG4gICAgdGhpcy5faXRlbXMgPSBudWxsO1xcbiAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XFxuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xcbiAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xcbiAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcXG4gICAgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsO1xcbiAgICB0aGlzLnRvdWNoU3RhcnRYID0gMDtcXG4gICAgdGhpcy50b3VjaERlbHRhWCA9IDA7XFxuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xcbiAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfSU5ESUNBVE9SUywgdGhpcy5fZWxlbWVudCk7XFxuICAgIHRoaXMuX3RvdWNoU3VwcG9ydGVkID0gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDA7XFxuICAgIHRoaXMuX3BvaW50ZXJFdmVudCA9IEJvb2xlYW4od2luZG93LlBvaW50ZXJFdmVudCk7XFxuXFxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XFxuICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgcmV0dXJuIERlZmF1bHQkOTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgcmV0dXJuIE5BTUUkYTtcXG4gIH0gLy8gUHVibGljXFxuXFxuXFxuICBuZXh0KCkge1xcbiAgICBpZiAoIXRoaXMuX2lzU2xpZGluZykge1xcbiAgICAgIHRoaXMuX3NsaWRlKE9SREVSX05FWFQpO1xcbiAgICB9XFxuICB9XFxuXFxuICBuZXh0V2hlblZpc2libGUoKSB7XFxuICAgIC8vIERvbid0IGNhbGwgbmV4dCB3aGVuIHRoZSBwYWdlIGlzbid0IHZpc2libGVcXG4gICAgLy8gb3IgdGhlIGNhcm91c2VsIG9yIGl0cyBwYXJlbnQgaXNuJ3QgdmlzaWJsZVxcbiAgICBpZiAoIWRvY3VtZW50LmhpZGRlbiAmJiBpc1Zpc2libGUodGhpcy5fZWxlbWVudCkpIHtcXG4gICAgICB0aGlzLm5leHQoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcHJldigpIHtcXG4gICAgaWYgKCF0aGlzLl9pc1NsaWRpbmcpIHtcXG4gICAgICB0aGlzLl9zbGlkZShPUkRFUl9QUkVWKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcGF1c2UoZXZlbnQpIHtcXG4gICAgaWYgKCFldmVudCkge1xcbiAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAoU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9ORVhUX1BSRVYsIHRoaXMuX2VsZW1lbnQpKSB7XFxuICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQodGhpcy5fZWxlbWVudCk7XFxuICAgICAgdGhpcy5jeWNsZSh0cnVlKTtcXG4gICAgfVxcblxcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xcbiAgfVxcblxcbiAgY3ljbGUoZXZlbnQpIHtcXG4gICAgaWYgKCFldmVudCkge1xcbiAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XFxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XFxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9jb25maWcgJiYgdGhpcy5fY29uZmlnLmludGVydmFsICYmICF0aGlzLl9pc1BhdXNlZCkge1xcbiAgICAgIHRoaXMuX3VwZGF0ZUludGVydmFsKCk7XFxuXFxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID8gdGhpcy5uZXh0V2hlblZpc2libGUgOiB0aGlzLm5leHQpLmJpbmQodGhpcyksIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRvKGluZGV4KSB7XFxuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRV9JVEVNLCB0aGlzLl9lbGVtZW50KTtcXG5cXG4gICAgY29uc3QgYWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgodGhpcy5fYWN0aXZlRWxlbWVudCk7XFxuXFxuICAgIGlmIChpbmRleCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcXG4gICAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NMSUQsICgpID0+IHRoaXMudG8oaW5kZXgpKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKGFjdGl2ZUluZGV4ID09PSBpbmRleCkge1xcbiAgICAgIHRoaXMucGF1c2UoKTtcXG4gICAgICB0aGlzLmN5Y2xlKCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IG9yZGVyID0gaW5kZXggPiBhY3RpdmVJbmRleCA/IE9SREVSX05FWFQgOiBPUkRFUl9QUkVWO1xcblxcbiAgICB0aGlzLl9zbGlkZShvcmRlciwgdGhpcy5faXRlbXNbaW5kZXhdKTtcXG4gIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgY29uZmlnID0geyAuLi5EZWZhdWx0JDksXFxuICAgICAgLi4uY29uZmlnXFxuICAgIH07XFxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FJGEsIGNvbmZpZywgRGVmYXVsdFR5cGUkOSk7XFxuICAgIHJldHVybiBjb25maWc7XFxuICB9XFxuXFxuICBfaGFuZGxlU3dpcGUoKSB7XFxuICAgIGNvbnN0IGFic0RlbHRheCA9IE1hdGguYWJzKHRoaXMudG91Y2hEZWx0YVgpO1xcblxcbiAgICBpZiAoYWJzRGVsdGF4IDw9IFNXSVBFX1RIUkVTSE9MRCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBhYnNEZWx0YXggLyB0aGlzLnRvdWNoRGVsdGFYO1xcbiAgICB0aGlzLnRvdWNoRGVsdGFYID0gMDtcXG5cXG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fc2xpZGUoZGlyZWN0aW9uID4gMCA/IERJUkVDVElPTl9SSUdIVCA6IERJUkVDVElPTl9MRUZUKTtcXG4gIH1cXG5cXG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRUVOVEVSLCBldmVudCA9PiB0aGlzLnBhdXNlKGV2ZW50KSk7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFTEVBVkUsIGV2ZW50ID0+IHRoaXMuY3ljbGUoZXZlbnQpKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5fY29uZmlnLnRvdWNoICYmIHRoaXMuX3RvdWNoU3VwcG9ydGVkKSB7XFxuICAgICAgdGhpcy5fYWRkVG91Y2hFdmVudExpc3RlbmVycygpO1xcbiAgICB9XFxuICB9XFxuXFxuICBfYWRkVG91Y2hFdmVudExpc3RlbmVycygpIHtcXG4gICAgY29uc3Qgc3RhcnQgPSBldmVudCA9PiB7XFxuICAgICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCAmJiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9QRU4gfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9UT1VDSCkpIHtcXG4gICAgICAgIHRoaXMudG91Y2hTdGFydFggPSBldmVudC5jbGllbnRYO1xcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3BvaW50ZXJFdmVudCkge1xcbiAgICAgICAgdGhpcy50b3VjaFN0YXJ0WCA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WDtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGNvbnN0IG1vdmUgPSBldmVudCA9PiB7XFxuICAgICAgLy8gZW5zdXJlIHN3aXBpbmcgd2l0aCBvbmUgdG91Y2ggYW5kIG5vdCBwaW5jaGluZ1xcbiAgICAgIHRoaXMudG91Y2hEZWx0YVggPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSA/IDAgOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYO1xcbiAgICB9O1xcblxcbiAgICBjb25zdCBlbmQgPSBldmVudCA9PiB7XFxuICAgICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCAmJiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9QRU4gfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9UT1VDSCkpIHtcXG4gICAgICAgIHRoaXMudG91Y2hEZWx0YVggPSBldmVudC5jbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0WDtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5faGFuZGxlU3dpcGUoKTtcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlID09PSAnaG92ZXInKSB7XFxuICAgICAgICAvLyBJZiBpdCdzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2UsIG1vdXNlZW50ZXIvbGVhdmUgYXJlIGZpcmVkIGFzXFxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSBtb3VzZSBjb21wYXRpYmlsaXR5IGV2ZW50cyBvbiBmaXJzdCB0YXAgLSB0aGUgY2Fyb3VzZWxcXG4gICAgICAgIC8vIHdvdWxkIHN0b3AgY3ljbGluZyB1bnRpbCB1c2VyIHRhcHBlZCBvdXQgb2YgaXQ7XFxuICAgICAgICAvLyBoZXJlLCB3ZSBsaXN0ZW4gZm9yIHRvdWNoZW5kLCBleHBsaWNpdGx5IHBhdXNlIHRoZSBjYXJvdXNlbFxcbiAgICAgICAgLy8gKGFzIGlmIGl0J3MgdGhlIHNlY29uZCB0aW1lIHdlIHRhcCBvbiBpdCwgbW91c2VlbnRlciBjb21wYXQgZXZlbnRcXG4gICAgICAgIC8vIGlzIE5PVCBmaXJlZCkgYW5kIGFmdGVyIGEgdGltZW91dCAodG8gYWxsb3cgZm9yIG1vdXNlIGNvbXBhdGliaWxpdHlcXG4gICAgICAgIC8vIGV2ZW50cyB0byBmaXJlKSB3ZSBleHBsaWNpdGx5IHJlc3RhcnQgY3ljbGluZ1xcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xcblxcbiAgICAgICAgaWYgKHRoaXMudG91Y2hUaW1lb3V0KSB7XFxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRvdWNoVGltZW91dCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoZXZlbnQgPT4gdGhpcy5jeWNsZShldmVudCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNX0lNRywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChpdGVtSW1nID0+IHtcXG4gICAgICBFdmVudEhhbmRsZXIub24oaXRlbUltZywgRVZFTlRfRFJBR19TVEFSVCwgZSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xcbiAgICB9KTtcXG5cXG4gICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCkge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9QT0lOVEVSRE9XTiwgZXZlbnQgPT4gc3RhcnQoZXZlbnQpKTtcXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfUE9JTlRFUlVQLCBldmVudCA9PiBlbmQoZXZlbnQpKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hTVEFSVCwgZXZlbnQgPT4gc3RhcnQoZXZlbnQpKTtcXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hNT1ZFLCBldmVudCA9PiBtb3ZlKGV2ZW50KSk7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIRU5ELCBldmVudCA9PiBlbmQoZXZlbnQpKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgX2tleWRvd24oZXZlbnQpIHtcXG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmIChldmVudC5rZXkgPT09IEFSUk9XX0xFRlRfS0VZKSB7XFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICB0aGlzLl9zbGlkZShESVJFQ1RJT05fUklHSFQpO1xcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfUklHSFRfS0VZKSB7XFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICB0aGlzLl9zbGlkZShESVJFQ1RJT05fTEVGVCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9nZXRJdGVtSW5kZXgoZWxlbWVudCkge1xcbiAgICB0aGlzLl9pdGVtcyA9IGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlID8gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNLCBlbGVtZW50LnBhcmVudE5vZGUpIDogW107XFxuICAgIHJldHVybiB0aGlzLl9pdGVtcy5pbmRleE9mKGVsZW1lbnQpO1xcbiAgfVxcblxcbiAgX2dldEl0ZW1CeU9yZGVyKG9yZGVyLCBhY3RpdmVFbGVtZW50KSB7XFxuICAgIGNvbnN0IGlzTmV4dCA9IG9yZGVyID09PSBPUkRFUl9ORVhUO1xcbiAgICBjb25zdCBpc1ByZXYgPSBvcmRlciA9PT0gT1JERVJfUFJFVjtcXG5cXG4gICAgY29uc3QgYWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCk7XFxuXFxuICAgIGNvbnN0IGxhc3RJdGVtSW5kZXggPSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxO1xcbiAgICBjb25zdCBpc0dvaW5nVG9XcmFwID0gaXNQcmV2ICYmIGFjdGl2ZUluZGV4ID09PSAwIHx8IGlzTmV4dCAmJiBhY3RpdmVJbmRleCA9PT0gbGFzdEl0ZW1JbmRleDtcXG5cXG4gICAgaWYgKGlzR29pbmdUb1dyYXAgJiYgIXRoaXMuX2NvbmZpZy53cmFwKSB7XFxuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZGVsdGEgPSBpc1ByZXYgPyAtMSA6IDE7XFxuICAgIGNvbnN0IGl0ZW1JbmRleCA9IChhY3RpdmVJbmRleCArIGRlbHRhKSAlIHRoaXMuX2l0ZW1zLmxlbmd0aDtcXG4gICAgcmV0dXJuIGl0ZW1JbmRleCA9PT0gLTEgPyB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXSA6IHRoaXMuX2l0ZW1zW2l0ZW1JbmRleF07XFxuICB9XFxuXFxuICBfdHJpZ2dlclNsaWRlRXZlbnQocmVsYXRlZFRhcmdldCwgZXZlbnREaXJlY3Rpb25OYW1lKSB7XFxuICAgIGNvbnN0IHRhcmdldEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHJlbGF0ZWRUYXJnZXQpO1xcblxcbiAgICBjb25zdCBmcm9tSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgoU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9BQ1RJVkVfSVRFTSwgdGhpcy5fZWxlbWVudCkpO1xcblxcbiAgICByZXR1cm4gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0xJREUsIHtcXG4gICAgICByZWxhdGVkVGFyZ2V0LFxcbiAgICAgIGRpcmVjdGlvbjogZXZlbnREaXJlY3Rpb25OYW1lLFxcbiAgICAgIGZyb206IGZyb21JbmRleCxcXG4gICAgICB0bzogdGFyZ2V0SW5kZXhcXG4gICAgfSk7XFxuICB9XFxuXFxuICBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChlbGVtZW50KSB7XFxuICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xcbiAgICAgIGNvbnN0IGFjdGl2ZUluZGljYXRvciA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFJDEsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcXG4gICAgICBhY3RpdmVJbmRpY2F0b3IuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQyKTtcXG4gICAgICBhY3RpdmVJbmRpY2F0b3IucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnKTtcXG4gICAgICBjb25zdCBpbmRpY2F0b3JzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JTkRJQ0FUT1IsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcXG5cXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljYXRvcnMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoaW5kaWNhdG9yc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtc2xpZGUtdG8nKSwgMTApID09PSB0aGlzLl9nZXRJdGVtSW5kZXgoZWxlbWVudCkpIHtcXG4gICAgICAgICAgaW5kaWNhdG9yc1tpXS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDIpO1xcbiAgICAgICAgICBpbmRpY2F0b3JzW2ldLnNldEF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50JywgJ3RydWUnKTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBfdXBkYXRlSW50ZXJ2YWwoKSB7XFxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9hY3RpdmVFbGVtZW50IHx8IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFX0lURU0sIHRoaXMuX2VsZW1lbnQpO1xcblxcbiAgICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZWxlbWVudEludGVydmFsID0gTnVtYmVyLnBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLWludGVydmFsJyksIDEwKTtcXG5cXG4gICAgaWYgKGVsZW1lbnRJbnRlcnZhbCkge1xcbiAgICAgIHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgPSB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5pbnRlcnZhbDtcXG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBlbGVtZW50SW50ZXJ2YWw7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWw7XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9zbGlkZShkaXJlY3Rpb25Pck9yZGVyLCBlbGVtZW50KSB7XFxuICAgIGNvbnN0IG9yZGVyID0gdGhpcy5fZGlyZWN0aW9uVG9PcmRlcihkaXJlY3Rpb25Pck9yZGVyKTtcXG5cXG4gICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFX0lURU0sIHRoaXMuX2VsZW1lbnQpO1xcblxcbiAgICBjb25zdCBhY3RpdmVFbGVtZW50SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCk7XFxuXFxuICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCB0aGlzLl9nZXRJdGVtQnlPcmRlcihvcmRlciwgYWN0aXZlRWxlbWVudCk7XFxuXFxuICAgIGNvbnN0IG5leHRFbGVtZW50SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgobmV4dEVsZW1lbnQpO1xcblxcbiAgICBjb25zdCBpc0N5Y2xpbmcgPSBCb29sZWFuKHRoaXMuX2ludGVydmFsKTtcXG4gICAgY29uc3QgaXNOZXh0ID0gb3JkZXIgPT09IE9SREVSX05FWFQ7XFxuICAgIGNvbnN0IGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gaXNOZXh0ID8gQ0xBU1NfTkFNRV9TVEFSVCA6IENMQVNTX05BTUVfRU5EO1xcbiAgICBjb25zdCBvcmRlckNsYXNzTmFtZSA9IGlzTmV4dCA/IENMQVNTX05BTUVfTkVYVCA6IENMQVNTX05BTUVfUFJFVjtcXG5cXG4gICAgY29uc3QgZXZlbnREaXJlY3Rpb25OYW1lID0gdGhpcy5fb3JkZXJUb0RpcmVjdGlvbihvcmRlcik7XFxuXFxuICAgIGlmIChuZXh0RWxlbWVudCAmJiBuZXh0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUkMikpIHtcXG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3Qgc2xpZGVFdmVudCA9IHRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KG5leHRFbGVtZW50LCBldmVudERpcmVjdGlvbk5hbWUpO1xcblxcbiAgICBpZiAoc2xpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAhbmV4dEVsZW1lbnQpIHtcXG4gICAgICAvLyBTb21lIHdlaXJkbmVzcyBpcyBoYXBwZW5pbmcsIHNvIHdlIGJhaWxcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5faXNTbGlkaW5nID0gdHJ1ZTtcXG5cXG4gICAgaWYgKGlzQ3ljbGluZykge1xcbiAgICAgIHRoaXMucGF1c2UoKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50KTtcXG5cXG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG5leHRFbGVtZW50O1xcblxcbiAgICBjb25zdCB0cmlnZ2VyU2xpZEV2ZW50ID0gKCkgPT4ge1xcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NMSUQsIHtcXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG5leHRFbGVtZW50LFxcbiAgICAgICAgZGlyZWN0aW9uOiBldmVudERpcmVjdGlvbk5hbWUsXFxuICAgICAgICBmcm9tOiBhY3RpdmVFbGVtZW50SW5kZXgsXFxuICAgICAgICB0bzogbmV4dEVsZW1lbnRJbmRleFxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBpZiAodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TTElERSkpIHtcXG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKG9yZGVyQ2xhc3NOYW1lKTtcXG4gICAgICByZWZsb3cobmV4dEVsZW1lbnQpO1xcbiAgICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XFxuICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XFxuXFxuICAgICAgY29uc3QgY29tcGxldGVDYWxsQmFjayA9ICgpID0+IHtcXG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoZGlyZWN0aW9uYWxDbGFzc05hbWUsIG9yZGVyQ2xhc3NOYW1lKTtcXG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XFxuICAgICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMiwgb3JkZXJDbGFzc05hbWUsIGRpcmVjdGlvbmFsQ2xhc3NOYW1lKTtcXG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xcbiAgICAgICAgc2V0VGltZW91dCh0cmlnZ2VyU2xpZEV2ZW50LCAwKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsQmFjaywgYWN0aXZlRWxlbWVudCwgdHJ1ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDIpO1xcbiAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XFxuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XFxuICAgICAgdHJpZ2dlclNsaWRFdmVudCgpO1xcbiAgICB9XFxuXFxuICAgIGlmIChpc0N5Y2xpbmcpIHtcXG4gICAgICB0aGlzLmN5Y2xlKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9kaXJlY3Rpb25Ub09yZGVyKGRpcmVjdGlvbikge1xcbiAgICBpZiAoIVtESVJFQ1RJT05fUklHSFQsIERJUkVDVElPTl9MRUZUXS5pbmNsdWRlcyhkaXJlY3Rpb24pKSB7XFxuICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcXG4gICAgfVxcblxcbiAgICBpZiAoaXNSVEwoKSkge1xcbiAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUID8gT1JERVJfUFJFViA6IE9SREVSX05FWFQ7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVjtcXG4gIH1cXG5cXG4gIF9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSB7XFxuICAgIGlmICghW09SREVSX05FWFQsIE9SREVSX1BSRVZdLmluY2x1ZGVzKG9yZGVyKSkge1xcbiAgICAgIHJldHVybiBvcmRlcjtcXG4gICAgfVxcblxcbiAgICBpZiAoaXNSVEwoKSkge1xcbiAgICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9SSUdIVCA6IERJUkVDVElPTl9MRUZUO1xcbiAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gIHN0YXRpYyBjYXJvdXNlbEludGVyZmFjZShlbGVtZW50LCBjb25maWcpIHtcXG4gICAgbGV0IGRhdGEgPSBEYXRhLmdldChlbGVtZW50LCBEQVRBX0tFWSQ5KTtcXG4gICAgbGV0IF9jb25maWcgPSB7IC4uLkRlZmF1bHQkOSxcXG4gICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyhlbGVtZW50KVxcbiAgICB9O1xcblxcbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcpIHtcXG4gICAgICBfY29uZmlnID0geyAuLi5fY29uZmlnLFxcbiAgICAgICAgLi4uY29uZmlnXFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBhY3Rpb24gPSB0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyA/IGNvbmZpZyA6IF9jb25maWcuc2xpZGU7XFxuXFxuICAgIGlmICghZGF0YSkge1xcbiAgICAgIGRhdGEgPSBuZXcgQ2Fyb3VzZWwoZWxlbWVudCwgX2NvbmZpZyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XFxuICAgICAgZGF0YS50byhjb25maWcpO1xcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnKSB7XFxuICAgICAgaWYgKHR5cGVvZiBkYXRhW2FjdGlvbl0gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7YWN0aW9ufVxcXCJgKTtcXG4gICAgICB9XFxuXFxuICAgICAgZGF0YVthY3Rpb25dKCk7XFxuICAgIH0gZWxzZSBpZiAoX2NvbmZpZy5pbnRlcnZhbCAmJiBfY29uZmlnLnJpZGUpIHtcXG4gICAgICBkYXRhLnBhdXNlKCk7XFxuICAgICAgZGF0YS5jeWNsZSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICBDYXJvdXNlbC5jYXJvdXNlbEludGVyZmFjZSh0aGlzLCBjb25maWcpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBkYXRhQXBpQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XFxuICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XFxuXFxuICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQ0FST1VTRUwpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGNvbmZpZyA9IHsgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGFyZ2V0KSxcXG4gICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzKVxcbiAgICB9O1xcbiAgICBjb25zdCBzbGlkZUluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtc2xpZGUtdG8nKTtcXG5cXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcXG4gICAgICBjb25maWcuaW50ZXJ2YWwgPSBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBDYXJvdXNlbC5jYXJvdXNlbEludGVyZmFjZSh0YXJnZXQsIGNvbmZpZyk7XFxuXFxuICAgIGlmIChzbGlkZUluZGV4KSB7XFxuICAgICAgRGF0YS5nZXQodGFyZ2V0LCBEQVRBX0tFWSQ5KS50byhzbGlkZUluZGV4KTtcXG4gICAgfVxcblxcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgfVxcblxcbn1cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcblxcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSwgU0VMRUNUT1JfREFUQV9TTElERSwgQ2Fyb3VzZWwuZGF0YUFwaUNsaWNrSGFuZGxlcik7XFxuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQyLCAoKSA9PiB7XFxuICBjb25zdCBjYXJvdXNlbHMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfUklERSk7XFxuXFxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2Fyb3VzZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgIENhcm91c2VsLmNhcm91c2VsSW50ZXJmYWNlKGNhcm91c2Vsc1tpXSwgRGF0YS5nZXQoY2Fyb3VzZWxzW2ldLCBEQVRBX0tFWSQ5KSk7XFxuICB9XFxufSk7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogalF1ZXJ5XFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogYWRkIC5DYXJvdXNlbCB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxcbiAqL1xcblxcbmRlZmluZUpRdWVyeVBsdWdpbihDYXJvdXNlbCk7XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGNvbGxhcHNlLmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBOQU1FJDkgPSAnY29sbGFwc2UnO1xcbmNvbnN0IERBVEFfS0VZJDggPSAnYnMuY29sbGFwc2UnO1xcbmNvbnN0IEVWRU5UX0tFWSQ4ID0gYC4ke0RBVEFfS0VZJDh9YDtcXG5jb25zdCBEQVRBX0FQSV9LRVkkNSA9ICcuZGF0YS1hcGknO1xcbmNvbnN0IERlZmF1bHQkOCA9IHtcXG4gIHRvZ2dsZTogdHJ1ZSxcXG4gIHBhcmVudDogJydcXG59O1xcbmNvbnN0IERlZmF1bHRUeXBlJDggPSB7XFxuICB0b2dnbGU6ICdib29sZWFuJyxcXG4gIHBhcmVudDogJyhzdHJpbmd8ZWxlbWVudCknXFxufTtcXG5jb25zdCBFVkVOVF9TSE9XJDUgPSBgc2hvdyR7RVZFTlRfS0VZJDh9YDtcXG5jb25zdCBFVkVOVF9TSE9XTiQ1ID0gYHNob3duJHtFVkVOVF9LRVkkOH1gO1xcbmNvbnN0IEVWRU5UX0hJREUkNSA9IGBoaWRlJHtFVkVOVF9LRVkkOH1gO1xcbmNvbnN0IEVWRU5UX0hJRERFTiQ1ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDh9YDtcXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ0ID0gYGNsaWNrJHtFVkVOVF9LRVkkOH0ke0RBVEFfQVBJX0tFWSQ1fWA7XFxuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDggPSAnc2hvdyc7XFxuY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRSA9ICdjb2xsYXBzZSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTSU5HID0gJ2NvbGxhcHNpbmcnO1xcbmNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0VEID0gJ2NvbGxhcHNlZCc7XFxuY29uc3QgV0lEVEggPSAnd2lkdGgnO1xcbmNvbnN0IEhFSUdIVCA9ICdoZWlnaHQnO1xcbmNvbnN0IFNFTEVDVE9SX0FDVElWRVMgPSAnLnNob3csIC5jb2xsYXBzaW5nJztcXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0ID0gJ1tkYXRhLWJzLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiXSc7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIENvbGxhcHNlIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XFxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgc3VwZXIoZWxlbWVudCk7XFxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgdGhpcy5fdHJpZ2dlckFycmF5ID0gU2VsZWN0b3JFbmdpbmUuZmluZChgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0fVtocmVmPVxcXCIjJHt0aGlzLl9lbGVtZW50LmlkfVxcXCJdLGAgKyBgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0fVtkYXRhLWJzLXRhcmdldD1cXFwiIyR7dGhpcy5fZWxlbWVudC5pZH1cXFwiXWApO1xcbiAgICBjb25zdCB0b2dnbGVMaXN0ID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0KTtcXG5cXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRvZ2dsZUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICBjb25zdCBlbGVtID0gdG9nZ2xlTGlzdFtpXTtcXG4gICAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbSk7XFxuICAgICAgY29uc3QgZmlsdGVyRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpLmZpbHRlcihmb3VuZEVsZW0gPT4gZm91bmRFbGVtID09PSB0aGlzLl9lbGVtZW50KTtcXG5cXG4gICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwgJiYgZmlsdGVyRWxlbWVudC5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7XFxuXFxuICAgICAgICB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChlbGVtKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fY29uZmlnLnBhcmVudCA/IHRoaXMuX2dldFBhcmVudCgpIDogbnVsbDtcXG5cXG4gICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XFxuICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3RyaWdnZXJBcnJheSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcXG4gICAgICB0aGlzLnRvZ2dsZSgpO1xcbiAgICB9XFxuICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgcmV0dXJuIERlZmF1bHQkODtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgcmV0dXJuIE5BTUUkOTtcXG4gIH0gLy8gUHVibGljXFxuXFxuXFxuICB0b2dnbGUoKSB7XFxuICAgIGlmICh0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckOCkpIHtcXG4gICAgICB0aGlzLmhpZGUoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLnNob3coKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgc2hvdygpIHtcXG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckOCkpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgbGV0IGFjdGl2ZXM7XFxuICAgIGxldCBhY3RpdmVzRGF0YTtcXG5cXG4gICAgaWYgKHRoaXMuX3BhcmVudCkge1xcbiAgICAgIGFjdGl2ZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0FDVElWRVMsIHRoaXMuX3BhcmVudCkuZmlsdGVyKGVsZW0gPT4ge1xcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucGFyZW50ID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtcGFyZW50JykgPT09IHRoaXMuX2NvbmZpZy5wYXJlbnQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9DT0xMQVBTRSk7XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICBhY3RpdmVzID0gbnVsbDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgY29uc3QgY29udGFpbmVyID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZSh0aGlzLl9zZWxlY3Rvcik7XFxuXFxuICAgIGlmIChhY3RpdmVzKSB7XFxuICAgICAgY29uc3QgdGVtcEFjdGl2ZURhdGEgPSBhY3RpdmVzLmZpbmQoZWxlbSA9PiBjb250YWluZXIgIT09IGVsZW0pO1xcbiAgICAgIGFjdGl2ZXNEYXRhID0gdGVtcEFjdGl2ZURhdGEgPyBEYXRhLmdldCh0ZW1wQWN0aXZlRGF0YSwgREFUQV9LRVkkOCkgOiBudWxsO1xcblxcbiAgICAgIGlmIChhY3RpdmVzRGF0YSAmJiBhY3RpdmVzRGF0YS5faXNUcmFuc2l0aW9uaW5nKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDUpO1xcblxcbiAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmIChhY3RpdmVzKSB7XFxuICAgICAgYWN0aXZlcy5mb3JFYWNoKGVsZW1BY3RpdmUgPT4ge1xcbiAgICAgICAgaWYgKGNvbnRhaW5lciAhPT0gZWxlbUFjdGl2ZSkge1xcbiAgICAgICAgICBDb2xsYXBzZS5jb2xsYXBzZUludGVyZmFjZShlbGVtQWN0aXZlLCAnaGlkZScpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFhY3RpdmVzRGF0YSkge1xcbiAgICAgICAgICBEYXRhLnNldChlbGVtQWN0aXZlLCBEQVRBX0tFWSQ4LCBudWxsKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcXG5cXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcXG5cXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gMDtcXG5cXG4gICAgaWYgKHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGgpIHtcXG4gICAgICB0aGlzLl90cmlnZ2VyQXJyYXkuZm9yRWFjaChlbGVtZW50ID0+IHtcXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNFRCk7XFxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKTtcXG5cXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0UsIENMQVNTX05BTUVfU0hPVyQ4KTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJztcXG4gICAgICB0aGlzLnNldFRyYW5zaXRpb25pbmcoZmFsc2UpO1xcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDUpO1xcbiAgICB9O1xcblxcbiAgICBjb25zdCBjYXBpdGFsaXplZERpbWVuc2lvbiA9IGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpO1xcbiAgICBjb25zdCBzY3JvbGxTaXplID0gYHNjcm9sbCR7Y2FwaXRhbGl6ZWREaW1lbnNpb259YDtcXG5cXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IGAke3RoaXMuX2VsZW1lbnRbc2Nyb2xsU2l6ZV19cHhgO1xcbiAgfVxcblxcbiAgaGlkZSgpIHtcXG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAhdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDgpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDUpO1xcblxcbiAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbWVuc2lvbl19cHhgO1xcbiAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XJDgpO1xcblxcbiAgICBjb25zdCB0cmlnZ2VyQXJyYXlMZW5ndGggPSB0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoO1xcblxcbiAgICBpZiAodHJpZ2dlckFycmF5TGVuZ3RoID4gMCkge1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpZ2dlckFycmF5TGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGNvbnN0IHRyaWdnZXIgPSB0aGlzLl90cmlnZ2VyQXJyYXlbaV07XFxuICAgICAgICBjb25zdCBlbGVtID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0cmlnZ2VyKTtcXG5cXG4gICAgICAgIGlmIChlbGVtICYmICFlbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckOCkpIHtcXG4gICAgICAgICAgdHJpZ2dlci5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0VEKTtcXG4gICAgICAgICAgdHJpZ2dlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKTtcXG5cXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XFxuICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKGZhbHNlKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRSk7XFxuXFxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDUpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJztcXG5cXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XFxuICB9XFxuXFxuICBzZXRUcmFuc2l0aW9uaW5nKGlzVHJhbnNpdGlvbmluZykge1xcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBpc1RyYW5zaXRpb25pbmc7XFxuICB9IC8vIFByaXZhdGVcXG5cXG5cXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XFxuICAgIGNvbmZpZyA9IHsgLi4uRGVmYXVsdCQ4LFxcbiAgICAgIC4uLmNvbmZpZ1xcbiAgICB9O1xcbiAgICBjb25maWcudG9nZ2xlID0gQm9vbGVhbihjb25maWcudG9nZ2xlKTsgLy8gQ29lcmNlIHN0cmluZyB2YWx1ZXNcXG5cXG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUkOSwgY29uZmlnLCBEZWZhdWx0VHlwZSQ4KTtcXG4gICAgcmV0dXJuIGNvbmZpZztcXG4gIH1cXG5cXG4gIF9nZXREaW1lbnNpb24oKSB7XFxuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhXSURUSCkgPyBXSURUSCA6IEhFSUdIVDtcXG4gIH1cXG5cXG4gIF9nZXRQYXJlbnQoKSB7XFxuICAgIGxldCB7XFxuICAgICAgcGFyZW50XFxuICAgIH0gPSB0aGlzLl9jb25maWc7XFxuICAgIHBhcmVudCA9IGdldEVsZW1lbnQocGFyZW50KTtcXG4gICAgY29uc3Qgc2VsZWN0b3IgPSBgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0fVtkYXRhLWJzLXBhcmVudD1cXFwiJHtwYXJlbnR9XFxcIl1gO1xcbiAgICBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yLCBwYXJlbnQpLmZvckVhY2goZWxlbWVudCA9PiB7XFxuICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpO1xcblxcbiAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhzZWxlY3RlZCwgW2VsZW1lbnRdKTtcXG4gICAgfSk7XFxuICAgIHJldHVybiBwYXJlbnQ7XFxuICB9XFxuXFxuICBfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKGVsZW1lbnQsIHRyaWdnZXJBcnJheSkge1xcbiAgICBpZiAoIWVsZW1lbnQgfHwgIXRyaWdnZXJBcnJheS5sZW5ndGgpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgaXNPcGVuID0gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDgpO1xcbiAgICB0cmlnZ2VyQXJyYXkuZm9yRWFjaChlbGVtID0+IHtcXG4gICAgICBpZiAoaXNPcGVuKSB7XFxuICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRUQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBlbGVtLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRUQpO1xcbiAgICAgIH1cXG5cXG4gICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGlzT3Blbik7XFxuICAgIH0pO1xcbiAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gIHN0YXRpYyBjb2xsYXBzZUludGVyZmFjZShlbGVtZW50LCBjb25maWcpIHtcXG4gICAgbGV0IGRhdGEgPSBEYXRhLmdldChlbGVtZW50LCBEQVRBX0tFWSQ4KTtcXG4gICAgY29uc3QgX2NvbmZpZyA9IHsgLi4uRGVmYXVsdCQ4LFxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpLFxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcXG4gICAgfTtcXG5cXG4gICAgaWYgKCFkYXRhICYmIF9jb25maWcudG9nZ2xlICYmIHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xcbiAgICAgIF9jb25maWcudG9nZ2xlID0gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgaWYgKCFkYXRhKSB7XFxuICAgICAgZGF0YSA9IG5ldyBDb2xsYXBzZShlbGVtZW50LCBfY29uZmlnKTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcXFwiJHtjb25maWd9XFxcImApO1xcbiAgICAgIH1cXG5cXG4gICAgICBkYXRhW2NvbmZpZ10oKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgQ29sbGFwc2UuY29sbGFwc2VJbnRlcmZhY2UodGhpcywgY29uZmlnKTtcXG4gICAgfSk7XFxuICB9XFxuXFxufVxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuXFxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ0LCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0LCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gIC8vIHByZXZlbnREZWZhdWx0IG9ubHkgZm9yIDxhPiBlbGVtZW50cyAod2hpY2ggY2hhbmdlIHRoZSBVUkwpIG5vdCBpbnNpZGUgdGhlIGNvbGxhcHNpYmxlIGVsZW1lbnRcXG4gIGlmIChldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0EnIHx8IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmIGV2ZW50LmRlbGVnYXRlVGFyZ2V0LnRhZ05hbWUgPT09ICdBJykge1xcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgfVxcblxcbiAgY29uc3QgdHJpZ2dlckRhdGEgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzKTtcXG4gIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtcXG4gIGNvbnN0IHNlbGVjdG9yRWxlbWVudHMgPSBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yKTtcXG4gIHNlbGVjdG9yRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcXG4gICAgY29uc3QgZGF0YSA9IERhdGEuZ2V0KGVsZW1lbnQsIERBVEFfS0VZJDgpO1xcbiAgICBsZXQgY29uZmlnO1xcblxcbiAgICBpZiAoZGF0YSkge1xcbiAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgYXR0cmlidXRlXFxuICAgICAgaWYgKGRhdGEuX3BhcmVudCA9PT0gbnVsbCAmJiB0eXBlb2YgdHJpZ2dlckRhdGEucGFyZW50ID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgZGF0YS5fY29uZmlnLnBhcmVudCA9IHRyaWdnZXJEYXRhLnBhcmVudDtcXG4gICAgICAgIGRhdGEuX3BhcmVudCA9IGRhdGEuX2dldFBhcmVudCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25maWcgPSAndG9nZ2xlJztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjb25maWcgPSB0cmlnZ2VyRGF0YTtcXG4gICAgfVxcblxcbiAgICBDb2xsYXBzZS5jb2xsYXBzZUludGVyZmFjZShlbGVtZW50LCBjb25maWcpO1xcbiAgfSk7XFxufSk7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogalF1ZXJ5XFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogYWRkIC5Db2xsYXBzZSB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxcbiAqL1xcblxcbmRlZmluZUpRdWVyeVBsdWdpbihDb2xsYXBzZSk7XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IGRyb3Bkb3duLmpzXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBOQU1FJDggPSAnZHJvcGRvd24nO1xcbmNvbnN0IERBVEFfS0VZJDcgPSAnYnMuZHJvcGRvd24nO1xcbmNvbnN0IEVWRU5UX0tFWSQ3ID0gYC4ke0RBVEFfS0VZJDd9YDtcXG5jb25zdCBEQVRBX0FQSV9LRVkkNCA9ICcuZGF0YS1hcGknO1xcbmNvbnN0IEVTQ0FQRV9LRVkkMiA9ICdFc2NhcGUnO1xcbmNvbnN0IFNQQUNFX0tFWSA9ICdTcGFjZSc7XFxuY29uc3QgVEFCX0tFWSA9ICdUYWInO1xcbmNvbnN0IEFSUk9XX1VQX0tFWSA9ICdBcnJvd1VwJztcXG5jb25zdCBBUlJPV19ET1dOX0tFWSA9ICdBcnJvd0Rvd24nO1xcbmNvbnN0IFJJR0hUX01PVVNFX0JVVFRPTiA9IDI7IC8vIE1vdXNlRXZlbnQuYnV0dG9uIHZhbHVlIGZvciB0aGUgc2Vjb25kYXJ5IGJ1dHRvbiwgdXN1YWxseSB0aGUgcmlnaHQgYnV0dG9uXFxuXFxuY29uc3QgUkVHRVhQX0tFWURPV04gPSBuZXcgUmVnRXhwKGAke0FSUk9XX1VQX0tFWX18JHtBUlJPV19ET1dOX0tFWX18JHtFU0NBUEVfS0VZJDJ9YCk7XFxuY29uc3QgRVZFTlRfSElERSQ0ID0gYGhpZGUke0VWRU5UX0tFWSQ3fWA7XFxuY29uc3QgRVZFTlRfSElEREVOJDQgPSBgaGlkZGVuJHtFVkVOVF9LRVkkN31gO1xcbmNvbnN0IEVWRU5UX1NIT1ckNCA9IGBzaG93JHtFVkVOVF9LRVkkN31gO1xcbmNvbnN0IEVWRU5UX1NIT1dOJDQgPSBgc2hvd24ke0VWRU5UX0tFWSQ3fWA7XFxuY29uc3QgRVZFTlRfQ0xJQ0sgPSBgY2xpY2ske0VWRU5UX0tFWSQ3fWA7XFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMyA9IGBjbGljayR7RVZFTlRfS0VZJDd9JHtEQVRBX0FQSV9LRVkkNH1gO1xcbmNvbnN0IEVWRU5UX0tFWURPV05fREFUQV9BUEkgPSBga2V5ZG93biR7RVZFTlRfS0VZJDd9JHtEQVRBX0FQSV9LRVkkNH1gO1xcbmNvbnN0IEVWRU5UX0tFWVVQX0RBVEFfQVBJID0gYGtleXVwJHtFVkVOVF9LRVkkN30ke0RBVEFfQVBJX0tFWSQ0fWA7XFxuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDcgPSAnc2hvdyc7XFxuY29uc3QgQ0xBU1NfTkFNRV9EUk9QVVAgPSAnZHJvcHVwJztcXG5jb25zdCBDTEFTU19OQU1FX0RST1BFTkQgPSAnZHJvcGVuZCc7XFxuY29uc3QgQ0xBU1NfTkFNRV9EUk9QU1RBUlQgPSAnZHJvcHN0YXJ0JztcXG5jb25zdCBDTEFTU19OQU1FX05BVkJBUiA9ICduYXZiYXInO1xcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMgPSAnW2RhdGEtYnMtdG9nZ2xlPVxcXCJkcm9wZG93blxcXCJdJztcXG5jb25zdCBTRUxFQ1RPUl9NRU5VID0gJy5kcm9wZG93bi1tZW51JztcXG5jb25zdCBTRUxFQ1RPUl9OQVZCQVJfTkFWID0gJy5uYXZiYXItbmF2JztcXG5jb25zdCBTRUxFQ1RPUl9WSVNJQkxFX0lURU1TID0gJy5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJztcXG5jb25zdCBQTEFDRU1FTlRfVE9QID0gaXNSVEwoKSA/ICd0b3AtZW5kJyA6ICd0b3Atc3RhcnQnO1xcbmNvbnN0IFBMQUNFTUVOVF9UT1BFTkQgPSBpc1JUTCgpID8gJ3RvcC1zdGFydCcgOiAndG9wLWVuZCc7XFxuY29uc3QgUExBQ0VNRU5UX0JPVFRPTSA9IGlzUlRMKCkgPyAnYm90dG9tLWVuZCcgOiAnYm90dG9tLXN0YXJ0JztcXG5jb25zdCBQTEFDRU1FTlRfQk9UVE9NRU5EID0gaXNSVEwoKSA/ICdib3R0b20tc3RhcnQnIDogJ2JvdHRvbS1lbmQnO1xcbmNvbnN0IFBMQUNFTUVOVF9SSUdIVCA9IGlzUlRMKCkgPyAnbGVmdC1zdGFydCcgOiAncmlnaHQtc3RhcnQnO1xcbmNvbnN0IFBMQUNFTUVOVF9MRUZUID0gaXNSVEwoKSA/ICdyaWdodC1zdGFydCcgOiAnbGVmdC1zdGFydCc7XFxuY29uc3QgRGVmYXVsdCQ3ID0ge1xcbiAgb2Zmc2V0OiBbMCwgMl0sXFxuICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXFxuICByZWZlcmVuY2U6ICd0b2dnbGUnLFxcbiAgZGlzcGxheTogJ2R5bmFtaWMnLFxcbiAgcG9wcGVyQ29uZmlnOiBudWxsLFxcbiAgYXV0b0Nsb3NlOiB0cnVlXFxufTtcXG5jb25zdCBEZWZhdWx0VHlwZSQ3ID0ge1xcbiAgb2Zmc2V0OiAnKGFycmF5fHN0cmluZ3xmdW5jdGlvbiknLFxcbiAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcXG4gIHJlZmVyZW5jZTogJyhzdHJpbmd8ZWxlbWVudHxvYmplY3QpJyxcXG4gIGRpc3BsYXk6ICdzdHJpbmcnLFxcbiAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0fGZ1bmN0aW9uKScsXFxuICBhdXRvQ2xvc2U6ICcoYm9vbGVhbnxzdHJpbmcpJ1xcbn07XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIERyb3Bkb3duIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XFxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgc3VwZXIoZWxlbWVudCk7XFxuICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XFxuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xcbiAgICB0aGlzLl9tZW51ID0gdGhpcy5fZ2V0TWVudUVsZW1lbnQoKTtcXG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcXG5cXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcXG4gIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xcbiAgICByZXR1cm4gRGVmYXVsdCQ3O1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcXG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDc7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgIHJldHVybiBOQU1FJDg7XFxuICB9IC8vIFB1YmxpY1xcblxcblxcbiAgdG9nZ2xlKCkge1xcbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzLl9lbGVtZW50KSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ3KTtcXG5cXG4gICAgaWYgKGlzQWN0aXZlKSB7XFxuICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuc2hvdygpO1xcbiAgfVxcblxcbiAgc2hvdygpIHtcXG4gICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgdGhpcy5fbWVudS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDcpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHBhcmVudCA9IERyb3Bkb3duLmdldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xcbiAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcXG4gICAgfTtcXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ0LCByZWxhdGVkVGFyZ2V0KTtcXG5cXG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9IC8vIFRvdGFsbHkgZGlzYWJsZSBQb3BwZXIgZm9yIERyb3Bkb3ducyBpbiBOYXZiYXJcXG5cXG5cXG4gICAgaWYgKHRoaXMuX2luTmF2YmFyKSB7XFxuICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJywgJ25vbmUnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAodHlwZW9mIF9wb3BwZXJqc19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXFxcJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGxldCByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ3BhcmVudCcpIHtcXG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBwYXJlbnQ7XFxuICAgICAgfSBlbHNlIGlmIChpc0VsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkpIHtcXG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBnZXRFbGVtZW50KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpO1xcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZTtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgcG9wcGVyQ29uZmlnID0gdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCk7XFxuXFxuICAgICAgY29uc3QgaXNEaXNwbGF5U3RhdGljID0gcG9wcGVyQ29uZmlnLm1vZGlmaWVycy5maW5kKG1vZGlmaWVyID0+IG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlcycgJiYgbW9kaWZpZXIuZW5hYmxlZCA9PT0gZmFsc2UpO1xcbiAgICAgIHRoaXMuX3BvcHBlciA9IF9wb3BwZXJqc19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImNyZWF0ZVBvcHBlclxcXCJdKHJlZmVyZW5jZUVsZW1lbnQsIHRoaXMuX21lbnUsIHBvcHBlckNvbmZpZyk7XFxuXFxuICAgICAgaWYgKGlzRGlzcGxheVN0YXRpYykge1xcbiAgICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJywgJ3N0YXRpYycpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXFxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XFxuICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXFxuICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxcblxcblxcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICFwYXJlbnQuY2xvc2VzdChTRUxFQ1RPUl9OQVZCQVJfTkFWKSkge1xcbiAgICAgIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKGVsZW0gPT4gRXZlbnRIYW5kbGVyLm9uKGVsZW0sICdtb3VzZW92ZXInLCBub29wKSk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xcblxcbiAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfTkFNRV9TSE9XJDcpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfTkFNRV9TSE9XJDcpO1xcblxcbiAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQ0LCByZWxhdGVkVGFyZ2V0KTtcXG4gIH1cXG5cXG4gIGhpZGUoKSB7XFxuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8ICF0aGlzLl9tZW51LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckNykpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcXG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KTtcXG4gIH1cXG5cXG4gIGRpc3Bvc2UoKSB7XFxuICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcXG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xcbiAgICB9XFxuXFxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcXG4gIH1cXG5cXG4gIHVwZGF0ZSgpIHtcXG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcXG5cXG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xcbiAgICAgIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcXG4gICAgfVxcbiAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XFxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDSywgZXZlbnQgPT4ge1xcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgdGhpcy50b2dnbGUoKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBfY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ0LCByZWxhdGVkVGFyZ2V0KTtcXG5cXG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXFxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XFxuXFxuXFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcXG4gICAgICBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaChlbGVtID0+IEV2ZW50SGFuZGxlci5vZmYoZWxlbSwgJ21vdXNlb3ZlcicsIG5vb3ApKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XFxuICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDcpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDcpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xcblxcbiAgICBNYW5pcHVsYXRvci5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInKTtcXG4gICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDQsIHJlbGF0ZWRUYXJnZXQpO1xcbiAgfVxcblxcbiAgX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgY29uZmlnID0geyAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXFxuICAgICAgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXFxuICAgICAgLi4uY29uZmlnXFxuICAgIH07XFxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FJDgsIGNvbmZpZywgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSk7XFxuXFxuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgIWlzRWxlbWVudChjb25maWcucmVmZXJlbmNlKSAmJiB0eXBlb2YgY29uZmlnLnJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAvLyBQb3BwZXIgdmlydHVhbCBlbGVtZW50cyByZXF1aXJlIGEgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG1ldGhvZFxcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7TkFNRSQ4LnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXFxcInJlZmVyZW5jZVxcXCIgcHJvdmlkZWQgdHlwZSBcXFwib2JqZWN0XFxcIiB3aXRob3V0IGEgcmVxdWlyZWQgXFxcImdldEJvdW5kaW5nQ2xpZW50UmVjdFxcXCIgbWV0aG9kLmApO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBjb25maWc7XFxuICB9XFxuXFxuICBfZ2V0TWVudUVsZW1lbnQoKSB7XFxuICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5uZXh0KHRoaXMuX2VsZW1lbnQsIFNFTEVDVE9SX01FTlUpWzBdO1xcbiAgfVxcblxcbiAgX2dldFBsYWNlbWVudCgpIHtcXG4gICAgY29uc3QgcGFyZW50RHJvcGRvd24gPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7XFxuXFxuICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRU5EKSkge1xcbiAgICAgIHJldHVybiBQTEFDRU1FTlRfUklHSFQ7XFxuICAgIH1cXG5cXG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BTVEFSVCkpIHtcXG4gICAgICByZXR1cm4gUExBQ0VNRU5UX0xFRlQ7XFxuICAgIH0gLy8gV2UgbmVlZCB0byB0cmltIHRoZSB2YWx1ZSBiZWNhdXNlIGN1c3RvbSBwcm9wZXJ0aWVzIGNhbiBhbHNvIGluY2x1ZGUgc3BhY2VzXFxuXFxuXFxuICAgIGNvbnN0IGlzRW5kID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZW51KS5nZXRQcm9wZXJ0eVZhbHVlKCctLWJzLXBvc2l0aW9uJykudHJpbSgpID09PSAnZW5kJztcXG5cXG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BVUCkpIHtcXG4gICAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfVE9QRU5EIDogUExBQ0VNRU5UX1RPUDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfQk9UVE9NRU5EIDogUExBQ0VNRU5UX0JPVFRPTTtcXG4gIH1cXG5cXG4gIF9kZXRlY3ROYXZiYXIoKSB7XFxuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoYC4ke0NMQVNTX05BTUVfTkFWQkFSfWApICE9PSBudWxsO1xcbiAgfVxcblxcbiAgX2dldE9mZnNldCgpIHtcXG4gICAgY29uc3Qge1xcbiAgICAgIG9mZnNldFxcbiAgICB9ID0gdGhpcy5fY29uZmlnO1xcblxcbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICByZXR1cm4gb2Zmc2V0LnNwbGl0KCcsJykubWFwKHZhbCA9PiBOdW1iZXIucGFyc2VJbnQodmFsLCAxMCkpO1xcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgcmV0dXJuIHBvcHBlckRhdGEgPT4gb2Zmc2V0KHBvcHBlckRhdGEsIHRoaXMuX2VsZW1lbnQpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBvZmZzZXQ7XFxuICB9XFxuXFxuICBfZ2V0UG9wcGVyQ29uZmlnKCkge1xcbiAgICBjb25zdCBkZWZhdWx0QnNQb3BwZXJDb25maWcgPSB7XFxuICAgICAgcGxhY2VtZW50OiB0aGlzLl9nZXRQbGFjZW1lbnQoKSxcXG4gICAgICBtb2RpZmllcnM6IFt7XFxuICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcXG4gICAgICAgIG9wdGlvbnM6IHtcXG4gICAgICAgICAgYm91bmRhcnk6IHRoaXMuX2NvbmZpZy5ib3VuZGFyeVxcbiAgICAgICAgfVxcbiAgICAgIH0sIHtcXG4gICAgICAgIG5hbWU6ICdvZmZzZXQnLFxcbiAgICAgICAgb3B0aW9uczoge1xcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXFxuICAgICAgICB9XFxuICAgICAgfV1cXG4gICAgfTsgLy8gRGlzYWJsZSBQb3BwZXIgaWYgd2UgaGF2ZSBhIHN0YXRpYyBkaXNwbGF5XFxuXFxuICAgIGlmICh0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcXG4gICAgICBkZWZhdWx0QnNQb3BwZXJDb25maWcubW9kaWZpZXJzID0gW3tcXG4gICAgICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXFxuICAgICAgICBlbmFibGVkOiBmYWxzZVxcbiAgICAgIH1dO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB7IC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcXG4gICAgICAuLi4odHlwZW9mIHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGRlZmF1bHRCc1BvcHBlckNvbmZpZykgOiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKVxcbiAgICB9O1xcbiAgfVxcblxcbiAgX3NlbGVjdE1lbnVJdGVtKGV2ZW50KSB7XFxuICAgIGNvbnN0IGl0ZW1zID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9WSVNJQkxFX0lURU1TLCB0aGlzLl9tZW51KS5maWx0ZXIoaXNWaXNpYmxlKTtcXG5cXG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgbGV0IGluZGV4ID0gaXRlbXMuaW5kZXhPZihldmVudC50YXJnZXQpOyAvLyBVcFxcblxcbiAgICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19VUF9LRVkgJiYgaW5kZXggPiAwKSB7XFxuICAgICAgaW5kZXgtLTtcXG4gICAgfSAvLyBEb3duXFxuXFxuXFxuICAgIGlmIChldmVudC5rZXkgPT09IEFSUk9XX0RPV05fS0VZICYmIGluZGV4IDwgaXRlbXMubGVuZ3RoIC0gMSkge1xcbiAgICAgIGluZGV4Kys7XFxuICAgIH0gLy8gaW5kZXggaXMgLTEgaWYgdGhlIGZpcnN0IGtleWRvd24gaXMgYW4gQXJyb3dVcFxcblxcblxcbiAgICBpbmRleCA9IGluZGV4ID09PSAtMSA/IDAgOiBpbmRleDtcXG4gICAgaXRlbXNbaW5kZXhdLmZvY3VzKCk7XFxuICB9IC8vIFN0YXRpY1xcblxcblxcbiAgc3RhdGljIGRyb3Bkb3duSW50ZXJmYWNlKGVsZW1lbnQsIGNvbmZpZykge1xcbiAgICBsZXQgZGF0YSA9IERhdGEuZ2V0KGVsZW1lbnQsIERBVEFfS0VZJDcpO1xcblxcbiAgICBjb25zdCBfY29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsO1xcblxcbiAgICBpZiAoIWRhdGEpIHtcXG4gICAgICBkYXRhID0gbmV3IERyb3Bkb3duKGVsZW1lbnQsIF9jb25maWcpO1xcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xcbiAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFxcXCIke2NvbmZpZ31cXFwiYCk7XFxuICAgICAgfVxcblxcbiAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICBEcm9wZG93bi5kcm9wZG93bkludGVyZmFjZSh0aGlzLCBjb25maWcpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBjbGVhck1lbnVzKGV2ZW50KSB7XFxuICAgIGlmIChldmVudCAmJiAoZXZlbnQuYnV0dG9uID09PSBSSUdIVF9NT1VTRV9CVVRUT04gfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC5rZXkgIT09IFRBQl9LRVkpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHRvZ2dsZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpO1xcblxcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdG9nZ2xlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBEYXRhLmdldCh0b2dnbGVzW2ldLCBEQVRBX0tFWSQ3KTtcXG5cXG4gICAgICBpZiAoIWNvbnRleHQgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gZmFsc2UpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWNvbnRleHQuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ3KSkge1xcbiAgICAgICAgY29udGludWU7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiBjb250ZXh0Ll9lbGVtZW50XFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAoZXZlbnQpIHtcXG4gICAgICAgIGNvbnN0IGNvbXBvc2VkUGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xcbiAgICAgICAgY29uc3QgaXNNZW51VGFyZ2V0ID0gY29tcG9zZWRQYXRoLmluY2x1ZGVzKGNvbnRleHQuX21lbnUpO1xcblxcbiAgICAgICAgaWYgKGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9lbGVtZW50KSB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnaW5zaWRlJyAmJiAhaXNNZW51VGFyZ2V0IHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09ICdvdXRzaWRlJyAmJiBpc01lbnVUYXJnZXQpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9IC8vIFRhYiBuYXZpZ2F0aW9uIHRocm91Z2ggdGhlIGRyb3Bkb3duIG1lbnUgb3IgZXZlbnRzIGZyb20gY29udGFpbmVkIGlucHV0cyBzaG91bGRuJ3QgY2xvc2UgdGhlIG1lbnVcXG5cXG5cXG4gICAgICAgIGlmIChjb250ZXh0Ll9tZW51LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgJiYgKGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ID09PSBUQUJfS0VZIHx8IC9pbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGZvcm0vaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0LmNsaWNrRXZlbnQgPSBldmVudDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgY29udGV4dC5fY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpO1xcbiAgICB9XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0UGFyZW50RnJvbUVsZW1lbnQoZWxlbWVudCkge1xcbiAgICByZXR1cm4gZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSB8fCBlbGVtZW50LnBhcmVudE5vZGU7XFxuICB9XFxuXFxuICBzdGF0aWMgZGF0YUFwaUtleWRvd25IYW5kbGVyKGV2ZW50KSB7XFxuICAgIC8vIElmIG5vdCBpbnB1dC90ZXh0YXJlYTpcXG4gICAgLy8gIC0gQW5kIG5vdCBhIGtleSBpbiBSRUdFWFBfS0VZRE9XTiA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXFxuICAgIC8vIElmIGlucHV0L3RleHRhcmVhOlxcbiAgICAvLyAgLSBJZiBzcGFjZSBrZXkgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxcbiAgICAvLyAgLSBJZiBrZXkgaXMgb3RoZXIgdGhhbiBlc2NhcGVcXG4gICAgLy8gICAgLSBJZiBrZXkgaXMgbm90IHVwIG9yIGRvd24gPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxcbiAgICAvLyAgICAtIElmIHRyaWdnZXIgaW5zaWRlIHRoZSBtZW51ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcXG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpID8gZXZlbnQua2V5ID09PSBTUEFDRV9LRVkgfHwgZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZJDIgJiYgKGV2ZW50LmtleSAhPT0gQVJST1dfRE9XTl9LRVkgJiYgZXZlbnQua2V5ICE9PSBBUlJPV19VUF9LRVkgfHwgZXZlbnQudGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1JfTUVOVSkpIDogIVJFR0VYUF9LRVlET1dOLnRlc3QoZXZlbnQua2V5KSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ3KTtcXG5cXG4gICAgaWYgKCFpc0FjdGl2ZSAmJiBldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkkMikge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXG4gICAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZ2V0VG9nZ2xlQnV0dG9uID0gKCkgPT4gdGhpcy5tYXRjaGVzKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpID8gdGhpcyA6IFNlbGVjdG9yRW5naW5lLnByZXYodGhpcywgU0VMRUNUT1JfREFUQV9UT0dHTEUkMylbMF07XFxuXFxuICAgIGlmIChldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkkMikge1xcbiAgICAgIGdldFRvZ2dsZUJ1dHRvbigpLmZvY3VzKCk7XFxuICAgICAgRHJvcGRvd24uY2xlYXJNZW51cygpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAoIWlzQWN0aXZlICYmIChldmVudC5rZXkgPT09IEFSUk9XX1VQX0tFWSB8fCBldmVudC5rZXkgPT09IEFSUk9XX0RPV05fS0VZKSkge1xcbiAgICAgIGdldFRvZ2dsZUJ1dHRvbigpLmNsaWNrKCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICghaXNBY3RpdmUgfHwgZXZlbnQua2V5ID09PSBTUEFDRV9LRVkpIHtcXG4gICAgICBEcm9wZG93bi5jbGVhck1lbnVzKCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIERyb3Bkb3duLmdldEluc3RhbmNlKGdldFRvZ2dsZUJ1dHRvbigpKS5fc2VsZWN0TWVudUl0ZW0oZXZlbnQpO1xcbiAgfVxcblxcbn1cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcblxcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKTtcXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX01FTlUsIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcik7XFxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQzLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWVVQX0RBVEFfQVBJLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gIERyb3Bkb3duLmRyb3Bkb3duSW50ZXJmYWNlKHRoaXMpO1xcbn0pO1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGpRdWVyeVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGFkZCAuRHJvcGRvd24gdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcXG4gKi9cXG5cXG5kZWZpbmVKUXVlcnlQbHVnaW4oRHJvcGRvd24pO1xcblxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQm9vdHN0cmFwICh2NS4wLjEpOiB1dGlsL3Njcm9sbEJhci5qc1xcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuY29uc3QgU0VMRUNUT1JfRklYRURfQ09OVEVOVCA9ICcuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wJztcXG5jb25zdCBTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCA9ICcuc3RpY2t5LXRvcCc7XFxuXFxuY29uc3QgZ2V0V2lkdGggPSAoKSA9PiB7XFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2lubmVyV2lkdGgjdXNhZ2Vfbm90ZXNcXG4gIGNvbnN0IGRvY3VtZW50V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XFxuICByZXR1cm4gTWF0aC5hYnMod2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudFdpZHRoKTtcXG59O1xcblxcbmNvbnN0IGhpZGUgPSAod2lkdGggPSBnZXRXaWR0aCgpKSA9PiB7XFxuICBfZGlzYWJsZU92ZXJGbG93KCk7IC8vIGdpdmUgcGFkZGluZyB0byBlbGVtZW50IHRvIGJhbGFuY2VzIHRoZSBoaWRkZW4gc2Nyb2xsYmFyIHdpZHRoXFxuXFxuXFxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoJ2JvZHknLCAncGFkZGluZ1JpZ2h0JywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKTsgLy8gdHJpY2s6IFdlIGFkanVzdCBwb3NpdGl2ZSBwYWRkaW5nUmlnaHQgYW5kIG5lZ2F0aXZlIG1hcmdpblJpZ2h0IHRvIHN0aWNreS10b3AgZWxlbWVudHMsIHRvIGtlZXAgc2hvd24gZnVsbHdpZHRoXFxuXFxuXFxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfRklYRURfQ09OVEVOVCwgJ3BhZGRpbmdSaWdodCcsIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgKyB3aWR0aCk7XFxuXFxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsICdtYXJnaW5SaWdodCcsIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgLSB3aWR0aCk7XFxufTtcXG5cXG5jb25zdCBfZGlzYWJsZU92ZXJGbG93ID0gKCkgPT4ge1xcbiAgY29uc3QgYWN0dWFsVmFsdWUgPSBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93O1xcblxcbiAgaWYgKGFjdHVhbFZhbHVlKSB7XFxuICAgIE1hbmlwdWxhdG9yLnNldERhdGFBdHRyaWJ1dGUoZG9jdW1lbnQuYm9keSwgJ292ZXJmbG93JywgYWN0dWFsVmFsdWUpO1xcbiAgfVxcblxcbiAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xcbn07XFxuXFxuY29uc3QgX3NldEVsZW1lbnRBdHRyaWJ1dGVzID0gKHNlbGVjdG9yLCBzdHlsZVByb3AsIGNhbGxiYWNrKSA9PiB7XFxuICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IGdldFdpZHRoKCk7XFxuICBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xcbiAgICBpZiAoZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+IGVsZW1lbnQuY2xpZW50V2lkdGggKyBzY3JvbGxiYXJXaWR0aCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBhY3R1YWxWYWx1ZSA9IGVsZW1lbnQuc3R5bGVbc3R5bGVQcm9wXTtcXG4gICAgY29uc3QgY2FsY3VsYXRlZFZhbHVlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbc3R5bGVQcm9wXTtcXG4gICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3AsIGFjdHVhbFZhbHVlKTtcXG4gICAgZWxlbWVudC5zdHlsZVtzdHlsZVByb3BdID0gYCR7Y2FsbGJhY2soTnVtYmVyLnBhcnNlRmxvYXQoY2FsY3VsYXRlZFZhbHVlKSl9cHhgO1xcbiAgfSk7XFxufTtcXG5cXG5jb25zdCByZXNldCA9ICgpID0+IHtcXG4gIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKCdib2R5JywgJ292ZXJmbG93Jyk7XFxuXFxuICBfcmVzZXRFbGVtZW50QXR0cmlidXRlcygnYm9keScsICdwYWRkaW5nUmlnaHQnKTtcXG5cXG4gIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsICdwYWRkaW5nUmlnaHQnKTtcXG5cXG4gIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX1NUSUNLWV9DT05URU5ULCAnbWFyZ2luUmlnaHQnKTtcXG59O1xcblxcbmNvbnN0IF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzID0gKHNlbGVjdG9yLCBzdHlsZVByb3ApID0+IHtcXG4gIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpLmZvckVhY2goZWxlbWVudCA9PiB7XFxuICAgIGNvbnN0IHZhbHVlID0gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3ApO1xcblxcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoc3R5bGVQcm9wKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBNYW5pcHVsYXRvci5yZW1vdmVEYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcCk7XFxuICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZVByb3BdID0gdmFsdWU7XFxuICAgIH1cXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IHV0aWwvYmFja2Ryb3AuanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuY29uc3QgRGVmYXVsdCQ2ID0ge1xcbiAgaXNWaXNpYmxlOiB0cnVlLFxcbiAgLy8gaWYgZmFsc2UsIHdlIHVzZSB0aGUgYmFja2Ryb3AgaGVscGVyIHdpdGhvdXQgYWRkaW5nIGFueSBlbGVtZW50IHRvIHRoZSBkb21cXG4gIGlzQW5pbWF0ZWQ6IGZhbHNlLFxcbiAgcm9vdEVsZW1lbnQ6IGRvY3VtZW50LmJvZHksXFxuICAvLyBnaXZlIHRoZSBjaG9pY2UgdG8gcGxhY2UgYmFja2Ryb3AgdW5kZXIgZGlmZmVyZW50IGVsZW1lbnRzXFxuICBjbGlja0NhbGxiYWNrOiBudWxsXFxufTtcXG5jb25zdCBEZWZhdWx0VHlwZSQ2ID0ge1xcbiAgaXNWaXNpYmxlOiAnYm9vbGVhbicsXFxuICBpc0FuaW1hdGVkOiAnYm9vbGVhbicsXFxuICByb290RWxlbWVudDogJ2VsZW1lbnQnLFxcbiAgY2xpY2tDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKSdcXG59O1xcbmNvbnN0IE5BTUUkNyA9ICdiYWNrZHJvcCc7XFxuY29uc3QgQ0xBU1NfTkFNRV9CQUNLRFJPUCA9ICdtb2RhbC1iYWNrZHJvcCc7XFxuY29uc3QgQ0xBU1NfTkFNRV9GQURFJDUgPSAnZmFkZSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDYgPSAnc2hvdyc7XFxuY29uc3QgRVZFTlRfTU9VU0VET1dOID0gYG1vdXNlZG93bi5icy4ke05BTUUkN31gO1xcblxcbmNsYXNzIEJhY2tkcm9wIHtcXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgdGhpcy5faXNBcHBlbmRlZCA9IGZhbHNlO1xcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcXG4gIH1cXG5cXG4gIHNob3coY2FsbGJhY2spIHtcXG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XFxuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2FwcGVuZCgpO1xcblxcbiAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcXG4gICAgICByZWZsb3codGhpcy5fZ2V0RWxlbWVudCgpKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9nZXRFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNik7XFxuXFxuICAgIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xcbiAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGhpZGUoY2FsbGJhY2spIHtcXG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XFxuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ2KTtcXG5cXG4gICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XFxuICAgICAgdGhpcy5kaXNwb3NlKCk7XFxuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XFxuICAgIH0pO1xcbiAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICBfZ2V0RWxlbWVudCgpIHtcXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50KSB7XFxuICAgICAgY29uc3QgYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICBiYWNrZHJvcC5jbGFzc05hbWUgPSBDTEFTU19OQU1FX0JBQ0tEUk9QO1xcblxcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaXNBbmltYXRlZCkge1xcbiAgICAgICAgYmFja2Ryb3AuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUkNSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBiYWNrZHJvcDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcXG4gIH1cXG5cXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XFxuICAgIGNvbmZpZyA9IHsgLi4uRGVmYXVsdCQ2LFxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KVxcbiAgICB9O1xcbiAgICBjb25maWcucm9vdEVsZW1lbnQgPSBjb25maWcucm9vdEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcXG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUkNywgY29uZmlnLCBEZWZhdWx0VHlwZSQ2KTtcXG4gICAgcmV0dXJuIGNvbmZpZztcXG4gIH1cXG5cXG4gIF9hcHBlbmQoKSB7XFxuICAgIGlmICh0aGlzLl9pc0FwcGVuZGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2NvbmZpZy5yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9nZXRFbGVtZW50KCkpO1xcblxcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZ2V0RWxlbWVudCgpLCBFVkVOVF9NT1VTRURPV04sICgpID0+IHtcXG4gICAgICBleGVjdXRlKHRoaXMuX2NvbmZpZy5jbGlja0NhbGxiYWNrKTtcXG4gICAgfSk7XFxuICAgIHRoaXMuX2lzQXBwZW5kZWQgPSB0cnVlO1xcbiAgfVxcblxcbiAgZGlzcG9zZSgpIHtcXG4gICAgaWYgKCF0aGlzLl9pc0FwcGVuZGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOKTtcXG5cXG4gICAgdGhpcy5fZ2V0RWxlbWVudCgpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZWxlbWVudCk7XFxuXFxuICAgIHRoaXMuX2lzQXBwZW5kZWQgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIF9lbXVsYXRlQW5pbWF0aW9uKGNhbGxiYWNrKSB7XFxuICAgIGlmICghdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcXG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24gPSBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9nZXRFbGVtZW50KCkpO1xcbiAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2dldEVsZW1lbnQoKSwgJ3RyYW5zaXRpb25lbmQnLCAoKSA9PiBleGVjdXRlKGNhbGxiYWNrKSk7XFxuICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRoaXMuX2dldEVsZW1lbnQoKSwgYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24pO1xcbiAgfVxcblxcbn1cXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIEJvb3RzdHJhcCAodjUuMC4xKTogbW9kYWwuanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIENvbnN0YW50c1xcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNvbnN0IE5BTUUkNiA9ICdtb2RhbCc7XFxuY29uc3QgREFUQV9LRVkkNiA9ICdicy5tb2RhbCc7XFxuY29uc3QgRVZFTlRfS0VZJDYgPSBgLiR7REFUQV9LRVkkNn1gO1xcbmNvbnN0IERBVEFfQVBJX0tFWSQzID0gJy5kYXRhLWFwaSc7XFxuY29uc3QgRVNDQVBFX0tFWSQxID0gJ0VzY2FwZSc7XFxuY29uc3QgRGVmYXVsdCQ1ID0ge1xcbiAgYmFja2Ryb3A6IHRydWUsXFxuICBrZXlib2FyZDogdHJ1ZSxcXG4gIGZvY3VzOiB0cnVlXFxufTtcXG5jb25zdCBEZWZhdWx0VHlwZSQ1ID0ge1xcbiAgYmFja2Ryb3A6ICcoYm9vbGVhbnxzdHJpbmcpJyxcXG4gIGtleWJvYXJkOiAnYm9vbGVhbicsXFxuICBmb2N1czogJ2Jvb2xlYW4nXFxufTtcXG5jb25zdCBFVkVOVF9ISURFJDMgPSBgaGlkZSR7RVZFTlRfS0VZJDZ9YDtcXG5jb25zdCBFVkVOVF9ISURFX1BSRVZFTlRFRCA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkNn1gO1xcbmNvbnN0IEVWRU5UX0hJRERFTiQzID0gYGhpZGRlbiR7RVZFTlRfS0VZJDZ9YDtcXG5jb25zdCBFVkVOVF9TSE9XJDMgPSBgc2hvdyR7RVZFTlRfS0VZJDZ9YDtcXG5jb25zdCBFVkVOVF9TSE9XTiQzID0gYHNob3duJHtFVkVOVF9LRVkkNn1gO1xcbmNvbnN0IEVWRU5UX0ZPQ1VTSU4kMiA9IGBmb2N1c2luJHtFVkVOVF9LRVkkNn1gO1xcbmNvbnN0IEVWRU5UX1JFU0laRSA9IGByZXNpemUke0VWRU5UX0tFWSQ2fWA7XFxuY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyQyID0gYGNsaWNrLmRpc21pc3Mke0VWRU5UX0tFWSQ2fWA7XFxuY29uc3QgRVZFTlRfS0VZRE9XTl9ESVNNSVNTJDEgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkNn1gO1xcbmNvbnN0IEVWRU5UX01PVVNFVVBfRElTTUlTUyA9IGBtb3VzZXVwLmRpc21pc3Mke0VWRU5UX0tFWSQ2fWA7XFxuY29uc3QgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MgPSBgbW91c2Vkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQ2fWA7XFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiA9IGBjbGljayR7RVZFTlRfS0VZJDZ9JHtEQVRBX0FQSV9LRVkkM31gO1xcbmNvbnN0IENMQVNTX05BTUVfT1BFTiA9ICdtb2RhbC1vcGVuJztcXG5jb25zdCBDTEFTU19OQU1FX0ZBREUkNCA9ICdmYWRlJztcXG5jb25zdCBDTEFTU19OQU1FX1NIT1ckNSA9ICdzaG93JztcXG5jb25zdCBDTEFTU19OQU1FX1NUQVRJQyA9ICdtb2RhbC1zdGF0aWMnO1xcbmNvbnN0IFNFTEVDVE9SX0RJQUxPRyA9ICcubW9kYWwtZGlhbG9nJztcXG5jb25zdCBTRUxFQ1RPUl9NT0RBTF9CT0RZID0gJy5tb2RhbC1ib2R5JztcXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyID0gJ1tkYXRhLWJzLXRvZ2dsZT1cXFwibW9kYWxcXFwiXSc7XFxuY29uc3QgU0VMRUNUT1JfREFUQV9ESVNNSVNTJDIgPSAnW2RhdGEtYnMtZGlzbWlzcz1cXFwibW9kYWxcXFwiXSc7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIE1vZGFsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XFxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgc3VwZXIoZWxlbWVudCk7XFxuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xcbiAgICB0aGlzLl9kaWFsb2cgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RJQUxPRywgdGhpcy5fZWxlbWVudCk7XFxuICAgIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCk7XFxuICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcXG4gICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlO1xcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcXG4gIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xcbiAgICByZXR1cm4gRGVmYXVsdCQ1O1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICByZXR1cm4gTkFNRSQ2O1xcbiAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XFxuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldCk7XFxuICB9XFxuXFxuICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9pc0FuaW1hdGVkKCkpIHtcXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckMywge1xcbiAgICAgIHJlbGF0ZWRUYXJnZXRcXG4gICAgfSk7XFxuXFxuICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xcbiAgICBoaWRlKCk7XFxuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX09QRU4pO1xcblxcbiAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcXG5cXG4gICAgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKTtcXG5cXG4gICAgdGhpcy5fc2V0UmVzaXplRXZlbnQoKTtcXG5cXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLX0RJU01JU1MkMiwgU0VMRUNUT1JfREFUQV9ESVNNSVNTJDIsIGV2ZW50ID0+IHRoaXMuaGlkZShldmVudCkpO1xcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZGlhbG9nLCBFVkVOVF9NT1VTRURPV05fRElTTUlTUywgKCkgPT4ge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VVUF9ESVNNSVNTLCBldmVudCA9PiB7XFxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLl9lbGVtZW50KSB7XFxuICAgICAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5fc2hvd0JhY2tkcm9wKCgpID0+IHRoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpKTtcXG4gIH1cXG5cXG4gIGhpZGUoZXZlbnQpIHtcXG4gICAgaWYgKGV2ZW50KSB7XFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgfVxcblxcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkMyk7XFxuXFxuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XFxuXFxuICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSB0aGlzLl9pc0FuaW1hdGVkKCk7XFxuXFxuICAgIGlmIChpc0FuaW1hdGVkKSB7XFxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9zZXRFc2NhcGVFdmVudCgpO1xcblxcbiAgICB0aGlzLl9zZXRSZXNpemVFdmVudCgpO1xcblxcbiAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOJDIpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDUpO1xcblxcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLX0RJU01JU1MkMik7XFxuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZGlhbG9nLCBFVkVOVF9NT1VTRURPV05fRElTTUlTUyk7XFxuXFxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5faGlkZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQsIGlzQW5pbWF0ZWQpO1xcbiAgfVxcblxcbiAgZGlzcG9zZSgpIHtcXG4gICAgW3dpbmRvdywgdGhpcy5fZGlhbG9nXS5mb3JFYWNoKGh0bWxFbGVtZW50ID0+IEV2ZW50SGFuZGxlci5vZmYoaHRtbEVsZW1lbnQsIEVWRU5UX0tFWSQ2KSk7XFxuXFxuICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKTtcXG5cXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xcbiAgICAvKipcXG4gICAgICogYGRvY3VtZW50YCBoYXMgMiBldmVudHMgYEVWRU5UX0ZPQ1VTSU5gIGFuZCBgRVZFTlRfQ0xJQ0tfREFUQV9BUElgXFxuICAgICAqIERvIG5vdCBtb3ZlIGBkb2N1bWVudGAgaW4gYGh0bWxFbGVtZW50c2AgYXJyYXlcXG4gICAgICogSXQgd2lsbCByZW1vdmUgYEVWRU5UX0NMSUNLX0RBVEFfQVBJYCBldmVudCB0aGF0IHNob3VsZCByZW1haW5cXG4gICAgICovXFxuXFxuICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0ZPQ1VTSU4kMik7XFxuICB9XFxuXFxuICBoYW5kbGVVcGRhdGUoKSB7XFxuICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xcbiAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xcbiAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcXG4gICAgICBpc1Zpc2libGU6IEJvb2xlYW4odGhpcy5fY29uZmlnLmJhY2tkcm9wKSxcXG4gICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWVcXG4gICAgICBpc0FuaW1hdGVkOiB0aGlzLl9pc0FuaW1hdGVkKClcXG4gICAgfSk7XFxuICB9XFxuXFxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xcbiAgICBjb25maWcgPSB7IC4uLkRlZmF1bHQkNSxcXG4gICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcXG4gICAgICAuLi5jb25maWdcXG4gICAgfTtcXG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUkNiwgY29uZmlnLCBEZWZhdWx0VHlwZSQ1KTtcXG4gICAgcmV0dXJuIGNvbmZpZztcXG4gIH1cXG5cXG4gIF9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSB7XFxuICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSB0aGlzLl9pc0FuaW1hdGVkKCk7XFxuXFxuICAgIGNvbnN0IG1vZGFsQm9keSA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTU9EQUxfQk9EWSwgdGhpcy5fZGlhbG9nKTtcXG5cXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgfHwgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xcbiAgICAgIC8vIERvbid0IG1vdmUgbW9kYWwncyBET00gcG9zaXRpb25cXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcXG5cXG4gICAgdGhpcy5fZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xcblxcbiAgICBpZiAobW9kYWxCb2R5KSB7XFxuICAgICAgbW9kYWxCb2R5LnNjcm9sbFRvcCA9IDA7XFxuICAgIH1cXG5cXG4gICAgaWYgKGlzQW5pbWF0ZWQpIHtcXG4gICAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ1KTtcXG5cXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5mb2N1cykge1xcbiAgICAgIHRoaXMuX2VuZm9yY2VGb2N1cygpO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHRyYW5zaXRpb25Db21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XFxuICAgICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDMsIHtcXG4gICAgICAgIHJlbGF0ZWRUYXJnZXRcXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayh0cmFuc2l0aW9uQ29tcGxldGUsIHRoaXMuX2RpYWxvZywgaXNBbmltYXRlZCk7XFxuICB9XFxuXFxuICBfZW5mb3JjZUZvY3VzKCkge1xcbiAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOJDIpOyAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcXG5cXG4gICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOJDIsIGV2ZW50ID0+IHtcXG4gICAgICBpZiAoZG9jdW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJiB0aGlzLl9lbGVtZW50ICE9PSBldmVudC50YXJnZXQgJiYgIXRoaXMuX2VsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xcbiAgICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICBfc2V0RXNjYXBlRXZlbnQoKSB7XFxuICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUyQxLCBldmVudCA9PiB7XFxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkICYmIGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSQxKSB7XFxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSQxKSB7XFxuICAgICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUyQxKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgX3NldFJlc2l6ZUV2ZW50KCkge1xcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX1JFU0laRSwgKCkgPT4gdGhpcy5fYWRqdXN0RGlhbG9nKCkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYod2luZG93LCBFVkVOVF9SRVNJWkUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBfaGlkZU1vZGFsKCkge1xcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xcblxcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcXG5cXG4gICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgoKSA9PiB7XFxuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfT1BFTik7XFxuXFxuICAgICAgdGhpcy5fcmVzZXRBZGp1c3RtZW50cygpO1xcblxcbiAgICAgIHJlc2V0KCk7XFxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDMpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIF9zaG93QmFja2Ryb3AoY2FsbGJhY2spIHtcXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLX0RJU01JU1MkMiwgZXZlbnQgPT4ge1xcbiAgICAgIGlmICh0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XFxuICAgICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2U7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XFxuICAgICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5fYmFja2Ryb3Auc2hvdyhjYWxsYmFjayk7XFxuICB9XFxuXFxuICBfaXNBbmltYXRlZCgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQ0KTtcXG4gIH1cXG5cXG4gIF90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkge1xcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCk7XFxuXFxuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XFxuXFxuICAgIGlmICghaXNNb2RhbE92ZXJmbG93aW5nKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcXG4gICAgfVxcblxcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TVEFUSUMpO1xcblxcbiAgICBjb25zdCBtb2RhbFRyYW5zaXRpb25EdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2RpYWxvZyk7XFxuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnKTtcXG4gICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsICgpID0+IHtcXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TVEFUSUMpO1xcblxcbiAgICAgIGlmICghaXNNb2RhbE92ZXJmbG93aW5nKSB7XFxuICAgICAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2VsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgKCkgPT4ge1xcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9ICcnO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50LCBtb2RhbFRyYW5zaXRpb25EdXJhdGlvbik7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgZW11bGF0ZVRyYW5zaXRpb25FbmQodGhpcy5fZWxlbWVudCwgbW9kYWxUcmFuc2l0aW9uRHVyYXRpb24pO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XFxuICB9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gIC8vIHRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuXFxuICBfYWRqdXN0RGlhbG9nKCkge1xcbiAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XFxuICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gZ2V0V2lkdGgoKTtcXG4gICAgY29uc3QgaXNCb2R5T3ZlcmZsb3dpbmcgPSBzY3JvbGxiYXJXaWR0aCA+IDA7XFxuXFxuICAgIGlmICghaXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nICYmICFpc1JUTCgpIHx8IGlzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcgJiYgaXNSVEwoKSkge1xcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBgJHtzY3JvbGxiYXJXaWR0aH1weGA7XFxuICAgIH1cXG5cXG4gICAgaWYgKGlzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcgJiYgIWlzUlRMKCkgfHwgIWlzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZyAmJiBpc1JUTCgpKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtzY3JvbGxiYXJXaWR0aH1weGA7XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9yZXNldEFkanVzdG1lbnRzKCkge1xcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gJyc7XFxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XFxuICB9IC8vIFN0YXRpY1xcblxcblxcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcsIHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgY29uc3QgZGF0YSA9IE1vZGFsLmdldEluc3RhbmNlKHRoaXMpIHx8IG5ldyBNb2RhbCh0aGlzLCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KTtcXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICB9XFxuXFxuICAgICAgZGF0YVtjb25maWddKHJlbGF0ZWRUYXJnZXQpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG59XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5cXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcXG5cXG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gIH1cXG5cXG4gIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9TSE9XJDMsIHNob3dFdmVudCA9PiB7XFxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiQzLCAoKSA9PiB7XFxuICAgICAgaWYgKGlzVmlzaWJsZSh0aGlzKSkge1xcbiAgICAgICAgdGhpcy5mb2N1cygpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9KTtcXG4gIGNvbnN0IGRhdGEgPSBNb2RhbC5nZXRJbnN0YW5jZSh0YXJnZXQpIHx8IG5ldyBNb2RhbCh0YXJnZXQpO1xcbiAgZGF0YS50b2dnbGUodGhpcyk7XFxufSk7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogalF1ZXJ5XFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogYWRkIC5Nb2RhbCB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxcbiAqL1xcblxcbmRlZmluZUpRdWVyeVBsdWdpbihNb2RhbCk7XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IG9mZmNhbnZhcy5qc1xcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDb25zdGFudHNcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jb25zdCBOQU1FJDUgPSAnb2ZmY2FudmFzJztcXG5jb25zdCBEQVRBX0tFWSQ1ID0gJ2JzLm9mZmNhbnZhcyc7XFxuY29uc3QgRVZFTlRfS0VZJDUgPSBgLiR7REFUQV9LRVkkNX1gO1xcbmNvbnN0IERBVEFfQVBJX0tFWSQyID0gJy5kYXRhLWFwaSc7XFxuY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQxID0gYGxvYWQke0VWRU5UX0tFWSQ1fSR7REFUQV9BUElfS0VZJDJ9YDtcXG5jb25zdCBFU0NBUEVfS0VZID0gJ0VzY2FwZSc7XFxuY29uc3QgRGVmYXVsdCQ0ID0ge1xcbiAgYmFja2Ryb3A6IHRydWUsXFxuICBrZXlib2FyZDogdHJ1ZSxcXG4gIHNjcm9sbDogZmFsc2VcXG59O1xcbmNvbnN0IERlZmF1bHRUeXBlJDQgPSB7XFxuICBiYWNrZHJvcDogJ2Jvb2xlYW4nLFxcbiAga2V5Ym9hcmQ6ICdib29sZWFuJyxcXG4gIHNjcm9sbDogJ2Jvb2xlYW4nXFxufTtcXG5jb25zdCBDTEFTU19OQU1FX1NIT1ckNCA9ICdzaG93JztcXG5jb25zdCBPUEVOX1NFTEVDVE9SID0gJy5vZmZjYW52YXMuc2hvdyc7XFxuY29uc3QgRVZFTlRfU0hPVyQyID0gYHNob3cke0VWRU5UX0tFWSQ1fWA7XFxuY29uc3QgRVZFTlRfU0hPV04kMiA9IGBzaG93biR7RVZFTlRfS0VZJDV9YDtcXG5jb25zdCBFVkVOVF9ISURFJDIgPSBgaGlkZSR7RVZFTlRfS0VZJDV9YDtcXG5jb25zdCBFVkVOVF9ISURERU4kMiA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ1fWA7XFxuY29uc3QgRVZFTlRfRk9DVVNJTiQxID0gYGZvY3VzaW4ke0VWRU5UX0tFWSQ1fWA7XFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMSA9IGBjbGljayR7RVZFTlRfS0VZJDV9JHtEQVRBX0FQSV9LRVkkMn1gO1xcbmNvbnN0IEVWRU5UX0NMSUNLX0RJU01JU1MkMSA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVkkNX1gO1xcbmNvbnN0IEVWRU5UX0tFWURPV05fRElTTUlTUyA9IGBrZXlkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQ1fWA7XFxuY29uc3QgU0VMRUNUT1JfREFUQV9ESVNNSVNTJDEgPSAnW2RhdGEtYnMtZGlzbWlzcz1cXFwib2ZmY2FudmFzXFxcIl0nO1xcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEgPSAnW2RhdGEtYnMtdG9nZ2xlPVxcXCJvZmZjYW52YXNcXFwiXSc7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIE9mZmNhbnZhcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgIHN1cGVyKGVsZW1lbnQpO1xcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xcbiAgICB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpO1xcblxcbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xcbiAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgIHJldHVybiBOQU1FJDU7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgIHJldHVybiBEZWZhdWx0JDQ7XFxuICB9IC8vIFB1YmxpY1xcblxcblxcbiAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcXG4gIH1cXG5cXG4gIHNob3cocmVsYXRlZFRhcmdldCkge1xcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDIsIHtcXG4gICAgICByZWxhdGVkVGFyZ2V0XFxuICAgIH0pO1xcblxcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5faXNTaG93biA9IHRydWU7XFxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcXG5cXG4gICAgdGhpcy5fYmFja2Ryb3Auc2hvdygpO1xcblxcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwpIHtcXG4gICAgICBoaWRlKCk7XFxuXFxuICAgICAgdGhpcy5fZW5mb3JjZUZvY3VzT25FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpO1xcblxcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcXG5cXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ0KTtcXG5cXG4gICAgY29uc3QgY29tcGxldGVDYWxsQmFjayA9ICgpID0+IHtcXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQyLCB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsQmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XFxuICB9XFxuXFxuICBoaWRlKCkge1xcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24pIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQyKTtcXG5cXG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0ZPQ1VTSU4kMSk7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuYmx1cigpO1xcblxcbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNCk7XFxuXFxuICAgIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcXG5cXG4gICAgY29uc3QgY29tcGxldGVDYWxsYmFjayA9ICgpID0+IHtcXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XFxuXFxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XFxuICAgICAgICByZXNldCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kMik7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsYmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XFxuICB9XFxuXFxuICBkaXNwb3NlKCkge1xcbiAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCk7XFxuXFxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcXG4gICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiQxKTtcXG4gIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgY29uZmlnID0geyAuLi5EZWZhdWx0JDQsXFxuICAgICAgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDoge30pXFxuICAgIH07XFxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FJDUsIGNvbmZpZywgRGVmYXVsdFR5cGUkNCk7XFxuICAgIHJldHVybiBjb25maWc7XFxuICB9XFxuXFxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xcbiAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcXG4gICAgICBpc1Zpc2libGU6IHRoaXMuX2NvbmZpZy5iYWNrZHJvcCxcXG4gICAgICBpc0FuaW1hdGVkOiB0cnVlLFxcbiAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXFxuICAgICAgY2xpY2tDYWxsYmFjazogKCkgPT4gdGhpcy5oaWRlKClcXG4gICAgfSk7XFxuICB9XFxuXFxuICBfZW5mb3JjZUZvY3VzT25FbGVtZW50KGVsZW1lbnQpIHtcXG4gICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiQxKTsgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXFxuXFxuICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiQxLCBldmVudCA9PiB7XFxuICAgICAgaWYgKGRvY3VtZW50ICE9PSBldmVudC50YXJnZXQgJiYgZWxlbWVudCAhPT0gZXZlbnQudGFyZ2V0ICYmICFlbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcXG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICBlbGVtZW50LmZvY3VzKCk7XFxuICB9XFxuXFxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XFxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTJDEsIFNFTEVDVE9SX0RBVEFfRElTTUlTUyQxLCAoKSA9PiB0aGlzLmhpZGUoKSk7XFxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOX0RJU01JU1MsIGV2ZW50ID0+IHtcXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkICYmIGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSkge1xcbiAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH0gLy8gU3RhdGljXFxuXFxuXFxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICBjb25zdCBkYXRhID0gRGF0YS5nZXQodGhpcywgREFUQV9LRVkkNSkgfHwgbmV3IE9mZmNhbnZhcyh0aGlzLCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KTtcXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICB9XFxuXFxuICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG59XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5cXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDEsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcXG5cXG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gIH1cXG5cXG4gIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9ISURERU4kMiwgKCkgPT4ge1xcbiAgICAvLyBmb2N1cyBvbiB0cmlnZ2VyIHdoZW4gaXQgaXMgY2xvc2VkXFxuICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcXG4gICAgICB0aGlzLmZvY3VzKCk7XFxuICAgIH1cXG4gIH0pOyAvLyBhdm9pZCBjb25mbGljdCB3aGVuIGNsaWNraW5nIGEgdG9nZ2xlciBvZiBhbiBvZmZjYW52YXMsIHdoaWxlIGFub3RoZXIgaXMgb3BlblxcblxcbiAgY29uc3QgYWxsUmVhZHlPcGVuID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShPUEVOX1NFTEVDVE9SKTtcXG5cXG4gIGlmIChhbGxSZWFkeU9wZW4gJiYgYWxsUmVhZHlPcGVuICE9PSB0YXJnZXQpIHtcXG4gICAgT2ZmY2FudmFzLmdldEluc3RhbmNlKGFsbFJlYWR5T3BlbikuaGlkZSgpO1xcbiAgfVxcblxcbiAgY29uc3QgZGF0YSA9IERhdGEuZ2V0KHRhcmdldCwgREFUQV9LRVkkNSkgfHwgbmV3IE9mZmNhbnZhcyh0YXJnZXQpO1xcbiAgZGF0YS50b2dnbGUodGhpcyk7XFxufSk7XFxuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQxLCAoKSA9PiB7XFxuICBTZWxlY3RvckVuZ2luZS5maW5kKE9QRU5fU0VMRUNUT1IpLmZvckVhY2goZWwgPT4gKERhdGEuZ2V0KGVsLCBEQVRBX0tFWSQ1KSB8fCBuZXcgT2ZmY2FudmFzKGVsKSkuc2hvdygpKTtcXG59KTtcXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBqUXVlcnlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5kZWZpbmVKUXVlcnlQbHVnaW4oT2ZmY2FudmFzKTtcXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIEJvb3RzdHJhcCAodjUuMC4xKTogdXRpbC9zYW5pdGl6ZXIuanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcbmNvbnN0IHVyaUF0dHJzID0gbmV3IFNldChbJ2JhY2tncm91bmQnLCAnY2l0ZScsICdocmVmJywgJ2l0ZW10eXBlJywgJ2xvbmdkZXNjJywgJ3Bvc3RlcicsICdzcmMnLCAneGxpbms6aHJlZiddKTtcXG5jb25zdCBBUklBX0FUVFJJQlVURV9QQVRURVJOID0gL15hcmlhLVtcXFxcdy1dKiQvaTtcXG4vKipcXG4gKiBBIHBhdHRlcm4gdGhhdCByZWNvZ25pemVzIGEgY29tbW9ubHkgdXNlZnVsIHN1YnNldCBvZiBVUkxzIHRoYXQgYXJlIHNhZmUuXFxuICpcXG4gKiBTaG91dG91dCB0byBBbmd1bGFyIDcgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzcuMi40L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXFxuICovXFxuXFxuY29uc3QgU0FGRV9VUkxfUEFUVEVSTiA9IC9eKD86KD86aHR0cHM/fG1haWx0b3xmdHB8dGVsfGZpbGUpOnxbXiMmLzo/XSooPzpbIy8/XXwkKSkvaTtcXG4vKipcXG4gKiBBIHBhdHRlcm4gdGhhdCBtYXRjaGVzIHNhZmUgZGF0YSBVUkxzLiBPbmx5IG1hdGNoZXMgaW1hZ2UsIHZpZGVvIGFuZCBhdWRpbyB0eXBlcy5cXG4gKlxcbiAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgNyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvNy4yLjQvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcXG4gKi9cXG5cXG5jb25zdCBEQVRBX1VSTF9QQVRURVJOID0gL15kYXRhOig/OmltYWdlXFxcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFxcXC8oPzptcGVnfG1wNHxvZ2d8d2VibSl8YXVkaW9cXFxcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW1xcXFxkKy9hLXpdKz0qJC9pO1xcblxcbmNvbnN0IGFsbG93ZWRBdHRyaWJ1dGUgPSAoYXR0ciwgYWxsb3dlZEF0dHJpYnV0ZUxpc3QpID0+IHtcXG4gIGNvbnN0IGF0dHJOYW1lID0gYXR0ci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcbiAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmluY2x1ZGVzKGF0dHJOYW1lKSkge1xcbiAgICBpZiAodXJpQXR0cnMuaGFzKGF0dHJOYW1lKSkge1xcbiAgICAgIHJldHVybiBCb29sZWFuKFNBRkVfVVJMX1BBVFRFUk4udGVzdChhdHRyLm5vZGVWYWx1ZSkgfHwgREFUQV9VUkxfUEFUVEVSTi50ZXN0KGF0dHIubm9kZVZhbHVlKSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICBjb25zdCByZWdFeHAgPSBhbGxvd2VkQXR0cmlidXRlTGlzdC5maWx0ZXIoYXR0clJlZ2V4ID0+IGF0dHJSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCk7IC8vIENoZWNrIGlmIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlcyB0aGUgYXR0cmlidXRlLlxcblxcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJlZ0V4cC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICBpZiAocmVnRXhwW2ldLnRlc3QoYXR0ck5hbWUpKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBmYWxzZTtcXG59O1xcblxcbmNvbnN0IERlZmF1bHRBbGxvd2xpc3QgPSB7XFxuICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxcbiAgJyonOiBbJ2NsYXNzJywgJ2RpcicsICdpZCcsICdsYW5nJywgJ3JvbGUnLCBBUklBX0FUVFJJQlVURV9QQVRURVJOXSxcXG4gIGE6IFsndGFyZ2V0JywgJ2hyZWYnLCAndGl0bGUnLCAncmVsJ10sXFxuICBhcmVhOiBbXSxcXG4gIGI6IFtdLFxcbiAgYnI6IFtdLFxcbiAgY29sOiBbXSxcXG4gIGNvZGU6IFtdLFxcbiAgZGl2OiBbXSxcXG4gIGVtOiBbXSxcXG4gIGhyOiBbXSxcXG4gIGgxOiBbXSxcXG4gIGgyOiBbXSxcXG4gIGgzOiBbXSxcXG4gIGg0OiBbXSxcXG4gIGg1OiBbXSxcXG4gIGg2OiBbXSxcXG4gIGk6IFtdLFxcbiAgaW1nOiBbJ3NyYycsICdzcmNzZXQnLCAnYWx0JywgJ3RpdGxlJywgJ3dpZHRoJywgJ2hlaWdodCddLFxcbiAgbGk6IFtdLFxcbiAgb2w6IFtdLFxcbiAgcDogW10sXFxuICBwcmU6IFtdLFxcbiAgczogW10sXFxuICBzbWFsbDogW10sXFxuICBzcGFuOiBbXSxcXG4gIHN1YjogW10sXFxuICBzdXA6IFtdLFxcbiAgc3Ryb25nOiBbXSxcXG4gIHU6IFtdLFxcbiAgdWw6IFtdXFxufTtcXG5mdW5jdGlvbiBzYW5pdGl6ZUh0bWwodW5zYWZlSHRtbCwgYWxsb3dMaXN0LCBzYW5pdGl6ZUZuKSB7XFxuICBpZiAoIXVuc2FmZUh0bWwubGVuZ3RoKSB7XFxuICAgIHJldHVybiB1bnNhZmVIdG1sO1xcbiAgfVxcblxcbiAgaWYgKHNhbml0aXplRm4gJiYgdHlwZW9mIHNhbml0aXplRm4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgcmV0dXJuIHNhbml0aXplRm4odW5zYWZlSHRtbCk7XFxuICB9XFxuXFxuICBjb25zdCBkb21QYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xcbiAgY29uc3QgY3JlYXRlZERvY3VtZW50ID0gZG9tUGFyc2VyLnBhcnNlRnJvbVN0cmluZyh1bnNhZmVIdG1sLCAndGV4dC9odG1sJyk7XFxuICBjb25zdCBhbGxvd2xpc3RLZXlzID0gT2JqZWN0LmtleXMoYWxsb3dMaXN0KTtcXG4gIGNvbnN0IGVsZW1lbnRzID0gW10uY29uY2F0KC4uLmNyZWF0ZWREb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSk7XFxuXFxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgY29uc3QgZWwgPSBlbGVtZW50c1tpXTtcXG4gICAgY29uc3QgZWxOYW1lID0gZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXG4gICAgaWYgKCFhbGxvd2xpc3RLZXlzLmluY2x1ZGVzKGVsTmFtZSkpIHtcXG4gICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcXG4gICAgICBjb250aW51ZTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBhdHRyaWJ1dGVMaXN0ID0gW10uY29uY2F0KC4uLmVsLmF0dHJpYnV0ZXMpO1xcbiAgICBjb25zdCBhbGxvd2VkQXR0cmlidXRlcyA9IFtdLmNvbmNhdChhbGxvd0xpc3RbJyonXSB8fCBbXSwgYWxsb3dMaXN0W2VsTmFtZV0gfHwgW10pO1xcbiAgICBhdHRyaWJ1dGVMaXN0LmZvckVhY2goYXR0ciA9PiB7XFxuICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlKGF0dHIsIGFsbG93ZWRBdHRyaWJ1dGVzKSkge1xcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIubm9kZU5hbWUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICByZXR1cm4gY3JlYXRlZERvY3VtZW50LmJvZHkuaW5uZXJIVE1MO1xcbn1cXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIEJvb3RzdHJhcCAodjUuMC4xKTogdG9vbHRpcC5qc1xcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ29uc3RhbnRzXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuY29uc3QgTkFNRSQ0ID0gJ3Rvb2x0aXAnO1xcbmNvbnN0IERBVEFfS0VZJDQgPSAnYnMudG9vbHRpcCc7XFxuY29uc3QgRVZFTlRfS0VZJDQgPSBgLiR7REFUQV9LRVkkNH1gO1xcbmNvbnN0IENMQVNTX1BSRUZJWCQxID0gJ2JzLXRvb2x0aXAnO1xcbmNvbnN0IEJTQ0xTX1BSRUZJWF9SRUdFWCQxID0gbmV3IFJlZ0V4cChgKF58XFxcXFxcXFxzKSR7Q0xBU1NfUFJFRklYJDF9XFxcXFxcXFxTK2AsICdnJyk7XFxuY29uc3QgRElTQUxMT1dFRF9BVFRSSUJVVEVTID0gbmV3IFNldChbJ3Nhbml0aXplJywgJ2FsbG93TGlzdCcsICdzYW5pdGl6ZUZuJ10pO1xcbmNvbnN0IERlZmF1bHRUeXBlJDMgPSB7XFxuICBhbmltYXRpb246ICdib29sZWFuJyxcXG4gIHRlbXBsYXRlOiAnc3RyaW5nJyxcXG4gIHRpdGxlOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKScsXFxuICB0cmlnZ2VyOiAnc3RyaW5nJyxcXG4gIGRlbGF5OiAnKG51bWJlcnxvYmplY3QpJyxcXG4gIGh0bWw6ICdib29sZWFuJyxcXG4gIHNlbGVjdG9yOiAnKHN0cmluZ3xib29sZWFuKScsXFxuICBwbGFjZW1lbnQ6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXFxuICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXFxuICBjb250YWluZXI6ICcoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbiknLFxcbiAgZmFsbGJhY2tQbGFjZW1lbnRzOiAnYXJyYXknLFxcbiAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcXG4gIGN1c3RvbUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxcbiAgc2FuaXRpemU6ICdib29sZWFuJyxcXG4gIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxcbiAgYWxsb3dMaXN0OiAnb2JqZWN0JyxcXG4gIHBvcHBlckNvbmZpZzogJyhudWxsfG9iamVjdHxmdW5jdGlvbiknXFxufTtcXG5jb25zdCBBdHRhY2htZW50TWFwID0ge1xcbiAgQVVUTzogJ2F1dG8nLFxcbiAgVE9QOiAndG9wJyxcXG4gIFJJR0hUOiBpc1JUTCgpID8gJ2xlZnQnIDogJ3JpZ2h0JyxcXG4gIEJPVFRPTTogJ2JvdHRvbScsXFxuICBMRUZUOiBpc1JUTCgpID8gJ3JpZ2h0JyA6ICdsZWZ0J1xcbn07XFxuY29uc3QgRGVmYXVsdCQzID0ge1xcbiAgYW5pbWF0aW9uOiB0cnVlLFxcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwXFxcIiByb2xlPVxcXCJ0b29sdGlwXFxcIj4nICsgJzxkaXYgY2xhc3M9XFxcInRvb2x0aXAtYXJyb3dcXFwiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1pbm5lclxcXCI+PC9kaXY+JyArICc8L2Rpdj4nLFxcbiAgdHJpZ2dlcjogJ2hvdmVyIGZvY3VzJyxcXG4gIHRpdGxlOiAnJyxcXG4gIGRlbGF5OiAwLFxcbiAgaHRtbDogZmFsc2UsXFxuICBzZWxlY3RvcjogZmFsc2UsXFxuICBwbGFjZW1lbnQ6ICd0b3AnLFxcbiAgb2Zmc2V0OiBbMCwgMF0sXFxuICBjb250YWluZXI6IGZhbHNlLFxcbiAgZmFsbGJhY2tQbGFjZW1lbnRzOiBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLFxcbiAgYm91bmRhcnk6ICdjbGlwcGluZ1BhcmVudHMnLFxcbiAgY3VzdG9tQ2xhc3M6ICcnLFxcbiAgc2FuaXRpemU6IHRydWUsXFxuICBzYW5pdGl6ZUZuOiBudWxsLFxcbiAgYWxsb3dMaXN0OiBEZWZhdWx0QWxsb3dsaXN0LFxcbiAgcG9wcGVyQ29uZmlnOiBudWxsXFxufTtcXG5jb25zdCBFdmVudCQyID0ge1xcbiAgSElERTogYGhpZGUke0VWRU5UX0tFWSQ0fWAsXFxuICBISURERU46IGBoaWRkZW4ke0VWRU5UX0tFWSQ0fWAsXFxuICBTSE9XOiBgc2hvdyR7RVZFTlRfS0VZJDR9YCxcXG4gIFNIT1dOOiBgc2hvd24ke0VWRU5UX0tFWSQ0fWAsXFxuICBJTlNFUlRFRDogYGluc2VydGVkJHtFVkVOVF9LRVkkNH1gLFxcbiAgQ0xJQ0s6IGBjbGljayR7RVZFTlRfS0VZJDR9YCxcXG4gIEZPQ1VTSU46IGBmb2N1c2luJHtFVkVOVF9LRVkkNH1gLFxcbiAgRk9DVVNPVVQ6IGBmb2N1c291dCR7RVZFTlRfS0VZJDR9YCxcXG4gIE1PVVNFRU5URVI6IGBtb3VzZWVudGVyJHtFVkVOVF9LRVkkNH1gLFxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke0VWRU5UX0tFWSQ0fWBcXG59O1xcbmNvbnN0IENMQVNTX05BTUVfRkFERSQzID0gJ2ZhZGUnO1xcbmNvbnN0IENMQVNTX05BTUVfTU9EQUwgPSAnbW9kYWwnO1xcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQzID0gJ3Nob3cnO1xcbmNvbnN0IEhPVkVSX1NUQVRFX1NIT1cgPSAnc2hvdyc7XFxuY29uc3QgSE9WRVJfU1RBVEVfT1VUID0gJ291dCc7XFxuY29uc3QgU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiA9ICcudG9vbHRpcC1pbm5lcic7XFxuY29uc3QgVFJJR0dFUl9IT1ZFUiA9ICdob3Zlcic7XFxuY29uc3QgVFJJR0dFUl9GT0NVUyA9ICdmb2N1cyc7XFxuY29uc3QgVFJJR0dFUl9DTElDSyA9ICdjbGljayc7XFxuY29uc3QgVFJJR0dFUl9NQU5VQUwgPSAnbWFudWFsJztcXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDbGFzcyBEZWZpbml0aW9uXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuY2xhc3MgVG9vbHRpcCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgIGlmICh0eXBlb2YgX3BvcHBlcmpzX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXFxcJ3MgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZyknKTtcXG4gICAgfVxcblxcbiAgICBzdXBlcihlbGVtZW50KTsgLy8gcHJpdmF0ZVxcblxcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xcbiAgICB0aGlzLl90aW1lb3V0ID0gMDtcXG4gICAgdGhpcy5faG92ZXJTdGF0ZSA9ICcnO1xcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge307XFxuICAgIHRoaXMuX3BvcHBlciA9IG51bGw7IC8vIFByb3RlY3RlZFxcblxcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgdGhpcy50aXAgPSBudWxsO1xcblxcbiAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcXG4gIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xcbiAgICByZXR1cm4gRGVmYXVsdCQzO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICByZXR1cm4gTkFNRSQ0O1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBFdmVudCgpIHtcXG4gICAgcmV0dXJuIEV2ZW50JDI7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkMztcXG4gIH0gLy8gUHVibGljXFxuXFxuXFxuICBlbmFibGUoKSB7XFxuICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XFxuICB9XFxuXFxuICBkaXNhYmxlKCkge1xcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIHRvZ2dsZUVuYWJsZWQoKSB7XFxuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICF0aGlzLl9pc0VuYWJsZWQ7XFxuICB9XFxuXFxuICB0b2dnbGUoZXZlbnQpIHtcXG4gICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKGV2ZW50KSB7XFxuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCk7XFxuXFxuICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrO1xcblxcbiAgICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcXG4gICAgICAgIGNvbnRleHQuX2VudGVyKG51bGwsIGNvbnRleHQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb250ZXh0Ll9sZWF2ZShudWxsLCBjb250ZXh0KTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKHRoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckMykpIHtcXG4gICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xcblxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9lbnRlcihudWxsLCB0aGlzKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZGlzcG9zZSgpIHtcXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChgLiR7Q0xBU1NfTkFNRV9NT0RBTH1gKSwgJ2hpZGUuYnMubW9kYWwnLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKTtcXG5cXG4gICAgaWYgKHRoaXMudGlwICYmIHRoaXMudGlwLnBhcmVudE5vZGUpIHtcXG4gICAgICB0aGlzLnRpcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudGlwKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XFxuICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcXG4gICAgfVxcblxcbiAgICBzdXBlci5kaXNwb3NlKCk7XFxuICB9XFxuXFxuICBzaG93KCkge1xcbiAgICBpZiAodGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2Ugc2hvdyBvbiB2aXNpYmxlIGVsZW1lbnRzJyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKCEodGhpcy5pc1dpdGhDb250ZW50KCkgJiYgdGhpcy5faXNFbmFibGVkKSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1cpO1xcbiAgICBjb25zdCBzaGFkb3dSb290ID0gZmluZFNoYWRvd1Jvb3QodGhpcy5fZWxlbWVudCk7XFxuICAgIGNvbnN0IGlzSW5UaGVEb20gPSBzaGFkb3dSb290ID09PSBudWxsID8gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0aGlzLl9lbGVtZW50KSA6IHNoYWRvd1Jvb3QuY29udGFpbnModGhpcy5fZWxlbWVudCk7XFxuXFxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCAhaXNJblRoZURvbSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTtcXG4gICAgY29uc3QgdGlwSWQgPSBnZXRVSUQodGhpcy5jb25zdHJ1Y3Rvci5OQU1FKTtcXG4gICAgdGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aXBJZCk7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwSWQpO1xcblxcbiAgICB0aGlzLnNldENvbnRlbnQoKTtcXG5cXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcXG4gICAgICB0aXAuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUkMyk7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgcGxhY2VtZW50ID0gdHlwZW9mIHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgdGlwLCB0aGlzLl9lbGVtZW50KSA6IHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQ7XFxuXFxuICAgIGNvbnN0IGF0dGFjaG1lbnQgPSB0aGlzLl9nZXRBdHRhY2htZW50KHBsYWNlbWVudCk7XFxuXFxuICAgIHRoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KTtcXG5cXG4gICAgY29uc3Qge1xcbiAgICAgIGNvbnRhaW5lclxcbiAgICB9ID0gdGhpcy5fY29uZmlnO1xcbiAgICBEYXRhLnNldCh0aXAsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpO1xcblxcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy50aXApKSB7XFxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRpcCk7XFxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5JTlNFUlRFRCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xcbiAgICAgIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLl9wb3BwZXIgPSBfcG9wcGVyanNfY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJjcmVhdGVQb3BwZXJcXFwiXSh0aGlzLl9lbGVtZW50LCB0aXAsIHRoaXMuX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSk7XFxuICAgIH1cXG5cXG4gICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDMpO1xcbiAgICBjb25zdCBjdXN0b21DbGFzcyA9IHR5cGVvZiB0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MoKSA6IHRoaXMuX2NvbmZpZy5jdXN0b21DbGFzcztcXG5cXG4gICAgaWYgKGN1c3RvbUNsYXNzKSB7XFxuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoLi4uY3VzdG9tQ2xhc3Muc3BsaXQoJyAnKSk7XFxuICAgIH0gLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xcbiAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xcbiAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcXG5cXG5cXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xcbiAgICAgIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICBjb25zdCBwcmV2SG92ZXJTdGF0ZSA9IHRoaXMuX2hvdmVyU3RhdGU7XFxuICAgICAgdGhpcy5faG92ZXJTdGF0ZSA9IG51bGw7XFxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTik7XFxuXFxuICAgICAgaWYgKHByZXZIb3ZlclN0YXRlID09PSBIT1ZFUl9TVEFURV9PVVQpIHtcXG4gICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMyk7XFxuXFxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCBpc0FuaW1hdGVkKTtcXG4gIH1cXG5cXG4gIGhpZGUoKSB7XFxuICAgIGlmICghdGhpcy5fcG9wcGVyKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xcblxcbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICBpZiAodGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9ob3ZlclN0YXRlICE9PSBIT1ZFUl9TVEFURV9TSE9XICYmIHRpcC5wYXJlbnROb2RlKSB7XFxuICAgICAgICB0aXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aXApO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9jbGVhblRpcENsYXNzKCk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcXG5cXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJRERFTik7XFxuXFxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcXG5cXG4gICAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJREUpO1xcblxcbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDMpOyAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxcblxcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XFxuICAgICAgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goZWxlbWVudCA9PiBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKSk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0NMSUNLXSA9IGZhbHNlO1xcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfRk9DVVNdID0gZmFsc2U7XFxuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9IT1ZFUl0gPSBmYWxzZTtcXG4gICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMyk7XFxuXFxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCBpc0FuaW1hdGVkKTtcXG5cXG4gICAgdGhpcy5faG92ZXJTdGF0ZSA9ICcnO1xcbiAgfVxcblxcbiAgdXBkYXRlKCkge1xcbiAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XFxuICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xcbiAgICB9XFxuICB9IC8vIFByb3RlY3RlZFxcblxcblxcbiAgaXNXaXRoQ29udGVudCgpIHtcXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRUaXRsZSgpKTtcXG4gIH1cXG5cXG4gIGdldFRpcEVsZW1lbnQoKSB7XFxuICAgIGlmICh0aGlzLnRpcCkge1xcbiAgICAgIHJldHVybiB0aGlzLnRpcDtcXG4gICAgfVxcblxcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fY29uZmlnLnRlbXBsYXRlO1xcbiAgICB0aGlzLnRpcCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XFxuICAgIHJldHVybiB0aGlzLnRpcDtcXG4gIH1cXG5cXG4gIHNldENvbnRlbnQoKSB7XFxuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xcbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiwgdGlwKSwgdGhpcy5nZXRUaXRsZSgpKTtcXG4gICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9GQURFJDMsIENMQVNTX05BTUVfU0hPVyQzKTtcXG4gIH1cXG5cXG4gIHNldEVsZW1lbnRDb250ZW50KGVsZW1lbnQsIGNvbnRlbnQpIHtcXG4gICAgaWYgKGVsZW1lbnQgPT09IG51bGwpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKGlzRWxlbWVudChjb250ZW50KSkge1xcbiAgICAgIGNvbnRlbnQgPSBnZXRFbGVtZW50KGNvbnRlbnQpOyAvLyBjb250ZW50IGlzIGEgRE9NIG5vZGUgb3IgYSBqUXVlcnlcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmh0bWwpIHtcXG4gICAgICAgIGlmIChjb250ZW50LnBhcmVudE5vZGUgIT09IGVsZW1lbnQpIHtcXG4gICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnJztcXG4gICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjb250ZW50KTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGNvbnRlbnQudGV4dENvbnRlbnQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5fY29uZmlnLmh0bWwpIHtcXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnNhbml0aXplKSB7XFxuICAgICAgICBjb250ZW50ID0gc2FuaXRpemVIdG1sKGNvbnRlbnQsIHRoaXMuX2NvbmZpZy5hbGxvd0xpc3QsIHRoaXMuX2NvbmZpZy5zYW5pdGl6ZUZuKTtcXG4gICAgICB9XFxuXFxuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBjb250ZW50O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBjb250ZW50O1xcbiAgICB9XFxuICB9XFxuXFxuICBnZXRUaXRsZSgpIHtcXG4gICAgbGV0IHRpdGxlID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnKTtcXG5cXG4gICAgaWYgKCF0aXRsZSkge1xcbiAgICAgIHRpdGxlID0gdHlwZW9mIHRoaXMuX2NvbmZpZy50aXRsZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuX2NvbmZpZy50aXRsZS5jYWxsKHRoaXMuX2VsZW1lbnQpIDogdGhpcy5fY29uZmlnLnRpdGxlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aXRsZTtcXG4gIH1cXG5cXG4gIHVwZGF0ZUF0dGFjaG1lbnQoYXR0YWNobWVudCkge1xcbiAgICBpZiAoYXR0YWNobWVudCA9PT0gJ3JpZ2h0Jykge1xcbiAgICAgIHJldHVybiAnZW5kJztcXG4gICAgfVxcblxcbiAgICBpZiAoYXR0YWNobWVudCA9PT0gJ2xlZnQnKSB7XFxuICAgICAgcmV0dXJuICdzdGFydCc7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGF0dGFjaG1lbnQ7XFxuICB9IC8vIFByaXZhdGVcXG5cXG5cXG4gIF9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQsIGNvbnRleHQpIHtcXG4gICAgY29uc3QgZGF0YUtleSA9IHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVk7XFxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IERhdGEuZ2V0KGV2ZW50LmRlbGVnYXRlVGFyZ2V0LCBkYXRhS2V5KTtcXG5cXG4gICAgaWYgKCFjb250ZXh0KSB7XFxuICAgICAgY29udGV4dCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGV2ZW50LmRlbGVnYXRlVGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcXG4gICAgICBEYXRhLnNldChldmVudC5kZWxlZ2F0ZVRhcmdldCwgZGF0YUtleSwgY29udGV4dCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGNvbnRleHQ7XFxuICB9XFxuXFxuICBfZ2V0T2Zmc2V0KCkge1xcbiAgICBjb25zdCB7XFxuICAgICAgb2Zmc2V0XFxuICAgIH0gPSB0aGlzLl9jb25maWc7XFxuXFxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xcbiAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsID0+IE51bWJlci5wYXJzZUludCh2YWwsIDEwKSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICByZXR1cm4gcG9wcGVyRGF0YSA9PiBvZmZzZXQocG9wcGVyRGF0YSwgdGhpcy5fZWxlbWVudCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG9mZnNldDtcXG4gIH1cXG5cXG4gIF9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkge1xcbiAgICBjb25zdCBkZWZhdWx0QnNQb3BwZXJDb25maWcgPSB7XFxuICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxcbiAgICAgIG1vZGlmaWVyczogW3tcXG4gICAgICAgIG5hbWU6ICdmbGlwJyxcXG4gICAgICAgIG9wdGlvbnM6IHtcXG4gICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiB0aGlzLl9jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRzXFxuICAgICAgICB9XFxuICAgICAgfSwge1xcbiAgICAgICAgbmFtZTogJ29mZnNldCcsXFxuICAgICAgICBvcHRpb25zOiB7XFxuICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcXG4gICAgICAgIH1cXG4gICAgICB9LCB7XFxuICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcXG4gICAgICAgIG9wdGlvbnM6IHtcXG4gICAgICAgICAgYm91bmRhcnk6IHRoaXMuX2NvbmZpZy5ib3VuZGFyeVxcbiAgICAgICAgfVxcbiAgICAgIH0sIHtcXG4gICAgICAgIG5hbWU6ICdhcnJvdycsXFxuICAgICAgICBvcHRpb25zOiB7XFxuICAgICAgICAgIGVsZW1lbnQ6IGAuJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9LWFycm93YFxcbiAgICAgICAgfVxcbiAgICAgIH0sIHtcXG4gICAgICAgIG5hbWU6ICdvbkNoYW5nZScsXFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxcbiAgICAgICAgcGhhc2U6ICdhZnRlcldyaXRlJyxcXG4gICAgICAgIGZuOiBkYXRhID0+IHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKVxcbiAgICAgIH1dLFxcbiAgICAgIG9uRmlyc3RVcGRhdGU6IGRhdGEgPT4ge1xcbiAgICAgICAgaWYgKGRhdGEub3B0aW9ucy5wbGFjZW1lbnQgIT09IGRhdGEucGxhY2VtZW50KSB7XFxuICAgICAgICAgIHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuICAgIHJldHVybiB7IC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcXG4gICAgICAuLi4odHlwZW9mIHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGRlZmF1bHRCc1BvcHBlckNvbmZpZykgOiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKVxcbiAgICB9O1xcbiAgfVxcblxcbiAgX2FkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KSB7XFxuICAgIHRoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoYCR7Q0xBU1NfUFJFRklYJDF9LSR7dGhpcy51cGRhdGVBdHRhY2htZW50KGF0dGFjaG1lbnQpfWApO1xcbiAgfVxcblxcbiAgX2dldEF0dGFjaG1lbnQocGxhY2VtZW50KSB7XFxuICAgIHJldHVybiBBdHRhY2htZW50TWFwW3BsYWNlbWVudC50b1VwcGVyQ2FzZSgpXTtcXG4gIH1cXG5cXG4gIF9zZXRMaXN0ZW5lcnMoKSB7XFxuICAgIGNvbnN0IHRyaWdnZXJzID0gdGhpcy5fY29uZmlnLnRyaWdnZXIuc3BsaXQoJyAnKTtcXG5cXG4gICAgdHJpZ2dlcnMuZm9yRWFjaCh0cmlnZ2VyID0+IHtcXG4gICAgICBpZiAodHJpZ2dlciA9PT0gJ2NsaWNrJykge1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuQ0xJQ0ssIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4gdGhpcy50b2dnbGUoZXZlbnQpKTtcXG4gICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgIT09IFRSSUdHRVJfTUFOVUFMKSB7XFxuICAgICAgICBjb25zdCBldmVudEluID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUiA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTjtcXG4gICAgICAgIGNvbnN0IGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VMRUFWRSA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNPVVQ7XFxuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgZXZlbnRJbiwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB0aGlzLl9lbnRlcihldmVudCkpO1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50T3V0LCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHRoaXMuX2xlYXZlKGV2ZW50KSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9ICgpID0+IHtcXG4gICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xcbiAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudC5jbG9zZXN0KGAuJHtDTEFTU19OQU1FX01PREFMfWApLCAnaGlkZS5icy5tb2RhbCcsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xcblxcbiAgICBpZiAodGhpcy5fY29uZmlnLnNlbGVjdG9yKSB7XFxuICAgICAgdGhpcy5fY29uZmlnID0geyAuLi50aGlzLl9jb25maWcsXFxuICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcXG4gICAgICAgIHNlbGVjdG9yOiAnJ1xcbiAgICAgIH07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5fZml4VGl0bGUoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgX2ZpeFRpdGxlKCkge1xcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpO1xcblxcbiAgICBjb25zdCBvcmlnaW5hbFRpdGxlVHlwZSA9IHR5cGVvZiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpO1xcblxcbiAgICBpZiAodGl0bGUgfHwgb3JpZ2luYWxUaXRsZVR5cGUgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnLCB0aXRsZSB8fCAnJyk7XFxuXFxuICAgICAgaWYgKHRpdGxlICYmICF0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpICYmICF0aGlzLl9lbGVtZW50LnRleHRDb250ZW50KSB7XFxuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRpdGxlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJycpO1xcbiAgICB9XFxuICB9XFxuXFxuICBfZW50ZXIoZXZlbnQsIGNvbnRleHQpIHtcXG4gICAgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCwgY29udGV4dCk7XFxuXFxuICAgIGlmIChldmVudCkge1xcbiAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAoY29udGV4dC5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQzKSB8fCBjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIT1ZFUl9TVEFURV9TSE9XKSB7XFxuICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX1NIT1c7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNsZWFyVGltZW91dChjb250ZXh0Ll90aW1lb3V0KTtcXG4gICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX1NIT1c7XFxuXFxuICAgIGlmICghY29udGV4dC5fY29uZmlnLmRlbGF5IHx8ICFjb250ZXh0Ll9jb25maWcuZGVsYXkuc2hvdykge1xcbiAgICAgIGNvbnRleHQuc2hvdygpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb250ZXh0Ll90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XFxuICAgICAgaWYgKGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX1NIT1cpIHtcXG4gICAgICAgIGNvbnRleHQuc2hvdygpO1xcbiAgICAgIH1cXG4gICAgfSwgY29udGV4dC5fY29uZmlnLmRlbGF5LnNob3cpO1xcbiAgfVxcblxcbiAgX2xlYXZlKGV2ZW50LCBjb250ZXh0KSB7XFxuICAgIGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQsIGNvbnRleHQpO1xcblxcbiAgICBpZiAoZXZlbnQpIHtcXG4gICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW2V2ZW50LnR5cGUgPT09ICdmb2N1c291dCcgPyBUUklHR0VSX0ZPQ1VTIDogVFJJR0dFUl9IT1ZFUl0gPSBjb250ZXh0Ll9lbGVtZW50LmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xcbiAgICB9XFxuXFxuICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpO1xcbiAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSE9WRVJfU1RBVEVfT1VUO1xcblxcbiAgICBpZiAoIWNvbnRleHQuX2NvbmZpZy5kZWxheSB8fCAhY29udGV4dC5fY29uZmlnLmRlbGF5LmhpZGUpIHtcXG4gICAgICBjb250ZXh0LmhpZGUoKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29udGV4dC5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgIGlmIChjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIT1ZFUl9TVEFURV9PVVQpIHtcXG4gICAgICAgIGNvbnRleHQuaGlkZSgpO1xcbiAgICAgIH1cXG4gICAgfSwgY29udGV4dC5fY29uZmlnLmRlbGF5LmhpZGUpO1xcbiAgfVxcblxcbiAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XFxuICAgIGZvciAoY29uc3QgdHJpZ2dlciBpbiB0aGlzLl9hY3RpdmVUcmlnZ2VyKSB7XFxuICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRyaWdnZXJbdHJpZ2dlcl0pIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xcbiAgICBjb25zdCBkYXRhQXR0cmlidXRlcyA9IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xcbiAgICBPYmplY3Qua2V5cyhkYXRhQXR0cmlidXRlcykuZm9yRWFjaChkYXRhQXR0ciA9PiB7XFxuICAgICAgaWYgKERJU0FMTE9XRURfQVRUUklCVVRFUy5oYXMoZGF0YUF0dHIpKSB7XFxuICAgICAgICBkZWxldGUgZGF0YUF0dHJpYnV0ZXNbZGF0YUF0dHJdO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIGNvbmZpZyA9IHsgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxcbiAgICAgIC4uLmRhdGFBdHRyaWJ1dGVzLFxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcXG4gICAgfTtcXG4gICAgY29uZmlnLmNvbnRhaW5lciA9IGNvbmZpZy5jb250YWluZXIgPT09IGZhbHNlID8gZG9jdW1lbnQuYm9keSA6IGdldEVsZW1lbnQoY29uZmlnLmNvbnRhaW5lcik7XFxuXFxuICAgIGlmICh0eXBlb2YgY29uZmlnLmRlbGF5ID09PSAnbnVtYmVyJykge1xcbiAgICAgIGNvbmZpZy5kZWxheSA9IHtcXG4gICAgICAgIHNob3c6IGNvbmZpZy5kZWxheSxcXG4gICAgICAgIGhpZGU6IGNvbmZpZy5kZWxheVxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGl0bGUgPT09ICdudW1iZXInKSB7XFxuICAgICAgY29uZmlnLnRpdGxlID0gY29uZmlnLnRpdGxlLnRvU3RyaW5nKCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBjb25maWcuY29udGVudCA9PT0gJ251bWJlcicpIHtcXG4gICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKCk7XFxuICAgIH1cXG5cXG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUkNCwgY29uZmlnLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKTtcXG5cXG4gICAgaWYgKGNvbmZpZy5zYW5pdGl6ZSkge1xcbiAgICAgIGNvbmZpZy50ZW1wbGF0ZSA9IHNhbml0aXplSHRtbChjb25maWcudGVtcGxhdGUsIGNvbmZpZy5hbGxvd0xpc3QsIGNvbmZpZy5zYW5pdGl6ZUZuKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gY29uZmlnO1xcbiAgfVxcblxcbiAgX2dldERlbGVnYXRlQ29uZmlnKCkge1xcbiAgICBjb25zdCBjb25maWcgPSB7fTtcXG5cXG4gICAgaWYgKHRoaXMuX2NvbmZpZykge1xcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuX2NvbmZpZykge1xcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtrZXldICE9PSB0aGlzLl9jb25maWdba2V5XSkge1xcbiAgICAgICAgICBjb25maWdba2V5XSA9IHRoaXMuX2NvbmZpZ1trZXldO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gY29uZmlnO1xcbiAgfVxcblxcbiAgX2NsZWFuVGlwQ2xhc3MoKSB7XFxuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xcbiAgICBjb25zdCB0YWJDbGFzcyA9IHRpcC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYJDEpO1xcblxcbiAgICBpZiAodGFiQ2xhc3MgIT09IG51bGwgJiYgdGFiQ2xhc3MubGVuZ3RoID4gMCkge1xcbiAgICAgIHRhYkNsYXNzLm1hcCh0b2tlbiA9PiB0b2tlbi50cmltKCkpLmZvckVhY2godENsYXNzID0+IHRpcC5jbGFzc0xpc3QucmVtb3ZlKHRDbGFzcykpO1xcbiAgICB9XFxuICB9XFxuXFxuICBfaGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHBvcHBlckRhdGEpIHtcXG4gICAgY29uc3Qge1xcbiAgICAgIHN0YXRlXFxuICAgIH0gPSBwb3BwZXJEYXRhO1xcblxcbiAgICBpZiAoIXN0YXRlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMudGlwID0gc3RhdGUuZWxlbWVudHMucG9wcGVyO1xcblxcbiAgICB0aGlzLl9jbGVhblRpcENsYXNzKCk7XFxuXFxuICAgIHRoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyh0aGlzLl9nZXRBdHRhY2htZW50KHN0YXRlLnBsYWNlbWVudCkpO1xcbiAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgIGxldCBkYXRhID0gRGF0YS5nZXQodGhpcywgREFUQV9LRVkkNCk7XFxuXFxuICAgICAgY29uc3QgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZztcXG5cXG4gICAgICBpZiAoIWRhdGEgJiYgL2Rpc3Bvc2V8aGlkZS8udGVzdChjb25maWcpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghZGF0YSkge1xcbiAgICAgICAgZGF0YSA9IG5ldyBUb29sdGlwKHRoaXMsIF9jb25maWcpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxufVxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGpRdWVyeVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGFkZCAuVG9vbHRpcCB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxcbiAqL1xcblxcblxcbmRlZmluZUpRdWVyeVBsdWdpbihUb29sdGlwKTtcXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIEJvb3RzdHJhcCAodjUuMC4xKTogcG9wb3Zlci5qc1xcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ29uc3RhbnRzXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuY29uc3QgTkFNRSQzID0gJ3BvcG92ZXInO1xcbmNvbnN0IERBVEFfS0VZJDMgPSAnYnMucG9wb3Zlcic7XFxuY29uc3QgRVZFTlRfS0VZJDMgPSBgLiR7REFUQV9LRVkkM31gO1xcbmNvbnN0IENMQVNTX1BSRUZJWCA9ICdicy1wb3BvdmVyJztcXG5jb25zdCBCU0NMU19QUkVGSVhfUkVHRVggPSBuZXcgUmVnRXhwKGAoXnxcXFxcXFxcXHMpJHtDTEFTU19QUkVGSVh9XFxcXFxcXFxTK2AsICdnJyk7XFxuY29uc3QgRGVmYXVsdCQyID0geyAuLi5Ub29sdGlwLkRlZmF1bHQsXFxuICBwbGFjZW1lbnQ6ICdyaWdodCcsXFxuICBvZmZzZXQ6IFswLCA4XSxcXG4gIHRyaWdnZXI6ICdjbGljaycsXFxuICBjb250ZW50OiAnJyxcXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cXFwicG9wb3ZlclxcXCIgcm9sZT1cXFwidG9vbHRpcFxcXCI+JyArICc8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWFycm93XFxcIj48L2Rpdj4nICsgJzxoMyBjbGFzcz1cXFwicG9wb3Zlci1oZWFkZXJcXFwiPjwvaDM+JyArICc8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWJvZHlcXFwiPjwvZGl2PicgKyAnPC9kaXY+J1xcbn07XFxuY29uc3QgRGVmYXVsdFR5cGUkMiA9IHsgLi4uVG9vbHRpcC5EZWZhdWx0VHlwZSxcXG4gIGNvbnRlbnQ6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJ1xcbn07XFxuY29uc3QgRXZlbnQkMSA9IHtcXG4gIEhJREU6IGBoaWRlJHtFVkVOVF9LRVkkM31gLFxcbiAgSElEREVOOiBgaGlkZGVuJHtFVkVOVF9LRVkkM31gLFxcbiAgU0hPVzogYHNob3cke0VWRU5UX0tFWSQzfWAsXFxuICBTSE9XTjogYHNob3duJHtFVkVOVF9LRVkkM31gLFxcbiAgSU5TRVJURUQ6IGBpbnNlcnRlZCR7RVZFTlRfS0VZJDN9YCxcXG4gIENMSUNLOiBgY2xpY2ske0VWRU5UX0tFWSQzfWAsXFxuICBGT0NVU0lOOiBgZm9jdXNpbiR7RVZFTlRfS0VZJDN9YCxcXG4gIEZPQ1VTT1VUOiBgZm9jdXNvdXQke0VWRU5UX0tFWSQzfWAsXFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7RVZFTlRfS0VZJDN9YCxcXG4gIE1PVVNFTEVBVkU6IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVkkM31gXFxufTtcXG5jb25zdCBDTEFTU19OQU1FX0ZBREUkMiA9ICdmYWRlJztcXG5jb25zdCBDTEFTU19OQU1FX1NIT1ckMiA9ICdzaG93JztcXG5jb25zdCBTRUxFQ1RPUl9USVRMRSA9ICcucG9wb3Zlci1oZWFkZXInO1xcbmNvbnN0IFNFTEVDVE9SX0NPTlRFTlQgPSAnLnBvcG92ZXItYm9keSc7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ2xhc3MgRGVmaW5pdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBUb29sdGlwIHtcXG4gIC8vIEdldHRlcnNcXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgcmV0dXJuIERlZmF1bHQkMjtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgcmV0dXJuIE5BTUUkMztcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgRXZlbnQoKSB7XFxuICAgIHJldHVybiBFdmVudCQxO1xcbiAgfVxcblxcbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcXG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDI7XFxuICB9IC8vIE92ZXJyaWRlc1xcblxcblxcbiAgaXNXaXRoQ29udGVudCgpIHtcXG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XFxuICB9XFxuXFxuICBzZXRDb250ZW50KCkge1xcbiAgICBjb25zdCB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTsgLy8gd2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xcblxcbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfVElUTEUsIHRpcCksIHRoaXMuZ2V0VGl0bGUoKSk7XFxuXFxuICAgIGxldCBjb250ZW50ID0gdGhpcy5fZ2V0Q29udGVudCgpO1xcblxcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBjb250ZW50ID0gY29udGVudC5jYWxsKHRoaXMuX2VsZW1lbnQpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQoU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9DT05URU5ULCB0aXApLCBjb250ZW50KTtcXG4gICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9GQURFJDIsIENMQVNTX05BTUVfU0hPVyQyKTtcXG4gIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgX2FkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KSB7XFxuICAgIHRoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoYCR7Q0xBU1NfUFJFRklYfS0ke3RoaXMudXBkYXRlQXR0YWNobWVudChhdHRhY2htZW50KX1gKTtcXG4gIH1cXG5cXG4gIF9nZXRDb250ZW50KCkge1xcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtY29udGVudCcpIHx8IHRoaXMuX2NvbmZpZy5jb250ZW50O1xcbiAgfVxcblxcbiAgX2NsZWFuVGlwQ2xhc3MoKSB7XFxuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xcbiAgICBjb25zdCB0YWJDbGFzcyA9IHRpcC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYKTtcXG5cXG4gICAgaWYgKHRhYkNsYXNzICE9PSBudWxsICYmIHRhYkNsYXNzLmxlbmd0aCA+IDApIHtcXG4gICAgICB0YWJDbGFzcy5tYXAodG9rZW4gPT4gdG9rZW4udHJpbSgpKS5mb3JFYWNoKHRDbGFzcyA9PiB0aXAuY2xhc3NMaXN0LnJlbW92ZSh0Q2xhc3MpKTtcXG4gICAgfVxcbiAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgIGxldCBkYXRhID0gRGF0YS5nZXQodGhpcywgREFUQV9LRVkkMyk7XFxuXFxuICAgICAgY29uc3QgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDogbnVsbDtcXG5cXG4gICAgICBpZiAoIWRhdGEgJiYgL2Rpc3Bvc2V8aGlkZS8udGVzdChjb25maWcpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghZGF0YSkge1xcbiAgICAgICAgZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIF9jb25maWcpO1xcbiAgICAgICAgRGF0YS5zZXQodGhpcywgREFUQV9LRVkkMywgZGF0YSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcXFwiJHtjb25maWd9XFxcImApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGF0YVtjb25maWddKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH1cXG5cXG59XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogalF1ZXJ5XFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogYWRkIC5Qb3BvdmVyIHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XFxuICovXFxuXFxuXFxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFBvcG92ZXIpO1xcblxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQm9vdHN0cmFwICh2NS4wLjEpOiBzY3JvbGxzcHkuanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIENvbnN0YW50c1xcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNvbnN0IE5BTUUkMiA9ICdzY3JvbGxzcHknO1xcbmNvbnN0IERBVEFfS0VZJDIgPSAnYnMuc2Nyb2xsc3B5JztcXG5jb25zdCBFVkVOVF9LRVkkMiA9IGAuJHtEQVRBX0tFWSQyfWA7XFxuY29uc3QgREFUQV9BUElfS0VZJDEgPSAnLmRhdGEtYXBpJztcXG5jb25zdCBEZWZhdWx0JDEgPSB7XFxuICBvZmZzZXQ6IDEwLFxcbiAgbWV0aG9kOiAnYXV0bycsXFxuICB0YXJnZXQ6ICcnXFxufTtcXG5jb25zdCBEZWZhdWx0VHlwZSQxID0ge1xcbiAgb2Zmc2V0OiAnbnVtYmVyJyxcXG4gIG1ldGhvZDogJ3N0cmluZycsXFxuICB0YXJnZXQ6ICcoc3RyaW5nfGVsZW1lbnQpJ1xcbn07XFxuY29uc3QgRVZFTlRfQUNUSVZBVEUgPSBgYWN0aXZhdGUke0VWRU5UX0tFWSQyfWA7XFxuY29uc3QgRVZFTlRfU0NST0xMID0gYHNjcm9sbCR7RVZFTlRfS0VZJDJ9YDtcXG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJID0gYGxvYWQke0VWRU5UX0tFWSQyfSR7REFUQV9BUElfS0VZJDF9YDtcXG5jb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0lURU0gPSAnZHJvcGRvd24taXRlbSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMSA9ICdhY3RpdmUnO1xcbmNvbnN0IFNFTEVDVE9SX0RBVEFfU1BZID0gJ1tkYXRhLWJzLXNweT1cXFwic2Nyb2xsXFxcIl0nO1xcbmNvbnN0IFNFTEVDVE9SX05BVl9MSVNUX0dST1VQJDEgPSAnLm5hdiwgLmxpc3QtZ3JvdXAnO1xcbmNvbnN0IFNFTEVDVE9SX05BVl9MSU5LUyA9ICcubmF2LWxpbmsnO1xcbmNvbnN0IFNFTEVDVE9SX05BVl9JVEVNUyA9ICcubmF2LWl0ZW0nO1xcbmNvbnN0IFNFTEVDVE9SX0xJU1RfSVRFTVMgPSAnLmxpc3QtZ3JvdXAtaXRlbSc7XFxuY29uc3QgU0VMRUNUT1JfRFJPUERPV04kMSA9ICcuZHJvcGRvd24nO1xcbmNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxID0gJy5kcm9wZG93bi10b2dnbGUnO1xcbmNvbnN0IE1FVEhPRF9PRkZTRVQgPSAnb2Zmc2V0JztcXG5jb25zdCBNRVRIT0RfUE9TSVRJT04gPSAncG9zaXRpb24nO1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIENsYXNzIERlZmluaXRpb25cXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jbGFzcyBTY3JvbGxTcHkgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xcbiAgICBzdXBlcihlbGVtZW50KTtcXG4gICAgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQudGFnTmFtZSA9PT0gJ0JPRFknID8gd2luZG93IDogdGhpcy5fZWxlbWVudDtcXG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XFxuICAgIHRoaXMuX3NlbGVjdG9yID0gYCR7dGhpcy5fY29uZmlnLnRhcmdldH0gJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke3RoaXMuX2NvbmZpZy50YXJnZXR9ICR7U0VMRUNUT1JfTElTVF9JVEVNU30sICR7dGhpcy5fY29uZmlnLnRhcmdldH0gLiR7Q0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNfWA7XFxuICAgIHRoaXMuX29mZnNldHMgPSBbXTtcXG4gICAgdGhpcy5fdGFyZ2V0cyA9IFtdO1xcbiAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xcbiAgICB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwO1xcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fc2Nyb2xsRWxlbWVudCwgRVZFTlRfU0NST0xMLCAoKSA9PiB0aGlzLl9wcm9jZXNzKCkpO1xcbiAgICB0aGlzLnJlZnJlc2goKTtcXG5cXG4gICAgdGhpcy5fcHJvY2VzcygpO1xcbiAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgIHJldHVybiBEZWZhdWx0JDE7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgIHJldHVybiBOQU1FJDI7XFxuICB9IC8vIFB1YmxpY1xcblxcblxcbiAgcmVmcmVzaCgpIHtcXG4gICAgY29uc3QgYXV0b01ldGhvZCA9IHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHRoaXMuX3Njcm9sbEVsZW1lbnQud2luZG93ID8gTUVUSE9EX09GRlNFVCA6IE1FVEhPRF9QT1NJVElPTjtcXG4gICAgY29uc3Qgb2Zmc2V0TWV0aG9kID0gdGhpcy5fY29uZmlnLm1ldGhvZCA9PT0gJ2F1dG8nID8gYXV0b01ldGhvZCA6IHRoaXMuX2NvbmZpZy5tZXRob2Q7XFxuICAgIGNvbnN0IG9mZnNldEJhc2UgPSBvZmZzZXRNZXRob2QgPT09IE1FVEhPRF9QT1NJVElPTiA/IHRoaXMuX2dldFNjcm9sbFRvcCgpIDogMDtcXG4gICAgdGhpcy5fb2Zmc2V0cyA9IFtdO1xcbiAgICB0aGlzLl90YXJnZXRzID0gW107XFxuICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpO1xcbiAgICBjb25zdCB0YXJnZXRzID0gU2VsZWN0b3JFbmdpbmUuZmluZCh0aGlzLl9zZWxlY3Rvcik7XFxuICAgIHRhcmdldHMubWFwKGVsZW1lbnQgPT4ge1xcbiAgICAgIGNvbnN0IHRhcmdldFNlbGVjdG9yID0gZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KTtcXG4gICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTZWxlY3RvciA/IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUodGFyZ2V0U2VsZWN0b3IpIDogbnVsbDtcXG5cXG4gICAgICBpZiAodGFyZ2V0KSB7XFxuICAgICAgICBjb25zdCB0YXJnZXRCQ1IgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFxuICAgICAgICBpZiAodGFyZ2V0QkNSLndpZHRoIHx8IHRhcmdldEJDUi5oZWlnaHQpIHtcXG4gICAgICAgICAgcmV0dXJuIFtNYW5pcHVsYXRvcltvZmZzZXRNZXRob2RdKHRhcmdldCkudG9wICsgb2Zmc2V0QmFzZSwgdGFyZ2V0U2VsZWN0b3JdO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfSkuZmlsdGVyKGl0ZW0gPT4gaXRlbSkuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pLmZvckVhY2goaXRlbSA9PiB7XFxuICAgICAgdGhpcy5fb2Zmc2V0cy5wdXNoKGl0ZW1bMF0pO1xcblxcbiAgICAgIHRoaXMuX3RhcmdldHMucHVzaChpdGVtWzFdKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBkaXNwb3NlKCkge1xcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX3Njcm9sbEVsZW1lbnQsIEVWRU5UX0tFWSQyKTtcXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xcbiAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xcbiAgICBjb25maWcgPSB7IC4uLkRlZmF1bHQkMSxcXG4gICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcXG4gICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pXFxuICAgIH07XFxuXFxuICAgIGlmICh0eXBlb2YgY29uZmlnLnRhcmdldCAhPT0gJ3N0cmluZycgJiYgaXNFbGVtZW50KGNvbmZpZy50YXJnZXQpKSB7XFxuICAgICAgbGV0IHtcXG4gICAgICAgIGlkXFxuICAgICAgfSA9IGNvbmZpZy50YXJnZXQ7XFxuXFxuICAgICAgaWYgKCFpZCkge1xcbiAgICAgICAgaWQgPSBnZXRVSUQoTkFNRSQyKTtcXG4gICAgICAgIGNvbmZpZy50YXJnZXQuaWQgPSBpZDtcXG4gICAgICB9XFxuXFxuICAgICAgY29uZmlnLnRhcmdldCA9IGAjJHtpZH1gO1xcbiAgICB9XFxuXFxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FJDIsIGNvbmZpZywgRGVmYXVsdFR5cGUkMSk7XFxuICAgIHJldHVybiBjb25maWc7XFxuICB9XFxuXFxuICBfZ2V0U2Nyb2xsVG9wKCkge1xcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gdGhpcy5fc2Nyb2xsRWxlbWVudC5wYWdlWU9mZnNldCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsVG9wO1xcbiAgfVxcblxcbiAgX2dldFNjcm9sbEhlaWdodCgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IHx8IE1hdGgubWF4KGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0KTtcXG4gIH1cXG5cXG4gIF9nZXRPZmZzZXRIZWlnaHQoKSB7XFxuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcXG4gIH1cXG5cXG4gIF9wcm9jZXNzKCkge1xcbiAgICBjb25zdCBzY3JvbGxUb3AgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKSArIHRoaXMuX2NvbmZpZy5vZmZzZXQ7XFxuXFxuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpO1xcblxcbiAgICBjb25zdCBtYXhTY3JvbGwgPSB0aGlzLl9jb25maWcub2Zmc2V0ICsgc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fZ2V0T2Zmc2V0SGVpZ2h0KCk7XFxuXFxuICAgIGlmICh0aGlzLl9zY3JvbGxIZWlnaHQgIT09IHNjcm9sbEhlaWdodCkge1xcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xcbiAgICB9XFxuXFxuICAgIGlmIChzY3JvbGxUb3AgPj0gbWF4U2Nyb2xsKSB7XFxuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1t0aGlzLl90YXJnZXRzLmxlbmd0aCAtIDFdO1xcblxcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRhcmdldCkge1xcbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgJiYgc2Nyb2xsVG9wIDwgdGhpcy5fb2Zmc2V0c1swXSAmJiB0aGlzLl9vZmZzZXRzWzBdID4gMCkge1xcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XFxuXFxuICAgICAgdGhpcy5fY2xlYXIoKTtcXG5cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuX29mZnNldHMubGVuZ3RoOyBpLS07KSB7XFxuICAgICAgY29uc3QgaXNBY3RpdmVUYXJnZXQgPSB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbaV0gJiYgc2Nyb2xsVG9wID49IHRoaXMuX29mZnNldHNbaV0gJiYgKHR5cGVvZiB0aGlzLl9vZmZzZXRzW2kgKyAxXSA9PT0gJ3VuZGVmaW5lZCcgfHwgc2Nyb2xsVG9wIDwgdGhpcy5fb2Zmc2V0c1tpICsgMV0pO1xcblxcbiAgICAgIGlmIChpc0FjdGl2ZVRhcmdldCkge1xcbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fdGFyZ2V0c1tpXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBfYWN0aXZhdGUodGFyZ2V0KSB7XFxuICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldDtcXG5cXG4gICAgdGhpcy5fY2xlYXIoKTtcXG5cXG4gICAgY29uc3QgcXVlcmllcyA9IHRoaXMuX3NlbGVjdG9yLnNwbGl0KCcsJykubWFwKHNlbGVjdG9yID0+IGAke3NlbGVjdG9yfVtkYXRhLWJzLXRhcmdldD1cXFwiJHt0YXJnZXR9XFxcIl0sJHtzZWxlY3Rvcn1baHJlZj1cXFwiJHt0YXJnZXR9XFxcIl1gKTtcXG5cXG4gICAgY29uc3QgbGluayA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUocXVlcmllcy5qb2luKCcsJykpO1xcblxcbiAgICBpZiAobGluay5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNKSkge1xcbiAgICAgIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEsIGxpbmsuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTiQxKSkuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcXG4gICAgICBsaW5rLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rIGFzIGFjdGl2ZVxcbiAgICAgIGxpbmsuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcXG4gICAgICBTZWxlY3RvckVuZ2luZS5wYXJlbnRzKGxpbmssIFNFTEVDVE9SX05BVl9MSVNUX0dST1VQJDEpLmZvckVhY2gobGlzdEdyb3VwID0+IHtcXG4gICAgICAgIC8vIFNldCB0cmlnZ2VyZWQgbGlua3MgcGFyZW50cyBhcyBhY3RpdmVcXG4gICAgICAgIC8vIFdpdGggYm90aCA8dWw+IGFuZCA8bmF2PiBtYXJrdXAgYSBwYXJlbnQgaXMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYW55IG5hdiBhbmNlc3RvclxcbiAgICAgICAgU2VsZWN0b3JFbmdpbmUucHJldihsaXN0R3JvdXAsIGAke1NFTEVDVE9SX05BVl9MSU5LU30sICR7U0VMRUNUT1JfTElTVF9JVEVNU31gKS5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpKTsgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSB3aGVuIC5uYXYtbGluayBpcyBpbnNpZGUgLm5hdi1pdGVtXFxuXFxuICAgICAgICBTZWxlY3RvckVuZ2luZS5wcmV2KGxpc3RHcm91cCwgU0VMRUNUT1JfTkFWX0lURU1TKS5mb3JFYWNoKG5hdkl0ZW0gPT4ge1xcbiAgICAgICAgICBTZWxlY3RvckVuZ2luZS5jaGlsZHJlbihuYXZJdGVtLCBTRUxFQ1RPUl9OQVZfTElOS1MpLmZvckVhY2goaXRlbSA9PiBpdGVtLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fc2Nyb2xsRWxlbWVudCwgRVZFTlRfQUNUSVZBVEUsIHtcXG4gICAgICByZWxhdGVkVGFyZ2V0OiB0YXJnZXRcXG4gICAgfSk7XFxuICB9XFxuXFxuICBfY2xlYXIoKSB7XFxuICAgIFNlbGVjdG9yRW5naW5lLmZpbmQodGhpcy5fc2VsZWN0b3IpLmZpbHRlcihub2RlID0+IG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFJDEpKS5mb3JFYWNoKG5vZGUgPT4gbm9kZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpKTtcXG4gIH0gLy8gU3RhdGljXFxuXFxuXFxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICBjb25zdCBkYXRhID0gU2Nyb2xsU3B5LmdldEluc3RhbmNlKHRoaXMpIHx8IG5ldyBTY3JvbGxTcHkodGhpcywgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiB7fSk7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFxcXCIke2NvbmZpZ31cXFwiYCk7XFxuICAgICAgfVxcblxcbiAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG59XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5cXG5FdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJLCAoKSA9PiB7XFxuICBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfU1BZKS5mb3JFYWNoKHNweSA9PiBuZXcgU2Nyb2xsU3B5KHNweSkpO1xcbn0pO1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGpRdWVyeVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGFkZCAuU2Nyb2xsU3B5IHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XFxuICovXFxuXFxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFNjcm9sbFNweSk7XFxuXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBCb290c3RyYXAgKHY1LjAuMSk6IHRhYi5qc1xcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogQ29uc3RhbnRzXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuY29uc3QgTkFNRSQxID0gJ3RhYic7XFxuY29uc3QgREFUQV9LRVkkMSA9ICdicy50YWInO1xcbmNvbnN0IEVWRU5UX0tFWSQxID0gYC4ke0RBVEFfS0VZJDF9YDtcXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcXG5jb25zdCBFVkVOVF9ISURFJDEgPSBgaGlkZSR7RVZFTlRfS0VZJDF9YDtcXG5jb25zdCBFVkVOVF9ISURERU4kMSA9IGBoaWRkZW4ke0VWRU5UX0tFWSQxfWA7XFxuY29uc3QgRVZFTlRfU0hPVyQxID0gYHNob3cke0VWRU5UX0tFWSQxfWA7XFxuY29uc3QgRVZFTlRfU0hPV04kMSA9IGBzaG93biR7RVZFTlRfS0VZJDF9YDtcXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSA9IGBjbGljayR7RVZFTlRfS0VZJDF9JHtEQVRBX0FQSV9LRVl9YDtcXG5jb25zdCBDTEFTU19OQU1FX0RST1BET1dOX01FTlUgPSAnZHJvcGRvd24tbWVudSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUgPSAnYWN0aXZlJztcXG5jb25zdCBDTEFTU19OQU1FX0ZBREUkMSA9ICdmYWRlJztcXG5jb25zdCBDTEFTU19OQU1FX1NIT1ckMSA9ICdzaG93JztcXG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTiA9ICcuZHJvcGRvd24nO1xcbmNvbnN0IFNFTEVDVE9SX05BVl9MSVNUX0dST1VQID0gJy5uYXYsIC5saXN0LWdyb3VwJztcXG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkUgPSAnLmFjdGl2ZSc7XFxuY29uc3QgU0VMRUNUT1JfQUNUSVZFX1VMID0gJzpzY29wZSA+IGxpID4gLmFjdGl2ZSc7XFxuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtYnMtdG9nZ2xlPVxcXCJ0YWJcXFwiXSwgW2RhdGEtYnMtdG9nZ2xlPVxcXCJwaWxsXFxcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cXFwibGlzdFxcXCJdJztcXG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUgPSAnLmRyb3Bkb3duLXRvZ2dsZSc7XFxuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fQUNUSVZFX0NISUxEID0gJzpzY29wZSA+IC5kcm9wZG93bi1tZW51IC5hY3RpdmUnO1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIENsYXNzIERlZmluaXRpb25cXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKi9cXG5cXG5jbGFzcyBUYWIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gIC8vIEdldHRlcnNcXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgcmV0dXJuIE5BTUUkMTtcXG4gIH0gLy8gUHVibGljXFxuXFxuXFxuICBzaG93KCkge1xcbiAgICBpZiAodGhpcy5fZWxlbWVudC5wYXJlbnROb2RlICYmIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGxldCBwcmV2aW91cztcXG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzLl9lbGVtZW50KTtcXG5cXG4gICAgY29uc3QgbGlzdEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVApO1xcblxcbiAgICBpZiAobGlzdEVsZW1lbnQpIHtcXG4gICAgICBjb25zdCBpdGVtU2VsZWN0b3IgPSBsaXN0RWxlbWVudC5ub2RlTmFtZSA9PT0gJ1VMJyB8fCBsaXN0RWxlbWVudC5ub2RlTmFtZSA9PT0gJ09MJyA/IFNFTEVDVE9SX0FDVElWRV9VTCA6IFNFTEVDVE9SX0FDVElWRTtcXG4gICAgICBwcmV2aW91cyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoaXRlbVNlbGVjdG9yLCBsaXN0RWxlbWVudCk7XFxuICAgICAgcHJldmlvdXMgPSBwcmV2aW91c1twcmV2aW91cy5sZW5ndGggLSAxXTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBwcmV2aW91cyA/IEV2ZW50SGFuZGxlci50cmlnZ2VyKHByZXZpb3VzLCBFVkVOVF9ISURFJDEsIHtcXG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XFxuICAgIH0pIDogbnVsbDtcXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQxLCB7XFxuICAgICAgcmVsYXRlZFRhcmdldDogcHJldmlvdXNcXG4gICAgfSk7XFxuXFxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCBoaWRlRXZlbnQgIT09IG51bGwgJiYgaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fZWxlbWVudCwgbGlzdEVsZW1lbnQpO1xcblxcbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcihwcmV2aW91cywgRVZFTlRfSElEREVOJDEsIHtcXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcXG4gICAgICB9KTtcXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQxLCB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBpZiAodGFyZ2V0KSB7XFxuICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0LCB0YXJnZXQucGFyZW50Tm9kZSwgY29tcGxldGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNvbXBsZXRlKCk7XFxuICAgIH1cXG4gIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgX2FjdGl2YXRlKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcXG4gICAgY29uc3QgYWN0aXZlRWxlbWVudHMgPSBjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlTmFtZSA9PT0gJ1VMJyB8fCBjb250YWluZXIubm9kZU5hbWUgPT09ICdPTCcpID8gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9BQ1RJVkVfVUwsIGNvbnRhaW5lcikgOiBTZWxlY3RvckVuZ2luZS5jaGlsZHJlbihjb250YWluZXIsIFNFTEVDVE9SX0FDVElWRSk7XFxuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzWzBdO1xcbiAgICBjb25zdCBpc1RyYW5zaXRpb25pbmcgPSBjYWxsYmFjayAmJiBhY3RpdmUgJiYgYWN0aXZlLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMSk7XFxuXFxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4gdGhpcy5fdHJhbnNpdGlvbkNvbXBsZXRlKGVsZW1lbnQsIGFjdGl2ZSwgY2FsbGJhY2spO1xcblxcbiAgICBpZiAoYWN0aXZlICYmIGlzVHJhbnNpdGlvbmluZykge1xcbiAgICAgIGFjdGl2ZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQxKTtcXG5cXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCBlbGVtZW50LCB0cnVlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjb21wbGV0ZSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBfdHJhbnNpdGlvbkNvbXBsZXRlKGVsZW1lbnQsIGFjdGl2ZSwgY2FsbGJhY2spIHtcXG4gICAgaWYgKGFjdGl2ZSkge1xcbiAgICAgIGFjdGl2ZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKTtcXG4gICAgICBjb25zdCBkcm9wZG93bkNoaWxkID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9EUk9QRE9XTl9BQ1RJVkVfQ0hJTEQsIGFjdGl2ZS5wYXJlbnROb2RlKTtcXG5cXG4gICAgICBpZiAoZHJvcGRvd25DaGlsZCkge1xcbiAgICAgICAgZHJvcGRvd25DaGlsZC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGFjdGl2ZS5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ3RhYicpIHtcXG4gICAgICAgIGFjdGl2ZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSk7XFxuXFxuICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAndGFiJykge1xcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XFxuICAgIH1cXG5cXG4gICAgcmVmbG93KGVsZW1lbnQpO1xcblxcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDEpKSB7XFxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQxKTtcXG4gICAgfVxcblxcbiAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xcblxcbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlTmFtZSA9PT0gJ0xJJykge1xcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xcbiAgICB9XFxuXFxuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX01FTlUpKSB7XFxuICAgICAgY29uc3QgZHJvcGRvd25FbGVtZW50ID0gZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX0RST1BET1dOKTtcXG5cXG4gICAgICBpZiAoZHJvcGRvd25FbGVtZW50KSB7XFxuICAgICAgICBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSwgZHJvcGRvd25FbGVtZW50KS5mb3JFYWNoKGRyb3Bkb3duID0+IGRyb3Bkb3duLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpKTtcXG4gICAgICB9XFxuXFxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcXG4gICAgfVxcblxcbiAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICBjYWxsYmFjaygpO1xcbiAgICB9XFxuICB9IC8vIFN0YXRpY1xcblxcblxcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgY29uc3QgZGF0YSA9IERhdGEuZ2V0KHRoaXMsIERBVEFfS0VZJDEpIHx8IG5ldyBUYWIodGhpcyk7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFxcXCIke2NvbmZpZ31cXFwiYCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcblxcbn1cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcblxcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gIH1cXG5cXG4gIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGNvbnN0IGRhdGEgPSBEYXRhLmdldCh0aGlzLCBEQVRBX0tFWSQxKSB8fCBuZXcgVGFiKHRoaXMpO1xcbiAgZGF0YS5zaG93KCk7XFxufSk7XFxuLyoqXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogalF1ZXJ5XFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogYWRkIC5UYWIgdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcXG4gKi9cXG5cXG5kZWZpbmVKUXVlcnlQbHVnaW4oVGFiKTtcXG5cXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIEJvb3RzdHJhcCAodjUuMC4xKTogdG9hc3QuanNcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIENvbnN0YW50c1xcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqL1xcblxcbmNvbnN0IE5BTUUgPSAndG9hc3QnO1xcbmNvbnN0IERBVEFfS0VZID0gJ2JzLnRvYXN0JztcXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YDtcXG5jb25zdCBFVkVOVF9DTElDS19ESVNNSVNTID0gYGNsaWNrLmRpc21pc3Mke0VWRU5UX0tFWX1gO1xcbmNvbnN0IEVWRU5UX01PVVNFT1ZFUiA9IGBtb3VzZW92ZXIke0VWRU5UX0tFWX1gO1xcbmNvbnN0IEVWRU5UX01PVVNFT1VUID0gYG1vdXNlb3V0JHtFVkVOVF9LRVl9YDtcXG5jb25zdCBFVkVOVF9GT0NVU0lOID0gYGZvY3VzaW4ke0VWRU5UX0tFWX1gO1xcbmNvbnN0IEVWRU5UX0ZPQ1VTT1VUID0gYGZvY3Vzb3V0JHtFVkVOVF9LRVl9YDtcXG5jb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gO1xcbmNvbnN0IEVWRU5UX0hJRERFTiA9IGBoaWRkZW4ke0VWRU5UX0tFWX1gO1xcbmNvbnN0IEVWRU5UX1NIT1cgPSBgc2hvdyR7RVZFTlRfS0VZfWA7XFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gO1xcbmNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJztcXG5jb25zdCBDTEFTU19OQU1FX0hJREUgPSAnaGlkZSc7XFxuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnO1xcbmNvbnN0IENMQVNTX05BTUVfU0hPV0lORyA9ICdzaG93aW5nJztcXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcXG4gIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxcbiAgYXV0b2hpZGU6ICdib29sZWFuJyxcXG4gIGRlbGF5OiAnbnVtYmVyJ1xcbn07XFxuY29uc3QgRGVmYXVsdCA9IHtcXG4gIGFuaW1hdGlvbjogdHJ1ZSxcXG4gIGF1dG9oaWRlOiB0cnVlLFxcbiAgZGVsYXk6IDUwMDBcXG59O1xcbmNvbnN0IFNFTEVDVE9SX0RBVEFfRElTTUlTUyA9ICdbZGF0YS1icy1kaXNtaXNzPVxcXCJ0b2FzdFxcXCJdJztcXG4vKipcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiBDbGFzcyBEZWZpbml0aW9uXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICovXFxuXFxuY2xhc3MgVG9hc3QgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xcbiAgICBzdXBlcihlbGVtZW50KTtcXG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XFxuICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xcbiAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gZmFsc2U7XFxuICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBmYWxzZTtcXG5cXG4gICAgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XFxuICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgIHJldHVybiBEZWZhdWx0VHlwZTtcXG4gIH1cXG5cXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgcmV0dXJuIERlZmF1bHQ7XFxuICB9XFxuXFxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgIHJldHVybiBOQU1FO1xcbiAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gIHNob3coKSB7XFxuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1cpO1xcblxcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XFxuXFxuICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSk7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORyk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyk7XFxuXFxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04pO1xcblxcbiAgICAgIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0hJREUpO1xcblxcbiAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1dJTkcpO1xcblxcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcXG4gIH1cXG5cXG4gIGhpZGUoKSB7XFxuICAgIGlmICghdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFKTtcXG5cXG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJREUpO1xcblxcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTik7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpO1xcblxcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcXG4gIH1cXG5cXG4gIGRpc3Bvc2UoKSB7XFxuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xcblxcbiAgICBpZiAodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpO1xcbiAgICB9XFxuXFxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcXG4gIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgY29uZmlnID0geyAuLi5EZWZhdWx0LFxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcXG4gICAgfTtcXG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSk7XFxuICAgIHJldHVybiBjb25maWc7XFxuICB9XFxuXFxuICBfbWF5YmVTY2hlZHVsZUhpZGUoKSB7XFxuICAgIGlmICghdGhpcy5fY29uZmlnLmF1dG9oaWRlKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uIHx8IHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24pIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpO1xcbiAgfVxcblxcbiAgX29uSW50ZXJhY3Rpb24oZXZlbnQsIGlzSW50ZXJhY3RpbmcpIHtcXG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XFxuICAgICAgY2FzZSAnbW91c2VvdmVyJzpcXG4gICAgICBjYXNlICdtb3VzZW91dCc6XFxuICAgICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gaXNJbnRlcmFjdGluZztcXG4gICAgICAgIGJyZWFrO1xcblxcbiAgICAgIGNhc2UgJ2ZvY3VzaW4nOlxcbiAgICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcXG4gICAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nO1xcbiAgICAgICAgYnJlYWs7XFxuICAgIH1cXG5cXG4gICAgaWYgKGlzSW50ZXJhY3RpbmcpIHtcXG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcXG5cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgbmV4dEVsZW1lbnQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xcblxcbiAgICBpZiAodGhpcy5fZWxlbWVudCA9PT0gbmV4dEVsZW1lbnQgfHwgdGhpcy5fZWxlbWVudC5jb250YWlucyhuZXh0RWxlbWVudCkpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcXG4gIH1cXG5cXG4gIF9zZXRMaXN0ZW5lcnMoKSB7XFxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTLCBTRUxFQ1RPUl9EQVRBX0RJU01JU1MsICgpID0+IHRoaXMuaGlkZSgpKTtcXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1ZFUiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpO1xcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VPVVQsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIGZhbHNlKSk7XFxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU0lOLCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCB0cnVlKSk7XFxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU09VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKTtcXG4gIH1cXG5cXG4gIF9jbGVhclRpbWVvdXQoKSB7XFxuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcXG4gICAgdGhpcy5fdGltZW91dCA9IG51bGw7XFxuICB9IC8vIFN0YXRpY1xcblxcblxcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgbGV0IGRhdGEgPSBEYXRhLmdldCh0aGlzLCBEQVRBX0tFWSk7XFxuXFxuICAgICAgY29uc3QgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZztcXG5cXG4gICAgICBpZiAoIWRhdGEpIHtcXG4gICAgICAgIGRhdGEgPSBuZXcgVG9hc3QodGhpcywgX2NvbmZpZyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcXFwiJHtjb25maWd9XFxcImApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxufVxcbi8qKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGpRdWVyeVxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqIGFkZCAuVG9hc3QgdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcXG4gKi9cXG5cXG5cXG5kZWZpbmVKUXVlcnlQbHVnaW4oVG9hc3QpO1xcblxcblxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb3RzdHJhcC5lc20uanMubWFwXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcC5lc20uanM/XCIpOy8qKiovfSwvKioqL1wiLi9ub2RlX21vZHVsZXMvZHJvcHpvbmUvZGlzdC9kcm9wem9uZS5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9kcm9wem9uZS9kaXN0L2Ryb3B6b25lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc0Ryb3B6b25lRGlzdERyb3B6b25lSnMobW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7ZXZhbChcIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XFxuXFx0aWYodHJ1ZSlcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcXG5cXHRlbHNlIHsgdmFyIGksIGE7IH1cXG59KShzZWxmLCBmdW5jdGlvbigpIHtcXG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKCkgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXFxuLyoqKioqKi8gXFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xcblxcbi8qKiovIDMwOTk6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHtcXG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XFxuICB9IHJldHVybiBpdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDYwNzc6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTEpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAoIWlzT2JqZWN0KGl0KSAmJiBpdCAhPT0gbnVsbCkge1xcbiAgICB0aHJvdyBUeXBlRXJyb3IoXFxcIkNhbid0IHNldCBcXFwiICsgU3RyaW5nKGl0KSArICcgYXMgYSBwcm90b3R5cGUnKTtcXG4gIH0gcmV0dXJuIGl0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMTIyMzpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTEyKTtcXG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XFxudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDcwKTtcXG5cXG52YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJyk7XFxudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xcblxcbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcXG5pZiAoQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkge1xcbiAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHtcXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICB2YWx1ZTogY3JlYXRlKG51bGwpXFxuICB9KTtcXG59XFxuXFxuLy8gYWRkIGEga2V5IHRvIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xcbiAgQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMTUzMDpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIGNoYXJBdCA9IF9fd2VicGFja19yZXF1aXJlX18oODcxMCkuY2hhckF0O1xcblxcbi8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcXG4gIHJldHVybiBpbmRleCArICh1bmljb2RlID8gY2hhckF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDU3ODc6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSkge1xcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcXG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgJyArIChuYW1lID8gbmFtZSArICcgJyA6ICcnKSArICdpbnZvY2F0aW9uJyk7XFxuICB9IHJldHVybiBpdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDk2NzA6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTEpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAoIWlzT2JqZWN0KGl0KSkge1xcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xcbiAgfSByZXR1cm4gaXQ7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA0MDE5Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJztcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAyNjA6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MDE5KTtcXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3ODEpO1xcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4NTQpO1xcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTExKTtcXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjU2KTtcXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ4KTtcXG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODgwKTtcXG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMjApO1xcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMzA3MCkuZjtcXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1MTgpO1xcbnZhciBzZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oNzY3NCk7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTExMik7XFxudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTcxMSk7XFxuXFxudmFyIEludDhBcnJheSA9IGdsb2JhbC5JbnQ4QXJyYXk7XFxudmFyIEludDhBcnJheVByb3RvdHlwZSA9IEludDhBcnJheSAmJiBJbnQ4QXJyYXkucHJvdG90eXBlO1xcbnZhciBVaW50OENsYW1wZWRBcnJheSA9IGdsb2JhbC5VaW50OENsYW1wZWRBcnJheTtcXG52YXIgVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUgPSBVaW50OENsYW1wZWRBcnJheSAmJiBVaW50OENsYW1wZWRBcnJheS5wcm90b3R5cGU7XFxudmFyIFR5cGVkQXJyYXkgPSBJbnQ4QXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoSW50OEFycmF5KTtcXG52YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IEludDhBcnJheVByb3RvdHlwZSAmJiBnZXRQcm90b3R5cGVPZihJbnQ4QXJyYXlQcm90b3R5cGUpO1xcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xcbnZhciBpc1Byb3RvdHlwZU9mID0gT2JqZWN0UHJvdG90eXBlLmlzUHJvdG90eXBlT2Y7XFxuXFxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XFxudmFyIFRZUEVEX0FSUkFZX1RBRyA9IHVpZCgnVFlQRURfQVJSQVlfVEFHJyk7XFxuLy8gRml4aW5nIG5hdGl2ZSB0eXBlZCBhcnJheXMgaW4gT3BlcmEgUHJlc3RvIGNyYXNoZXMgdGhlIGJyb3dzZXIsIHNlZSAjNTk1XFxudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBOQVRJVkVfQVJSQVlfQlVGRkVSICYmICEhc2V0UHJvdG90eXBlT2YgJiYgY2xhc3NvZihnbG9iYWwub3BlcmEpICE9PSAnT3BlcmEnO1xcbnZhciBUWVBFRF9BUlJBWV9UQUdfUkVRSVJFRCA9IGZhbHNlO1xcbnZhciBOQU1FO1xcblxcbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcXG4gIEludDhBcnJheTogMSxcXG4gIFVpbnQ4QXJyYXk6IDEsXFxuICBVaW50OENsYW1wZWRBcnJheTogMSxcXG4gIEludDE2QXJyYXk6IDIsXFxuICBVaW50MTZBcnJheTogMixcXG4gIEludDMyQXJyYXk6IDQsXFxuICBVaW50MzJBcnJheTogNCxcXG4gIEZsb2F0MzJBcnJheTogNCxcXG4gIEZsb2F0NjRBcnJheTogOFxcbn07XFxuXFxudmFyIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcXG4gIEJpZ0ludDY0QXJyYXk6IDgsXFxuICBCaWdVaW50NjRBcnJheTogOFxcbn07XFxuXFxudmFyIGlzVmlldyA9IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBmYWxzZTtcXG4gIHZhciBrbGFzcyA9IGNsYXNzb2YoaXQpO1xcbiAgcmV0dXJuIGtsYXNzID09PSAnRGF0YVZpZXcnXFxuICAgIHx8IGhhcyhUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpXFxuICAgIHx8IGhhcyhCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKTtcXG59O1xcblxcbnZhciBpc1R5cGVkQXJyYXkgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gZmFsc2U7XFxuICB2YXIga2xhc3MgPSBjbGFzc29mKGl0KTtcXG4gIHJldHVybiBoYXMoVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKVxcbiAgICB8fCBoYXMoQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcyk7XFxufTtcXG5cXG52YXIgYVR5cGVkQXJyYXkgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIGlmIChpc1R5cGVkQXJyYXkoaXQpKSByZXR1cm4gaXQ7XFxuICB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgYSB0eXBlZCBhcnJheScpO1xcbn07XFxuXFxudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoQykge1xcbiAgaWYgKHNldFByb3RvdHlwZU9mKSB7XFxuICAgIGlmIChpc1Byb3RvdHlwZU9mLmNhbGwoVHlwZWRBcnJheSwgQykpIHJldHVybiBDO1xcbiAgfSBlbHNlIGZvciAodmFyIEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSBpZiAoaGFzKFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBOQU1FKSkge1xcbiAgICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0FSUkFZXTtcXG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiAoQyA9PT0gVHlwZWRBcnJheUNvbnN0cnVjdG9yIHx8IGlzUHJvdG90eXBlT2YuY2FsbChUeXBlZEFycmF5Q29uc3RydWN0b3IsIEMpKSkge1xcbiAgICAgIHJldHVybiBDO1xcbiAgICB9XFxuICB9IHRocm93IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yJyk7XFxufTtcXG5cXG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IGZ1bmN0aW9uIChLRVksIHByb3BlcnR5LCBmb3JjZWQpIHtcXG4gIGlmICghREVTQ1JJUFRPUlMpIHJldHVybjtcXG4gIGlmIChmb3JjZWQpIGZvciAodmFyIEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XFxuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWxbQVJSQVldO1xcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIGhhcyhUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlLCBLRVkpKSB7XFxuICAgICAgZGVsZXRlIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXTtcXG4gICAgfVxcbiAgfVxcbiAgaWYgKCFUeXBlZEFycmF5UHJvdG90eXBlW0tFWV0gfHwgZm9yY2VkKSB7XFxuICAgIHJlZGVmaW5lKFR5cGVkQXJyYXlQcm90b3R5cGUsIEtFWSwgZm9yY2VkID8gcHJvcGVydHlcXG4gICAgICA6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgJiYgSW50OEFycmF5UHJvdG90eXBlW0tFWV0gfHwgcHJvcGVydHkpO1xcbiAgfVxcbn07XFxuXFxudmFyIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QgPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkKSB7XFxuICB2YXIgQVJSQVksIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcXG4gIGlmICghREVTQ1JJUFRPUlMpIHJldHVybjtcXG4gIGlmIChzZXRQcm90b3R5cGVPZikge1xcbiAgICBpZiAoZm9yY2VkKSBmb3IgKEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XFxuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0FSUkFZXTtcXG4gICAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIGhhcyhUeXBlZEFycmF5Q29uc3RydWN0b3IsIEtFWSkpIHtcXG4gICAgICAgIGRlbGV0ZSBUeXBlZEFycmF5Q29uc3RydWN0b3JbS0VZXTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKCFUeXBlZEFycmF5W0tFWV0gfHwgZm9yY2VkKSB7XFxuICAgICAgLy8gVjggfiBDaHJvbWUgNDktNTAgYCVUeXBlZEFycmF5JWAgbWV0aG9kcyBhcmUgbm9uLXdyaXRhYmxlIG5vbi1jb25maWd1cmFibGVcXG4gICAgICB0cnkge1xcbiAgICAgICAgcmV0dXJuIHJlZGVmaW5lKFR5cGVkQXJyYXksIEtFWSwgZm9yY2VkID8gcHJvcGVydHkgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIEludDhBcnJheVtLRVldIHx8IHByb3BlcnR5KTtcXG4gICAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxuICAgIH0gZWxzZSByZXR1cm47XFxuICB9XFxuICBmb3IgKEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XFxuICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbFtBUlJBWV07XFxuICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgKCFUeXBlZEFycmF5Q29uc3RydWN0b3JbS0VZXSB8fCBmb3JjZWQpKSB7XFxuICAgICAgcmVkZWZpbmUoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVksIHByb3BlcnR5KTtcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XFxuICBpZiAoIWdsb2JhbFtOQU1FXSkgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IGZhbHNlO1xcbn1cXG5cXG4vLyBXZWJLaXQgYnVnIC0gdHlwZWQgYXJyYXlzIGNvbnN0cnVjdG9ycyBwcm90b3R5cGUgaXMgT2JqZWN0LnByb3RvdHlwZVxcbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB8fCB0eXBlb2YgVHlwZWRBcnJheSAhPSAnZnVuY3Rpb24nIHx8IFR5cGVkQXJyYXkgPT09IEZ1bmN0aW9uLnByb3RvdHlwZSkge1xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdyAtLSBzYWZlXFxuICBUeXBlZEFycmF5ID0gZnVuY3Rpb24gVHlwZWRBcnJheSgpIHtcXG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xcbiAgfTtcXG4gIGlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcXG4gICAgaWYgKGdsb2JhbFtOQU1FXSkgc2V0UHJvdG90eXBlT2YoZ2xvYmFsW05BTUVdLCBUeXBlZEFycmF5KTtcXG4gIH1cXG59XFxuXFxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIHx8ICFUeXBlZEFycmF5UHJvdG90eXBlIHx8IFR5cGVkQXJyYXlQcm90b3R5cGUgPT09IE9iamVjdFByb3RvdHlwZSkge1xcbiAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkucHJvdG90eXBlO1xcbiAgaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xcbiAgICBpZiAoZ2xvYmFsW05BTUVdKSBzZXRQcm90b3R5cGVPZihnbG9iYWxbTkFNRV0ucHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlKTtcXG4gIH1cXG59XFxuXFxuLy8gV2ViS2l0IGJ1ZyAtIG9uZSBtb3JlIG9iamVjdCBpbiBVaW50OENsYW1wZWRBcnJheSBwcm90b3R5cGUgY2hhaW5cXG5pZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBnZXRQcm90b3R5cGVPZihVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSkgIT09IFR5cGVkQXJyYXlQcm90b3R5cGUpIHtcXG4gIHNldFByb3RvdHlwZU9mKFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlKTtcXG59XFxuXFxuaWYgKERFU0NSSVBUT1JTICYmICFoYXMoVHlwZWRBcnJheVByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcXG4gIFRZUEVEX0FSUkFZX1RBR19SRVFJUkVEID0gdHJ1ZTtcXG4gIGRlZmluZVByb3BlcnR5KFR5cGVkQXJyYXlQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBpc09iamVjdCh0aGlzKSA/IHRoaXNbVFlQRURfQVJSQVlfVEFHXSA6IHVuZGVmaW5lZDtcXG4gIH0gfSk7XFxuICBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIGlmIChnbG9iYWxbTkFNRV0pIHtcXG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGdsb2JhbFtOQU1FXSwgVFlQRURfQVJSQVlfVEFHLCBOQU1FKTtcXG4gIH1cXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTLFxcbiAgVFlQRURfQVJSQVlfVEFHOiBUWVBFRF9BUlJBWV9UQUdfUkVRSVJFRCAmJiBUWVBFRF9BUlJBWV9UQUcsXFxuICBhVHlwZWRBcnJheTogYVR5cGVkQXJyYXksXFxuICBhVHlwZWRBcnJheUNvbnN0cnVjdG9yOiBhVHlwZWRBcnJheUNvbnN0cnVjdG9yLFxcbiAgZXhwb3J0VHlwZWRBcnJheU1ldGhvZDogZXhwb3J0VHlwZWRBcnJheU1ldGhvZCxcXG4gIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2Q6IGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QsXFxuICBpc1ZpZXc6IGlzVmlldyxcXG4gIGlzVHlwZWRBcnJheTogaXNUeXBlZEFycmF5LFxcbiAgVHlwZWRBcnJheTogVHlwZWRBcnJheSxcXG4gIFR5cGVkQXJyYXlQcm90b3R5cGU6IFR5cGVkQXJyYXlQcm90b3R5cGVcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDMzMzE6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4NTQpO1xcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oOTc4MSk7XFxudmFyIE5BVElWRV9BUlJBWV9CVUZGRVIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwMTkpO1xcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4ODApO1xcbnZhciByZWRlZmluZUFsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjI0OCk7XFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MjkzKTtcXG52YXIgYW5JbnN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTc4Nyk7XFxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTk1OCk7XFxudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDY2KTtcXG52YXIgdG9JbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oNzA2Nyk7XFxudmFyIElFRUU3NTQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNzkpO1xcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oOTUxOCk7XFxudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Njc0KTtcXG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IF9fd2VicGFja19yZXF1aXJlX18oODAwNikuZjtcXG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwNzApLmY7XFxudmFyIGFycmF5RmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTI4NSk7XFxudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDAzKTtcXG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTkwOSk7XFxuXFxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xcbnZhciBEQVRBX1ZJRVcgPSAnRGF0YVZpZXcnO1xcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcXG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCc7XFxudmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4JztcXG52YXIgTmF0aXZlQXJyYXlCdWZmZXIgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXTtcXG52YXIgJEFycmF5QnVmZmVyID0gTmF0aXZlQXJyYXlCdWZmZXI7XFxudmFyICREYXRhVmlldyA9IGdsb2JhbFtEQVRBX1ZJRVddO1xcbnZhciAkRGF0YVZpZXdQcm90b3R5cGUgPSAkRGF0YVZpZXcgJiYgJERhdGFWaWV3W1BST1RPVFlQRV07XFxudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XFxudmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcXG5cXG52YXIgcGFja0lFRUU3NTQgPSBJRUVFNzU0LnBhY2s7XFxudmFyIHVucGFja0lFRUU3NTQgPSBJRUVFNzU0LnVucGFjaztcXG5cXG52YXIgcGFja0ludDggPSBmdW5jdGlvbiAobnVtYmVyKSB7XFxuICByZXR1cm4gW251bWJlciAmIDB4RkZdO1xcbn07XFxuXFxudmFyIHBhY2tJbnQxNiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcXG4gIHJldHVybiBbbnVtYmVyICYgMHhGRiwgbnVtYmVyID4+IDggJiAweEZGXTtcXG59O1xcblxcbnZhciBwYWNrSW50MzIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XFxuICByZXR1cm4gW251bWJlciAmIDB4RkYsIG51bWJlciA+PiA4ICYgMHhGRiwgbnVtYmVyID4+IDE2ICYgMHhGRiwgbnVtYmVyID4+IDI0ICYgMHhGRl07XFxufTtcXG5cXG52YXIgdW5wYWNrSW50MzIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XFxuICByZXR1cm4gYnVmZmVyWzNdIDw8IDI0IHwgYnVmZmVyWzJdIDw8IDE2IHwgYnVmZmVyWzFdIDw8IDggfCBidWZmZXJbMF07XFxufTtcXG5cXG52YXIgcGFja0Zsb2F0MzIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XFxuICByZXR1cm4gcGFja0lFRUU3NTQobnVtYmVyLCAyMywgNCk7XFxufTtcXG5cXG52YXIgcGFja0Zsb2F0NjQgPSBmdW5jdGlvbiAobnVtYmVyKSB7XFxuICByZXR1cm4gcGFja0lFRUU3NTQobnVtYmVyLCA1MiwgOCk7XFxufTtcXG5cXG52YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBrZXkpIHtcXG4gIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yW1BST1RPVFlQRV0sIGtleSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcylba2V5XTsgfSB9KTtcXG59O1xcblxcbnZhciBnZXQgPSBmdW5jdGlvbiAodmlldywgY291bnQsIGluZGV4LCBpc0xpdHRsZUVuZGlhbikge1xcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChpbmRleCk7XFxuICB2YXIgc3RvcmUgPSBnZXRJbnRlcm5hbFN0YXRlKHZpZXcpO1xcbiAgaWYgKGludEluZGV4ICsgY291bnQgPiBzdG9yZS5ieXRlTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcXG4gIHZhciBieXRlcyA9IGdldEludGVybmFsU3RhdGUoc3RvcmUuYnVmZmVyKS5ieXRlcztcXG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgc3RvcmUuYnl0ZU9mZnNldDtcXG4gIHZhciBwYWNrID0gYnl0ZXMuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xcbn07XFxuXFxudmFyIHNldCA9IGZ1bmN0aW9uICh2aWV3LCBjb3VudCwgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChpbmRleCk7XFxuICB2YXIgc3RvcmUgPSBnZXRJbnRlcm5hbFN0YXRlKHZpZXcpO1xcbiAgaWYgKGludEluZGV4ICsgY291bnQgPiBzdG9yZS5ieXRlTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcXG4gIHZhciBieXRlcyA9IGdldEludGVybmFsU3RhdGUoc3RvcmUuYnVmZmVyKS5ieXRlcztcXG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgc3RvcmUuYnl0ZU9mZnNldDtcXG4gIHZhciBwYWNrID0gY29udmVyc2lvbigrdmFsdWUpO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSBieXRlc1tzdGFydCArIGldID0gcGFja1tpc0xpdHRsZUVuZGlhbiA/IGkgOiBjb3VudCAtIGkgLSAxXTtcXG59O1xcblxcbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUikge1xcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XFxuICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRvSW5kZXgobGVuZ3RoKTtcXG4gICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XFxuICAgICAgYnl0ZXM6IGFycmF5RmlsbC5jYWxsKG5ldyBBcnJheShieXRlTGVuZ3RoKSwgMCksXFxuICAgICAgYnl0ZUxlbmd0aDogYnl0ZUxlbmd0aFxcbiAgICB9KTtcXG4gICAgaWYgKCFERVNDUklQVE9SUykgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcXG4gIH07XFxuXFxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcXG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XFxuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XFxuICAgIHZhciBidWZmZXJMZW5ndGggPSBnZXRJbnRlcm5hbFN0YXRlKGJ1ZmZlcikuYnl0ZUxlbmd0aDtcXG4gICAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihieXRlT2Zmc2V0KTtcXG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQnKTtcXG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xcbiAgICBpZiAob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xcbiAgICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcXG4gICAgICBidWZmZXI6IGJ1ZmZlcixcXG4gICAgICBieXRlTGVuZ3RoOiBieXRlTGVuZ3RoLFxcbiAgICAgIGJ5dGVPZmZzZXQ6IG9mZnNldFxcbiAgICB9KTtcXG4gICAgaWYgKCFERVNDUklQVE9SUykge1xcbiAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xcbiAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XFxuICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gb2Zmc2V0O1xcbiAgICB9XFxuICB9O1xcblxcbiAgaWYgKERFU0NSSVBUT1JTKSB7XFxuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsICdieXRlTGVuZ3RoJyk7XFxuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsICdidWZmZXInKTtcXG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgJ2J5dGVMZW5ndGgnKTtcXG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgJ2J5dGVPZmZzZXQnKTtcXG4gIH1cXG5cXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XFxuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCkge1xcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XFxuICAgIH0sXFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KSB7XFxuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcXG4gICAgfSxcXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcXG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcXG4gICAgfSxcXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XFxuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcXG4gICAgfSxcXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcXG4gICAgICByZXR1cm4gdW5wYWNrSW50MzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSk7XFxuICAgIH0sXFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcXG4gICAgICByZXR1cm4gdW5wYWNrSW50MzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSkgPj4+IDA7XFxuICAgIH0sXFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCksIDIzKTtcXG4gICAgfSxcXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XFxuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSwgNTIpO1xcbiAgICB9LFxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XFxuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJbnQ4LCB2YWx1ZSk7XFxuICAgIH0sXFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSW50OCwgdmFsdWUpO1xcbiAgICB9LFxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcXG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0ludDE2LCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xcbiAgICB9LFxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSW50MTYsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XFxuICAgIH0sXFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSW50MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XFxuICAgIH0sXFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XFxuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJbnQzMiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcXG4gICAgfSxcXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRmxvYXQzMiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcXG4gICAgfSxcXG4gICAgc2V0RmxvYXQ2NDogZnVuY3Rpb24gc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRmxvYXQ2NCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcXG4gICAgfVxcbiAgfSk7XFxufSBlbHNlIHtcXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xcbiAgaWYgKCFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAgIE5hdGl2ZUFycmF5QnVmZmVyKDEpO1xcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKC0xKTtcXG4gIH0pIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gICAgbmV3IE5hdGl2ZUFycmF5QnVmZmVyKCk7XFxuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcigxLjUpO1xcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoTmFOKTtcXG4gICAgcmV0dXJuIE5hdGl2ZUFycmF5QnVmZmVyLm5hbWUgIT0gQVJSQVlfQlVGRkVSO1xcbiAgfSkpIHtcXG4gIC8qIGVzbGludC1lbmFibGUgbm8tbmV3IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXFxuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xcbiAgICAgIGFuSW5zdGFuY2UodGhpcywgJEFycmF5QnVmZmVyKTtcXG4gICAgICByZXR1cm4gbmV3IE5hdGl2ZUFycmF5QnVmZmVyKHRvSW5kZXgobGVuZ3RoKSk7XFxuICAgIH07XFxuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvdHlwZSA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gTmF0aXZlQXJyYXlCdWZmZXJbUFJPVE9UWVBFXTtcXG4gICAgZm9yICh2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoTmF0aXZlQXJyYXlCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7KSB7XFxuICAgICAgaWYgKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSkge1xcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KCRBcnJheUJ1ZmZlciwga2V5LCBOYXRpdmVBcnJheUJ1ZmZlcltrZXldKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgQXJyYXlCdWZmZXJQcm90b3R5cGUuY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XFxuICB9XFxuXFxuICAvLyBXZWJLaXQgYnVnIC0gdGhlIHNhbWUgcGFyZW50IHByb3RvdHlwZSBmb3IgdHlwZWQgYXJyYXlzIGFuZCBkYXRhIHZpZXdcXG4gIGlmIChzZXRQcm90b3R5cGVPZiAmJiBnZXRQcm90b3R5cGVPZigkRGF0YVZpZXdQcm90b3R5cGUpICE9PSBPYmplY3RQcm90b3R5cGUpIHtcXG4gICAgc2V0UHJvdG90eXBlT2YoJERhdGFWaWV3UHJvdG90eXBlLCBPYmplY3RQcm90b3R5cGUpO1xcbiAgfVxcblxcbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXFxuICB2YXIgdGVzdFZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xcbiAgdmFyIG5hdGl2ZVNldEludDggPSAkRGF0YVZpZXdQcm90b3R5cGUuc2V0SW50ODtcXG4gIHRlc3RWaWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XFxuICB0ZXN0Vmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xcbiAgaWYgKHRlc3RWaWV3LmdldEludDgoMCkgfHwgIXRlc3RWaWV3LmdldEludDgoMSkpIHJlZGVmaW5lQWxsKCREYXRhVmlld1Byb3RvdHlwZSwge1xcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XFxuICAgICAgbmF0aXZlU2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcXG4gICAgfSxcXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XFxuICAgICAgbmF0aXZlU2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcXG4gICAgfVxcbiAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XFxufVxcblxcbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcXG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyLFxcbiAgRGF0YVZpZXc6ICREYXRhVmlld1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMTA0ODpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTA4KTtcXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDAwKTtcXG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0NjYpO1xcblxcbnZhciBtaW4gPSBNYXRoLm1pbjtcXG5cXG4vLyBgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW5gIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvcHl3aXRoaW5cXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcXG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XFxuICB2YXIgbGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcXG4gIHZhciBmcm9tID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xcbiAgdmFyIGNvdW50ID0gbWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbikpIC0gZnJvbSwgbGVuIC0gdG8pO1xcbiAgdmFyIGluYyA9IDE7XFxuICBpZiAoZnJvbSA8IHRvICYmIHRvIDwgZnJvbSArIGNvdW50KSB7XFxuICAgIGluYyA9IC0xO1xcbiAgICBmcm9tICs9IGNvdW50IC0gMTtcXG4gICAgdG8gKz0gY291bnQgLSAxO1xcbiAgfVxcbiAgd2hpbGUgKGNvdW50LS0gPiAwKSB7XFxuICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcXG4gICAgZWxzZSBkZWxldGUgT1t0b107XFxuICAgIHRvICs9IGluYztcXG4gICAgZnJvbSArPSBpbmM7XFxuICB9IHJldHVybiBPO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMTI4NTpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTA4KTtcXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDAwKTtcXG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0NjYpO1xcblxcbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsbFxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLykge1xcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcXG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XFxuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xcbiAgdmFyIGVuZCA9IGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XFxuICB2YXIgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0Fic29sdXRlSW5kZXgoZW5kLCBsZW5ndGgpO1xcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XFxuICByZXR1cm4gTztcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDg1MzM6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciAkZm9yRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMjA5MikuZm9yRWFjaDtcXG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTM0MSk7XFxuXFxudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdmb3JFYWNoJyk7XFxuXFxuLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QgaW1wbGVtZW50YXRpb25cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXFxubW9kdWxlLmV4cG9ydHMgPSAhU1RSSUNUX01FVEhPRCA/IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcXG4gIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XFxufSA6IFtdLmZvckVhY2g7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gODQ1NzpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5NzQpO1xcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzkwOCk7XFxudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0MTEpO1xcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NTkpO1xcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNzQ2Nik7XFxudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTM1KTtcXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNDYpO1xcblxcbi8vIGBBcnJheS5mcm9tYCBtZXRob2QgaW1wbGVtZW50YXRpb25cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcXG4gIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcXG4gIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcXG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xcbiAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcXG4gIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcXG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pO1xcbiAgdmFyIGluZGV4ID0gMDtcXG4gIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3IsIG5leHQsIHZhbHVlO1xcbiAgaWYgKG1hcHBpbmcpIG1hcGZuID0gYmluZChtYXBmbiwgYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XFxuICAvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBpdGVyYWJsZSBvciBpdCdzIGFuIGFycmF5IHdpdGggdGhlIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2UgYSBzaW1wbGUgY2FzZVxcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkpIHtcXG4gICAgaXRlcmF0b3IgPSBpdGVyYXRvck1ldGhvZC5jYWxsKE8pO1xcbiAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcXG4gICAgcmVzdWx0ID0gbmV3IEMoKTtcXG4gICAgZm9yICg7IShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZTsgaW5kZXgrKykge1xcbiAgICAgIHZhbHVlID0gbWFwcGluZyA/IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWU7XFxuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XFxuICAgIHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7XFxuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XFxuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcXG4gICAgfVxcbiAgfVxcbiAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDEzMTg6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTY1Nik7XFxudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDY2KTtcXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDAwKTtcXG5cXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxcbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcXG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoJHRoaXMpO1xcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xcbiAgICB2YXIgdmFsdWU7XFxuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcXG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcXG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xcbiAgfTtcXG59O1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXFxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAyMDkyOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTc0KTtcXG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODM2MSk7XFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTA4KTtcXG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0NjYpO1xcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0MTcpO1xcblxcbnZhciBwdXNoID0gW10ucHVzaDtcXG5cXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXgsIGZpbHRlck91dCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXFxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XFxuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcXG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XFxuICB2YXIgSVNfRklMVEVSX09VVCA9IFRZUEUgPT0gNztcXG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcXG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XFxuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcXG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xcbiAgICB2YXIgaW5kZXggPSAwO1xcbiAgICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlO1xcbiAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSIHx8IElTX0ZJTFRFUl9PVVQgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xcbiAgICB2YXIgdmFsdWUsIHJlc3VsdDtcXG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XFxuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcXG4gICAgICByZXN1bHQgPSBib3VuZEZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgTyk7XFxuICAgICAgaWYgKFRZUEUpIHtcXG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxcbiAgICAgICAgZWxzZSBpZiAocmVzdWx0KSBzd2l0Y2ggKFRZUEUpIHtcXG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgIC8vIHNvbWVcXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxcbiAgICAgICAgICBjYXNlIDI6IHB1c2guY2FsbCh0YXJnZXQsIHZhbHVlKTsgLy8gZmlsdGVyXFxuICAgICAgICB9IGVsc2Ugc3dpdGNoIChUWVBFKSB7XFxuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAvLyBldmVyeVxcbiAgICAgICAgICBjYXNlIDc6IHB1c2guY2FsbCh0YXJnZXQsIHZhbHVlKTsgLy8gZmlsdGVyT3V0XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XFxuICB9O1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxcbiAgZm9yRWFjaDogY3JlYXRlTWV0aG9kKDApLFxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXFxuICBtYXA6IGNyZWF0ZU1ldGhvZCgxKSxcXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxcbiAgZmlsdGVyOiBjcmVhdGVNZXRob2QoMiksXFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxcbiAgc29tZTogY3JlYXRlTWV0aG9kKDMpLFxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxcbiAgZXZlcnk6IGNyZWF0ZU1ldGhvZCg0KSxcXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXFxuICBmaW5kOiBjcmVhdGVNZXRob2QoNSksXFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleGAgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcXG4gIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kKDYpLFxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJPdXRgIG1ldGhvZFxcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXktZmlsdGVyaW5nXFxuICBmaWx0ZXJPdXQ6IGNyZWF0ZU1ldGhvZCg3KVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNjU4MzpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTY1Nik7XFxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTk1OCk7XFxudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDY2KTtcXG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTM0MSk7XFxuXFxudmFyIG1pbiA9IE1hdGgubWluO1xcbnZhciBuYXRpdmVMYXN0SW5kZXhPZiA9IFtdLmxhc3RJbmRleE9mO1xcbnZhciBORUdBVElWRV9aRVJPID0gISFuYXRpdmVMYXN0SW5kZXhPZiAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XFxudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdsYXN0SW5kZXhPZicpO1xcbnZhciBGT1JDRUQgPSBORUdBVElWRV9aRVJPIHx8ICFTVFJJQ1RfTUVUSE9EO1xcblxcbi8vIGBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2ZgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmxhc3RpbmRleG9mXFxubW9kdWxlLmV4cG9ydHMgPSBGT1JDRUQgPyBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gQFsqLTFdICovKSB7XFxuICAvLyBjb252ZXJ0IC0wIHRvICswXFxuICBpZiAoTkVHQVRJVkVfWkVSTykgcmV0dXJuIG5hdGl2ZUxhc3RJbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcXG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KHRoaXMpO1xcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcXG4gIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGluZGV4ID0gbWluKGluZGV4LCB0b0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XFxuICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IGxlbmd0aCArIGluZGV4O1xcbiAgZm9yICg7aW5kZXggPj0gMDsgaW5kZXgtLSkgaWYgKGluZGV4IGluIE8gJiYgT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpIHJldHVybiBpbmRleCB8fCAwO1xcbiAgcmV0dXJuIC0xO1xcbn0gOiBuYXRpdmVMYXN0SW5kZXhPZjtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAxMTk0Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNzI5Myk7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTExMik7XFxudmFyIFY4X1ZFUlNJT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczOTIpO1xcblxcbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcXG4gIC8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzdcXG4gIHJldHVybiBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBhcnJheSA9IFtdO1xcbiAgICB2YXIgY29uc3RydWN0b3IgPSBhcnJheS5jb25zdHJ1Y3RvciA9IHt9O1xcbiAgICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4geyBmb286IDEgfTtcXG4gICAgfTtcXG4gICAgcmV0dXJuIGFycmF5W01FVEhPRF9OQU1FXShCb29sZWFuKS5mb28gIT09IDE7XFxuICB9KTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDkzNDE6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNzI5Myk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIGFyZ3VtZW50KSB7XFxuICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbCxuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXFxuICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgdGhyb3cgMTsgfSwgMSk7XFxuICB9KTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDM2NzE6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzA5OSk7XFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTA4KTtcXG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODM2MSk7XFxudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDY2KTtcXG5cXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgcmVkdWNlLCByZWR1Y2VSaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXFxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19SSUdIVCkge1xcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBjYWxsYmFja2ZuLCBhcmd1bWVudHNMZW5ndGgsIG1lbW8pIHtcXG4gICAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XFxuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XFxuICAgIHZhciBpbmRleCA9IElTX1JJR0hUID8gbGVuZ3RoIC0gMSA6IDA7XFxuICAgIHZhciBpID0gSVNfUklHSFQgPyAtMSA6IDE7XFxuICAgIGlmIChhcmd1bWVudHNMZW5ndGggPCAyKSB3aGlsZSAodHJ1ZSkge1xcbiAgICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XFxuICAgICAgICBtZW1vID0gc2VsZltpbmRleF07XFxuICAgICAgICBpbmRleCArPSBpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICAgIGluZGV4ICs9IGk7XFxuICAgICAgaWYgKElTX1JJR0hUID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XFxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgZm9yICg7SVNfUklHSFQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XFxuICAgICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcXG4gICAgfVxcbiAgICByZXR1cm4gbWVtbztcXG4gIH07XFxufTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxcbiAgbGVmdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcXG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHRgIG1ldGhvZFxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlcmlnaHRcXG4gIHJpZ2h0OiBjcmVhdGVNZXRob2QodHJ1ZSlcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDU0MTc6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTEpO1xcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTU3KTtcXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTEyKTtcXG5cXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xcblxcbi8vIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XFxuICB2YXIgQztcXG4gIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XFxuICAgIEMgPSBvcmlnaW5hbEFycmF5LmNvbnN0cnVjdG9yO1xcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xcbiAgICBlbHNlIGlmIChpc09iamVjdChDKSkge1xcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xcbiAgICB9XFxuICB9IHJldHVybiBuZXcgKEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQykobGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aCk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAzNDExOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTY3MCk7XFxudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyMTIpO1xcblxcbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XFxuICB0cnkge1xcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcXG4gIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xcbiAgICB0aHJvdyBlcnJvcjtcXG4gIH1cXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDcwNzI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTExMik7XFxuXFxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcXG5cXG50cnkge1xcbiAgdmFyIGNhbGxlZCA9IDA7XFxuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xcbiAgICB9LFxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xcbiAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XFxuICAgIH1cXG4gIH07XFxuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xcbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XFxufSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xcbiAgaWYgKCFTS0lQX0NMT1NJTkcgJiYgIVNBRkVfQ0xPU0lORykgcmV0dXJuIGZhbHNlO1xcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XFxuICB0cnkge1xcbiAgICB2YXIgb2JqZWN0ID0ge307XFxuICAgIG9iamVjdFtJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfTtcXG4gICAgZXhlYyhvYmplY3QpO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxcbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNDMyNjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XFxuXFxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA2NDg6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd2VicGFja19yZXF1aXJlX18oMTY5NCk7XFxudmFyIGNsYXNzb2ZSYXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzMjYpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxMTIpO1xcblxcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xcbi8vIEVTMyB3cm9uZyBoZXJlXFxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XFxuXFxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiBpdFtrZXldO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxcbn07XFxuXFxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXFxuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXFxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXFxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDk5MjA6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjY1Nik7XFxudmFyIG93bktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4ODcpO1xcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMzYpO1xcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzA3MCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcXG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcXG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcXG4gICAgaWYgKCFoYXModGFyZ2V0LCBrZXkpKSBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XFxuICB9XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA4NTQ0Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNzI5Myk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxcbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNDk5NDpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzgzKS5JdGVyYXRvclByb3RvdHlwZTtcXG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XFxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oOTExNCk7XFxudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDAzKTtcXG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDk3KTtcXG5cXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xcbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XFxuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XFxuICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSwgdHJ1ZSk7XFxuICBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA4ODgwOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oOTc4MSk7XFxudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDcwKTtcXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTE0KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XFxuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xcbiAgcmV0dXJuIG9iamVjdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDkxMTQ6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcXG4gIHJldHVybiB7XFxuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXFxuICAgIHZhbHVlOiB2YWx1ZVxcbiAgfTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDYxMzU6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzU5Myk7XFxudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDcwKTtcXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTE0KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcXG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKGtleSk7XFxuICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCB2YWx1ZSkpO1xcbiAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA2NTQ6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTA5KTtcXG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDk5NCk7XFxudmFyIGdldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTE4KTtcXG52YXIgc2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NzQpO1xcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oODAwMyk7XFxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oODg4MCk7XFxudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzIwKTtcXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTEyKTtcXG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkxMyk7XFxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNzQ5Nyk7XFxudmFyIEl0ZXJhdG9yc0NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzODMpO1xcblxcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XFxudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XFxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xcbnZhciBLRVlTID0gJ2tleXMnO1xcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcXG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcXG5cXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XFxuICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xcblxcbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XFxuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcXG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcXG4gICAgc3dpdGNoIChLSU5EKSB7XFxuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XFxuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xcbiAgICB9IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcXG4gIH07XFxuXFxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcXG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcXG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcXG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXVxcbiAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXFxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XFxuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xcblxcbiAgLy8gZml4IG5hdGl2ZVxcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XFxuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcXG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XFxuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XFxuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcXG4gICAgICAgICAgc2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXFxuICAgICAgc2V0VG9TdHJpbmdUYWcoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlLCB0cnVlKTtcXG4gICAgICBpZiAoSVNfUFVSRSkgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxcbiAgaWYgKERFRkFVTFQgPT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xcbiAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xcbiAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuYXRpdmVJdGVyYXRvci5jYWxsKHRoaXMpOyB9O1xcbiAgfVxcblxcbiAgLy8gZGVmaW5lIGl0ZXJhdG9yXFxuICBpZiAoKCFJU19QVVJFIHx8IEZPUkNFRCkgJiYgSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcXG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yKTtcXG4gIH1cXG4gIEl0ZXJhdG9yc1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcXG5cXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcXG4gIGlmIChERUZBVUxUKSB7XFxuICAgIG1ldGhvZHMgPSB7XFxuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXFxuICAgIH07XFxuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcXG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XFxuICAgICAgICByZWRlZmluZShJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlICQoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xcbiAgfVxcblxcbiAgcmV0dXJuIG1ldGhvZHM7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA5NzgxOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNzI5Myk7XFxuXFxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDMxNzpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODU0KTtcXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMSk7XFxuXFxudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxcbnZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBFWElTVFMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gODMyNDpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XFxuXFxuLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXFxuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgQ1NTUnVsZUxpc3Q6IDAsXFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXFxuICBET01SZWN0TGlzdDogMCxcXG4gIERPTVN0cmluZ0xpc3Q6IDAsXFxuICBET01Ub2tlbkxpc3Q6IDEsXFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcXG4gIEZpbGVMaXN0OiAwLFxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXFxuICBIVE1MQ29sbGVjdGlvbjogMCxcXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxcbiAgTWVkaWFMaXN0OiAwLFxcbiAgTWltZVR5cGVBcnJheTogMCxcXG4gIE5hbWVkTm9kZU1hcDogMCxcXG4gIE5vZGVMaXN0OiAxLFxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcXG4gIFBsdWdpbjogMCxcXG4gIFBsdWdpbkFycmF5OiAwLFxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcXG4gIFNWR051bWJlckxpc3Q6IDAsXFxuICBTVkdQYXRoU2VnTGlzdDogMCxcXG4gIFNWR1BvaW50TGlzdDogMCxcXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcXG4gIFRleHRUcmFja0xpc3Q6IDAsXFxuICBUb3VjaExpc3Q6IDBcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDgxMTM6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwMDUpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDczOTI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzg1NCk7XFxudmFyIHVzZXJBZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oODExMyk7XFxuXFxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcXG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnM7XFxudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XFxudmFyIG1hdGNoLCB2ZXJzaW9uO1xcblxcbmlmICh2OCkge1xcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xcbiAgdmVyc2lvbiA9IG1hdGNoWzBdICsgbWF0Y2hbMV07XFxufSBlbHNlIGlmICh1c2VyQWdlbnQpIHtcXG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFxcXC8oXFxcXGQrKS8pO1xcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFxcXC8oXFxcXGQrKS8pO1xcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSBtYXRjaFsxXTtcXG4gIH1cXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB2ZXJzaW9uICYmICt2ZXJzaW9uO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDc0ODpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XFxuXFxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXFxubW9kdWxlLmV4cG9ydHMgPSBbXFxuICAnY29uc3RydWN0b3InLFxcbiAgJ2hhc093blByb3BlcnR5JyxcXG4gICdpc1Byb3RvdHlwZU9mJyxcXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXFxuICAndG9Mb2NhbGVTdHJpbmcnLFxcbiAgJ3RvU3RyaW5nJyxcXG4gICd2YWx1ZU9mJ1xcbl07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMjEwOTpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODU0KTtcXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjM2KS5mO1xcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4ODApO1xcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMyMCk7XFxudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUwNSk7XFxudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MjApO1xcbnZhciBpc0ZvcmNlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNDcwNSk7XFxuXFxuLypcXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XFxuICBvcHRpb25zLmdsb2JhbCAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XFxuICBvcHRpb25zLnN0YXQgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcXG4gIG9wdGlvbnMucmVhbCAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxcbiAgb3B0aW9ucy5mb3JjZWQgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxcbiAgb3B0aW9ucy53cmFwICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxcbiAgb3B0aW9ucy51bnNhZmUgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxcbiAgb3B0aW9ucy5ub1RhcmdldEdldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcXG4qL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcXG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XFxuICBpZiAoR0xPQkFMKSB7XFxuICAgIHRhcmdldCA9IGdsb2JhbDtcXG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XFxuICAgIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcXG4gIH0gZWxzZSB7XFxuICAgIHRhcmdldCA9IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xcbiAgfVxcbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XFxuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XFxuICAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XFxuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XFxuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XFxuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcXG4gICAgfVxcbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXFxuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XFxuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xcbiAgICB9XFxuICAgIC8vIGV4dGVuZCBnbG9iYWxcXG4gICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcXG4gIH1cXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDcyOTM6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiAhIWV4ZWMoKTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNzAwNzpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGAgc2luY2UgaXQncyBtb3ZlZCB0byBlbnRyeSBwb2ludHNcXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQ5MTYpO1xcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMyMCk7XFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MjkzKTtcXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTEyKTtcXG52YXIgcmVnZXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oMjI2MSk7XFxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oODg4MCk7XFxuXFxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcXG5cXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgLy8gI3JlcGxhY2UgbmVlZHMgYnVpbHQtaW4gc3VwcG9ydCBmb3IgbmFtZWQgZ3JvdXBzLlxcbiAgLy8gI21hdGNoIHdvcmtzIGZpbmUgYmVjYXVzZSBpdCBqdXN0IHJldHVybiB0aGUgZXhlYyByZXN1bHRzLCBldmVuIGlmIGl0IGhhc1xcbiAgLy8gYSBcXFwiZ3JvcHNcXFwiIHByb3BlcnR5LlxcbiAgdmFyIHJlID0gLy4vO1xcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xcbiAgICByZXN1bHQuZ3JvdXBzID0geyBhOiAnNycgfTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH07XFxuICByZXR1cm4gJycucmVwbGFjZShyZSwgJyQ8YT4nKSAhPT0gJzcnO1xcbn0pO1xcblxcbi8vIElFIDw9IDExIHJlcGxhY2VzICQwIHdpdGggdGhlIHdob2xlIG1hdGNoLCBhcyBpZiBpdCB3YXMgJCZcXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MDI0NjY2L2dldHRpbmctaWUtdG8tcmVwbGFjZS1hLXJlZ2V4LXdpdGgtdGhlLWxpdGVyYWwtc3RyaW5nLTBcXG52YXIgUkVQTEFDRV9LRUVQU18kMCA9IChmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gJ2EnLnJlcGxhY2UoLy4vLCAnJDAnKSA9PT0gJyQwJztcXG59KSgpO1xcblxcbnZhciBSRVBMQUNFID0gd2VsbEtub3duU3ltYm9sKCdyZXBsYWNlJyk7XFxuLy8gU2FmYXJpIDw9IDEzLjAuMyg/KSBzdWJzdGl0dXRlcyBudGggY2FwdHVyZSB3aGVyZSBuPm0gd2l0aCBhbiBlbXB0eSBzdHJpbmdcXG52YXIgUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUgPSAoZnVuY3Rpb24gKCkge1xcbiAgaWYgKC8uL1tSRVBMQUNFXSkge1xcbiAgICByZXR1cm4gLy4vW1JFUExBQ0VdKCdhJywgJyQwJykgPT09ICcnO1xcbiAgfVxcbiAgcmV0dXJuIGZhbHNlO1xcbn0pKCk7XFxuXFxuLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFxcXCJzcGxpdFxcXCIgaW1wbGVtZW50YXRpb24gd2hlbiBSZWdFeHAjZXhlYyAhPT0gbmF0aXZlRXhlY1xcbi8vIFdlZXggSlMgaGFzIGZyb3plbiBidWlsdC1pbiBwcm90b3R5cGVzLCBzbyB1c2UgdHJ5IC8gY2F0Y2ggd3JhcHBlclxcbnZhciBTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1lbXB0eS1ncm91cCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xcbiAgdmFyIHJlID0gLyg/OikvO1xcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XFxuICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JpZ2luYWxFeGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XFxuICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XFxuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAhPT0gMiB8fCByZXN1bHRbMF0gIT09ICdhJyB8fCByZXN1bHRbMV0gIT09ICdiJztcXG59KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGxlbmd0aCwgZXhlYywgc2hhbSkge1xcbiAgdmFyIFNZTUJPTCA9IHdlbGxLbm93blN5bWJvbChLRVkpO1xcblxcbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgICAvLyBTdHJpbmcgbWV0aG9kcyBjYWxsIHN5bWJvbC1uYW1lZCBSZWdFcCBtZXRob2RzXFxuICAgIHZhciBPID0ge307XFxuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH07XFxuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XFxuICB9KTtcXG5cXG4gIHZhciBERUxFR0FURVNfVE9fRVhFQyA9IERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gICAgLy8gU3ltYm9sLW5hbWVkIFJlZ0V4cCBtZXRob2RzIGNhbGwgLmV4ZWNcXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcXG4gICAgdmFyIHJlID0gL2EvO1xcblxcbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XFxuICAgICAgLy8gV2UgY2FuJ3QgdXNlIHJlYWwgcmVnZXggaGVyZSBzaW5jZSBpdCBjYXVzZXMgZGVvcHRpbWl6YXRpb25cXG4gICAgICAvLyBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbiBpbiBWOFxcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMDZcXG4gICAgICByZSA9IHt9O1xcbiAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXFxuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxcbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XFxuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZTsgfTtcXG4gICAgICByZS5mbGFncyA9ICcnO1xcbiAgICAgIHJlW1NZTUJPTF0gPSAvLi9bU1lNQk9MXTtcXG4gICAgfVxcblxcbiAgICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyBleGVjQ2FsbGVkID0gdHJ1ZTsgcmV0dXJuIG51bGw7IH07XFxuXFxuICAgIHJlW1NZTUJPTF0oJycpO1xcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XFxuICB9KTtcXG5cXG4gIGlmIChcXG4gICAgIURFTEVHQVRFU19UT19TWU1CT0wgfHxcXG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XFxuICAgIChLRVkgPT09ICdyZXBsYWNlJyAmJiAhKFxcbiAgICAgIFJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTICYmXFxuICAgICAgUkVQTEFDRV9LRUVQU18kMCAmJlxcbiAgICAgICFSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRVxcbiAgICApKSB8fFxcbiAgICAoS0VZID09PSAnc3BsaXQnICYmICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMpXFxuICApIHtcXG4gICAgdmFyIG5hdGl2ZVJlZ0V4cE1ldGhvZCA9IC8uL1tTWU1CT0xdO1xcbiAgICB2YXIgbWV0aG9kcyA9IGV4ZWMoU1lNQk9MLCAnJ1tLRVldLCBmdW5jdGlvbiAobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcXG4gICAgICBpZiAocmVnZXhwLmV4ZWMgPT09IHJlZ2V4cEV4ZWMpIHtcXG4gICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xcbiAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcXG4gICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxcbiAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlUmVnRXhwTWV0aG9kLmNhbGwocmVnZXhwLCBzdHIsIGFyZzIpIH07XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlTWV0aG9kLmNhbGwoc3RyLCByZWdleHAsIGFyZzIpIH07XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlIH07XFxuICAgIH0sIHtcXG4gICAgICBSRVBMQUNFX0tFRVBTXyQwOiBSRVBMQUNFX0tFRVBTXyQwLFxcbiAgICAgIFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFOiBSRUdFWFBfUkVQTEFDRV9TVUJTVElUVVRFU19VTkRFRklORURfQ0FQVFVSRVxcbiAgICB9KTtcXG4gICAgdmFyIHN0cmluZ01ldGhvZCA9IG1ldGhvZHNbMF07XFxuICAgIHZhciByZWdleE1ldGhvZCA9IG1ldGhvZHNbMV07XFxuXFxuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyaW5nTWV0aG9kKTtcXG4gICAgcmVkZWZpbmUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByZWdleE1ldGhvZC5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxcbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcXG4gICAgICA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHJlZ2V4TWV0aG9kLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxcbiAgICApO1xcbiAgfVxcblxcbiAgaWYgKHNoYW0pIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShSZWdFeHAucHJvdG90eXBlW1NZTUJPTF0sICdzaGFtJywgdHJ1ZSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA5OTc0Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwOTkpO1xcblxcbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcXG4gIGFGdW5jdGlvbihmbik7XFxuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XFxuICBzd2l0Y2ggKGxlbmd0aCkge1xcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCk7XFxuICAgIH07XFxuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XFxuICAgIH07XFxuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XFxuICAgIH07XFxuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XFxuICAgIH07XFxuICB9XFxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XFxuICB9O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNTAwNTpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oODU3KTtcXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODU0KTtcXG5cXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09ICdmdW5jdGlvbicgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcXG59O1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XFxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24ocGF0aFtuYW1lc3BhY2VdKSB8fCBhRnVuY3Rpb24oZ2xvYmFsW25hbWVzcGFjZV0pXFxuICAgIDogcGF0aFtuYW1lc3BhY2VdICYmIHBhdGhbbmFtZXNwYWNlXVttZXRob2RdIHx8IGdsb2JhbFtuYW1lc3BhY2VdICYmIGdsb2JhbFtuYW1lc3BhY2VdW21ldGhvZF07XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAxMjQ2Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDgpO1xcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0OTcpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxMTIpO1xcblxcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxcbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXFxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA4NTU0Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTY3MCk7XFxudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjQ2KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoaXQpO1xcbiAgaWYgKHR5cGVvZiBpdGVyYXRvck1ldGhvZCAhPSAnZnVuY3Rpb24nKSB7XFxuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcXG4gIH0gcmV0dXJuIGFuT2JqZWN0KGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXQpKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDY0NzpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5MDgpO1xcblxcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XFxudmFyIHJlcGxhY2UgPSAnJy5yZXBsYWNlO1xcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MUyA9IC9cXFxcJChbJCYnYF18XFxcXGRcXFxcZD98PFtePl0qPikvZztcXG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFxcXCQoWyQmJ2BdfFxcXFxkXFxcXGQ/KS9nO1xcblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0c3Vic3RpdHV0aW9uXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XFxuICB2YXIgdGFpbFBvcyA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XFxuICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcXG4gIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XFxuICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcXG4gICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xcbiAgfVxcbiAgcmV0dXJuIHJlcGxhY2UuY2FsbChyZXBsYWNlbWVudCwgc3ltYm9scywgZnVuY3Rpb24gKG1hdGNoLCBjaCkge1xcbiAgICB2YXIgY2FwdHVyZTtcXG4gICAgc3dpdGNoIChjaC5jaGFyQXQoMCkpIHtcXG4gICAgICBjYXNlICckJzogcmV0dXJuICckJztcXG4gICAgICBjYXNlICcmJzogcmV0dXJuIG1hdGNoZWQ7XFxuICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHIuc2xpY2UoMCwgcG9zaXRpb24pO1xcbiAgICAgIGNhc2UgXFxcIidcXFwiOiByZXR1cm4gc3RyLnNsaWNlKHRhaWxQb3MpO1xcbiAgICAgIGNhc2UgJzwnOlxcbiAgICAgICAgY2FwdHVyZSA9IG5hbWVkQ2FwdHVyZXNbY2guc2xpY2UoMSwgLTEpXTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6IC8vIFxcXFxkXFxcXGQ/XFxuICAgICAgICB2YXIgbiA9ICtjaDtcXG4gICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XFxuICAgICAgICBpZiAobiA+IG0pIHtcXG4gICAgICAgICAgdmFyIGYgPSBmbG9vcihuIC8gMTApO1xcbiAgICAgICAgICBpZiAoZiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xcbiAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaC5jaGFyQXQoMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaC5jaGFyQXQoMSk7XFxuICAgICAgICAgIHJldHVybiBtYXRjaDtcXG4gICAgICAgIH1cXG4gICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XFxuICAgIH1cXG4gICAgcmV0dXJuIGNhcHR1cmUgPT09IHVuZGVmaW5lZCA/ICcnIDogY2FwdHVyZTtcXG4gIH0pO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNzg1NDpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XFxufTtcXG5cXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxcbm1vZHVsZS5leHBvcnRzID1cXG4gIC8qIGdsb2JhbCBnbG9iYWxUaGlzIC0tIHNhZmUgKi9cXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XFxuICBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHxcXG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XFxuICBjaGVjayh0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXy5nID09ICdvYmplY3QnICYmIF9fd2VicGFja19yZXF1aXJlX18uZykgfHxcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA2NjU2Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcXG5cXG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XFxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDM1MDE6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xcblxcbm1vZHVsZS5leHBvcnRzID0ge307XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNDkwOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDA1KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDQ2NjQ6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NzgxKTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyOTMpO1xcbnZhciBjcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTcpO1xcblxcbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcXG5tb2R1bGUuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxcbiAgfSkuYSAhPSA3O1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDExNzk6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xcblxcbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XFxudmFyIGFicyA9IE1hdGguYWJzO1xcbnZhciBwb3cgPSBNYXRoLnBvdztcXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xcbnZhciBsb2cgPSBNYXRoLmxvZztcXG52YXIgTE4yID0gTWF0aC5MTjI7XFxuXFxudmFyIHBhY2sgPSBmdW5jdGlvbiAobnVtYmVyLCBtYW50aXNzYUxlbmd0aCwgYnl0ZXMpIHtcXG4gIHZhciBidWZmZXIgPSBuZXcgQXJyYXkoYnl0ZXMpO1xcbiAgdmFyIGV4cG9uZW50TGVuZ3RoID0gYnl0ZXMgKiA4IC0gbWFudGlzc2FMZW5ndGggLSAxO1xcbiAgdmFyIGVNYXggPSAoMSA8PCBleHBvbmVudExlbmd0aCkgLSAxO1xcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xcbiAgdmFyIHJ0ID0gbWFudGlzc2FMZW5ndGggPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDA7XFxuICB2YXIgc2lnbiA9IG51bWJlciA8IDAgfHwgbnVtYmVyID09PSAwICYmIDEgLyBudW1iZXIgPCAwID8gMSA6IDA7XFxuICB2YXIgaW5kZXggPSAwO1xcbiAgdmFyIGV4cG9uZW50LCBtYW50aXNzYSwgYztcXG4gIG51bWJlciA9IGFicyhudW1iZXIpO1xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcXG4gIGlmIChudW1iZXIgIT0gbnVtYmVyIHx8IG51bWJlciA9PT0gSW5maW5pdHkpIHtcXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcXG4gICAgbWFudGlzc2EgPSBudW1iZXIgIT0gbnVtYmVyID8gMSA6IDA7XFxuICAgIGV4cG9uZW50ID0gZU1heDtcXG4gIH0gZWxzZSB7XFxuICAgIGV4cG9uZW50ID0gZmxvb3IobG9nKG51bWJlcikgLyBMTjIpO1xcbiAgICBpZiAobnVtYmVyICogKGMgPSBwb3coMiwgLWV4cG9uZW50KSkgPCAxKSB7XFxuICAgICAgZXhwb25lbnQtLTtcXG4gICAgICBjICo9IDI7XFxuICAgIH1cXG4gICAgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gMSkge1xcbiAgICAgIG51bWJlciArPSBydCAvIGM7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbnVtYmVyICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XFxuICAgIH1cXG4gICAgaWYgKG51bWJlciAqIGMgPj0gMikge1xcbiAgICAgIGV4cG9uZW50Kys7XFxuICAgICAgYyAvPSAyO1xcbiAgICB9XFxuICAgIGlmIChleHBvbmVudCArIGVCaWFzID49IGVNYXgpIHtcXG4gICAgICBtYW50aXNzYSA9IDA7XFxuICAgICAgZXhwb25lbnQgPSBlTWF4O1xcbiAgICB9IGVsc2UgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gMSkge1xcbiAgICAgIG1hbnRpc3NhID0gKG51bWJlciAqIGMgLSAxKSAqIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XFxuICAgICAgZXhwb25lbnQgPSBleHBvbmVudCArIGVCaWFzO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG1hbnRpc3NhID0gbnVtYmVyICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xcbiAgICAgIGV4cG9uZW50ID0gMDtcXG4gICAgfVxcbiAgfVxcbiAgZm9yICg7IG1hbnRpc3NhTGVuZ3RoID49IDg7IGJ1ZmZlcltpbmRleCsrXSA9IG1hbnRpc3NhICYgMjU1LCBtYW50aXNzYSAvPSAyNTYsIG1hbnRpc3NhTGVuZ3RoIC09IDgpO1xcbiAgZXhwb25lbnQgPSBleHBvbmVudCA8PCBtYW50aXNzYUxlbmd0aCB8IG1hbnRpc3NhO1xcbiAgZXhwb25lbnRMZW5ndGggKz0gbWFudGlzc2FMZW5ndGg7XFxuICBmb3IgKDsgZXhwb25lbnRMZW5ndGggPiAwOyBidWZmZXJbaW5kZXgrK10gPSBleHBvbmVudCAmIDI1NSwgZXhwb25lbnQgLz0gMjU2LCBleHBvbmVudExlbmd0aCAtPSA4KTtcXG4gIGJ1ZmZlclstLWluZGV4XSB8PSBzaWduICogMTI4O1xcbiAgcmV0dXJuIGJ1ZmZlcjtcXG59O1xcblxcbnZhciB1bnBhY2sgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYW50aXNzYUxlbmd0aCkge1xcbiAgdmFyIGJ5dGVzID0gYnVmZmVyLmxlbmd0aDtcXG4gIHZhciBleHBvbmVudExlbmd0aCA9IGJ5dGVzICogOCAtIG1hbnRpc3NhTGVuZ3RoIC0gMTtcXG4gIHZhciBlTWF4ID0gKDEgPDwgZXhwb25lbnRMZW5ndGgpIC0gMTtcXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcXG4gIHZhciBuQml0cyA9IGV4cG9uZW50TGVuZ3RoIC0gNztcXG4gIHZhciBpbmRleCA9IGJ5dGVzIC0gMTtcXG4gIHZhciBzaWduID0gYnVmZmVyW2luZGV4LS1dO1xcbiAgdmFyIGV4cG9uZW50ID0gc2lnbiAmIDEyNztcXG4gIHZhciBtYW50aXNzYTtcXG4gIHNpZ24gPj49IDc7XFxuICBmb3IgKDsgbkJpdHMgPiAwOyBleHBvbmVudCA9IGV4cG9uZW50ICogMjU2ICsgYnVmZmVyW2luZGV4XSwgaW5kZXgtLSwgbkJpdHMgLT0gOCk7XFxuICBtYW50aXNzYSA9IGV4cG9uZW50ICYgKDEgPDwgLW5CaXRzKSAtIDE7XFxuICBleHBvbmVudCA+Pj0gLW5CaXRzO1xcbiAgbkJpdHMgKz0gbWFudGlzc2FMZW5ndGg7XFxuICBmb3IgKDsgbkJpdHMgPiAwOyBtYW50aXNzYSA9IG1hbnRpc3NhICogMjU2ICsgYnVmZmVyW2luZGV4XSwgaW5kZXgtLSwgbkJpdHMgLT0gOCk7XFxuICBpZiAoZXhwb25lbnQgPT09IDApIHtcXG4gICAgZXhwb25lbnQgPSAxIC0gZUJpYXM7XFxuICB9IGVsc2UgaWYgKGV4cG9uZW50ID09PSBlTWF4KSB7XFxuICAgIHJldHVybiBtYW50aXNzYSA/IE5hTiA6IHNpZ24gPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcXG4gIH0gZWxzZSB7XFxuICAgIG1hbnRpc3NhID0gbWFudGlzc2EgKyBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xcbiAgICBleHBvbmVudCA9IGV4cG9uZW50IC0gZUJpYXM7XFxuICB9IHJldHVybiAoc2lnbiA/IC0xIDogMSkgKiBtYW50aXNzYSAqIHBvdygyLCBleHBvbmVudCAtIG1hbnRpc3NhTGVuZ3RoKTtcXG59O1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgcGFjazogcGFjayxcXG4gIHVucGFjazogdW5wYWNrXFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA4MzYxOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNzI5Myk7XFxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzMjYpO1xcblxcbnZhciBzcGxpdCA9ICcnLnNwbGl0O1xcblxcbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXFxubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcXG4gIHJldHVybiAhT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XFxufSkgPyBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBjbGFzc29mKGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0LmNhbGwoaXQsICcnKSA6IE9iamVjdChpdCk7XFxufSA6IE9iamVjdDtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA5NTg3Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTExKTtcXG52YXIgc2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NzQpO1xcblxcbi8vIG1ha2VzIHN1YmNsYXNzaW5nIHdvcmsgY29ycmVjdCBmb3Igd3JhcHBlZCBidWlsdC1pbnNcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkdGhpcywgZHVtbXksIFdyYXBwZXIpIHtcXG4gIHZhciBOZXdUYXJnZXQsIE5ld1RhcmdldFByb3RvdHlwZTtcXG4gIGlmIChcXG4gICAgLy8gaXQgY2FuIHdvcmsgb25seSB3aXRoIG5hdGl2ZSBgc2V0UHJvdG90eXBlT2ZgXFxuICAgIHNldFByb3RvdHlwZU9mICYmXFxuICAgIC8vIHdlIGhhdmVuJ3QgY29tcGxldGVseSBjb3JyZWN0IHByZS1FUzYgd2F5IGZvciBnZXR0aW5nIGBuZXcudGFyZ2V0YCwgc28gdXNlIHRoaXNcXG4gICAgdHlwZW9mIChOZXdUYXJnZXQgPSBkdW1teS5jb25zdHJ1Y3RvcikgPT0gJ2Z1bmN0aW9uJyAmJlxcbiAgICBOZXdUYXJnZXQgIT09IFdyYXBwZXIgJiZcXG4gICAgaXNPYmplY3QoTmV3VGFyZ2V0UHJvdG90eXBlID0gTmV3VGFyZ2V0LnByb3RvdHlwZSkgJiZcXG4gICAgTmV3VGFyZ2V0UHJvdG90eXBlICE9PSBXcmFwcGVyLnByb3RvdHlwZVxcbiAgKSBzZXRQcm90b3R5cGVPZigkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcXG4gIHJldHVybiAkdGhpcztcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDI3ODg6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NDY1KTtcXG5cXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnRvU3RyaW5nO1xcblxcbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXFxuaWYgKHR5cGVvZiBzdG9yZS5pbnNwZWN0U291cmNlICE9ICdmdW5jdGlvbicpIHtcXG4gIHN0b3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XFxuICB9O1xcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gOTkwOTpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTM2KTtcXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODU0KTtcXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMSk7XFxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oODg4MCk7XFxudmFyIG9iamVjdEhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjY1Nik7XFxudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTQ2NSk7XFxudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oNjIwMCk7XFxudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1MDEpO1xcblxcbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XFxudmFyIHNldCwgZ2V0LCBoYXM7XFxuXFxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xcbn07XFxuXFxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XFxuICAgIHZhciBzdGF0ZTtcXG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcXG4gICAgfSByZXR1cm4gc3RhdGU7XFxuICB9O1xcbn07XFxuXFxuaWYgKE5BVElWRV9XRUFLX01BUCkge1xcbiAgdmFyIHN0b3JlID0gc2hhcmVkLnN0YXRlIHx8IChzaGFyZWQuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcXG4gIHZhciB3bWdldCA9IHN0b3JlLmdldDtcXG4gIHZhciB3bWhhcyA9IHN0b3JlLmhhcztcXG4gIHZhciB3bXNldCA9IHN0b3JlLnNldDtcXG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcXG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XFxuICAgIHdtc2V0LmNhbGwoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XFxuICAgIHJldHVybiBtZXRhZGF0YTtcXG4gIH07XFxuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIHdtZ2V0LmNhbGwoc3RvcmUsIGl0KSB8fCB7fTtcXG4gIH07XFxuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIHdtaGFzLmNhbGwoc3RvcmUsIGl0KTtcXG4gIH07XFxufSBlbHNlIHtcXG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcXG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcXG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcXG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XFxuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcXG4gICAgcmV0dXJuIG1ldGFkYXRhO1xcbiAgfTtcXG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcXG4gIH07XFxuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpO1xcbiAgfTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBzZXQ6IHNldCxcXG4gIGdldDogZ2V0LFxcbiAgaGFzOiBoYXMsXFxuICBlbmZvcmNlOiBlbmZvcmNlLFxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3JcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDc2NTk6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTExMik7XFxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNzQ5Nyk7XFxuXFxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcXG5cXG4vLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SXSA9PT0gaXQpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMzE1NzpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oNDMyNik7XFxuXFxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xcbiAgcmV0dXJuIGNsYXNzb2YoYXJnKSA9PSAnQXJyYXknO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNDcwNTpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyOTMpO1xcblxcbnZhciByZXBsYWNlbWVudCA9IC8jfFxcXFwucHJvdG90eXBlXFxcXC4vO1xcblxcbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcXG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcXG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWVcXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxcbiAgICA6IHR5cGVvZiBkZXRlY3Rpb24gPT0gJ2Z1bmN0aW9uJyA/IGZhaWxzKGRldGVjdGlvbilcXG4gICAgOiAhIWRldGVjdGlvbjtcXG59O1xcblxcbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZC5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XFxuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xcbn07XFxuXFxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XFxudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcXG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZC5QT0xZRklMTCA9ICdQJztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDExMTpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAxOTEzOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDc4NTA6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTEpO1xcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzI2KTtcXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTEyKTtcXG5cXG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XFxuXFxuLy8gYElzUmVnRXhwYCBhYnN0cmFjdCBvcGVyYXRpb25cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzcmVnZXhwXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHZhciBpc1JlZ0V4cDtcXG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjbGFzc29mKGl0KSA9PSAnUmVnRXhwJyk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA5MjEyOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTY3MCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcXG4gIHZhciByZXR1cm5NZXRob2QgPSBpdGVyYXRvclsncmV0dXJuJ107XFxuICBpZiAocmV0dXJuTWV0aG9kICE9PSB1bmRlZmluZWQpIHtcXG4gICAgcmV0dXJuIGFuT2JqZWN0KHJldHVybk1ldGhvZC5jYWxsKGl0ZXJhdG9yKSkudmFsdWU7XFxuICB9XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAzMzgzOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyOTMpO1xcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oOTUxOCk7XFxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oODg4MCk7XFxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjY1Nik7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTExMik7XFxudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MTMpO1xcblxcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcXG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IGZhbHNlO1xcblxcbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcXG5cXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJWAgb2JqZWN0XFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xcblxcbmlmIChbXS5rZXlzKSB7XFxuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xcbiAgLy8gU2FmYXJpIDggaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO1xcbiAgZWxzZSB7XFxuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGdldFByb3RvdHlwZU9mKGFycmF5SXRlcmF0b3IpKTtcXG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XFxuICB9XFxufVxcblxcbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gSXRlcmF0b3JQcm90b3R5cGUgPT0gdW5kZWZpbmVkIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIHZhciB0ZXN0ID0ge307XFxuICAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcXG4gIHJldHVybiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcXG59KTtcXG5cXG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcXG5cXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxcbmlmICgoIUlTX1BVUkUgfHwgTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSB7XFxuICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUsXFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA3NDk3Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDEzMzpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyOTMpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxcbiAgLyogZ2xvYmFsIFN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xcbiAgcmV0dXJuICFTdHJpbmcoU3ltYm9sKCkpO1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDU5MDpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyOTMpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxMTIpO1xcbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEzKTtcXG5cXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgdmFyIHVybCA9IG5ldyBVUkwoJ2I/YT0xJmI9MiZjPTMnLCAnaHR0cDovL2EnKTtcXG4gIHZhciBzZWFyY2hQYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xcbiAgdmFyIHJlc3VsdCA9ICcnO1xcbiAgdXJsLnBhdGhuYW1lID0gJ2MlMjBkJztcXG4gIHNlYXJjaFBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XFxuICAgIHNlYXJjaFBhcmFtc1snZGVsZXRlJ10oJ2InKTtcXG4gICAgcmVzdWx0ICs9IGtleSArIHZhbHVlO1xcbiAgfSk7XFxuICByZXR1cm4gKElTX1BVUkUgJiYgIXVybC50b0pTT04pXFxuICAgIHx8ICFzZWFyY2hQYXJhbXMuc29ydFxcbiAgICB8fCB1cmwuaHJlZiAhPT0gJ2h0dHA6Ly9hL2MlMjBkP2E9MSZjPTMnXFxuICAgIHx8IHNlYXJjaFBhcmFtcy5nZXQoJ2MnKSAhPT0gJzMnXFxuICAgIHx8IFN0cmluZyhuZXcgVVJMU2VhcmNoUGFyYW1zKCc/YT0xJykpICE9PSAnYT0xJ1xcbiAgICB8fCAhc2VhcmNoUGFyYW1zW0lURVJBVE9SXVxcbiAgICAvLyB0aHJvd3MgaW4gRWRnZVxcbiAgICB8fCBuZXcgVVJMKCdodHRwczovL2FAYicpLnVzZXJuYW1lICE9PSAnYSdcXG4gICAgfHwgbmV3IFVSTFNlYXJjaFBhcmFtcyhuZXcgVVJMU2VhcmNoUGFyYW1zKCdhPWInKSkuZ2V0KCdhJykgIT09ICdiJ1xcbiAgICAvLyBub3QgcHVueWNvZGVkIGluIEVkZ2VcXG4gICAgfHwgbmV3IFVSTCgnaHR0cDovL1xcdTA0NDJcXHUwNDM1XFx1MDQ0MVxcdTA0NDInKS5ob3N0ICE9PSAneG4tLWUxYXliYydcXG4gICAgLy8gbm90IGVzY2FwZWQgaW4gQ2hyb21lIDYyLVxcbiAgICB8fCBuZXcgVVJMKCdodHRwOi8vYSNcXHUwNDMxJykuaGFzaCAhPT0gJyMlRDAlQjEnXFxuICAgIC8vIGZhaWxzIGluIENocm9tZSA2Ni1cXG4gICAgfHwgcmVzdWx0ICE9PSAnYTFjMydcXG4gICAgLy8gdGhyb3dzIGluIFNhZmFyaVxcbiAgICB8fCBuZXcgVVJMKCdodHRwOi8veCcsIHVuZGVmaW5lZCkuaG9zdCAhPT0gJ3gnO1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDg1MzY6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzg1NCk7XFxudmFyIGluc3BlY3RTb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3ODgpO1xcblxcbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZShXZWFrTWFwKSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMTU3NDpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NzgxKTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyOTMpO1xcbnZhciBvYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTU2KTtcXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTgxKTtcXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyOTYpO1xcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzkwOCk7XFxudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgzNjEpO1xcblxcbnZhciBuYXRpdmVBc3NpZ24gPSBPYmplY3QuYXNzaWduO1xcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcXG5cXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXFxubW9kdWxlLmV4cG9ydHMgPSAhbmF0aXZlQXNzaWduIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIC8vIHNob3VsZCBoYXZlIGNvcnJlY3Qgb3JkZXIgb2Ygb3BlcmF0aW9ucyAoRWRnZSBidWcpXFxuICBpZiAoREVTQ1JJUFRPUlMgJiYgbmF0aXZlQXNzaWduKHsgYjogMSB9LCBuYXRpdmVBc3NpZ24oZGVmaW5lUHJvcGVydHkoe30sICdhJywge1xcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYicsIHtcXG4gICAgICAgIHZhbHVlOiAzLFxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XFxuICAvLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZylcXG4gIHZhciBBID0ge307XFxuICB2YXIgQiA9IHt9O1xcbiAgLyogZ2xvYmFsIFN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xcbiAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcXG4gIEFbc3ltYm9sXSA9IDc7XFxuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XFxuICByZXR1cm4gbmF0aXZlQXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cyhuYXRpdmVBc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcXG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcXG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xcbiAgdmFyIGluZGV4ID0gMTtcXG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcXG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XFxuICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcXG4gICAgdmFyIFMgPSBJbmRleGVkT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XFxuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gb2JqZWN0S2V5cyhTKS5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMoUyk7XFxuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcXG4gICAgdmFyIGogPSAwO1xcbiAgICB2YXIga2V5O1xcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xcbiAgICAgIGtleSA9IGtleXNbaisrXTtcXG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoUywga2V5KSkgVFtrZXldID0gU1trZXldO1xcbiAgICB9XFxuICB9IHJldHVybiBUO1xcbn0gOiBuYXRpdmVBc3NpZ247XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMzA6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjcwKTtcXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjA0OCk7XFxudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDgpO1xcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNTAxKTtcXG52YXIgaHRtbCA9IF9fd2VicGFja19yZXF1aXJlX18oNDkwKTtcXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTcpO1xcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyMDApO1xcblxcbnZhciBHVCA9ICc+JztcXG52YXIgTFQgPSAnPCc7XFxudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XFxuXFxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XFxuXFxudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XFxuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xcbn07XFxuXFxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcXG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcXG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcXG4gIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXFxuICByZXR1cm4gdGVtcDtcXG59O1xcblxcbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XFxuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDc1XFxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcXG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XFxuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XFxuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcXG4gIHJldHVybiBpZnJhbWVEb2N1bWVudC5GO1xcbn07XFxuXFxuLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcXG4vLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0Nlxcbi8vIGF2b2lkIElFIEdDIGJ1Z1xcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XFxudmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcXG4gIHRyeSB7XFxuICAgIC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSAqL1xcbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBkb2N1bWVudC5kb21haW4gJiYgbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XFxuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxcbiAgTnVsbFByb3RvT2JqZWN0ID0gYWN0aXZlWERvY3VtZW50ID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIDogTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKCk7XFxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XFxuICByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XFxufTtcXG5cXG5oaWRkZW5LZXlzW0lFX1BST1RPXSA9IHRydWU7XFxuXFxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xcbiAgdmFyIHJlc3VsdDtcXG4gIGlmIChPICE9PSBudWxsKSB7XFxuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBudWxsO1xcbiAgICAvLyBhZGQgXFxcIl9fcHJvdG9fX1xcXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcXG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcXG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzKHJlc3VsdCwgUHJvcGVydGllcyk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA2MDQ4Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oOTc4MSk7XFxudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDcwKTtcXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2NzApO1xcbnZhciBvYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTU2KTtcXG5cXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcXG4gIGFuT2JqZWN0KE8pO1xcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xcbiAgdmFyIGluZGV4ID0gMDtcXG4gIHZhciBrZXk7XFxuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgUHJvcGVydGllc1trZXldKTtcXG4gIHJldHVybiBPO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMzA3MDpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3ODEpO1xcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oNDY2NCk7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjcwKTtcXG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1OTMpO1xcblxcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcXG5cXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlRGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XFxuICBhbk9iamVjdChPKTtcXG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcXG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xcbiAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XFxuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XFxuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcXG4gIHJldHVybiBPO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMTIzNjpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3ODEpO1xcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTI5Nik7XFxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oOTExNCk7XFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTY1Nik7XFxudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTkzKTtcXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjU2KTtcXG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2NjQpO1xcblxcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xcblxcbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XFxuICBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxcbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZi5jYWxsKE8sIFApLCBPW1BdKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDgwMDY6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNjMyNCk7XFxudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDgpO1xcblxcbnZhciBoaWRkZW5LZXlzID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XFxuXFxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXFxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XFxuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNTE4MTpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDk1MTg6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjY1Nik7XFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTA4KTtcXG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MjAwKTtcXG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTQ0KTtcXG5cXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XFxudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XFxuXFxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XFxuICBPID0gdG9PYmplY3QoTyk7XFxuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcXG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA2MzI0Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2NTYpO1xcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2NTYpO1xcbnZhciBpbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzE4KS5pbmRleE9mO1xcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNTAxKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XFxuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xcbiAgdmFyIGkgPSAwO1xcbiAgdmFyIHJlc3VsdCA9IFtdO1xcbiAgdmFyIGtleTtcXG4gIGZvciAoa2V5IGluIE8pICFoYXMoaGlkZGVuS2V5cywga2V5KSAmJiBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcXG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMTk1NjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MzI0KTtcXG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0OCk7XFxuXFxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXFxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcXG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgZW51bUJ1Z0tleXMpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNTI5NjpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XFxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XFxuXFxuLy8gTmFzaG9ybiB+IEpESzggYnVnXFxudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICFuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcXG5cXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXFxuZXhwb3J0cy5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XFxuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcXG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xcbn0gOiBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA3Njc0Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2NzApO1xcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwNzcpO1xcblxcbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXFxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXFxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XFxuICB2YXIgdGVzdCA9IHt9O1xcbiAgdmFyIHNldHRlcjtcXG4gIHRyeSB7XFxuICAgIHNldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldDtcXG4gICAgc2V0dGVyLmNhbGwodGVzdCwgW10pO1xcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cXG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xcbiAgICBhbk9iamVjdChPKTtcXG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcXG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIuY2FsbChPLCBwcm90byk7XFxuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcXG4gICAgcmV0dXJuIE87XFxuICB9O1xcbn0oKSA6IHVuZGVmaW5lZCk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMjg4Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjk0KTtcXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ4KTtcXG5cXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kIGltcGxlbWVudGF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXFxubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xcbiAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMzg4NzpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNTAwNSk7XFxudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwMDYpO1xcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxODEpO1xcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTY3MCk7XFxuXFxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcXG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcXG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA4NTc6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzg1NCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMjI0ODpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMjApO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XFxuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIG9wdGlvbnMpO1xcbiAgcmV0dXJuIHRhcmdldDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDEzMjA6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzg1NCk7XFxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oODg4MCk7XFxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjY1Nik7XFxudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUwNSk7XFxudmFyIGluc3BlY3RTb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3ODgpO1xcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA5KTtcXG5cXG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcXG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XFxuXFxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcXG4gIHZhciB1bnNhZmUgPSBvcHRpb25zID8gISFvcHRpb25zLnVuc2FmZSA6IGZhbHNlO1xcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMuZW51bWVyYWJsZSA6IGZhbHNlO1xcbiAgdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xcbiAgdmFyIHN0YXRlO1xcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XFxuICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnICYmICFoYXModmFsdWUsICduYW1lJykpIHtcXG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkodmFsdWUsICduYW1lJywga2V5KTtcXG4gICAgfVxcbiAgICBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcXG4gICAgaWYgKCFzdGF0ZS5zb3VyY2UpIHtcXG4gICAgICBzdGF0ZS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBrZXkgOiAnJyk7XFxuICAgIH1cXG4gIH1cXG4gIGlmIChPID09PSBnbG9iYWwpIHtcXG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XFxuICAgIGVsc2Ugc2V0R2xvYmFsKGtleSwgdmFsdWUpO1xcbiAgICByZXR1cm47XFxuICB9IGVsc2UgaWYgKCF1bnNhZmUpIHtcXG4gICAgZGVsZXRlIE9ba2V5XTtcXG4gIH0gZWxzZSBpZiAoIW5vVGFyZ2V0R2V0ICYmIE9ba2V5XSkge1xcbiAgICBzaW1wbGUgPSB0cnVlO1xcbiAgfVxcbiAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XFxuICBlbHNlIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPLCBrZXksIHZhbHVlKTtcXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcXG59KShGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSh0aGlzKTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA3NjUxOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzI2KTtcXG52YXIgcmVnZXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oMjI2MSk7XFxuXFxuLy8gYFJlZ0V4cEV4ZWNgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwZXhlY1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFIsIFMpIHtcXG4gIHZhciBleGVjID0gUi5leGVjO1xcbiAgaWYgKHR5cGVvZiBleGVjID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIHZhciByZXN1bHQgPSBleGVjLmNhbGwoUiwgUyk7XFxuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xcbiAgICAgIHRocm93IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG5cXG4gIGlmIChjbGFzc29mKFIpICE9PSAnUmVnRXhwJykge1xcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXInKTtcXG4gIH1cXG5cXG4gIHJldHVybiByZWdleHBFeGVjLmNhbGwoUiwgUyk7XFxufTtcXG5cXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAyMjYxOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgcmVnZXhwRmxhZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwNjYpO1xcbnZhciBzdGlja3lIZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTk5KTtcXG5cXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcXG4vLyBUaGlzIGFsd2F5cyByZWZlcnMgdG8gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiwgYmVjYXVzZSB0aGVcXG4vLyBTdHJpbmcjcmVwbGFjZSBwb2x5ZmlsbCB1c2VzIC4vZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYy5qcyxcXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXFxudmFyIG5hdGl2ZVJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XFxuXFxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcXG5cXG52YXIgVVBEQVRFU19MQVNUX0lOREVYX1dST05HID0gKGZ1bmN0aW9uICgpIHtcXG4gIHZhciByZTEgPSAvYS87XFxuICB2YXIgcmUyID0gL2IqL2c7XFxuICBuYXRpdmVFeGVjLmNhbGwocmUxLCAnYScpO1xcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcXG4gIHJldHVybiByZTEubGFzdEluZGV4ICE9PSAwIHx8IHJlMi5sYXN0SW5kZXggIT09IDA7XFxufSkoKTtcXG5cXG52YXIgVU5TVVBQT1JURURfWSA9IHN0aWNreUhlbHBlcnMuVU5TVVBQT1JURURfWSB8fCBzdGlja3lIZWxwZXJzLkJST0tFTl9DQVJFVDtcXG5cXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1hc3NlcnRpb24tY2FwdHVyaW5nLWdyb3VwLCByZWdleHAvbm8tZW1wdHktZ3JvdXAgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xcblxcbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEIHx8IFVOU1VQUE9SVEVEX1k7XFxuXFxuaWYgKFBBVENIKSB7XFxuICBwYXRjaGVkRXhlYyA9IGZ1bmN0aW9uIGV4ZWMoc3RyKSB7XFxuICAgIHZhciByZSA9IHRoaXM7XFxuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XFxuICAgIHZhciBzdGlja3kgPSBVTlNVUFBPUlRFRF9ZICYmIHJlLnN0aWNreTtcXG4gICAgdmFyIGZsYWdzID0gcmVnZXhwRmxhZ3MuY2FsbChyZSk7XFxuICAgIHZhciBzb3VyY2UgPSByZS5zb3VyY2U7XFxuICAgIHZhciBjaGFyc0FkZGVkID0gMDtcXG4gICAgdmFyIHN0ckNvcHkgPSBzdHI7XFxuXFxuICAgIGlmIChzdGlja3kpIHtcXG4gICAgICBmbGFncyA9IGZsYWdzLnJlcGxhY2UoJ3knLCAnJyk7XFxuICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJ2cnKSA9PT0gLTEpIHtcXG4gICAgICAgIGZsYWdzICs9ICdnJztcXG4gICAgICB9XFxuXFxuICAgICAgc3RyQ29weSA9IFN0cmluZyhzdHIpLnNsaWNlKHJlLmxhc3RJbmRleCk7XFxuICAgICAgLy8gU3VwcG9ydCBhbmNob3JlZCBzdGlja3kgYmVoYXZpb3IuXFxuICAgICAgaWYgKHJlLmxhc3RJbmRleCA+IDAgJiYgKCFyZS5tdWx0aWxpbmUgfHwgcmUubXVsdGlsaW5lICYmIHN0cltyZS5sYXN0SW5kZXggLSAxXSAhPT0gJ1xcXFxuJykpIHtcXG4gICAgICAgIHNvdXJjZSA9ICcoPzogJyArIHNvdXJjZSArICcpJztcXG4gICAgICAgIHN0ckNvcHkgPSAnICcgKyBzdHJDb3B5O1xcbiAgICAgICAgY2hhcnNBZGRlZCsrO1xcbiAgICAgIH1cXG4gICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgc3RyIHNsaWNpbmcsIHRvXFxuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxcbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14oPzonICsgc291cmNlICsgJyknLCBmbGFncyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQpIHtcXG4gICAgICByZUNvcHkgPSBuZXcgUmVnRXhwKCdeJyArIHNvdXJjZSArICckKD8hXFxcXFxcXFxzKScsIGZsYWdzKTtcXG4gICAgfVxcbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HKSBsYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XFxuXFxuICAgIG1hdGNoID0gbmF0aXZlRXhlYy5jYWxsKHN0aWNreSA/IHJlQ29weSA6IHJlLCBzdHJDb3B5KTtcXG5cXG4gICAgaWYgKHN0aWNreSkge1xcbiAgICAgIGlmIChtYXRjaCkge1xcbiAgICAgICAgbWF0Y2guaW5wdXQgPSBtYXRjaC5pbnB1dC5zbGljZShjaGFyc0FkZGVkKTtcXG4gICAgICAgIG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoY2hhcnNBZGRlZCk7XFxuICAgICAgICBtYXRjaC5pbmRleCA9IHJlLmxhc3RJbmRleDtcXG4gICAgICAgIHJlLmxhc3RJbmRleCArPSBtYXRjaFswXS5sZW5ndGg7XFxuICAgICAgfSBlbHNlIHJlLmxhc3RJbmRleCA9IDA7XFxuICAgIH0gZWxzZSBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XFxuICAgICAgcmUubGFzdEluZGV4ID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XFxuICAgIH1cXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xcbiAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXFxuICAgICAgbmF0aXZlUmVwbGFjZS5jYWxsKG1hdGNoWzBdLCByZUNvcHksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XFxuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG1hdGNoO1xcbiAgfTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaGVkRXhlYztcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA3MDY2Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2NzApO1xcblxcbi8vIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBnZXR0ZXIgaW1wbGVtZW50YXRpb25cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xcbiAgdmFyIHJlc3VsdCA9ICcnO1xcbiAgaWYgKHRoYXQuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcXG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcXG4gIGlmICh0aGF0LmRvdEFsbCkgcmVzdWx0ICs9ICdzJztcXG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XFxuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMjk5OTpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MjkzKTtcXG5cXG4vLyBiYWJlbC1taW5pZnkgdHJhbnNwaWxlcyBSZWdFeHAoJ2EnLCAneScpIC0+IC9hL3kgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvcixcXG4vLyBzbyB3ZSB1c2UgYW4gaW50ZXJtZWRpYXRlIGZ1bmN0aW9uLlxcbmZ1bmN0aW9uIFJFKHMsIGYpIHtcXG4gIHJldHVybiBSZWdFeHAocywgZik7XFxufVxcblxcbmV4cG9ydHMuVU5TVVBQT1JURURfWSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIC8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgnYScsICd5JykgLT4gL2EveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXFxuICB2YXIgcmUgPSBSRSgnYScsICd5Jyk7XFxuICByZS5sYXN0SW5kZXggPSAyO1xcbiAgcmV0dXJuIHJlLmV4ZWMoJ2FiY2QnKSAhPSBudWxsO1xcbn0pO1xcblxcbmV4cG9ydHMuQlJPS0VOX0NBUkVUID0gZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzczNjg3XFxuICB2YXIgcmUgPSBSRSgnXnInLCAnZ3knKTtcXG4gIHJlLmxhc3RJbmRleCA9IDI7XFxuICByZXR1cm4gcmUuZXhlYygnc3RyJykgIT0gbnVsbDtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA0NDg4Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcXG5cXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcXFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXFxcIiArIGl0KTtcXG4gIHJldHVybiBpdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDM1MDU6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzg1NCk7XFxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oODg4MCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgdHJ5IHtcXG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGdsb2JhbCwga2V5LCB2YWx1ZSk7XFxuICB9IGNhdGNoIChlcnJvcikge1xcbiAgICBnbG9iYWxba2V5XSA9IHZhbHVlO1xcbiAgfSByZXR1cm4gdmFsdWU7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA2MzQwOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oNTAwNSk7XFxudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDcwKTtcXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTEyKTtcXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3ODEpO1xcblxcbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xcbiAgdmFyIENvbnN0cnVjdG9yID0gZ2V0QnVpbHRJbihDT05TVFJVQ1RPUl9OQU1FKTtcXG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XFxuXFxuICBpZiAoREVTQ1JJUFRPUlMgJiYgQ29uc3RydWN0b3IgJiYgIUNvbnN0cnVjdG9yW1NQRUNJRVNdKSB7XFxuICAgIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTLCB7XFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxcbiAgICB9KTtcXG4gIH1cXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDgwMDM6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDcwKS5mO1xcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2NTYpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxMTIpO1xcblxcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBTVEFUSUMgPyBpdCA6IGl0LnByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcXG4gICAgZGVmaW5lUHJvcGVydHkoaXQsIFRPX1NUUklOR19UQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xcbiAgfVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNjIwMDpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzA5KTtcXG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NzExKTtcXG5cXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNTQ2NTpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODU0KTtcXG52YXIgc2V0R2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNTA1KTtcXG5cXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XFxudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgc2V0R2xvYmFsKFNIQVJFRCwge30pO1xcblxcbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMjMwOTpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkxMyk7XFxudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NDY1KTtcXG5cXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XFxufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xcbiAgdmVyc2lvbjogJzMuOS4wJyxcXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcXG4gIGNvcHlyaWdodDogJ1xceEE5IDIwMjEgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNjcwNzpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2NzApO1xcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwOTkpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxMTIpO1xcblxcbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XFxuXFxuLy8gYFNwZWNpZXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zcGVjaWVzY29uc3RydWN0b3JcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcXG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XFxuICB2YXIgUztcXG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUZ1bmN0aW9uKFMpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gODcxMDpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTU4KTtcXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQ4OCk7XFxuXFxuLy8gYFN0cmluZy5wcm90b3R5cGUueyBjb2RlUG9pbnRBdCwgYXQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxcbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoQ09OVkVSVF9UT19TVFJJTkcpIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xcbiAgICB2YXIgUyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XFxuICAgIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlcihwb3MpO1xcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcXG4gICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBzaXplKSByZXR1cm4gQ09OVkVSVF9UT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcXG4gICAgZmlyc3QgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24pO1xcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXFxuICAgICAgfHwgKHNlY29uZCA9IFMuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcXG4gICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkcgPyBTLmNoYXJBdChwb3NpdGlvbikgOiBmaXJzdFxcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklORyA/IFMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgMikgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xcbiAgfTtcXG59O1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMzE5NzpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9wdW55Y29kZS5qcy9ibG9iL21hc3Rlci9wdW55Y29kZS5qc1xcbnZhciBtYXhJbnQgPSAyMTQ3NDgzNjQ3OyAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXFxudmFyIGJhc2UgPSAzNjtcXG52YXIgdE1pbiA9IDE7XFxudmFyIHRNYXggPSAyNjtcXG52YXIgc2tldyA9IDM4O1xcbnZhciBkYW1wID0gNzAwO1xcbnZhciBpbml0aWFsQmlhcyA9IDcyO1xcbnZhciBpbml0aWFsTiA9IDEyODsgLy8gMHg4MFxcbnZhciBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXFxceDJEJ1xcbnZhciByZWdleE5vbkFTQ0lJID0gL1teXFxcXDAtXFxcXHUwMDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xcbnZhciByZWdleFNlcGFyYXRvcnMgPSAvWy5cXFxcdTMwMDJcXFxcdUZGMEVcXFxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcXG52YXIgT1ZFUkZMT1dfRVJST1IgPSAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnO1xcbnZhciBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XFxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcXG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcXG5cXG4vKipcXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXFxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXFxuICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXFxuICogbWF0Y2hpbmcgVVRGLTE2LlxcbiAqL1xcbnZhciB1Y3MyZGVjb2RlID0gZnVuY3Rpb24gKHN0cmluZykge1xcbiAgdmFyIG91dHB1dCA9IFtdO1xcbiAgdmFyIGNvdW50ZXIgPSAwO1xcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XFxuICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xcbiAgICB2YXIgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xcbiAgICBpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XFxuICAgICAgLy8gSXQncyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci5cXG4gICAgICB2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xcbiAgICAgIGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBMb3cgc3Vycm9nYXRlLlxcbiAgICAgICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcXG4gICAgICAgIC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxcbiAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xcbiAgICAgICAgY291bnRlci0tO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBvdXRwdXQ7XFxufTtcXG5cXG4vKipcXG4gKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXFxuICovXFxudmFyIGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIChkaWdpdCkge1xcbiAgLy8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcXG4gIC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxcbiAgcmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KTtcXG59O1xcblxcbi8qKlxcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXFxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcXG4gKi9cXG52YXIgYWRhcHQgPSBmdW5jdGlvbiAoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XFxuICB2YXIgayA9IDA7XFxuICBkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xcbiAgZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xcbiAgZm9yICg7IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XFxuICAgIGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcXG4gIH1cXG4gIHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xcbn07XFxuXFxuLyoqXFxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcXG4gKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxcbiAqL1xcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50cyAtLSBUT0RPXFxudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xcbiAgdmFyIG91dHB1dCA9IFtdO1xcblxcbiAgLy8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cXG4gIGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XFxuXFxuICAvLyBDYWNoZSB0aGUgbGVuZ3RoLlxcbiAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xcblxcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXFxuICB2YXIgbiA9IGluaXRpYWxOO1xcbiAgdmFyIGRlbHRhID0gMDtcXG4gIHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XFxuICB2YXIgaSwgY3VycmVudFZhbHVlO1xcblxcbiAgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cXG4gIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xcbiAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtpXTtcXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcXG4gICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7IC8vIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cXG4gIHZhciBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoOyAvLyBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcXG5cXG4gIC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXFxuICBpZiAoYmFzaWNMZW5ndGgpIHtcXG4gICAgb3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcXG4gIH1cXG5cXG4gIC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcXG4gIHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XFxuICAgIC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHQgbGFyZ2VyIG9uZTpcXG4gICAgdmFyIG0gPSBtYXhJbnQ7XFxuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2ldO1xcbiAgICAgIGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XFxuICAgICAgICBtID0gY3VycmVudFZhbHVlO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxcbiAgICB2YXIgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xcbiAgICBpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xcbiAgICAgIHRocm93IFJhbmdlRXJyb3IoT1ZFUkZMT1dfRVJST1IpO1xcbiAgICB9XFxuXFxuICAgIGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XFxuICAgIG4gPSBtO1xcblxcbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcXG4gICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtpXTtcXG4gICAgICBpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XFxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKE9WRVJGTE9XX0VSUk9SKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XFxuICAgICAgICAvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cXG4gICAgICAgIHZhciBxID0gZGVsdGE7XFxuICAgICAgICBmb3IgKHZhciBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcXG4gICAgICAgICAgdmFyIHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xcbiAgICAgICAgICBpZiAocSA8IHQpIGJyZWFrO1xcbiAgICAgICAgICB2YXIgcU1pbnVzVCA9IHEgLSB0O1xcbiAgICAgICAgICB2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCkpKTtcXG4gICAgICAgICAgcSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSkpKTtcXG4gICAgICAgIGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XFxuICAgICAgICBkZWx0YSA9IDA7XFxuICAgICAgICArK2hhbmRsZWRDUENvdW50O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICArK2RlbHRhO1xcbiAgICArK247XFxuICB9XFxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQpIHtcXG4gIHZhciBlbmNvZGVkID0gW107XFxuICB2YXIgbGFiZWxzID0gaW5wdXQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xcXFx1MDAyRScpLnNwbGl0KCcuJyk7XFxuICB2YXIgaSwgbGFiZWw7XFxuICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XFxuICAgIGxhYmVsID0gbGFiZWxzW2ldO1xcbiAgICBlbmNvZGVkLnB1c2gocmVnZXhOb25BU0NJSS50ZXN0KGxhYmVsKSA/ICd4bi0tJyArIGVuY29kZShsYWJlbCkgOiBsYWJlbCk7XFxuICB9XFxuICByZXR1cm4gZW5jb2RlZC5qb2luKCcuJyk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA2MDkxOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNzI5Myk7XFxudmFyIHdoaXRlc3BhY2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzYxKTtcXG5cXG52YXIgbm9uID0gJ1xcXFx1MjAwQlxcXFx1MDA4NVxcXFx1MTgwRSc7XFxuXFxuLy8gY2hlY2sgdGhhdCBhIG1ldGhvZCB3b3JrcyB3aXRoIHRoZSBjb3JyZWN0IGxpc3RcXG4vLyBvZiB3aGl0ZXNwYWNlcyBhbmQgaGFzIGEgY29ycmVjdCBuYW1lXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcXG4gIHJldHVybiBmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiAhIXdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXSgpIHx8IG5vbltNRVRIT0RfTkFNRV0oKSAhPSBub24gfHwgd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdLm5hbWUgIT09IE1FVEhPRF9OQU1FO1xcbiAgfSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAzMTExOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDg4KTtcXG52YXIgd2hpdGVzcGFjZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNjEpO1xcblxcbnZhciB3aGl0ZXNwYWNlID0gJ1snICsgd2hpdGVzcGFjZXMgKyAnXSc7XFxudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcXG52YXIgcnRyaW0gPSBSZWdFeHAod2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKiQnKTtcXG5cXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW0sIHRyaW1TdGFydCwgdHJpbUVuZCwgdHJpbUxlZnQsIHRyaW1SaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXFxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XFxuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xcbiAgICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XFxuICAgIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcXG4gICAgcmV0dXJuIHN0cmluZztcXG4gIH07XFxufTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUxlZnQsIHRyaW1TdGFydCB9YCBtZXRob2RzXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbXN0YXJ0XFxuICBzdGFydDogY3JlYXRlTWV0aG9kKDEpLFxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltUmlnaHQsIHRyaW1FbmQgfWAgbWV0aG9kc1xcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1lbmRcXG4gIGVuZDogY3JlYXRlTWV0aG9kKDIpLFxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxcbiAgdHJpbTogY3JlYXRlTWV0aG9kKDMpXFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAxNDAwOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5NTgpO1xcblxcbnZhciBtYXggPSBNYXRoLm1heDtcXG52YXIgbWluID0gTWF0aC5taW47XFxuXFxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XFxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxcbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXIoaW5kZXgpO1xcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA3MDY3Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5NTgpO1xcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNzQ2Nik7XFxuXFxuLy8gYFRvSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbmRleFxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XFxuICB2YXIgbnVtYmVyID0gdG9JbnRlZ2VyKGl0KTtcXG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChudW1iZXIpO1xcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGggb3IgaW5kZXgnKTtcXG4gIHJldHVybiBsZW5ndGg7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA1NjU2Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXFxudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgzNjEpO1xcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDg4KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gOTk1ODpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XFxuXFxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XFxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcXG5cXG4vLyBgVG9JbnRlZ2VyYCBhYnN0cmFjdCBvcGVyYXRpb25cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlclxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDc0NjY6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTk1OCk7XFxuXFxudmFyIG1pbiA9IE1hdGgubWluO1xcblxcbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlcihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNzkwODpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQ4OCk7XFxuXFxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcXG4gIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNDU5MDpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgdG9Qb3NpdGl2ZUludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwMDIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBCWVRFUykge1xcbiAgdmFyIG9mZnNldCA9IHRvUG9zaXRpdmVJbnRlZ2VyKGl0KTtcXG4gIGlmIChvZmZzZXQgJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0Jyk7XFxuICByZXR1cm4gb2Zmc2V0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMzAwMjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTU4KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgdmFyIHJlc3VsdCA9IHRvSW50ZWdlcihpdCk7XFxuICBpZiAocmVzdWx0IDwgMCkgdGhyb3cgUmFuZ2VFcnJvcihcXFwiVGhlIGFyZ3VtZW50IGNhbid0IGJlIGxlc3MgdGhhbiAwXFxcIik7XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNzU5MzpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMSk7XFxuXFxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXFxuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2VcXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBQUkVGRVJSRURfU1RSSU5HKSB7XFxuICBpZiAoIWlzT2JqZWN0KGlucHV0KSkgcmV0dXJuIGlucHV0O1xcbiAgdmFyIGZuLCB2YWw7XFxuICBpZiAoUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcXG4gIGlmICh0eXBlb2YgKGZuID0gaW5wdXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xcbiAgaWYgKCFQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xcbiAgdGhyb3cgVHlwZUVycm9yKFxcXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcXFwiKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDE2OTQ6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTExMik7XFxuXFxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XFxudmFyIHRlc3QgPSB7fTtcXG5cXG50ZXN0W1RPX1NUUklOR19UQUddID0gJ3onO1xcblxcbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gOTg0MzpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMDkpO1xcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4NTQpO1xcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oOTc4MSk7XFxudmFyIFRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4MzIpO1xcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjApO1xcbnZhciBBcnJheUJ1ZmZlck1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMzMSk7XFxudmFyIGFuSW5zdGFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3ODcpO1xcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTQpO1xcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4ODApO1xcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNzQ2Nik7XFxudmFyIHRvSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwNjcpO1xcbnZhciB0b09mZnNldCA9IF9fd2VicGFja19yZXF1aXJlX18oNDU5MCk7XFxudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTkzKTtcXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjU2KTtcXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oNjQ4KTtcXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMSk7XFxudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xcbnZhciBzZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oNzY3NCk7XFxudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwMDYpLmY7XFxudmFyIHR5cGVkQXJyYXlGcm9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MzIxKTtcXG52YXIgZm9yRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMjA5MikuZm9yRWFjaDtcXG52YXIgc2V0U3BlY2llcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjM0MCk7XFxudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDcwKTtcXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjM2KTtcXG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTkwOSk7XFxudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTg3KTtcXG5cXG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XFxudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcXG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XFxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcXG52YXIgUmFuZ2VFcnJvciA9IGdsb2JhbC5SYW5nZUVycm9yO1xcbnZhciBBcnJheUJ1ZmZlciA9IEFycmF5QnVmZmVyTW9kdWxlLkFycmF5QnVmZmVyO1xcbnZhciBEYXRhVmlldyA9IEFycmF5QnVmZmVyTW9kdWxlLkRhdGFWaWV3O1xcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTO1xcbnZhciBUWVBFRF9BUlJBWV9UQUcgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLlRZUEVEX0FSUkFZX1RBRztcXG52YXIgVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuVHlwZWRBcnJheTtcXG52YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IEFycmF5QnVmZmVyVmlld0NvcmUuVHlwZWRBcnJheVByb3RvdHlwZTtcXG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcXG52YXIgaXNUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5pc1R5cGVkQXJyYXk7XFxudmFyIEJZVEVTX1BFUl9FTEVNRU5UID0gJ0JZVEVTX1BFUl9FTEVNRU5UJztcXG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCc7XFxuXFxudmFyIGZyb21MaXN0ID0gZnVuY3Rpb24gKEMsIGxpc3QpIHtcXG4gIHZhciBpbmRleCA9IDA7XFxuICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XFxuICB2YXIgcmVzdWx0ID0gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yKEMpKShsZW5ndGgpO1xcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG52YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcXG4gIG5hdGl2ZURlZmluZVByb3BlcnR5KGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpW2tleV07XFxuICB9IH0pO1xcbn07XFxuXFxudmFyIGlzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHZhciBrbGFzcztcXG4gIHJldHVybiBpdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoaXQpKSA9PSAnQXJyYXlCdWZmZXInIHx8IGtsYXNzID09ICdTaGFyZWRBcnJheUJ1ZmZlcic7XFxufTtcXG5cXG52YXIgaXNUeXBlZEFycmF5SW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcXG4gIHJldHVybiBpc1R5cGVkQXJyYXkodGFyZ2V0KVxcbiAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXFxuICAgICYmIGtleSBpbiB0YXJnZXRcXG4gICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xcbn07XFxuXFxudmFyIHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcXG4gIHJldHVybiBpc1R5cGVkQXJyYXlJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXFxuICAgID8gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDIsIHRhcmdldFtrZXldKVxcbiAgICA6IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XFxufTtcXG5cXG52YXIgd3JhcHBlZERlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcXG4gIGlmIChpc1R5cGVkQXJyYXlJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXFxuICAgICYmIGlzT2JqZWN0KGRlc2NyaXB0b3IpXFxuICAgICYmIGhhcyhkZXNjcmlwdG9yLCAndmFsdWUnKVxcbiAgICAmJiAhaGFzKGRlc2NyaXB0b3IsICdnZXQnKVxcbiAgICAmJiAhaGFzKGRlc2NyaXB0b3IsICdzZXQnKVxcbiAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xcbiAgICAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGVcXG4gICAgJiYgKCFoYXMoZGVzY3JpcHRvciwgJ3dyaXRhYmxlJykgfHwgZGVzY3JpcHRvci53cml0YWJsZSlcXG4gICAgJiYgKCFoYXMoZGVzY3JpcHRvciwgJ2VudW1lcmFibGUnKSB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUpXFxuICApIHtcXG4gICAgdGFyZ2V0W2tleV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xcbiAgICByZXR1cm4gdGFyZ2V0O1xcbiAgfSByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xcbn07XFxuXFxuaWYgKERFU0NSSVBUT1JTKSB7XFxuICBpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIHtcXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYgPSB3cmFwcGVkR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xcbiAgICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mID0gd3JhcHBlZERlZmluZVByb3BlcnR5O1xcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J1ZmZlcicpO1xcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J5dGVPZmZzZXQnKTtcXG4gICAgYWRkR2V0dGVyKFR5cGVkQXJyYXlQcm90b3R5cGUsICdieXRlTGVuZ3RoJyk7XFxuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnbGVuZ3RoJyk7XFxuICB9XFxuXFxuICAkKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB9LCB7XFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogd3JhcHBlZEdldE93blByb3BlcnR5RGVzY3JpcHRvcixcXG4gICAgZGVmaW5lUHJvcGVydHk6IHdyYXBwZWREZWZpbmVQcm9wZXJ0eVxcbiAgfSk7XFxuXFxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUWVBFLCB3cmFwcGVyLCBDTEFNUEVEKSB7XFxuICAgIHZhciBCWVRFUyA9IFRZUEUubWF0Y2goL1xcXFxkKyQvKVswXSAvIDg7XFxuICAgIHZhciBDT05TVFJVQ1RPUl9OQU1FID0gVFlQRSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcXG4gICAgdmFyIEdFVFRFUiA9ICdnZXQnICsgVFlQRTtcXG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgVFlQRTtcXG4gICAgdmFyIE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbFtDT05TVFJVQ1RPUl9OQU1FXTtcXG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcXG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlO1xcbiAgICB2YXIgZXhwb3J0ZWQgPSB7fTtcXG5cXG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xcbiAgICAgIHZhciBkYXRhID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcXG4gICAgICByZXR1cm4gZGF0YS52aWV3W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEuYnl0ZU9mZnNldCwgdHJ1ZSk7XFxuICAgIH07XFxuXFxuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgsIHZhbHVlKSB7XFxuICAgICAgdmFyIGRhdGEgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xcbiAgICAgIGlmIChDTEFNUEVEKSB2YWx1ZSA9ICh2YWx1ZSA9IHJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhGRiA/IDB4RkYgOiB2YWx1ZSAmIDB4RkY7XFxuICAgICAgZGF0YS52aWV3W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEuYnl0ZU9mZnNldCwgdmFsdWUsIHRydWUpO1xcbiAgICB9O1xcblxcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xcbiAgICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KHRoYXQsIGluZGV4LCB7XFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XFxuICAgICAgICB9LFxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSB7XFxuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgb2Zmc2V0LCAkbGVuZ3RoKSB7XFxuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSk7XFxuICAgICAgICB2YXIgaW5kZXggPSAwO1xcbiAgICAgICAgdmFyIGJ5dGVPZmZzZXQgPSAwO1xcbiAgICAgICAgdmFyIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoO1xcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xcbiAgICAgICAgICBsZW5ndGggPSB0b0luZGV4KGRhdGEpO1xcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XFxuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihkYXRhKSkge1xcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xcbiAgICAgICAgICBieXRlT2Zmc2V0ID0gdG9PZmZzZXQob2Zmc2V0LCBCWVRFUyk7XFxuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xcbiAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gYnl0ZU9mZnNldDtcXG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8IDApIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcXG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIGJ5dGVPZmZzZXQgPiAkbGVuKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xcbiAgICAgICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHtcXG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXR1cm4gdHlwZWRBcnJheUZyb20uY2FsbChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XFxuICAgICAgICAgIGJ1ZmZlcjogYnVmZmVyLFxcbiAgICAgICAgICBieXRlT2Zmc2V0OiBieXRlT2Zmc2V0LFxcbiAgICAgICAgICBieXRlTGVuZ3RoOiBieXRlTGVuZ3RoLFxcbiAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcXG4gICAgICAgICAgdmlldzogbmV3IERhdGFWaWV3KGJ1ZmZlcilcXG4gICAgICAgIH0pO1xcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSBhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBUeXBlZEFycmF5KTtcXG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKFR5cGVkQXJyYXlQcm90b3R5cGUpO1xcbiAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMpIHtcXG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uIChkdW1teSwgZGF0YSwgdHlwZWRBcnJheU9mZnNldCwgJGxlbmd0aCkge1xcbiAgICAgICAgYW5JbnN0YW5jZShkdW1teSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FKTtcXG4gICAgICAgIHJldHVybiBpbmhlcml0SWZSZXF1aXJlZChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKHRvSW5kZXgoZGF0YSkpO1xcbiAgICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlcihkYXRhKSkgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxcbiAgICAgICAgICAgID8gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhLCB0b09mZnNldCh0eXBlZEFycmF5T2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpXFxuICAgICAgICAgICAgOiB0eXBlZEFycmF5T2Zmc2V0ICE9PSB1bmRlZmluZWRcXG4gICAgICAgICAgICAgID8gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhLCB0b09mZnNldCh0eXBlZEFycmF5T2Zmc2V0LCBCWVRFUykpXFxuICAgICAgICAgICAgICA6IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSk7XFxuICAgICAgICAgIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xcbiAgICAgICAgICByZXR1cm4gdHlwZWRBcnJheUZyb20uY2FsbChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xcbiAgICAgICAgfSgpLCBkdW1teSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgVHlwZWRBcnJheSk7XFxuICAgICAgZm9yRWFjaChnZXRPd25Qcm9wZXJ0eU5hbWVzKE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciksIGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3IpKSB7XFxuICAgICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShUeXBlZEFycmF5Q29uc3RydWN0b3IsIGtleSwgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yW2tleV0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGU7XFxuICAgIH1cXG5cXG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZS5jb25zdHJ1Y3RvciAhPT0gVHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XFxuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheUNvbnN0cnVjdG9yKTtcXG4gICAgfVxcblxcbiAgICBpZiAoVFlQRURfQVJSQVlfVEFHKSB7XFxuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgVFlQRURfQVJSQVlfVEFHLCBDT05TVFJVQ1RPUl9OQU1FKTtcXG4gICAgfVxcblxcbiAgICBleHBvcnRlZFtDT05TVFJVQ1RPUl9OQU1FXSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcXG5cXG4gICAgJCh7XFxuICAgICAgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAhPSBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IsIHNoYW06ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTXFxuICAgIH0sIGV4cG9ydGVkKTtcXG5cXG4gICAgaWYgKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yKSkge1xcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShUeXBlZEFycmF5Q29uc3RydWN0b3IsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlKSkge1xcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XFxuICAgIH1cXG5cXG4gICAgc2V0U3BlY2llcyhDT05TVFJVQ1RPUl9OQU1FKTtcXG4gIH07XFxufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDM4MzI6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tbmV3IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzg1NCk7XFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MjkzKTtcXG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDcyKTtcXG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYwKS5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTO1xcblxcbnZhciBBcnJheUJ1ZmZlciA9IGdsb2JhbC5BcnJheUJ1ZmZlcjtcXG52YXIgSW50OEFycmF5ID0gZ2xvYmFsLkludDhBcnJheTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICBJbnQ4QXJyYXkoMSk7XFxufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIG5ldyBJbnQ4QXJyYXkoLTEpO1xcbn0pIHx8ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XFxuICBuZXcgSW50OEFycmF5KCk7XFxuICBuZXcgSW50OEFycmF5KG51bGwpO1xcbiAgbmV3IEludDhBcnJheSgxLjUpO1xcbiAgbmV3IEludDhBcnJheShpdGVyYWJsZSk7XFxufSwgdHJ1ZSkgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgLy8gU2FmYXJpICgxMSspIGJ1ZyAtIGEgcmVhc29uIHdoeSBldmVuIFNhZmFyaSAxMyBzaG91bGQgbG9hZCBhIHR5cGVkIGFycmF5IHBvbHlmaWxsXFxuICByZXR1cm4gbmV3IEludDhBcnJheShuZXcgQXJyYXlCdWZmZXIoMiksIDEsIHVuZGVmaW5lZCkubGVuZ3RoICE9PSAxO1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDMwNzQ6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MCkuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzA3KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgbGlzdCkge1xcbiAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IoaW5zdGFuY2UsIGluc3RhbmNlLmNvbnN0cnVjdG9yKTtcXG4gIHZhciBpbmRleCA9IDA7XFxuICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XFxuICB2YXIgcmVzdWx0ID0gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yKEMpKShsZW5ndGgpO1xcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA3MzIxOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzkwOCk7XFxudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDY2KTtcXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNDYpO1xcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NTkpO1xcbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTc0KTtcXG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjYwKS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBmbiwgdGhpc0FyZyAqLykge1xcbiAgdmFyIE8gPSB0b09iamVjdChzb3VyY2UpO1xcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XFxuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xcbiAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoTyk7XFxuICB2YXIgaSwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yLCBuZXh0O1xcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICE9IHVuZGVmaW5lZCAmJiAhaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkge1xcbiAgICBpdGVyYXRvciA9IGl0ZXJhdG9yTWV0aG9kLmNhbGwoTyk7XFxuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xcbiAgICBPID0gW107XFxuICAgIHdoaWxlICghKHN0ZXAgPSBuZXh0LmNhbGwoaXRlcmF0b3IpKS5kb25lKSB7XFxuICAgICAgTy5wdXNoKHN0ZXAudmFsdWUpO1xcbiAgICB9XFxuICB9XFxuICBpZiAobWFwcGluZyAmJiBhcmd1bWVudHNMZW5ndGggPiAyKSB7XFxuICAgIG1hcGZuID0gYmluZChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcXG4gIH1cXG4gIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcXG4gIHJlc3VsdCA9IG5ldyAoYVR5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0aGlzKSkobGVuZ3RoKTtcXG4gIGZvciAoaSA9IDA7IGxlbmd0aCA+IGk7IGkrKykge1xcbiAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDk3MTE6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xcblxcbnZhciBpZCA9IDA7XFxudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xcbiAgcmV0dXJuICdTeW1ib2woJyArIFN0cmluZyhrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyAoKytpZCArIHBvc3RmaXgpLnRvU3RyaW5nKDM2KTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDMzMDc6XFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfU1lNQk9MXFxuICAvKiBnbG9iYWwgU3ltYm9sIC0tIHNhZmUgKi9cXG4gICYmICFTeW1ib2wuc2hhbVxcbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA1MTEyOlxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4NTQpO1xcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzMDkpO1xcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2NTYpO1xcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3MTEpO1xcbnZhciBOQVRJVkVfU1lNQk9MID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzMpO1xcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IF9fd2VicGFja19yZXF1aXJlX18oMzMwNyk7XFxuXFxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XFxudmFyIFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XFxudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sIDogU3ltYm9sICYmIFN5bWJvbC53aXRob3V0U2V0dGVyIHx8IHVpZDtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICBpZiAoIWhhcyhXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpKSB7XFxuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhcyhTeW1ib2wsIG5hbWUpKSBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2xbbmFtZV07XFxuICAgIGVsc2UgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKCdTeW1ib2wuJyArIG5hbWUpO1xcbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMTM2MTpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XFxuXFxuLy8gYSBzdHJpbmcgb2YgYWxsIHZhbGlkIHVuaWNvZGUgd2hpdGVzcGFjZXNcXG5tb2R1bGUuZXhwb3J0cyA9ICdcXFxcdTAwMDlcXFxcdTAwMEFcXFxcdTAwMEJcXFxcdTAwMENcXFxcdTAwMERcXFxcdTAwMjBcXFxcdTAwQTBcXFxcdTE2ODBcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDInICtcXG4gICdcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMEFcXFxcdTIwMkZcXFxcdTIwNUZcXFxcdTMwMDBcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdUZFRkYnO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDgyNjQ6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMDkpO1xcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4NTQpO1xcbnZhciBhcnJheUJ1ZmZlck1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMzMSk7XFxudmFyIHNldFNwZWNpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzNDApO1xcblxcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xcbnZhciBBcnJheUJ1ZmZlciA9IGFycmF5QnVmZmVyTW9kdWxlW0FSUkFZX0JVRkZFUl07XFxudmFyIE5hdGl2ZUFycmF5QnVmZmVyID0gZ2xvYmFsW0FSUkFZX0JVRkZFUl07XFxuXFxuLy8gYEFycmF5QnVmZmVyYCBjb25zdHJ1Y3Rvclxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlidWZmZXItY29uc3RydWN0b3JcXG4kKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IE5hdGl2ZUFycmF5QnVmZmVyICE9PSBBcnJheUJ1ZmZlciB9LCB7XFxuICBBcnJheUJ1ZmZlcjogQXJyYXlCdWZmZXJcXG59KTtcXG5cXG5zZXRTcGVjaWVzKEFSUkFZX0JVRkZFUik7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMjIyMjpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEwOSk7XFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MjkzKTtcXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMzE1Nyk7XFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTEpO1xcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzkwOCk7XFxudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDY2KTtcXG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxMzUpO1xcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0MTcpO1xcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTk0KTtcXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTEyKTtcXG52YXIgVjhfVkVSU0lPTiA9IF9fd2VicGFja19yZXF1aXJlX18oNzM5Mik7XFxuXFxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gd2VsbEtub3duU3ltYm9sKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7XFxudmFyIE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCA9ICdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnO1xcblxcbi8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xcbi8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3OVxcbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUID0gVjhfVkVSU0lPTiA+PSA1MSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgdmFyIGFycmF5ID0gW107XFxuICBhcnJheVtJU19DT05DQVRfU1BSRUFEQUJMRV0gPSBmYWxzZTtcXG4gIHJldHVybiBhcnJheS5jb25jYXQoKVswXSAhPT0gYXJyYXk7XFxufSk7XFxuXFxudmFyIFNQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2NvbmNhdCcpO1xcblxcbnZhciBpc0NvbmNhdFNwcmVhZGFibGUgPSBmdW5jdGlvbiAoTykge1xcbiAgaWYgKCFpc09iamVjdChPKSkgcmV0dXJuIGZhbHNlO1xcbiAgdmFyIHNwcmVhZGFibGUgPSBPW0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcXG4gIHJldHVybiBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5KE8pO1xcbn07XFxuXFxudmFyIEZPUkNFRCA9ICFJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIHx8ICFTUEVDSUVTX1NVUFBPUlQ7XFxuXFxuLy8gYEFycmF5LnByb3RvdHlwZS5jb25jYXRgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdFxcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBpc0NvbmNhdFNwcmVhZGFibGUgYW5kIEBAc3BlY2llc1xcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxcbiAgY29uY2F0OiBmdW5jdGlvbiBjb25jYXQoYXJnKSB7XFxuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XFxuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xcbiAgICB2YXIgbiA9IDA7XFxuICAgIHZhciBpLCBrLCBsZW5ndGgsIGxlbiwgRTtcXG4gICAgZm9yIChpID0gLTEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICAgIEUgPSBpID09PSAtMSA/IE8gOiBhcmd1bWVudHNbaV07XFxuICAgICAgaWYgKGlzQ29uY2F0U3ByZWFkYWJsZShFKSkge1xcbiAgICAgICAgbGVuID0gdG9MZW5ndGgoRS5sZW5ndGgpO1xcbiAgICAgICAgaWYgKG4gKyBsZW4gPiBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyBUeXBlRXJyb3IoTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEKTtcXG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBsZW47IGsrKywgbisrKSBpZiAoayBpbiBFKSBjcmVhdGVQcm9wZXJ0eShBLCBuLCBFW2tdKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKG4gPj0gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XFxuICAgICAgICBjcmVhdGVQcm9wZXJ0eShBLCBuKyssIEUpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBBLmxlbmd0aCA9IG47XFxuICAgIHJldHVybiBBO1xcbiAgfVxcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDczMjc6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMDkpO1xcbnZhciAkZmlsdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDkyKS5maWx0ZXI7XFxudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOTQpO1xcblxcbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnZmlsdGVyJyk7XFxuXFxuLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQgfSwge1xcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcXG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xcbiAgfVxcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDI3NzI6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMDkpO1xcbnZhciAkaW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMxOCkuaW5kZXhPZjtcXG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTM0MSk7XFxuXFxudmFyIG5hdGl2ZUluZGV4T2YgPSBbXS5pbmRleE9mO1xcblxcbnZhciBORUdBVElWRV9aRVJPID0gISFuYXRpdmVJbmRleE9mICYmIDEgLyBbMV0uaW5kZXhPZigxLCAtMCkgPCAwO1xcbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnaW5kZXhPZicpO1xcblxcbi8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IE5FR0FUSVZFX1pFUk8gfHwgIVNUUklDVF9NRVRIT0QgfSwge1xcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xcbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcXG4gICAgICA/IG5hdGl2ZUluZGV4T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXFxuICAgICAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XFxuICB9XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNjk5MjpcXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTY1Nik7XFxudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMjMpO1xcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0OTcpO1xcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA5KTtcXG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1NCk7XFxuXFxudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xcblxcbi8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xcbi8vIGBBcnJheS5wcm90b3R5cGUua2V5c2AgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcXG4vLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXFxuLy8gYENyZWF0ZUFycmF5SXRlcmF0b3JgIGludGVybmFsIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxcbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XFxuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxcbiAgICBpbmRleDogMCwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcXG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXFxuICB9KTtcXG4vLyBgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcXG59LCBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcXG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcXG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XFxuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XFxuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcXG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xcbiAgfVxcbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlIH07XFxuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IHRhcmdldFtpbmRleF0sIGRvbmU6IGZhbHNlIH07XFxuICByZXR1cm4geyB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSwgZG9uZTogZmFsc2UgfTtcXG59LCAndmFsdWVzJyk7XFxuXFxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGV1bm1hcHBlZGFyZ3VtZW50c29iamVjdFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlbWFwcGVkYXJndW1lbnRzb2JqZWN0XFxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcXG5cXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXFxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAxMjQ5Olxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTA5KTtcXG52YXIgJG1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjA5MikubWFwO1xcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTk0KTtcXG5cXG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ21hcCcpO1xcblxcbi8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHtcXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XFxuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcXG4gIH1cXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA3MDQyOlxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTA5KTtcXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMSk7XFxudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxNTcpO1xcbnZhciB0b0Fic29sdXRlSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MDApO1xcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNzQ2Nik7XFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTY1Nik7XFxudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTM1KTtcXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MTEyKTtcXG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTE5NCk7XFxuXFxudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdzbGljZScpO1xcblxcbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XFxudmFyIG5hdGl2ZVNsaWNlID0gW10uc2xpY2U7XFxudmFyIG1heCA9IE1hdGgubWF4O1xcblxcbi8vIGBBcnJheS5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNsaWNlXFxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHtcXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XFxuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KHRoaXMpO1xcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xcbiAgICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcXG4gICAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcXG4gICAgLy8gaW5saW5lIGBBcnJheVNwZWNpZXNDcmVhdGVgIGZvciB1c2FnZSBuYXRpdmUgYEFycmF5I3NsaWNlYCB3aGVyZSBpdCdzIHBvc3NpYmxlXFxuICAgIHZhciBDb25zdHJ1Y3RvciwgcmVzdWx0LCBuO1xcbiAgICBpZiAoaXNBcnJheShPKSkge1xcbiAgICAgIENvbnN0cnVjdG9yID0gTy5jb25zdHJ1Y3RvcjtcXG4gICAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xcbiAgICAgIGlmICh0eXBlb2YgQ29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAoQ29uc3RydWN0b3IgPT09IEFycmF5IHx8IGlzQXJyYXkoQ29uc3RydWN0b3IucHJvdG90eXBlKSkpIHtcXG4gICAgICAgIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoQ29uc3RydWN0b3IpKSB7XFxuICAgICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yW1NQRUNJRVNdO1xcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBudWxsKSBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBBcnJheSB8fCBDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICByZXR1cm4gbmF0aXZlU2xpY2UuY2FsbChPLCBrLCBmaW4pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXN1bHQgPSBuZXcgKENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgPyBBcnJheSA6IENvbnN0cnVjdG9yKShtYXgoZmluIC0gaywgMCkpO1xcbiAgICBmb3IgKG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgaWYgKGsgaW4gTykgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBuLCBPW2tdKTtcXG4gICAgcmVzdWx0Lmxlbmd0aCA9IG47XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNTYxOlxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTA5KTtcXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDAwKTtcXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTU4KTtcXG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0NjYpO1xcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzkwOCk7XFxudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQxNyk7XFxudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MTM1KTtcXG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTE5NCk7XFxuXFxudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdzcGxpY2UnKTtcXG5cXG52YXIgbWF4ID0gTWF0aC5tYXg7XFxudmFyIG1pbiA9IE1hdGgubWluO1xcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjtcXG52YXIgTUFYSU1VTV9BTExPV0VEX0xFTkdUSF9FWENFRURFRCA9ICdNYXhpbXVtIGFsbG93ZWQgbGVuZ3RoIGV4Y2VlZGVkJztcXG5cXG4vLyBgQXJyYXkucHJvdG90eXBlLnNwbGljZWAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc3BsaWNlXFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCB9LCB7XFxuICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQgLyogLCAuLi5pdGVtcyAqLykge1xcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xcbiAgICB2YXIgYWN0dWFsU3RhcnQgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XFxuICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xcbiAgICB2YXIgaW5zZXJ0Q291bnQsIGFjdHVhbERlbGV0ZUNvdW50LCBBLCBrLCBmcm9tLCB0bztcXG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMCkge1xcbiAgICAgIGluc2VydENvdW50ID0gYWN0dWFsRGVsZXRlQ291bnQgPSAwO1xcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMSkge1xcbiAgICAgIGluc2VydENvdW50ID0gMDtcXG4gICAgICBhY3R1YWxEZWxldGVDb3VudCA9IGxlbiAtIGFjdHVhbFN0YXJ0O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGluc2VydENvdW50ID0gYXJndW1lbnRzTGVuZ3RoIC0gMjtcXG4gICAgICBhY3R1YWxEZWxldGVDb3VudCA9IG1pbihtYXgodG9JbnRlZ2VyKGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcXG4gICAgfVxcbiAgICBpZiAobGVuICsgaW5zZXJ0Q291bnQgLSBhY3R1YWxEZWxldGVDb3VudCA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcXG4gICAgICB0aHJvdyBUeXBlRXJyb3IoTUFYSU1VTV9BTExPV0VEX0xFTkdUSF9FWENFRURFRCk7XFxuICAgIH1cXG4gICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCBhY3R1YWxEZWxldGVDb3VudCk7XFxuICAgIGZvciAoayA9IDA7IGsgPCBhY3R1YWxEZWxldGVDb3VudDsgaysrKSB7XFxuICAgICAgZnJvbSA9IGFjdHVhbFN0YXJ0ICsgaztcXG4gICAgICBpZiAoZnJvbSBpbiBPKSBjcmVhdGVQcm9wZXJ0eShBLCBrLCBPW2Zyb21dKTtcXG4gICAgfVxcbiAgICBBLmxlbmd0aCA9IGFjdHVhbERlbGV0ZUNvdW50O1xcbiAgICBpZiAoaW5zZXJ0Q291bnQgPCBhY3R1YWxEZWxldGVDb3VudCkge1xcbiAgICAgIGZvciAoayA9IGFjdHVhbFN0YXJ0OyBrIDwgbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xcbiAgICAgICAgZnJvbSA9IGsgKyBhY3R1YWxEZWxldGVDb3VudDtcXG4gICAgICAgIHRvID0gayArIGluc2VydENvdW50O1xcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xcbiAgICAgICAgZWxzZSBkZWxldGUgT1t0b107XFxuICAgICAgfVxcbiAgICAgIGZvciAoayA9IGxlbjsgayA+IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7IGstLSkgZGVsZXRlIE9bayAtIDFdO1xcbiAgICB9IGVsc2UgaWYgKGluc2VydENvdW50ID4gYWN0dWFsRGVsZXRlQ291bnQpIHtcXG4gICAgICBmb3IgKGsgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDsgayA+IGFjdHVhbFN0YXJ0OyBrLS0pIHtcXG4gICAgICAgIGZyb20gPSBrICsgYWN0dWFsRGVsZXRlQ291bnQgLSAxO1xcbiAgICAgICAgdG8gPSBrICsgaW5zZXJ0Q291bnQgLSAxO1xcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xcbiAgICAgICAgZWxzZSBkZWxldGUgT1t0b107XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGZvciAoayA9IDA7IGsgPCBpbnNlcnRDb3VudDsgaysrKSB7XFxuICAgICAgT1trICsgYWN0dWFsU3RhcnRdID0gYXJndW1lbnRzW2sgKyAyXTtcXG4gICAgfVxcbiAgICBPLmxlbmd0aCA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7XFxuICAgIHJldHVybiBBO1xcbiAgfVxcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDgzMDk6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3ODEpO1xcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMzA3MCkuZjtcXG5cXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XFxudmFyIEZ1bmN0aW9uUHJvdG90eXBlVG9TdHJpbmcgPSBGdW5jdGlvblByb3RvdHlwZS50b1N0cmluZztcXG52YXIgbmFtZVJFID0gL15cXFxccypmdW5jdGlvbiAoW14gKF0qKS87XFxudmFyIE5BTUUgPSAnbmFtZSc7XFxuXFxuLy8gRnVuY3Rpb24gaW5zdGFuY2VzIGAubmFtZWAgcHJvcGVydHlcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLWluc3RhbmNlcy1uYW1lXFxuaWYgKERFU0NSSVBUT1JTICYmICEoTkFNRSBpbiBGdW5jdGlvblByb3RvdHlwZSkpIHtcXG4gIGRlZmluZVByb3BlcnR5KEZ1bmN0aW9uUHJvdG90eXBlLCBOQU1FLCB7XFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHJldHVybiBGdW5jdGlvblByb3RvdHlwZVRvU3RyaW5nLmNhbGwodGhpcykubWF0Y2gobmFtZVJFKVsxXTtcXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xcbiAgICAgICAgcmV0dXJuICcnO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSk7XFxufVxcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDQ4OTpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTA5KTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyOTMpO1xcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzkwOCk7XFxudmFyIG5hdGl2ZUdldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTE4KTtcXG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTQ0KTtcXG5cXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgbmF0aXZlR2V0UHJvdG90eXBlT2YoMSk7IH0pO1xcblxcbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXFxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUywgc2hhbTogIUNPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiB9LCB7XFxuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcXG4gICAgcmV0dXJuIG5hdGl2ZUdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XFxuICB9XFxufSk7XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMTUzOTpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OTQpO1xcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMyMCk7XFxudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyODgpO1xcblxcbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcXG5pZiAoIVRPX1NUUklOR19UQUdfU1VQUE9SVCkge1xcbiAgcmVkZWZpbmUoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgdG9TdHJpbmcsIHsgdW5zYWZlOiB0cnVlIH0pO1xcbn1cXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA0OTE2Olxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTA5KTtcXG52YXIgZXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oMjI2MSk7XFxuXFxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZXhlY2AgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLmV4ZWNcXG4kKHsgdGFyZ2V0OiAnUmVnRXhwJywgcHJvdG86IHRydWUsIGZvcmNlZDogLy4vLmV4ZWMgIT09IGV4ZWMgfSwge1xcbiAgZXhlYzogZXhlY1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDk3MTQ6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzIwKTtcXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2NzApO1xcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNzI5Myk7XFxudmFyIGZsYWdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDY2KTtcXG5cXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcXG52YXIgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcXG52YXIgbmF0aXZlVG9TdHJpbmcgPSBSZWdFeHBQcm90b3R5cGVbVE9fU1RSSU5HXTtcXG5cXG52YXIgTk9UX0dFTkVSSUMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRpdmVUb1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KTtcXG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxcbnZhciBJTkNPUlJFQ1RfTkFNRSA9IG5hdGl2ZVRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HO1xcblxcbi8vIGBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcXG5pZiAoTk9UX0dFTkVSSUMgfHwgSU5DT1JSRUNUX05BTUUpIHtcXG4gIHJlZGVmaW5lKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XFxuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XFxuICAgIHZhciBwID0gU3RyaW5nKFIuc291cmNlKTtcXG4gICAgdmFyIHJmID0gUi5mbGFncztcXG4gICAgdmFyIGYgPSBTdHJpbmcocmYgPT09IHVuZGVmaW5lZCAmJiBSIGluc3RhbmNlb2YgUmVnRXhwICYmICEoJ2ZsYWdzJyBpbiBSZWdFeHBQcm90b3R5cGUpID8gZmxhZ3MuY2FsbChSKSA6IHJmKTtcXG4gICAgcmV0dXJuICcvJyArIHAgKyAnLycgKyBmO1xcbiAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XFxufVxcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDg3ODM6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIGNoYXJBdCA9IF9fd2VicGFja19yZXF1aXJlX18oODcxMCkuY2hhckF0O1xcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA5KTtcXG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1NCk7XFxuXFxudmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XFxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihTVFJJTkdfSVRFUkFUT1IpO1xcblxcbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxcbmRlZmluZUl0ZXJhdG9yKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XFxuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcXG4gICAgc3RyaW5nOiBTdHJpbmcoaXRlcmF0ZWQpLFxcbiAgICBpbmRleDogMFxcbiAgfSk7XFxuLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcXG59LCBmdW5jdGlvbiBuZXh0KCkge1xcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcXG4gIHZhciBzdHJpbmcgPSBzdGF0ZS5zdHJpbmc7XFxuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleDtcXG4gIHZhciBwb2ludDtcXG4gIGlmIChpbmRleCA+PSBzdHJpbmcubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XFxuICBwb2ludCA9IGNoYXJBdChzdHJpbmcsIGluZGV4KTtcXG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcXG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA0NzIzOlxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNzAwNyk7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjcwKTtcXG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0NjYpO1xcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDg4KTtcXG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTMwKTtcXG52YXIgcmVnRXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oNzY1MSk7XFxuXFxuLy8gQEBtYXRjaCBsb2dpY1xcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdtYXRjaCcsIDEsIGZ1bmN0aW9uIChNQVRDSCwgbmF0aXZlTWF0Y2gsIG1heWJlQ2FsbE5hdGl2ZSkge1xcbiAgcmV0dXJuIFtcXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgIG1ldGhvZFxcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUubWF0Y2hcXG4gICAgZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XFxuICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xcbiAgICAgIHZhciBtYXRjaGVyID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XFxuICAgICAgcmV0dXJuIG1hdGNoZXIgIT09IHVuZGVmaW5lZCA/IG1hdGNoZXIuY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xcbiAgICB9LFxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXWAgbWV0aG9kXFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQG1hdGNoXFxuICAgIGZ1bmN0aW9uIChyZWdleHApIHtcXG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZU1hdGNoLCByZWdleHAsIHRoaXMpO1xcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcXG5cXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xcblxcbiAgICAgIGlmICghcnguZ2xvYmFsKSByZXR1cm4gcmVnRXhwRXhlYyhyeCwgUyk7XFxuXFxuICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcXG4gICAgICByeC5sYXN0SW5kZXggPSAwO1xcbiAgICAgIHZhciBBID0gW107XFxuICAgICAgdmFyIG4gPSAwO1xcbiAgICAgIHZhciByZXN1bHQ7XFxuICAgICAgd2hpbGUgKChyZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKSkgIT09IG51bGwpIHtcXG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xcbiAgICAgICAgQVtuXSA9IG1hdGNoU3RyO1xcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcXG4gICAgICAgIG4rKztcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG4gPT09IDAgPyBudWxsIDogQTtcXG4gICAgfVxcbiAgXTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA1MzA2Olxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNzAwNyk7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjcwKTtcXG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0NjYpO1xcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5NTgpO1xcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDg4KTtcXG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTMwKTtcXG52YXIgZ2V0U3Vic3RpdHV0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDcpO1xcbnZhciByZWdFeHBFeGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjUxKTtcXG5cXG52YXIgbWF4ID0gTWF0aC5tYXg7XFxudmFyIG1pbiA9IE1hdGgubWluO1xcblxcbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcXG59O1xcblxcbi8vIEBAcmVwbGFjZSBsb2dpY1xcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24gKFJFUExBQ0UsIG5hdGl2ZVJlcGxhY2UsIG1heWJlQ2FsbE5hdGl2ZSwgcmVhc29uKSB7XFxuICB2YXIgUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUgPSByZWFzb24uUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkU7XFxuICB2YXIgUkVQTEFDRV9LRUVQU18kMCA9IHJlYXNvbi5SRVBMQUNFX0tFRVBTXyQwO1xcbiAgdmFyIFVOU0FGRV9TVUJTVElUVVRFID0gUkVHRVhQX1JFUExBQ0VfU1VCU1RJVFVURVNfVU5ERUZJTkVEX0NBUFRVUkUgPyAnJCcgOiAnJDAnO1xcblxcbiAgcmV0dXJuIFtcXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgbWV0aG9kXFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlXFxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcXG4gICAgICB2YXIgcmVwbGFjZXIgPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcXG4gICAgICByZXR1cm4gcmVwbGFjZXIgIT09IHVuZGVmaW5lZFxcbiAgICAgICAgPyByZXBsYWNlci5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXFxuICAgICAgICA6IG5hdGl2ZVJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xcbiAgICB9LFxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxcbiAgICBmdW5jdGlvbiAocmVnZXhwLCByZXBsYWNlVmFsdWUpIHtcXG4gICAgICBpZiAoXFxuICAgICAgICAoIVJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFICYmIFJFUExBQ0VfS0VFUFNfJDApIHx8XFxuICAgICAgICAodHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ3N0cmluZycgJiYgcmVwbGFjZVZhbHVlLmluZGV4T2YoVU5TQUZFX1NVQlNUSVRVVEUpID09PSAtMSlcXG4gICAgICApIHtcXG4gICAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlUmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xcbiAgICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xcblxcbiAgICAgIHZhciBmdW5jdGlvbmFsUmVwbGFjZSA9IHR5cGVvZiByZXBsYWNlVmFsdWUgPT09ICdmdW5jdGlvbic7XFxuICAgICAgaWYgKCFmdW5jdGlvbmFsUmVwbGFjZSkgcmVwbGFjZVZhbHVlID0gU3RyaW5nKHJlcGxhY2VWYWx1ZSk7XFxuXFxuICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcXG4gICAgICBpZiAoZ2xvYmFsKSB7XFxuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcXG4gICAgICB9XFxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcXG4gICAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpO1xcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XFxuXFxuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcXG4gICAgICAgIGlmICghZ2xvYmFsKSBicmVhaztcXG5cXG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XFxuICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xcblxcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBTdHJpbmcocmVzdWx0WzBdKTtcXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG1heChtaW4odG9JbnRlZ2VyKHJlc3VsdC5pbmRleCksIFMubGVuZ3RoKSwgMCk7XFxuICAgICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXF1aXZhbGVudCB0b1xcbiAgICAgICAgLy8gICBjYXB0dXJlcyA9IHJlc3VsdC5zbGljZSgxKS5tYXAobWF5YmVUb1N0cmluZylcXG4gICAgICAgIC8vIGJ1dCBmb3Igc29tZSByZWFzb24gYG5hdGl2ZVNsaWNlLmNhbGwocmVzdWx0LCAxLCByZXN1bHQubGVuZ3RoKWAgKGNhbGxlZCBpblxcbiAgICAgICAgLy8gdGhlIHNsaWNlIHBvbHlmaWxsIHdoZW4gc2xpY2luZyBuYXRpdmUgYXJyYXlzKSBcXFwiZG9lc24ndCB3b3JrXFxcIiBpbiBzYWZhcmkgOSBhbmRcXG4gICAgICAgIC8vIGNhdXNlcyBhIGNyYXNoIChodHRwczovL3Bhc3RlYmluLmNvbS9OMjFRemVRQSkgd2hlbiB0cnlpbmcgdG8gZGVidWcgaXQuXFxuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJlc3VsdC5sZW5ndGg7IGorKykgY2FwdHVyZXMucHVzaChtYXliZVRvU3RyaW5nKHJlc3VsdFtqXSkpO1xcbiAgICAgICAgdmFyIG5hbWVkQ2FwdHVyZXMgPSByZXN1bHQuZ3JvdXBzO1xcbiAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XFxuICAgICAgICAgIHZhciByZXBsYWNlckFyZ3MgPSBbbWF0Y2hlZF0uY29uY2F0KGNhcHR1cmVzLCBwb3NpdGlvbiwgUyk7XFxuICAgICAgICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHJlcGxhY2VyQXJncy5wdXNoKG5hbWVkQ2FwdHVyZXMpO1xcbiAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBTdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXBsYWNlbWVudCA9IGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBTLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VWYWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAocG9zaXRpb24gPj0gbmV4dFNvdXJjZVBvc2l0aW9uKSB7XFxuICAgICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0ICs9IFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uLCBwb3NpdGlvbikgKyByZXBsYWNlbWVudDtcXG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24pO1xcbiAgICB9XFxuICBdO1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDMxMjM6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIGZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDA3KTtcXG52YXIgaXNSZWdFeHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4NTApO1xcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTY3MCk7XFxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0ODgpO1xcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3MDcpO1xcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1MzApO1xcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNzQ2Nik7XFxudmFyIGNhbGxSZWdFeHBFeGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjUxKTtcXG52YXIgcmVnZXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oMjI2MSk7XFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MjkzKTtcXG5cXG52YXIgYXJyYXlQdXNoID0gW10ucHVzaDtcXG52YXIgbWluID0gTWF0aC5taW47XFxudmFyIE1BWF9VSU5UMzIgPSAweEZGRkZGRkZGO1xcblxcbi8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgneCcsICd5JykgLT4gL3gveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXFxudmFyIFNVUFBPUlRTX1kgPSAhZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gIVJlZ0V4cChNQVhfVUlOVDMyLCAneScpOyB9KTtcXG5cXG4vLyBAQHNwbGl0IGxvZ2ljXFxuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3NwbGl0JywgMiwgZnVuY3Rpb24gKFNQTElULCBuYXRpdmVTcGxpdCwgbWF5YmVDYWxsTmF0aXZlKSB7XFxuICB2YXIgaW50ZXJuYWxTcGxpdDtcXG4gIGlmIChcXG4gICAgJ2FiYmMnLnNwbGl0KC8oYikqLylbMV0gPT0gJ2MnIHx8XFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZW1wdHktZ3JvdXAgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcXG4gICAgJ3Rlc3QnLnNwbGl0KC8oPzopLywgLTEpLmxlbmd0aCAhPSA0IHx8XFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT0gMiB8fFxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9IDQgfHxcXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1hc3NlcnRpb24tY2FwdHVyaW5nLWdyb3VwLCByZWdleHAvbm8tZW1wdHktZ3JvdXAgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcXG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMSB8fFxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGhcXG4gICkge1xcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcXG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XFxuICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKTtcXG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcXG4gICAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XFxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW3N0cmluZ107XFxuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcXG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHtcXG4gICAgICAgIHJldHVybiBuYXRpdmVTcGxpdC5jYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW0pO1xcbiAgICAgIH1cXG4gICAgICB2YXIgb3V0cHV0ID0gW107XFxuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXFxuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcXG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XFxuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcXG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xcbiAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xcbiAgICAgIHdoaWxlIChtYXRjaCA9IHJlZ2V4cEV4ZWMuY2FsbChzZXBhcmF0b3JDb3B5LCBzdHJpbmcpKSB7XFxuICAgICAgICBsYXN0SW5kZXggPSBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleDtcXG4gICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XFxuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xcbiAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIGFycmF5UHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcXG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcXG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcXG4gICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltKSBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHkubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcXG4gICAgICB9XFxuICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcXG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSBvdXRwdXQucHVzaCgnJyk7XFxuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XFxuICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW0gPyBvdXRwdXQuc2xpY2UoMCwgbGltKSA6IG91dHB1dDtcXG4gICAgfTtcXG4gIC8vIENoYWtyYSwgVjhcXG4gIH0gZWxzZSBpZiAoJzAnLnNwbGl0KHVuZGVmaW5lZCwgMCkubGVuZ3RoKSB7XFxuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogbmF0aXZlU3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcXG4gICAgfTtcXG4gIH0gZWxzZSBpbnRlcm5hbFNwbGl0ID0gbmF0aXZlU3BsaXQ7XFxuXFxuICByZXR1cm4gW1xcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgbWV0aG9kXFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxcbiAgICBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XFxuICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xcbiAgICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xcbiAgICAgIHJldHVybiBzcGxpdHRlciAhPT0gdW5kZWZpbmVkXFxuICAgICAgICA/IHNwbGl0dGVyLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdClcXG4gICAgICAgIDogaW50ZXJuYWxTcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XFxuICAgIH0sXFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdYCBtZXRob2RcXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAc3BsaXRcXG4gICAgLy9cXG4gICAgLy8gTk9URTogVGhpcyBjYW5ub3QgYmUgcHJvcGVybHkgcG9seWZpbGxlZCBpbiBlbmdpbmVzIHRoYXQgZG9uJ3Qgc3VwcG9ydFxcbiAgICAvLyB0aGUgJ3knIGZsYWcuXFxuICAgIGZ1bmN0aW9uIChyZWdleHAsIGxpbWl0KSB7XFxuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShpbnRlcm5hbFNwbGl0LCByZWdleHAsIHRoaXMsIGxpbWl0LCBpbnRlcm5hbFNwbGl0ICE9PSBuYXRpdmVTcGxpdCk7XFxuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xcblxcbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XFxuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XFxuICAgICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IocngsIFJlZ0V4cCk7XFxuXFxuICAgICAgdmFyIHVuaWNvZGVNYXRjaGluZyA9IHJ4LnVuaWNvZGU7XFxuICAgICAgdmFyIGZsYWdzID0gKHJ4Lmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xcbiAgICAgICAgICAgICAgICAgIChyeC5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xcbiAgICAgICAgICAgICAgICAgIChyeC51bmljb2RlID8gJ3UnIDogJycpICtcXG4gICAgICAgICAgICAgICAgICAoU1VQUE9SVFNfWSA/ICd5JyA6ICdnJyk7XFxuXFxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIFMgc2xpY2luZywgdG9cXG4gICAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXFxuICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IEMoU1VQUE9SVFNfWSA/IHJ4IDogJ14oPzonICsgcnguc291cmNlICsgJyknLCBmbGFncyk7XFxuICAgICAgdmFyIGxpbSA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XFxuICAgICAgaWYgKGxpbSA9PT0gMCkgcmV0dXJuIFtdO1xcbiAgICAgIGlmIChTLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTKSA9PT0gbnVsbCA/IFtTXSA6IFtdO1xcbiAgICAgIHZhciBwID0gMDtcXG4gICAgICB2YXIgcSA9IDA7XFxuICAgICAgdmFyIEEgPSBbXTtcXG4gICAgICB3aGlsZSAocSA8IFMubGVuZ3RoKSB7XFxuICAgICAgICBzcGxpdHRlci5sYXN0SW5kZXggPSBTVVBQT1JUU19ZID8gcSA6IDA7XFxuICAgICAgICB2YXIgeiA9IGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTVVBQT1JUU19ZID8gUyA6IFMuc2xpY2UocSkpO1xcbiAgICAgICAgdmFyIGU7XFxuICAgICAgICBpZiAoXFxuICAgICAgICAgIHogPT09IG51bGwgfHxcXG4gICAgICAgICAgKGUgPSBtaW4odG9MZW5ndGgoc3BsaXR0ZXIubGFzdEluZGV4ICsgKFNVUFBPUlRTX1kgPyAwIDogcSkpLCBTLmxlbmd0aCkpID09PSBwXFxuICAgICAgICApIHtcXG4gICAgICAgICAgcSA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCBxLCB1bmljb2RlTWF0Y2hpbmcpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgQS5wdXNoKFMuc2xpY2UocCwgcSkpO1xcbiAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XFxuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHoubGVuZ3RoIC0gMTsgaSsrKSB7XFxuICAgICAgICAgICAgQS5wdXNoKHpbaV0pO1xcbiAgICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBxID0gcCA9IGU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIEEucHVzaChTLnNsaWNlKHApKTtcXG4gICAgICByZXR1cm4gQTtcXG4gICAgfVxcbiAgXTtcXG59LCAhU1VQUE9SVFNfWSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMzIxMDpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEwOSk7XFxudmFyICR0cmltID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTExKS50cmltO1xcbnZhciBmb3JjZWRTdHJpbmdUcmltTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDkxKTtcXG5cXG4vLyBgU3RyaW5nLnByb3RvdHlwZS50cmltYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdUcmltTWV0aG9kKCd0cmltJykgfSwge1xcbiAgdHJpbTogZnVuY3Rpb24gdHJpbSgpIHtcXG4gICAgcmV0dXJuICR0cmltKHRoaXMpO1xcbiAgfVxcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDI5OTA6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MCk7XFxudmFyICRjb3B5V2l0aGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDQ4KTtcXG5cXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xcblxcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmNvcHlXaXRoaW5gIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5jb3B5d2l0aGluXFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnY29weVdpdGhpbicsIGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCAvKiAsIGVuZCAqLykge1xcbiAgcmV0dXJuICRjb3B5V2l0aGluLmNhbGwoYVR5cGVkQXJyYXkodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA4OTI3Olxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjApO1xcbnZhciAkZXZlcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwOTIpLmV2ZXJ5O1xcblxcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XFxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XFxuXFxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5ldmVyeVxcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ2V2ZXJ5JywgZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcXG4gIHJldHVybiAkZXZlcnkoYVR5cGVkQXJyYXkodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAzMTA1Olxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjApO1xcbnZhciAkZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTI4NSk7XFxuXFxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcXG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcXG5cXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maWxsYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZmlsbFxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnZmlsbCcsIGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCwgZW5kICovKSB7XFxuICByZXR1cm4gJGZpbGwuYXBwbHkoYVR5cGVkQXJyYXkodGhpcyksIGFyZ3VtZW50cyk7XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNTAzNTpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjYwKTtcXG52YXIgJGZpbHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjA5MikuZmlsdGVyO1xcbnZhciBmcm9tU3BlY2llc0FuZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwNzQpO1xcblxcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XFxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XFxuXFxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZmlsdGVyXFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnZmlsdGVyJywgZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XFxuICB2YXIgbGlzdCA9ICRmaWx0ZXIoYVR5cGVkQXJyYXkodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcXG4gIHJldHVybiBmcm9tU3BlY2llc0FuZExpc3QodGhpcywgbGlzdCk7XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNzE3NDpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjYwKTtcXG52YXIgJGZpbmRJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oMjA5MikuZmluZEluZGV4O1xcblxcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XFxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XFxuXFxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZmluZGluZGV4XFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnZmluZEluZGV4JywgZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcXG4gIHJldHVybiAkZmluZEluZGV4KGFUeXBlZEFycmF5KHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA0MzQ1Olxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjApO1xcbnZhciAkZmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjA5MikuZmluZDtcXG5cXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xcblxcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5maW5kXFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnZmluZCcsIGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xcbiAgcmV0dXJuICRmaW5kKGFUeXBlZEFycmF5KHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAyODQ2Olxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjApO1xcbnZhciAkZm9yRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMjA5MikuZm9yRWFjaDtcXG5cXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xcblxcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5mb3JlYWNoXFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnZm9yRWFjaCcsIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcXG4gICRmb3JFYWNoKGFUeXBlZEFycmF5KHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNDczMTpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjYwKTtcXG52YXIgJGluY2x1ZGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzE4KS5pbmNsdWRlcztcXG5cXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xcblxcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuaW5jbHVkZXNcXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdpbmNsdWRlcycsIGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcXG4gIHJldHVybiAkaW5jbHVkZXMoYVR5cGVkQXJyYXkodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA3MjA5Olxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjApO1xcbnZhciAkaW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMxOCkuaW5kZXhPZjtcXG5cXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xcblxcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5pbmRleG9mXFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnaW5kZXhPZicsIGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xcbiAgcmV0dXJuICRpbmRleE9mKGFUeXBlZEFycmF5KHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNjMxOTpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODU0KTtcXG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjYwKTtcXG52YXIgQXJyYXlJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5OTIpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxMTIpO1xcblxcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcXG52YXIgVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5O1xcbnZhciBhcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JzLnZhbHVlcztcXG52YXIgYXJyYXlLZXlzID0gQXJyYXlJdGVyYXRvcnMua2V5cztcXG52YXIgYXJyYXlFbnRyaWVzID0gQXJyYXlJdGVyYXRvcnMuZW50cmllcztcXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xcbnZhciBuYXRpdmVUeXBlZEFycmF5SXRlcmF0b3IgPSBVaW50OEFycmF5ICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlW0lURVJBVE9SXTtcXG5cXG52YXIgQ09SUkVDVF9JVEVSX05BTUUgPSAhIW5hdGl2ZVR5cGVkQXJyYXlJdGVyYXRvclxcbiAgJiYgKG5hdGl2ZVR5cGVkQXJyYXlJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8IG5hdGl2ZVR5cGVkQXJyYXlJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZCk7XFxuXFxudmFyIHR5cGVkQXJyYXlWYWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XFxuICByZXR1cm4gYXJyYXlWYWx1ZXMuY2FsbChhVHlwZWRBcnJheSh0aGlzKSk7XFxufTtcXG5cXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZW50cmllc1xcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ2VudHJpZXMnLCBmdW5jdGlvbiBlbnRyaWVzKCkge1xcbiAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKGFUeXBlZEFycmF5KHRoaXMpKTtcXG59KTtcXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5rZXlzYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUua2V5c1xcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ2tleXMnLCBmdW5jdGlvbiBrZXlzKCkge1xcbiAgcmV0dXJuIGFycmF5S2V5cy5jYWxsKGFUeXBlZEFycmF5KHRoaXMpKTtcXG59KTtcXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS52YWx1ZXNcXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCd2YWx1ZXMnLCB0eXBlZEFycmF5VmFsdWVzLCAhQ09SUkVDVF9JVEVSX05BTUUpO1xcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUtQEBpdGVyYXRvclxcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoSVRFUkFUT1IsIHR5cGVkQXJyYXlWYWx1ZXMsICFDT1JSRUNUX0lURVJfTkFNRSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gODg2NzpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjYwKTtcXG5cXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xcbnZhciAkam9pbiA9IFtdLmpvaW47XFxuXFxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuam9pbmAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmpvaW5cXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ2pvaW4nLCBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xcbiAgcmV0dXJuICRqb2luLmFwcGx5KGFUeXBlZEFycmF5KHRoaXMpLCBhcmd1bWVudHMpO1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDc3ODk6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MCk7XFxudmFyICRsYXN0SW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oNjU4Myk7XFxuXFxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcXG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcXG5cXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5sYXN0SW5kZXhPZmAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmxhc3RpbmRleG9mXFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdsYXN0SW5kZXhPZicsIGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcXG4gIHJldHVybiAkbGFzdEluZGV4T2YuYXBwbHkoYVR5cGVkQXJyYXkodGhpcyksIGFyZ3VtZW50cyk7XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMzczOTpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjYwKTtcXG52YXIgJG1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjA5MikubWFwO1xcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3MDcpO1xcblxcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XFxudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XFxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XFxuXFxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUubWFwYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUubWFwXFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnbWFwJywgZnVuY3Rpb24gbWFwKG1hcGZuIC8qICwgdGhpc0FyZyAqLykge1xcbiAgcmV0dXJuICRtYXAoYVR5cGVkQXJyYXkodGhpcyksIG1hcGZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xcbiAgICByZXR1cm4gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPLmNvbnN0cnVjdG9yKSkpKGxlbmd0aCk7XFxuICB9KTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyA0NDgzOlxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjApO1xcbnZhciAkcmVkdWNlUmlnaHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2NzEpLnJpZ2h0O1xcblxcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XFxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XFxuXFxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUucmVkdWNlUmljaHRgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5yZWR1Y2VyaWdodFxcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ3JlZHVjZVJpZ2h0JywgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xcbiAgcmV0dXJuICRyZWR1Y2VSaWdodChhVHlwZWRBcnJheSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDkzNjg6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MCk7XFxudmFyICRyZWR1Y2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2NzEpLmxlZnQ7XFxuXFxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcXG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcXG5cXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5yZWR1Y2VcXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdyZWR1Y2UnLCBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xcbiAgcmV0dXJuICRyZWR1Y2UoYVR5cGVkQXJyYXkodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAyMDU2Olxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjApO1xcblxcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XFxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XFxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcXG5cXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5yZXZlcnNlYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUucmV2ZXJzZVxcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ3JldmVyc2UnLCBmdW5jdGlvbiByZXZlcnNlKCkge1xcbiAgdmFyIHRoYXQgPSB0aGlzO1xcbiAgdmFyIGxlbmd0aCA9IGFUeXBlZEFycmF5KHRoYXQpLmxlbmd0aDtcXG4gIHZhciBtaWRkbGUgPSBmbG9vcihsZW5ndGggLyAyKTtcXG4gIHZhciBpbmRleCA9IDA7XFxuICB2YXIgdmFsdWU7XFxuICB3aGlsZSAoaW5kZXggPCBtaWRkbGUpIHtcXG4gICAgdmFsdWUgPSB0aGF0W2luZGV4XTtcXG4gICAgdGhhdFtpbmRleCsrXSA9IHRoYXRbLS1sZW5ndGhdO1xcbiAgICB0aGF0W2xlbmd0aF0gPSB2YWx1ZTtcXG4gIH0gcmV0dXJuIHRoYXQ7XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMzQ2MjpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjYwKTtcXG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0NjYpO1xcbnZhciB0b09mZnNldCA9IF9fd2VicGFja19yZXF1aXJlX18oNDU5MCk7XFxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTA4KTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyOTMpO1xcblxcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XFxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XFxuXFxudmFyIEZPUkNFRCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIC8qIGdsb2JhbCBJbnQ4QXJyYXkgLS0gc2FmZSAqL1xcbiAgbmV3IEludDhBcnJheSgxKS5zZXQoe30pO1xcbn0pO1xcblxcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNldGAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNldFxcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ3NldCcsIGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyogLCBvZmZzZXQgKi8pIHtcXG4gIGFUeXBlZEFycmF5KHRoaXMpO1xcbiAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAxKTtcXG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcXG4gIHZhciBzcmMgPSB0b09iamVjdChhcnJheUxpa2UpO1xcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKHNyYy5sZW5ndGgpO1xcbiAgdmFyIGluZGV4ID0gMDtcXG4gIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCcpO1xcbiAgd2hpbGUgKGluZGV4IDwgbGVuKSB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcXG59LCBGT1JDRUQpO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDY3ODpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjYwKTtcXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzA3KTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyOTMpO1xcblxcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XFxudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XFxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XFxudmFyICRzbGljZSA9IFtdLnNsaWNlO1xcblxcbnZhciBGT1JDRUQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvKiBnbG9iYWwgSW50OEFycmF5IC0tIHNhZmUgKi9cXG4gIG5ldyBJbnQ4QXJyYXkoMSkuc2xpY2UoKTtcXG59KTtcXG5cXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zbGljZWAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNsaWNlXFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnc2xpY2UnLCBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XFxuICB2YXIgbGlzdCA9ICRzbGljZS5jYWxsKGFUeXBlZEFycmF5KHRoaXMpLCBzdGFydCwgZW5kKTtcXG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xcbiAgdmFyIGluZGV4ID0gMDtcXG4gIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcXG4gIHZhciByZXN1bHQgPSBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3IoQykpKGxlbmd0aCk7XFxuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59LCBGT1JDRUQpO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDc0NjI6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MCk7XFxudmFyICRzb21lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDkyKS5zb21lO1xcblxcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XFxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XFxuXFxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNvbWVcXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdzb21lJywgZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xcbiAgcmV0dXJuICRzb21lKGFUeXBlZEFycmF5KHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMzgyNDpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjYwKTtcXG5cXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xcbnZhciAkc29ydCA9IFtdLnNvcnQ7XFxuXFxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc29ydGAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNvcnRcXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdzb3J0JywgZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcXG4gIHJldHVybiAkc29ydC5jYWxsKGFUeXBlZEFycmF5KHRoaXMpLCBjb21wYXJlZm4pO1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDUwMjE6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MCk7XFxudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDY2KTtcXG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDAwKTtcXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzA3KTtcXG5cXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xcblxcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnN1YmFycmF5YCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc3ViYXJyYXlcXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdzdWJhcnJheScsIGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpIHtcXG4gIHZhciBPID0gYVR5cGVkQXJyYXkodGhpcyk7XFxuICB2YXIgbGVuZ3RoID0gTy5sZW5ndGg7XFxuICB2YXIgYmVnaW5JbmRleCA9IHRvQWJzb2x1dGVJbmRleChiZWdpbiwgbGVuZ3RoKTtcXG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPLmNvbnN0cnVjdG9yKSkoXFxuICAgIE8uYnVmZmVyLFxcbiAgICBPLmJ5dGVPZmZzZXQgKyBiZWdpbkluZGV4ICogTy5CWVRFU19QRVJfRUxFTUVOVCxcXG4gICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKSkgLSBiZWdpbkluZGV4KVxcbiAgKTtcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAyOTc0Olxcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4NTQpO1xcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjApO1xcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNzI5Myk7XFxuXFxudmFyIEludDhBcnJheSA9IGdsb2JhbC5JbnQ4QXJyYXk7XFxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcXG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcXG52YXIgJHRvTG9jYWxlU3RyaW5nID0gW10udG9Mb2NhbGVTdHJpbmc7XFxudmFyICRzbGljZSA9IFtdLnNsaWNlO1xcblxcbi8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcXG52YXIgVE9fTE9DQUxFX1NUUklOR19CVUcgPSAhIUludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAkdG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgSW50OEFycmF5KDEpKTtcXG59KTtcXG5cXG52YXIgRk9SQ0VEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyBJbnQ4QXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpO1xcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICBJbnQ4QXJyYXkucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcXG59KTtcXG5cXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZ2AgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnRvbG9jYWxlc3RyaW5nXFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgndG9Mb2NhbGVTdHJpbmcnLCBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcXG4gIHJldHVybiAkdG9Mb2NhbGVTdHJpbmcuYXBwbHkoVE9fTE9DQUxFX1NUUklOR19CVUcgPyAkc2xpY2UuY2FsbChhVHlwZWRBcnJheSh0aGlzKSkgOiBhVHlwZWRBcnJheSh0aGlzKSwgYXJndW1lbnRzKTtcXG59LCBGT1JDRUQpO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDUwMTY6XFxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MCkuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyOTMpO1xcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4NTQpO1xcblxcbnZhciBVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXk7XFxudmFyIFVpbnQ4QXJyYXlQcm90b3R5cGUgPSBVaW50OEFycmF5ICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlIHx8IHt9O1xcbnZhciBhcnJheVRvU3RyaW5nID0gW10udG9TdHJpbmc7XFxudmFyIGFycmF5Sm9pbiA9IFtdLmpvaW47XFxuXFxuaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpIHtcXG4gIGFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcXG4gICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xcbiAgfTtcXG59XFxuXFxudmFyIElTX05PVF9BUlJBWV9NRVRIT0QgPSBVaW50OEFycmF5UHJvdG90eXBlLnRvU3RyaW5nICE9IGFycmF5VG9TdHJpbmc7XFxuXFxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS50b3N0cmluZ1xcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ3RvU3RyaW5nJywgYXJyYXlUb1N0cmluZywgSVNfTk9UX0FSUkFZX01FVEhPRCk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMjQ3MjpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBjcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NDMpO1xcblxcbi8vIGBVaW50OEFycmF5YCBjb25zdHJ1Y3Rvclxcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXFxuY3JlYXRlVHlwZWRBcnJheUNvbnN0cnVjdG9yKCdVaW50OCcsIGZ1bmN0aW9uIChpbml0KSB7XFxuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcXG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcXG4gIH07XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gNDc0NzpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4NTQpO1xcbnZhciBET01JdGVyYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgzMjQpO1xcbnZhciBmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTMzKTtcXG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODgwKTtcXG5cXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XFxuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdO1xcbiAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xcbiAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XFxuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSAmJiBDb2xsZWN0aW9uUHJvdG90eXBlLmZvckVhY2ggIT09IGZvckVhY2gpIHRyeSB7XFxuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCAnZm9yRWFjaCcsIGZvckVhY2gpO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgQ29sbGVjdGlvblByb3RvdHlwZS5mb3JFYWNoID0gZm9yRWFjaDtcXG4gIH1cXG59XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gMzk0ODpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4NTQpO1xcbnZhciBET01JdGVyYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgzMjQpO1xcbnZhciBBcnJheUl0ZXJhdG9yTWV0aG9kcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjk5Mik7XFxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oODg4MCk7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTExMik7XFxuXFxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xcbnZhciBBcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JNZXRob2RzLnZhbHVlcztcXG5cXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XFxuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdO1xcbiAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcXG4gICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XFxuICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XFxuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gPSBBcnJheVZhbHVlcztcXG4gICAgfVxcbiAgICBpZiAoIUNvbGxlY3Rpb25Qcm90b3R5cGVbVE9fU1RSSU5HX1RBR10pIHtcXG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgQ09MTEVDVElPTl9OQU1FKTtcXG4gICAgfVxcbiAgICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIGZvciAodmFyIE1FVEhPRF9OQU1FIGluIEFycmF5SXRlcmF0b3JNZXRob2RzKSB7XFxuICAgICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XFxuICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pIHRyeSB7XFxuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgTUVUSE9EX05BTUUsIEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSk7XFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAxNjM3Olxcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4vLyBUT0RPOiBpbiBjb3JlLWpzQDQsIG1vdmUgL21vZHVsZXMvIGRlcGVuZGVuY2llcyB0byBwdWJsaWMgZW50cmllcyBmb3IgYmV0dGVyIG9wdGltaXphdGlvbiBieSB0b29scyBsaWtlIGBwcmVzZXQtZW52YFxcbl9fd2VicGFja19yZXF1aXJlX18oNjk5Mik7XFxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMDkpO1xcbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDA1KTtcXG52YXIgVVNFX05BVElWRV9VUkwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5MCk7XFxudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzIwKTtcXG52YXIgcmVkZWZpbmVBbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNDgpO1xcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oODAwMyk7XFxudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5OTQpO1xcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA5KTtcXG52YXIgYW5JbnN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTc4Nyk7XFxudmFyIGhhc093biA9IF9fd2VicGFja19yZXF1aXJlX18oNjY1Nik7XFxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5NzQpO1xcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NDgpO1xcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTY3MCk7XFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTEpO1xcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTE0KTtcXG52YXIgZ2V0SXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTQpO1xcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTI0Nik7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTExMik7XFxuXFxudmFyICRmZXRjaCA9IGdldEJ1aWx0SW4oJ2ZldGNoJyk7XFxudmFyIEhlYWRlcnMgPSBnZXRCdWlsdEluKCdIZWFkZXJzJyk7XFxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xcbnZhciBVUkxfU0VBUkNIX1BBUkFNUyA9ICdVUkxTZWFyY2hQYXJhbXMnO1xcbnZhciBVUkxfU0VBUkNIX1BBUkFNU19JVEVSQVRPUiA9IFVSTF9TRUFSQ0hfUEFSQU1TICsgJ0l0ZXJhdG9yJztcXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xcbnZhciBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoVVJMX1NFQVJDSF9QQVJBTVMpO1xcbnZhciBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihVUkxfU0VBUkNIX1BBUkFNU19JVEVSQVRPUik7XFxuXFxudmFyIHBsdXMgPSAvXFxcXCsvZztcXG52YXIgc2VxdWVuY2VzID0gQXJyYXkoNCk7XFxuXFxudmFyIHBlcmNlbnRTZXF1ZW5jZSA9IGZ1bmN0aW9uIChieXRlcykge1xcbiAgcmV0dXJuIHNlcXVlbmNlc1tieXRlcyAtIDFdIHx8IChzZXF1ZW5jZXNbYnl0ZXMgLSAxXSA9IFJlZ0V4cCgnKCg/OiVbXFxcXFxcXFxkYS1mXXsyfSl7JyArIGJ5dGVzICsgJ30pJywgJ2dpJykpO1xcbn07XFxuXFxudmFyIHBlcmNlbnREZWNvZGUgPSBmdW5jdGlvbiAoc2VxdWVuY2UpIHtcXG4gIHRyeSB7XFxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc2VxdWVuY2UpO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgcmV0dXJuIHNlcXVlbmNlO1xcbiAgfVxcbn07XFxuXFxudmFyIGRlc2VyaWFsaXplID0gZnVuY3Rpb24gKGl0KSB7XFxuICB2YXIgcmVzdWx0ID0gaXQucmVwbGFjZShwbHVzLCAnICcpO1xcbiAgdmFyIGJ5dGVzID0gNDtcXG4gIHRyeSB7XFxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0KTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgIHdoaWxlIChieXRlcykge1xcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKHBlcmNlbnRTZXF1ZW5jZShieXRlcy0tKSwgcGVyY2VudERlY29kZSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG59O1xcblxcbnZhciBmaW5kID0gL1shJygpfl18JTIwL2c7XFxuXFxudmFyIHJlcGxhY2UgPSB7XFxuICAnISc6ICclMjEnLFxcbiAgXFxcIidcXFwiOiAnJTI3JyxcXG4gICcoJzogJyUyOCcsXFxuICAnKSc6ICclMjknLFxcbiAgJ34nOiAnJTdFJyxcXG4gICclMjAnOiAnKydcXG59O1xcblxcbnZhciByZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xcbiAgcmV0dXJuIHJlcGxhY2VbbWF0Y2hdO1xcbn07XFxuXFxudmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChpdCkucmVwbGFjZShmaW5kLCByZXBsYWNlcik7XFxufTtcXG5cXG52YXIgcGFyc2VTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiAocmVzdWx0LCBxdWVyeSkge1xcbiAgaWYgKHF1ZXJ5KSB7XFxuICAgIHZhciBhdHRyaWJ1dGVzID0gcXVlcnkuc3BsaXQoJyYnKTtcXG4gICAgdmFyIGluZGV4ID0gMDtcXG4gICAgdmFyIGF0dHJpYnV0ZSwgZW50cnk7XFxuICAgIHdoaWxlIChpbmRleCA8IGF0dHJpYnV0ZXMubGVuZ3RoKSB7XFxuICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpbmRleCsrXTtcXG4gICAgICBpZiAoYXR0cmlidXRlLmxlbmd0aCkge1xcbiAgICAgICAgZW50cnkgPSBhdHRyaWJ1dGUuc3BsaXQoJz0nKTtcXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcXG4gICAgICAgICAga2V5OiBkZXNlcmlhbGl6ZShlbnRyeS5zaGlmdCgpKSxcXG4gICAgICAgICAgdmFsdWU6IGRlc2VyaWFsaXplKGVudHJ5LmpvaW4oJz0nKSlcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn07XFxuXFxudmFyIHVwZGF0ZVNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uIChxdWVyeSkge1xcbiAgdGhpcy5lbnRyaWVzLmxlbmd0aCA9IDA7XFxuICBwYXJzZVNlYXJjaFBhcmFtcyh0aGlzLmVudHJpZXMsIHF1ZXJ5KTtcXG59O1xcblxcbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IGZ1bmN0aW9uIChwYXNzZWQsIHJlcXVpcmVkKSB7XFxuICBpZiAocGFzc2VkIDwgcmVxdWlyZWQpIHRocm93IFR5cGVFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcXG59O1xcblxcbnZhciBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvciA9IGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoZnVuY3Rpb24gSXRlcmF0b3IocGFyYW1zLCBraW5kKSB7XFxuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcXG4gICAgdHlwZTogVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IsXFxuICAgIGl0ZXJhdG9yOiBnZXRJdGVyYXRvcihnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHBhcmFtcykuZW50cmllcyksXFxuICAgIGtpbmQ6IGtpbmRcXG4gIH0pO1xcbn0sICdJdGVyYXRvcicsIGZ1bmN0aW9uIG5leHQoKSB7XFxuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XFxuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XFxuICB2YXIgc3RlcCA9IHN0YXRlLml0ZXJhdG9yLm5leHQoKTtcXG4gIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XFxuICBpZiAoIXN0ZXAuZG9uZSkge1xcbiAgICBzdGVwLnZhbHVlID0ga2luZCA9PT0gJ2tleXMnID8gZW50cnkua2V5IDoga2luZCA9PT0gJ3ZhbHVlcycgPyBlbnRyeS52YWx1ZSA6IFtlbnRyeS5rZXksIGVudHJ5LnZhbHVlXTtcXG4gIH0gcmV0dXJuIHN0ZXA7XFxufSk7XFxuXFxuLy8gYFVSTFNlYXJjaFBhcmFtc2AgY29uc3RydWN0b3JcXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS11cmxzZWFyY2hwYXJhbXNcXG52YXIgVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBVUkxTZWFyY2hQYXJhbXMoLyogaW5pdCAqLykge1xcbiAgYW5JbnN0YW5jZSh0aGlzLCBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvciwgVVJMX1NFQVJDSF9QQVJBTVMpO1xcbiAgdmFyIGluaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcXG4gIHZhciB0aGF0ID0gdGhpcztcXG4gIHZhciBlbnRyaWVzID0gW107XFxuICB2YXIgaXRlcmF0b3JNZXRob2QsIGl0ZXJhdG9yLCBuZXh0LCBzdGVwLCBlbnRyeUl0ZXJhdG9yLCBlbnRyeU5leHQsIGZpcnN0LCBzZWNvbmQsIGtleTtcXG5cXG4gIHNldEludGVybmFsU3RhdGUodGhhdCwge1xcbiAgICB0eXBlOiBVUkxfU0VBUkNIX1BBUkFNUyxcXG4gICAgZW50cmllczogZW50cmllcyxcXG4gICAgdXBkYXRlVVJMOiBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sXFxuICAgIHVwZGF0ZVNlYXJjaFBhcmFtczogdXBkYXRlU2VhcmNoUGFyYW1zXFxuICB9KTtcXG5cXG4gIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgaWYgKGlzT2JqZWN0KGluaXQpKSB7XFxuICAgICAgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChpbml0KTtcXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yTWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBpdGVyYXRvciA9IGl0ZXJhdG9yTWV0aG9kLmNhbGwoaW5pdCk7XFxuICAgICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBuZXh0LmNhbGwoaXRlcmF0b3IpKS5kb25lKSB7XFxuICAgICAgICAgIGVudHJ5SXRlcmF0b3IgPSBnZXRJdGVyYXRvcihhbk9iamVjdChzdGVwLnZhbHVlKSk7XFxuICAgICAgICAgIGVudHJ5TmV4dCA9IGVudHJ5SXRlcmF0b3IubmV4dDtcXG4gICAgICAgICAgaWYgKFxcbiAgICAgICAgICAgIChmaXJzdCA9IGVudHJ5TmV4dC5jYWxsKGVudHJ5SXRlcmF0b3IpKS5kb25lIHx8XFxuICAgICAgICAgICAgKHNlY29uZCA9IGVudHJ5TmV4dC5jYWxsKGVudHJ5SXRlcmF0b3IpKS5kb25lIHx8XFxuICAgICAgICAgICAgIWVudHJ5TmV4dC5jYWxsKGVudHJ5SXRlcmF0b3IpLmRvbmVcXG4gICAgICAgICAgKSB0aHJvdyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHNlcXVlbmNlIHdpdGggbGVuZ3RoIDInKTtcXG4gICAgICAgICAgZW50cmllcy5wdXNoKHsga2V5OiBmaXJzdC52YWx1ZSArICcnLCB2YWx1ZTogc2Vjb25kLnZhbHVlICsgJycgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGZvciAoa2V5IGluIGluaXQpIGlmIChoYXNPd24oaW5pdCwga2V5KSkgZW50cmllcy5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiBpbml0W2tleV0gKyAnJyB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBwYXJzZVNlYXJjaFBhcmFtcyhlbnRyaWVzLCB0eXBlb2YgaW5pdCA9PT0gJ3N0cmluZycgPyBpbml0LmNoYXJBdCgwKSA9PT0gJz8nID8gaW5pdC5zbGljZSgxKSA6IGluaXQgOiBpbml0ICsgJycpO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG52YXIgVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlID0gVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IucHJvdG90eXBlO1xcblxcbnJlZGVmaW5lQWxsKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwge1xcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuYXBwZW5kYCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1hcHBlbmRcXG4gIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XFxuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDIpO1xcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xcbiAgICBzdGF0ZS5lbnRyaWVzLnB1c2goeyBrZXk6IG5hbWUgKyAnJywgdmFsdWU6IHZhbHVlICsgJycgfSk7XFxuICAgIHN0YXRlLnVwZGF0ZVVSTCgpO1xcbiAgfSxcXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmRlbGV0ZWAgbWV0aG9kXFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtZGVsZXRlXFxuICAnZGVsZXRlJzogZnVuY3Rpb24gKG5hbWUpIHtcXG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XFxuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcyk7XFxuICAgIHZhciBlbnRyaWVzID0gc3RhdGUuZW50cmllcztcXG4gICAgdmFyIGtleSA9IG5hbWUgKyAnJztcXG4gICAgdmFyIGluZGV4ID0gMDtcXG4gICAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcXG4gICAgICBpZiAoZW50cmllc1tpbmRleF0ua2V5ID09PSBrZXkpIGVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcXG4gICAgICBlbHNlIGluZGV4Kys7XFxuICAgIH1cXG4gICAgc3RhdGUudXBkYXRlVVJMKCk7XFxuICB9LFxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZ2V0YCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1nZXRcXG4gIGdldDogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcXG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XFxuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xcbiAgICB2YXIga2V5ID0gbmFtZSArICcnO1xcbiAgICB2YXIgaW5kZXggPSAwO1xcbiAgICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xcbiAgICAgIGlmIChlbnRyaWVzW2luZGV4XS5rZXkgPT09IGtleSkgcmV0dXJuIGVudHJpZXNbaW5kZXhdLnZhbHVlO1xcbiAgICB9XFxuICAgIHJldHVybiBudWxsO1xcbiAgfSxcXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmdldEFsbGAgbWV0aG9kXFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtZ2V0YWxsXFxuICBnZXRBbGw6IGZ1bmN0aW9uIGdldEFsbChuYW1lKSB7XFxuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xcbiAgICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcXG4gICAgdmFyIGtleSA9IG5hbWUgKyAnJztcXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xcbiAgICB2YXIgaW5kZXggPSAwO1xcbiAgICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xcbiAgICAgIGlmIChlbnRyaWVzW2luZGV4XS5rZXkgPT09IGtleSkgcmVzdWx0LnB1c2goZW50cmllc1tpbmRleF0udmFsdWUpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9LFxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaGFzYCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1oYXNcXG4gIGhhczogZnVuY3Rpb24gaGFzKG5hbWUpIHtcXG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XFxuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xcbiAgICB2YXIga2V5ID0gbmFtZSArICcnO1xcbiAgICB2YXIgaW5kZXggPSAwO1xcbiAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xcbiAgICAgIGlmIChlbnRyaWVzW2luZGV4KytdLmtleSA9PT0ga2V5KSByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9LFxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuc2V0YCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1zZXRcXG4gIHNldDogZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XFxuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xcbiAgICB2YXIgZW50cmllcyA9IHN0YXRlLmVudHJpZXM7XFxuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xcbiAgICB2YXIga2V5ID0gbmFtZSArICcnO1xcbiAgICB2YXIgdmFsID0gdmFsdWUgKyAnJztcXG4gICAgdmFyIGluZGV4ID0gMDtcXG4gICAgdmFyIGVudHJ5O1xcbiAgICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpbmRleF07XFxuICAgICAgaWYgKGVudHJ5LmtleSA9PT0ga2V5KSB7XFxuICAgICAgICBpZiAoZm91bmQpIGVudHJpZXMuc3BsaWNlKGluZGV4LS0sIDEpO1xcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcXG4gICAgICAgICAgZW50cnkudmFsdWUgPSB2YWw7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICghZm91bmQpIGVudHJpZXMucHVzaCh7IGtleToga2V5LCB2YWx1ZTogdmFsIH0pO1xcbiAgICBzdGF0ZS51cGRhdGVVUkwoKTtcXG4gIH0sXFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5zb3J0YCBtZXRob2RcXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1zb3J0XFxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KCkge1xcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xcbiAgICB2YXIgZW50cmllcyA9IHN0YXRlLmVudHJpZXM7XFxuICAgIC8vIEFycmF5I3NvcnQgaXMgbm90IHN0YWJsZSBpbiBzb21lIGVuZ2luZXNcXG4gICAgdmFyIHNsaWNlID0gZW50cmllcy5zbGljZSgpO1xcbiAgICB2YXIgZW50cnksIGVudHJpZXNJbmRleCwgc2xpY2VJbmRleDtcXG4gICAgZW50cmllcy5sZW5ndGggPSAwO1xcbiAgICBmb3IgKHNsaWNlSW5kZXggPSAwOyBzbGljZUluZGV4IDwgc2xpY2UubGVuZ3RoOyBzbGljZUluZGV4KyspIHtcXG4gICAgICBlbnRyeSA9IHNsaWNlW3NsaWNlSW5kZXhdO1xcbiAgICAgIGZvciAoZW50cmllc0luZGV4ID0gMDsgZW50cmllc0luZGV4IDwgc2xpY2VJbmRleDsgZW50cmllc0luZGV4KyspIHtcXG4gICAgICAgIGlmIChlbnRyaWVzW2VudHJpZXNJbmRleF0ua2V5ID4gZW50cnkua2V5KSB7XFxuICAgICAgICAgIGVudHJpZXMuc3BsaWNlKGVudHJpZXNJbmRleCwgMCwgZW50cnkpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKGVudHJpZXNJbmRleCA9PT0gc2xpY2VJbmRleCkgZW50cmllcy5wdXNoKGVudHJ5KTtcXG4gICAgfVxcbiAgICBzdGF0ZS51cGRhdGVVUkwoKTtcXG4gIH0sXFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2sgLyogLCB0aGlzQXJnICovKSB7XFxuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2ssIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcXG4gICAgdmFyIGluZGV4ID0gMDtcXG4gICAgdmFyIGVudHJ5O1xcbiAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpbmRleCsrXTtcXG4gICAgICBib3VuZEZ1bmN0aW9uKGVudHJ5LnZhbHVlLCBlbnRyeS5rZXksIHRoaXMpO1xcbiAgICB9XFxuICB9LFxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUua2V5c2AgbWV0aG9kXFxuICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yKHRoaXMsICdrZXlzJyk7XFxuICB9LFxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUudmFsdWVzYCBtZXRob2RcXG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yKHRoaXMsICd2YWx1ZXMnKTtcXG4gIH0sXFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2RcXG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XFxuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IodGhpcywgJ2VudHJpZXMnKTtcXG4gIH1cXG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XFxuXFxuLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxcbnJlZGVmaW5lKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgSVRFUkFUT1IsIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5lbnRyaWVzKTtcXG5cXG4vLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXFxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmxzZWFyY2hwYXJhbXMtc3RyaW5naWZpY2F0aW9uLWJlaGF2aW9yXFxucmVkZWZpbmUoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcXG4gIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xcbiAgdmFyIHJlc3VsdCA9IFtdO1xcbiAgdmFyIGluZGV4ID0gMDtcXG4gIHZhciBlbnRyeTtcXG4gIHdoaWxlIChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSB7XFxuICAgIGVudHJ5ID0gZW50cmllc1tpbmRleCsrXTtcXG4gICAgcmVzdWx0LnB1c2goc2VyaWFsaXplKGVudHJ5LmtleSkgKyAnPScgKyBzZXJpYWxpemUoZW50cnkudmFsdWUpKTtcXG4gIH0gcmV0dXJuIHJlc3VsdC5qb2luKCcmJyk7XFxufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xcblxcbnNldFRvU3RyaW5nVGFnKFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yLCBVUkxfU0VBUkNIX1BBUkFNUyk7XFxuXFxuJCh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiAhVVNFX05BVElWRV9VUkwgfSwge1xcbiAgVVJMU2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3Rvclxcbn0pO1xcblxcbi8vIFdyYXAgYGZldGNoYCBmb3IgY29ycmVjdCB3b3JrIHdpdGggcG9seWZpbGxlZCBgVVJMU2VhcmNoUGFyYW1zYFxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzRcXG5pZiAoIVVTRV9OQVRJVkVfVVJMICYmIHR5cGVvZiAkZmV0Y2ggPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSGVhZGVycyA9PSAnZnVuY3Rpb24nKSB7XFxuICAkKHsgZ2xvYmFsOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xcbiAgICBmZXRjaDogZnVuY3Rpb24gZmV0Y2goaW5wdXQgLyogLCBpbml0ICovKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBbaW5wdXRdO1xcbiAgICAgIHZhciBpbml0LCBib2R5LCBoZWFkZXJzO1xcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgaW5pdCA9IGFyZ3VtZW50c1sxXTtcXG4gICAgICAgIGlmIChpc09iamVjdChpbml0KSkge1xcbiAgICAgICAgICBib2R5ID0gaW5pdC5ib2R5O1xcbiAgICAgICAgICBpZiAoY2xhc3NvZihib2R5KSA9PT0gVVJMX1NFQVJDSF9QQVJBTVMpIHtcXG4gICAgICAgICAgICBoZWFkZXJzID0gaW5pdC5oZWFkZXJzID8gbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzKSA6IG5ldyBIZWFkZXJzKCk7XFxuICAgICAgICAgICAgaWYgKCFoZWFkZXJzLmhhcygnY29udGVudC10eXBlJykpIHtcXG4gICAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW5pdCA9IGNyZWF0ZShpbml0LCB7XFxuICAgICAgICAgICAgICBib2R5OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgU3RyaW5nKGJvZHkpKSxcXG4gICAgICAgICAgICAgIGhlYWRlcnM6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBoZWFkZXJzKVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBhcmdzLnB1c2goaW5pdCk7XFxuICAgICAgfSByZXR1cm4gJGZldGNoLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgICB9XFxuICB9KTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBVUkxTZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yLFxcbiAgZ2V0U3RhdGU6IGdldEludGVybmFsUGFyYW1zU3RhdGVcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIDI4NTpcXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4vLyBUT0RPOiBpbiBjb3JlLWpzQDQsIG1vdmUgL21vZHVsZXMvIGRlcGVuZGVuY2llcyB0byBwdWJsaWMgZW50cmllcyBmb3IgYmV0dGVyIG9wdGltaXphdGlvbiBieSB0b29scyBsaWtlIGBwcmVzZXQtZW52YFxcbl9fd2VicGFja19yZXF1aXJlX18oODc4Myk7XFxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMDkpO1xcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oOTc4MSk7XFxudmFyIFVTRV9OQVRJVkVfVVJMID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTApO1xcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4NTQpO1xcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDQ4KTtcXG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMjApO1xcbnZhciBhbkluc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nzg3KTtcXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjU2KTtcXG52YXIgYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTc0KTtcXG52YXIgYXJyYXlGcm9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDU3KTtcXG52YXIgY29kZUF0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NzEwKS5jb2RlQXQ7XFxudmFyIHRvQVNDSUkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxOTcpO1xcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oODAwMyk7XFxudmFyIFVSTFNlYXJjaFBhcmFtc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYzNyk7XFxudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MDkpO1xcblxcbnZhciBOYXRpdmVVUkwgPSBnbG9iYWwuVVJMO1xcbnZhciBVUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXNNb2R1bGUuVVJMU2VhcmNoUGFyYW1zO1xcbnZhciBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlID0gVVJMU2VhcmNoUGFyYW1zTW9kdWxlLmdldFN0YXRlO1xcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XFxudmFyIGdldEludGVybmFsVVJMU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcignVVJMJyk7XFxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcXG52YXIgcG93ID0gTWF0aC5wb3c7XFxuXFxudmFyIElOVkFMSURfQVVUSE9SSVRZID0gJ0ludmFsaWQgYXV0aG9yaXR5JztcXG52YXIgSU5WQUxJRF9TQ0hFTUUgPSAnSW52YWxpZCBzY2hlbWUnO1xcbnZhciBJTlZBTElEX0hPU1QgPSAnSW52YWxpZCBob3N0JztcXG52YXIgSU5WQUxJRF9QT1JUID0gJ0ludmFsaWQgcG9ydCc7XFxuXFxudmFyIEFMUEhBID0gL1tBLVphLXpdLztcXG52YXIgQUxQSEFOVU1FUklDID0gL1tcXFxcZCstLkEtWmEtel0vO1xcbnZhciBESUdJVCA9IC9cXFxcZC87XFxudmFyIEhFWF9TVEFSVCA9IC9eKDB4fDBYKS87XFxudmFyIE9DVCA9IC9eWzAtN10rJC87XFxudmFyIERFQyA9IC9eXFxcXGQrJC87XFxudmFyIEhFWCA9IC9eW1xcXFxkQS1GYS1mXSskLztcXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb250cm9sLXJlZ2V4IC0tIHNhZmUgKi9cXG52YXIgRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVCA9IC9bXFxcXHUwMDAwXFxcXHRcXFxcdTAwMEFcXFxcdTAwMEQgIyUvOj9AW1xcXFxcXFxcXV0vO1xcbnZhciBGT1JCSURERU5fSE9TVF9DT0RFX1BPSU5UX0VYQ0xVRElOR19QRVJDRU5UID0gL1tcXFxcdTAwMDBcXFxcdFxcXFx1MDAwQVxcXFx1MDAwRCAjLzo/QFtcXFxcXFxcXF1dLztcXG52YXIgTEVBRElOR19BTkRfVFJBSUxJTkdfQzBfQ09OVFJPTF9PUl9TUEFDRSA9IC9eW1xcXFx1MDAwMC1cXFxcdTAwMUYgXSt8W1xcXFx1MDAwMC1cXFxcdTAwMUYgXSskL2c7XFxudmFyIFRBQl9BTkRfTkVXX0xJTkUgPSAvW1xcXFx0XFxcXHUwMDBBXFxcXHUwMDBEXS9nO1xcbi8qIGVzbGludC1lbmFibGUgbm8tY29udHJvbC1yZWdleCAtLSBzYWZlICovXFxudmFyIEVPRjtcXG5cXG52YXIgcGFyc2VIb3N0ID0gZnVuY3Rpb24gKHVybCwgaW5wdXQpIHtcXG4gIHZhciByZXN1bHQsIGNvZGVQb2ludHMsIGluZGV4O1xcbiAgaWYgKGlucHV0LmNoYXJBdCgwKSA9PSAnWycpIHtcXG4gICAgaWYgKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAxKSAhPSAnXScpIHJldHVybiBJTlZBTElEX0hPU1Q7XFxuICAgIHJlc3VsdCA9IHBhcnNlSVB2NihpbnB1dC5zbGljZSgxLCAtMSkpO1xcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIElOVkFMSURfSE9TVDtcXG4gICAgdXJsLmhvc3QgPSByZXN1bHQ7XFxuICAvLyBvcGFxdWUgaG9zdFxcbiAgfSBlbHNlIGlmICghaXNTcGVjaWFsKHVybCkpIHtcXG4gICAgaWYgKEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlRfRVhDTFVESU5HX1BFUkNFTlQudGVzdChpbnB1dCkpIHJldHVybiBJTlZBTElEX0hPU1Q7XFxuICAgIHJlc3VsdCA9ICcnO1xcbiAgICBjb2RlUG9pbnRzID0gYXJyYXlGcm9tKGlucHV0KTtcXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgY29kZVBvaW50cy5sZW5ndGg7IGluZGV4KyspIHtcXG4gICAgICByZXN1bHQgKz0gcGVyY2VudEVuY29kZShjb2RlUG9pbnRzW2luZGV4XSwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XFxuICAgIH1cXG4gICAgdXJsLmhvc3QgPSByZXN1bHQ7XFxuICB9IGVsc2Uge1xcbiAgICBpbnB1dCA9IHRvQVNDSUkoaW5wdXQpO1xcbiAgICBpZiAoRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVC50ZXN0KGlucHV0KSkgcmV0dXJuIElOVkFMSURfSE9TVDtcXG4gICAgcmVzdWx0ID0gcGFyc2VJUHY0KGlucHV0KTtcXG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgcmV0dXJuIElOVkFMSURfSE9TVDtcXG4gICAgdXJsLmhvc3QgPSByZXN1bHQ7XFxuICB9XFxufTtcXG5cXG52YXIgcGFyc2VJUHY0ID0gZnVuY3Rpb24gKGlucHV0KSB7XFxuICB2YXIgcGFydHMgPSBpbnB1dC5zcGxpdCgnLicpO1xcbiAgdmFyIHBhcnRzTGVuZ3RoLCBudW1iZXJzLCBpbmRleCwgcGFydCwgcmFkaXgsIG51bWJlciwgaXB2NDtcXG4gIGlmIChwYXJ0cy5sZW5ndGggJiYgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPT0gJycpIHtcXG4gICAgcGFydHMucG9wKCk7XFxuICB9XFxuICBwYXJ0c0xlbmd0aCA9IHBhcnRzLmxlbmd0aDtcXG4gIGlmIChwYXJ0c0xlbmd0aCA+IDQpIHJldHVybiBpbnB1dDtcXG4gIG51bWJlcnMgPSBbXTtcXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBhcnRzTGVuZ3RoOyBpbmRleCsrKSB7XFxuICAgIHBhcnQgPSBwYXJ0c1tpbmRleF07XFxuICAgIGlmIChwYXJ0ID09ICcnKSByZXR1cm4gaW5wdXQ7XFxuICAgIHJhZGl4ID0gMTA7XFxuICAgIGlmIChwYXJ0Lmxlbmd0aCA+IDEgJiYgcGFydC5jaGFyQXQoMCkgPT0gJzAnKSB7XFxuICAgICAgcmFkaXggPSBIRVhfU1RBUlQudGVzdChwYXJ0KSA/IDE2IDogODtcXG4gICAgICBwYXJ0ID0gcGFydC5zbGljZShyYWRpeCA9PSA4ID8gMSA6IDIpO1xcbiAgICB9XFxuICAgIGlmIChwYXJ0ID09PSAnJykge1xcbiAgICAgIG51bWJlciA9IDA7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKCEocmFkaXggPT0gMTAgPyBERUMgOiByYWRpeCA9PSA4ID8gT0NUIDogSEVYKS50ZXN0KHBhcnQpKSByZXR1cm4gaW5wdXQ7XFxuICAgICAgbnVtYmVyID0gcGFyc2VJbnQocGFydCwgcmFkaXgpO1xcbiAgICB9XFxuICAgIG51bWJlcnMucHVzaChudW1iZXIpO1xcbiAgfVxcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcGFydHNMZW5ndGg7IGluZGV4KyspIHtcXG4gICAgbnVtYmVyID0gbnVtYmVyc1tpbmRleF07XFxuICAgIGlmIChpbmRleCA9PSBwYXJ0c0xlbmd0aCAtIDEpIHtcXG4gICAgICBpZiAobnVtYmVyID49IHBvdygyNTYsIDUgLSBwYXJ0c0xlbmd0aCkpIHJldHVybiBudWxsO1xcbiAgICB9IGVsc2UgaWYgKG51bWJlciA+IDI1NSkgcmV0dXJuIG51bGw7XFxuICB9XFxuICBpcHY0ID0gbnVtYmVycy5wb3AoKTtcXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IG51bWJlcnMubGVuZ3RoOyBpbmRleCsrKSB7XFxuICAgIGlwdjQgKz0gbnVtYmVyc1tpbmRleF0gKiBwb3coMjU2LCAzIC0gaW5kZXgpO1xcbiAgfVxcbiAgcmV0dXJuIGlwdjQ7XFxufTtcXG5cXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHMgLS0gVE9ET1xcbnZhciBwYXJzZUlQdjYgPSBmdW5jdGlvbiAoaW5wdXQpIHtcXG4gIHZhciBhZGRyZXNzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xcbiAgdmFyIHBpZWNlSW5kZXggPSAwO1xcbiAgdmFyIGNvbXByZXNzID0gbnVsbDtcXG4gIHZhciBwb2ludGVyID0gMDtcXG4gIHZhciB2YWx1ZSwgbGVuZ3RoLCBudW1iZXJzU2VlbiwgaXB2NFBpZWNlLCBudW1iZXIsIHN3YXBzLCBzd2FwO1xcblxcbiAgdmFyIGNoYXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBpbnB1dC5jaGFyQXQocG9pbnRlcik7XFxuICB9O1xcblxcbiAgaWYgKGNoYXIoKSA9PSAnOicpIHtcXG4gICAgaWYgKGlucHV0LmNoYXJBdCgxKSAhPSAnOicpIHJldHVybjtcXG4gICAgcG9pbnRlciArPSAyO1xcbiAgICBwaWVjZUluZGV4Kys7XFxuICAgIGNvbXByZXNzID0gcGllY2VJbmRleDtcXG4gIH1cXG4gIHdoaWxlIChjaGFyKCkpIHtcXG4gICAgaWYgKHBpZWNlSW5kZXggPT0gOCkgcmV0dXJuO1xcbiAgICBpZiAoY2hhcigpID09ICc6Jykge1xcbiAgICAgIGlmIChjb21wcmVzcyAhPT0gbnVsbCkgcmV0dXJuO1xcbiAgICAgIHBvaW50ZXIrKztcXG4gICAgICBwaWVjZUluZGV4Kys7XFxuICAgICAgY29tcHJlc3MgPSBwaWVjZUluZGV4O1xcbiAgICAgIGNvbnRpbnVlO1xcbiAgICB9XFxuICAgIHZhbHVlID0gbGVuZ3RoID0gMDtcXG4gICAgd2hpbGUgKGxlbmd0aCA8IDQgJiYgSEVYLnRlc3QoY2hhcigpKSkge1xcbiAgICAgIHZhbHVlID0gdmFsdWUgKiAxNiArIHBhcnNlSW50KGNoYXIoKSwgMTYpO1xcbiAgICAgIHBvaW50ZXIrKztcXG4gICAgICBsZW5ndGgrKztcXG4gICAgfVxcbiAgICBpZiAoY2hhcigpID09ICcuJykge1xcbiAgICAgIGlmIChsZW5ndGggPT0gMCkgcmV0dXJuO1xcbiAgICAgIHBvaW50ZXIgLT0gbGVuZ3RoO1xcbiAgICAgIGlmIChwaWVjZUluZGV4ID4gNikgcmV0dXJuO1xcbiAgICAgIG51bWJlcnNTZWVuID0gMDtcXG4gICAgICB3aGlsZSAoY2hhcigpKSB7XFxuICAgICAgICBpcHY0UGllY2UgPSBudWxsO1xcbiAgICAgICAgaWYgKG51bWJlcnNTZWVuID4gMCkge1xcbiAgICAgICAgICBpZiAoY2hhcigpID09ICcuJyAmJiBudW1iZXJzU2VlbiA8IDQpIHBvaW50ZXIrKztcXG4gICAgICAgICAgZWxzZSByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIURJR0lULnRlc3QoY2hhcigpKSkgcmV0dXJuO1xcbiAgICAgICAgd2hpbGUgKERJR0lULnRlc3QoY2hhcigpKSkge1xcbiAgICAgICAgICBudW1iZXIgPSBwYXJzZUludChjaGFyKCksIDEwKTtcXG4gICAgICAgICAgaWYgKGlwdjRQaWVjZSA9PT0gbnVsbCkgaXB2NFBpZWNlID0gbnVtYmVyO1xcbiAgICAgICAgICBlbHNlIGlmIChpcHY0UGllY2UgPT0gMCkgcmV0dXJuO1xcbiAgICAgICAgICBlbHNlIGlwdjRQaWVjZSA9IGlwdjRQaWVjZSAqIDEwICsgbnVtYmVyO1xcbiAgICAgICAgICBpZiAoaXB2NFBpZWNlID4gMjU1KSByZXR1cm47XFxuICAgICAgICAgIHBvaW50ZXIrKztcXG4gICAgICAgIH1cXG4gICAgICAgIGFkZHJlc3NbcGllY2VJbmRleF0gPSBhZGRyZXNzW3BpZWNlSW5kZXhdICogMjU2ICsgaXB2NFBpZWNlO1xcbiAgICAgICAgbnVtYmVyc1NlZW4rKztcXG4gICAgICAgIGlmIChudW1iZXJzU2VlbiA9PSAyIHx8IG51bWJlcnNTZWVuID09IDQpIHBpZWNlSW5kZXgrKztcXG4gICAgICB9XFxuICAgICAgaWYgKG51bWJlcnNTZWVuICE9IDQpIHJldHVybjtcXG4gICAgICBicmVhaztcXG4gICAgfSBlbHNlIGlmIChjaGFyKCkgPT0gJzonKSB7XFxuICAgICAgcG9pbnRlcisrO1xcbiAgICAgIGlmICghY2hhcigpKSByZXR1cm47XFxuICAgIH0gZWxzZSBpZiAoY2hhcigpKSByZXR1cm47XFxuICAgIGFkZHJlc3NbcGllY2VJbmRleCsrXSA9IHZhbHVlO1xcbiAgfVxcbiAgaWYgKGNvbXByZXNzICE9PSBudWxsKSB7XFxuICAgIHN3YXBzID0gcGllY2VJbmRleCAtIGNvbXByZXNzO1xcbiAgICBwaWVjZUluZGV4ID0gNztcXG4gICAgd2hpbGUgKHBpZWNlSW5kZXggIT0gMCAmJiBzd2FwcyA+IDApIHtcXG4gICAgICBzd2FwID0gYWRkcmVzc1twaWVjZUluZGV4XTtcXG4gICAgICBhZGRyZXNzW3BpZWNlSW5kZXgtLV0gPSBhZGRyZXNzW2NvbXByZXNzICsgc3dhcHMgLSAxXTtcXG4gICAgICBhZGRyZXNzW2NvbXByZXNzICsgLS1zd2Fwc10gPSBzd2FwO1xcbiAgICB9XFxuICB9IGVsc2UgaWYgKHBpZWNlSW5kZXggIT0gOCkgcmV0dXJuO1xcbiAgcmV0dXJuIGFkZHJlc3M7XFxufTtcXG5cXG52YXIgZmluZExvbmdlc3RaZXJvU2VxdWVuY2UgPSBmdW5jdGlvbiAoaXB2Nikge1xcbiAgdmFyIG1heEluZGV4ID0gbnVsbDtcXG4gIHZhciBtYXhMZW5ndGggPSAxO1xcbiAgdmFyIGN1cnJTdGFydCA9IG51bGw7XFxuICB2YXIgY3Vyckxlbmd0aCA9IDA7XFxuICB2YXIgaW5kZXggPSAwO1xcbiAgZm9yICg7IGluZGV4IDwgODsgaW5kZXgrKykge1xcbiAgICBpZiAoaXB2NltpbmRleF0gIT09IDApIHtcXG4gICAgICBpZiAoY3Vyckxlbmd0aCA+IG1heExlbmd0aCkge1xcbiAgICAgICAgbWF4SW5kZXggPSBjdXJyU3RhcnQ7XFxuICAgICAgICBtYXhMZW5ndGggPSBjdXJyTGVuZ3RoO1xcbiAgICAgIH1cXG4gICAgICBjdXJyU3RhcnQgPSBudWxsO1xcbiAgICAgIGN1cnJMZW5ndGggPSAwO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmIChjdXJyU3RhcnQgPT09IG51bGwpIGN1cnJTdGFydCA9IGluZGV4O1xcbiAgICAgICsrY3Vyckxlbmd0aDtcXG4gICAgfVxcbiAgfVxcbiAgaWYgKGN1cnJMZW5ndGggPiBtYXhMZW5ndGgpIHtcXG4gICAgbWF4SW5kZXggPSBjdXJyU3RhcnQ7XFxuICAgIG1heExlbmd0aCA9IGN1cnJMZW5ndGg7XFxuICB9XFxuICByZXR1cm4gbWF4SW5kZXg7XFxufTtcXG5cXG52YXIgc2VyaWFsaXplSG9zdCA9IGZ1bmN0aW9uIChob3N0KSB7XFxuICB2YXIgcmVzdWx0LCBpbmRleCwgY29tcHJlc3MsIGlnbm9yZTA7XFxuICAvLyBpcHY0XFxuICBpZiAodHlwZW9mIGhvc3QgPT0gJ251bWJlcicpIHtcXG4gICAgcmVzdWx0ID0gW107XFxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDQ7IGluZGV4KyspIHtcXG4gICAgICByZXN1bHQudW5zaGlmdChob3N0ICUgMjU2KTtcXG4gICAgICBob3N0ID0gZmxvb3IoaG9zdCAvIDI1Nik7XFxuICAgIH0gcmV0dXJuIHJlc3VsdC5qb2luKCcuJyk7XFxuICAvLyBpcHY2XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBob3N0ID09ICdvYmplY3QnKSB7XFxuICAgIHJlc3VsdCA9ICcnO1xcbiAgICBjb21wcmVzcyA9IGZpbmRMb25nZXN0WmVyb1NlcXVlbmNlKGhvc3QpO1xcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA4OyBpbmRleCsrKSB7XFxuICAgICAgaWYgKGlnbm9yZTAgJiYgaG9zdFtpbmRleF0gPT09IDApIGNvbnRpbnVlO1xcbiAgICAgIGlmIChpZ25vcmUwKSBpZ25vcmUwID0gZmFsc2U7XFxuICAgICAgaWYgKGNvbXByZXNzID09PSBpbmRleCkge1xcbiAgICAgICAgcmVzdWx0ICs9IGluZGV4ID8gJzonIDogJzo6JztcXG4gICAgICAgIGlnbm9yZTAgPSB0cnVlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXN1bHQgKz0gaG9zdFtpbmRleF0udG9TdHJpbmcoMTYpO1xcbiAgICAgICAgaWYgKGluZGV4IDwgNykgcmVzdWx0ICs9ICc6JztcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuICdbJyArIHJlc3VsdCArICddJztcXG4gIH0gcmV0dXJuIGhvc3Q7XFxufTtcXG5cXG52YXIgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCA9IHt9O1xcbnZhciBmcmFnbWVudFBlcmNlbnRFbmNvZGVTZXQgPSBhc3NpZ24oe30sIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQsIHtcXG4gICcgJzogMSwgJ1xcXCInOiAxLCAnPCc6IDEsICc+JzogMSwgJ2AnOiAxXFxufSk7XFxudmFyIHBhdGhQZXJjZW50RW5jb2RlU2V0ID0gYXNzaWduKHt9LCBmcmFnbWVudFBlcmNlbnRFbmNvZGVTZXQsIHtcXG4gICcjJzogMSwgJz8nOiAxLCAneyc6IDEsICd9JzogMVxcbn0pO1xcbnZhciB1c2VyaW5mb1BlcmNlbnRFbmNvZGVTZXQgPSBhc3NpZ24oe30sIHBhdGhQZXJjZW50RW5jb2RlU2V0LCB7XFxuICAnLyc6IDEsICc6JzogMSwgJzsnOiAxLCAnPSc6IDEsICdAJzogMSwgJ1snOiAxLCAnXFxcXFxcXFwnOiAxLCAnXSc6IDEsICdeJzogMSwgJ3wnOiAxXFxufSk7XFxuXFxudmFyIHBlcmNlbnRFbmNvZGUgPSBmdW5jdGlvbiAoY2hhciwgc2V0KSB7XFxuICB2YXIgY29kZSA9IGNvZGVBdChjaGFyLCAwKTtcXG4gIHJldHVybiBjb2RlID4gMHgyMCAmJiBjb2RlIDwgMHg3RiAmJiAhaGFzKHNldCwgY2hhcikgPyBjaGFyIDogZW5jb2RlVVJJQ29tcG9uZW50KGNoYXIpO1xcbn07XFxuXFxudmFyIHNwZWNpYWxTY2hlbWVzID0ge1xcbiAgZnRwOiAyMSxcXG4gIGZpbGU6IG51bGwsXFxuICBodHRwOiA4MCxcXG4gIGh0dHBzOiA0NDMsXFxuICB3czogODAsXFxuICB3c3M6IDQ0M1xcbn07XFxuXFxudmFyIGlzU3BlY2lhbCA9IGZ1bmN0aW9uICh1cmwpIHtcXG4gIHJldHVybiBoYXMoc3BlY2lhbFNjaGVtZXMsIHVybC5zY2hlbWUpO1xcbn07XFxuXFxudmFyIGluY2x1ZGVzQ3JlZGVudGlhbHMgPSBmdW5jdGlvbiAodXJsKSB7XFxuICByZXR1cm4gdXJsLnVzZXJuYW1lICE9ICcnIHx8IHVybC5wYXNzd29yZCAhPSAnJztcXG59O1xcblxcbnZhciBjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQgPSBmdW5jdGlvbiAodXJsKSB7XFxuICByZXR1cm4gIXVybC5ob3N0IHx8IHVybC5jYW5ub3RCZUFCYXNlVVJMIHx8IHVybC5zY2hlbWUgPT0gJ2ZpbGUnO1xcbn07XFxuXFxudmFyIGlzV2luZG93c0RyaXZlTGV0dGVyID0gZnVuY3Rpb24gKHN0cmluZywgbm9ybWFsaXplZCkge1xcbiAgdmFyIHNlY29uZDtcXG4gIHJldHVybiBzdHJpbmcubGVuZ3RoID09IDIgJiYgQUxQSEEudGVzdChzdHJpbmcuY2hhckF0KDApKVxcbiAgICAmJiAoKHNlY29uZCA9IHN0cmluZy5jaGFyQXQoMSkpID09ICc6JyB8fCAoIW5vcm1hbGl6ZWQgJiYgc2Vjb25kID09ICd8JykpO1xcbn07XFxuXFxudmFyIHN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XFxuICB2YXIgdGhpcmQ7XFxuICByZXR1cm4gc3RyaW5nLmxlbmd0aCA+IDEgJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoc3RyaW5nLnNsaWNlKDAsIDIpKSAmJiAoXFxuICAgIHN0cmluZy5sZW5ndGggPT0gMiB8fFxcbiAgICAoKHRoaXJkID0gc3RyaW5nLmNoYXJBdCgyKSkgPT09ICcvJyB8fCB0aGlyZCA9PT0gJ1xcXFxcXFxcJyB8fCB0aGlyZCA9PT0gJz8nIHx8IHRoaXJkID09PSAnIycpXFxuICApO1xcbn07XFxuXFxudmFyIHNob3J0ZW5VUkxzUGF0aCA9IGZ1bmN0aW9uICh1cmwpIHtcXG4gIHZhciBwYXRoID0gdXJsLnBhdGg7XFxuICB2YXIgcGF0aFNpemUgPSBwYXRoLmxlbmd0aDtcXG4gIGlmIChwYXRoU2l6ZSAmJiAodXJsLnNjaGVtZSAhPSAnZmlsZScgfHwgcGF0aFNpemUgIT0gMSB8fCAhaXNXaW5kb3dzRHJpdmVMZXR0ZXIocGF0aFswXSwgdHJ1ZSkpKSB7XFxuICAgIHBhdGgucG9wKCk7XFxuICB9XFxufTtcXG5cXG52YXIgaXNTaW5nbGVEb3QgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xcbiAgcmV0dXJuIHNlZ21lbnQgPT09ICcuJyB8fCBzZWdtZW50LnRvTG93ZXJDYXNlKCkgPT09ICclMmUnO1xcbn07XFxuXFxudmFyIGlzRG91YmxlRG90ID0gZnVuY3Rpb24gKHNlZ21lbnQpIHtcXG4gIHNlZ21lbnQgPSBzZWdtZW50LnRvTG93ZXJDYXNlKCk7XFxuICByZXR1cm4gc2VnbWVudCA9PT0gJy4uJyB8fCBzZWdtZW50ID09PSAnJTJlLicgfHwgc2VnbWVudCA9PT0gJy4lMmUnIHx8IHNlZ21lbnQgPT09ICclMmUlMmUnO1xcbn07XFxuXFxuLy8gU3RhdGVzOlxcbnZhciBTQ0hFTUVfU1RBUlQgPSB7fTtcXG52YXIgU0NIRU1FID0ge307XFxudmFyIE5PX1NDSEVNRSA9IHt9O1xcbnZhciBTUEVDSUFMX1JFTEFUSVZFX09SX0FVVEhPUklUWSA9IHt9O1xcbnZhciBQQVRIX09SX0FVVEhPUklUWSA9IHt9O1xcbnZhciBSRUxBVElWRSA9IHt9O1xcbnZhciBSRUxBVElWRV9TTEFTSCA9IHt9O1xcbnZhciBTUEVDSUFMX0FVVEhPUklUWV9TTEFTSEVTID0ge307XFxudmFyIFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTID0ge307XFxudmFyIEFVVEhPUklUWSA9IHt9O1xcbnZhciBIT1NUID0ge307XFxudmFyIEhPU1ROQU1FID0ge307XFxudmFyIFBPUlQgPSB7fTtcXG52YXIgRklMRSA9IHt9O1xcbnZhciBGSUxFX1NMQVNIID0ge307XFxudmFyIEZJTEVfSE9TVCA9IHt9O1xcbnZhciBQQVRIX1NUQVJUID0ge307XFxudmFyIFBBVEggPSB7fTtcXG52YXIgQ0FOTk9UX0JFX0FfQkFTRV9VUkxfUEFUSCA9IHt9O1xcbnZhciBRVUVSWSA9IHt9O1xcbnZhciBGUkFHTUVOVCA9IHt9O1xcblxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50cyAtLSBUT0RPXFxudmFyIHBhcnNlVVJMID0gZnVuY3Rpb24gKHVybCwgaW5wdXQsIHN0YXRlT3ZlcnJpZGUsIGJhc2UpIHtcXG4gIHZhciBzdGF0ZSA9IHN0YXRlT3ZlcnJpZGUgfHwgU0NIRU1FX1NUQVJUO1xcbiAgdmFyIHBvaW50ZXIgPSAwO1xcbiAgdmFyIGJ1ZmZlciA9ICcnO1xcbiAgdmFyIHNlZW5BdCA9IGZhbHNlO1xcbiAgdmFyIHNlZW5CcmFja2V0ID0gZmFsc2U7XFxuICB2YXIgc2VlblBhc3N3b3JkVG9rZW4gPSBmYWxzZTtcXG4gIHZhciBjb2RlUG9pbnRzLCBjaGFyLCBidWZmZXJDb2RlUG9pbnRzLCBmYWlsdXJlO1xcblxcbiAgaWYgKCFzdGF0ZU92ZXJyaWRlKSB7XFxuICAgIHVybC5zY2hlbWUgPSAnJztcXG4gICAgdXJsLnVzZXJuYW1lID0gJyc7XFxuICAgIHVybC5wYXNzd29yZCA9ICcnO1xcbiAgICB1cmwuaG9zdCA9IG51bGw7XFxuICAgIHVybC5wb3J0ID0gbnVsbDtcXG4gICAgdXJsLnBhdGggPSBbXTtcXG4gICAgdXJsLnF1ZXJ5ID0gbnVsbDtcXG4gICAgdXJsLmZyYWdtZW50ID0gbnVsbDtcXG4gICAgdXJsLmNhbm5vdEJlQUJhc2VVUkwgPSBmYWxzZTtcXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKExFQURJTkdfQU5EX1RSQUlMSU5HX0MwX0NPTlRST0xfT1JfU1BBQ0UsICcnKTtcXG4gIH1cXG5cXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZShUQUJfQU5EX05FV19MSU5FLCAnJyk7XFxuXFxuICBjb2RlUG9pbnRzID0gYXJyYXlGcm9tKGlucHV0KTtcXG5cXG4gIHdoaWxlIChwb2ludGVyIDw9IGNvZGVQb2ludHMubGVuZ3RoKSB7XFxuICAgIGNoYXIgPSBjb2RlUG9pbnRzW3BvaW50ZXJdO1xcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XFxuICAgICAgY2FzZSBTQ0hFTUVfU1RBUlQ6XFxuICAgICAgICBpZiAoY2hhciAmJiBBTFBIQS50ZXN0KGNoYXIpKSB7XFxuICAgICAgICAgIGJ1ZmZlciArPSBjaGFyLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICAgIHN0YXRlID0gU0NIRU1FO1xcbiAgICAgICAgfSBlbHNlIGlmICghc3RhdGVPdmVycmlkZSkge1xcbiAgICAgICAgICBzdGF0ZSA9IE5PX1NDSEVNRTtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9IGVsc2UgcmV0dXJuIElOVkFMSURfU0NIRU1FO1xcbiAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgY2FzZSBTQ0hFTUU6XFxuICAgICAgICBpZiAoY2hhciAmJiAoQUxQSEFOVU1FUklDLnRlc3QoY2hhcikgfHwgY2hhciA9PSAnKycgfHwgY2hhciA9PSAnLScgfHwgY2hhciA9PSAnLicpKSB7XFxuICAgICAgICAgIGJ1ZmZlciArPSBjaGFyLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT0gJzonKSB7XFxuICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlICYmIChcXG4gICAgICAgICAgICAoaXNTcGVjaWFsKHVybCkgIT0gaGFzKHNwZWNpYWxTY2hlbWVzLCBidWZmZXIpKSB8fFxcbiAgICAgICAgICAgIChidWZmZXIgPT0gJ2ZpbGUnICYmIChpbmNsdWRlc0NyZWRlbnRpYWxzKHVybCkgfHwgdXJsLnBvcnQgIT09IG51bGwpKSB8fFxcbiAgICAgICAgICAgICh1cmwuc2NoZW1lID09ICdmaWxlJyAmJiAhdXJsLmhvc3QpXFxuICAgICAgICAgICkpIHJldHVybjtcXG4gICAgICAgICAgdXJsLnNjaGVtZSA9IGJ1ZmZlcjtcXG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHtcXG4gICAgICAgICAgICBpZiAoaXNTcGVjaWFsKHVybCkgJiYgc3BlY2lhbFNjaGVtZXNbdXJsLnNjaGVtZV0gPT0gdXJsLnBvcnQpIHVybC5wb3J0ID0gbnVsbDtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnVmZmVyID0gJyc7XFxuICAgICAgICAgIGlmICh1cmwuc2NoZW1lID09ICdmaWxlJykge1xcbiAgICAgICAgICAgIHN0YXRlID0gRklMRTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1NwZWNpYWwodXJsKSAmJiBiYXNlICYmIGJhc2Uuc2NoZW1lID09IHVybC5zY2hlbWUpIHtcXG4gICAgICAgICAgICBzdGF0ZSA9IFNQRUNJQUxfUkVMQVRJVkVfT1JfQVVUSE9SSVRZO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3BlY2lhbCh1cmwpKSB7XFxuICAgICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9TTEFTSEVTO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludHNbcG9pbnRlciArIDFdID09ICcvJykge1xcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSF9PUl9BVVRIT1JJVFk7XFxuICAgICAgICAgICAgcG9pbnRlcisrO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHVybC5jYW5ub3RCZUFCYXNlVVJMID0gdHJ1ZTtcXG4gICAgICAgICAgICB1cmwucGF0aC5wdXNoKCcnKTtcXG4gICAgICAgICAgICBzdGF0ZSA9IENBTk5PVF9CRV9BX0JBU0VfVVJMX1BBVEg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUpIHtcXG4gICAgICAgICAgYnVmZmVyID0gJyc7XFxuICAgICAgICAgIHN0YXRlID0gTk9fU0NIRU1FO1xcbiAgICAgICAgICBwb2ludGVyID0gMDtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9IGVsc2UgcmV0dXJuIElOVkFMSURfU0NIRU1FO1xcbiAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgY2FzZSBOT19TQ0hFTUU6XFxuICAgICAgICBpZiAoIWJhc2UgfHwgKGJhc2UuY2Fubm90QmVBQmFzZVVSTCAmJiBjaGFyICE9ICcjJykpIHJldHVybiBJTlZBTElEX1NDSEVNRTtcXG4gICAgICAgIGlmIChiYXNlLmNhbm5vdEJlQUJhc2VVUkwgJiYgY2hhciA9PSAnIycpIHtcXG4gICAgICAgICAgdXJsLnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xcbiAgICAgICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xcbiAgICAgICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xcbiAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcXG4gICAgICAgICAgdXJsLmNhbm5vdEJlQUJhc2VVUkwgPSB0cnVlO1xcbiAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIHN0YXRlID0gYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnID8gRklMRSA6IFJFTEFUSVZFO1xcbiAgICAgICAgY29udGludWU7XFxuXFxuICAgICAgY2FzZSBTUEVDSUFMX1JFTEFUSVZFX09SX0FVVEhPUklUWTpcXG4gICAgICAgIGlmIChjaGFyID09ICcvJyAmJiBjb2RlUG9pbnRzW3BvaW50ZXIgKyAxXSA9PSAnLycpIHtcXG4gICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcXG4gICAgICAgICAgcG9pbnRlcisrO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc3RhdGUgPSBSRUxBVElWRTtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9IGJyZWFrO1xcblxcbiAgICAgIGNhc2UgUEFUSF9PUl9BVVRIT1JJVFk6XFxuICAgICAgICBpZiAoY2hhciA9PSAnLycpIHtcXG4gICAgICAgICAgc3RhdGUgPSBBVVRIT1JJVFk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc3RhdGUgPSBQQVRIO1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICBjYXNlIFJFTEFUSVZFOlxcbiAgICAgICAgdXJsLnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xcbiAgICAgICAgaWYgKGNoYXIgPT0gRU9GKSB7XFxuICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XFxuICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XFxuICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xcbiAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcXG4gICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcXG4gICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnLycgfHwgKGNoYXIgPT0gJ1xcXFxcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkpIHtcXG4gICAgICAgICAgc3RhdGUgPSBSRUxBVElWRV9TTEFTSDtcXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnPycpIHtcXG4gICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcXG4gICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcXG4gICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XFxuICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xcbiAgICAgICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xcbiAgICAgICAgICB1cmwucXVlcnkgPSAnJztcXG4gICAgICAgICAgc3RhdGUgPSBRVUVSWTtcXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnIycpIHtcXG4gICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcXG4gICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcXG4gICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XFxuICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xcbiAgICAgICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xcbiAgICAgICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xcbiAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcXG4gICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XFxuICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XFxuICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xcbiAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcXG4gICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcXG4gICAgICAgICAgdXJsLnBhdGgucG9wKCk7XFxuICAgICAgICAgIHN0YXRlID0gUEFUSDtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9IGJyZWFrO1xcblxcbiAgICAgIGNhc2UgUkVMQVRJVkVfU0xBU0g6XFxuICAgICAgICBpZiAoaXNTcGVjaWFsKHVybCkgJiYgKGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJ1xcXFxcXFxcJykpIHtcXG4gICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnLycpIHtcXG4gICAgICAgICAgc3RhdGUgPSBBVVRIT1JJVFk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xcbiAgICAgICAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xcbiAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcXG4gICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XFxuICAgICAgICAgIHN0YXRlID0gUEFUSDtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9IGJyZWFrO1xcblxcbiAgICAgIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfU0xBU0hFUzpcXG4gICAgICAgIHN0YXRlID0gU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM7XFxuICAgICAgICBpZiAoY2hhciAhPSAnLycgfHwgYnVmZmVyLmNoYXJBdChwb2ludGVyICsgMSkgIT0gJy8nKSBjb250aW51ZTtcXG4gICAgICAgIHBvaW50ZXIrKztcXG4gICAgICAgIGJyZWFrO1xcblxcbiAgICAgIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM6XFxuICAgICAgICBpZiAoY2hhciAhPSAnLycgJiYgY2hhciAhPSAnXFxcXFxcXFwnKSB7XFxuICAgICAgICAgIHN0YXRlID0gQVVUSE9SSVRZO1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH0gYnJlYWs7XFxuXFxuICAgICAgY2FzZSBBVVRIT1JJVFk6XFxuICAgICAgICBpZiAoY2hhciA9PSAnQCcpIHtcXG4gICAgICAgICAgaWYgKHNlZW5BdCkgYnVmZmVyID0gJyU0MCcgKyBidWZmZXI7XFxuICAgICAgICAgIHNlZW5BdCA9IHRydWU7XFxuICAgICAgICAgIGJ1ZmZlckNvZGVQb2ludHMgPSBhcnJheUZyb20oYnVmZmVyKTtcXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJDb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IGJ1ZmZlckNvZGVQb2ludHNbaV07XFxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA9PSAnOicgJiYgIXNlZW5QYXNzd29yZFRva2VuKSB7XFxuICAgICAgICAgICAgICBzZWVuUGFzc3dvcmRUb2tlbiA9IHRydWU7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdmFyIGVuY29kZWRDb2RlUG9pbnRzID0gcGVyY2VudEVuY29kZShjb2RlUG9pbnQsIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCk7XFxuICAgICAgICAgICAgaWYgKHNlZW5QYXNzd29yZFRva2VuKSB1cmwucGFzc3dvcmQgKz0gZW5jb2RlZENvZGVQb2ludHM7XFxuICAgICAgICAgICAgZWxzZSB1cmwudXNlcm5hbWUgKz0gZW5jb2RlZENvZGVQb2ludHM7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnVmZmVyID0gJyc7XFxuICAgICAgICB9IGVsc2UgaWYgKFxcbiAgICAgICAgICBjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJyB8fFxcbiAgICAgICAgICAoY2hhciA9PSAnXFxcXFxcXFwnICYmIGlzU3BlY2lhbCh1cmwpKVxcbiAgICAgICAgKSB7XFxuICAgICAgICAgIGlmIChzZWVuQXQgJiYgYnVmZmVyID09ICcnKSByZXR1cm4gSU5WQUxJRF9BVVRIT1JJVFk7XFxuICAgICAgICAgIHBvaW50ZXIgLT0gYXJyYXlGcm9tKGJ1ZmZlcikubGVuZ3RoICsgMTtcXG4gICAgICAgICAgYnVmZmVyID0gJyc7XFxuICAgICAgICAgIHN0YXRlID0gSE9TVDtcXG4gICAgICAgIH0gZWxzZSBidWZmZXIgKz0gY2hhcjtcXG4gICAgICAgIGJyZWFrO1xcblxcbiAgICAgIGNhc2UgSE9TVDpcXG4gICAgICBjYXNlIEhPU1ROQU1FOlxcbiAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgJiYgdXJsLnNjaGVtZSA9PSAnZmlsZScpIHtcXG4gICAgICAgICAgc3RhdGUgPSBGSUxFX0hPU1Q7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICc6JyAmJiAhc2VlbkJyYWNrZXQpIHtcXG4gICAgICAgICAgaWYgKGJ1ZmZlciA9PSAnJykgcmV0dXJuIElOVkFMSURfSE9TVDtcXG4gICAgICAgICAgZmFpbHVyZSA9IHBhcnNlSG9zdCh1cmwsIGJ1ZmZlcik7XFxuICAgICAgICAgIGlmIChmYWlsdXJlKSByZXR1cm4gZmFpbHVyZTtcXG4gICAgICAgICAgYnVmZmVyID0gJyc7XFxuICAgICAgICAgIHN0YXRlID0gUE9SVDtcXG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgPT0gSE9TVE5BTUUpIHJldHVybjtcXG4gICAgICAgIH0gZWxzZSBpZiAoXFxuICAgICAgICAgIGNoYXIgPT0gRU9GIHx8IGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJz8nIHx8IGNoYXIgPT0gJyMnIHx8XFxuICAgICAgICAgIChjaGFyID09ICdcXFxcXFxcXCcgJiYgaXNTcGVjaWFsKHVybCkpXFxuICAgICAgICApIHtcXG4gICAgICAgICAgaWYgKGlzU3BlY2lhbCh1cmwpICYmIGJ1ZmZlciA9PSAnJykgcmV0dXJuIElOVkFMSURfSE9TVDtcXG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUgJiYgYnVmZmVyID09ICcnICYmIChpbmNsdWRlc0NyZWRlbnRpYWxzKHVybCkgfHwgdXJsLnBvcnQgIT09IG51bGwpKSByZXR1cm47XFxuICAgICAgICAgIGZhaWx1cmUgPSBwYXJzZUhvc3QodXJsLCBidWZmZXIpO1xcbiAgICAgICAgICBpZiAoZmFpbHVyZSkgcmV0dXJuIGZhaWx1cmU7XFxuICAgICAgICAgIGJ1ZmZlciA9ICcnO1xcbiAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XFxuICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKGNoYXIgPT0gJ1snKSBzZWVuQnJhY2tldCA9IHRydWU7XFxuICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT0gJ10nKSBzZWVuQnJhY2tldCA9IGZhbHNlO1xcbiAgICAgICAgICBidWZmZXIgKz0gY2hhcjtcXG4gICAgICAgIH0gYnJlYWs7XFxuXFxuICAgICAgY2FzZSBQT1JUOlxcbiAgICAgICAgaWYgKERJR0lULnRlc3QoY2hhcikpIHtcXG4gICAgICAgICAgYnVmZmVyICs9IGNoYXI7XFxuICAgICAgICB9IGVsc2UgaWYgKFxcbiAgICAgICAgICBjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJyB8fFxcbiAgICAgICAgICAoY2hhciA9PSAnXFxcXFxcXFwnICYmIGlzU3BlY2lhbCh1cmwpKSB8fFxcbiAgICAgICAgICBzdGF0ZU92ZXJyaWRlXFxuICAgICAgICApIHtcXG4gICAgICAgICAgaWYgKGJ1ZmZlciAhPSAnJykge1xcbiAgICAgICAgICAgIHZhciBwb3J0ID0gcGFyc2VJbnQoYnVmZmVyLCAxMCk7XFxuICAgICAgICAgICAgaWYgKHBvcnQgPiAweEZGRkYpIHJldHVybiBJTlZBTElEX1BPUlQ7XFxuICAgICAgICAgICAgdXJsLnBvcnQgPSAoaXNTcGVjaWFsKHVybCkgJiYgcG9ydCA9PT0gc3BlY2lhbFNjaGVtZXNbdXJsLnNjaGVtZV0pID8gbnVsbCA6IHBvcnQ7XFxuICAgICAgICAgICAgYnVmZmVyID0gJyc7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcXG4gICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH0gZWxzZSByZXR1cm4gSU5WQUxJRF9QT1JUO1xcbiAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgY2FzZSBGSUxFOlxcbiAgICAgICAgdXJsLnNjaGVtZSA9ICdmaWxlJztcXG4gICAgICAgIGlmIChjaGFyID09ICcvJyB8fCBjaGFyID09ICdcXFxcXFxcXCcpIHN0YXRlID0gRklMRV9TTEFTSDtcXG4gICAgICAgIGVsc2UgaWYgKGJhc2UgJiYgYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnKSB7XFxuICAgICAgICAgIGlmIChjaGFyID09IEVPRikge1xcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xcbiAgICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XFxuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICc/Jykge1xcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xcbiAgICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XFxuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XFxuICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICcjJykge1xcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xcbiAgICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XFxuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcXG4gICAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcXG4gICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGlmICghc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihjb2RlUG9pbnRzLnNsaWNlKHBvaW50ZXIpLmpvaW4oJycpKSkge1xcbiAgICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XFxuICAgICAgICAgICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xcbiAgICAgICAgICAgICAgc2hvcnRlblVSTHNQYXRoKHVybCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc3RhdGUgPSBQQVRIO1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH0gYnJlYWs7XFxuXFxuICAgICAgY2FzZSBGSUxFX1NMQVNIOlxcbiAgICAgICAgaWYgKGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJ1xcXFxcXFxcJykge1xcbiAgICAgICAgICBzdGF0ZSA9IEZJTEVfSE9TVDtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoYmFzZSAmJiBiYXNlLnNjaGVtZSA9PSAnZmlsZScgJiYgIXN0YXJ0c1dpdGhXaW5kb3dzRHJpdmVMZXR0ZXIoY29kZVBvaW50cy5zbGljZShwb2ludGVyKS5qb2luKCcnKSkpIHtcXG4gICAgICAgICAgaWYgKGlzV2luZG93c0RyaXZlTGV0dGVyKGJhc2UucGF0aFswXSwgdHJ1ZSkpIHVybC5wYXRoLnB1c2goYmFzZS5wYXRoWzBdKTtcXG4gICAgICAgICAgZWxzZSB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcXG4gICAgICAgIH1cXG4gICAgICAgIHN0YXRlID0gUEFUSDtcXG4gICAgICAgIGNvbnRpbnVlO1xcblxcbiAgICAgIGNhc2UgRklMRV9IT1NUOlxcbiAgICAgICAgaWYgKGNoYXIgPT0gRU9GIHx8IGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJ1xcXFxcXFxcJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJykge1xcbiAgICAgICAgICBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoYnVmZmVyKSkge1xcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcXG4gICAgICAgICAgfSBlbHNlIGlmIChidWZmZXIgPT0gJycpIHtcXG4gICAgICAgICAgICB1cmwuaG9zdCA9ICcnO1xcbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XFxuICAgICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZhaWx1cmUgPSBwYXJzZUhvc3QodXJsLCBidWZmZXIpO1xcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSByZXR1cm4gZmFpbHVyZTtcXG4gICAgICAgICAgICBpZiAodXJsLmhvc3QgPT0gJ2xvY2FsaG9zdCcpIHVybC5ob3N0ID0gJyc7XFxuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcXG4gICAgICAgICAgICBidWZmZXIgPSAnJztcXG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XFxuICAgICAgICAgIH0gY29udGludWU7XFxuICAgICAgICB9IGVsc2UgYnVmZmVyICs9IGNoYXI7XFxuICAgICAgICBicmVhaztcXG5cXG4gICAgICBjYXNlIFBBVEhfU1RBUlQ6XFxuICAgICAgICBpZiAoaXNTcGVjaWFsKHVybCkpIHtcXG4gICAgICAgICAgc3RhdGUgPSBQQVRIO1xcbiAgICAgICAgICBpZiAoY2hhciAhPSAnLycgJiYgY2hhciAhPSAnXFxcXFxcXFwnKSBjb250aW51ZTtcXG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hhciA9PSAnPycpIHtcXG4gICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XFxuICAgICAgICAgIHN0YXRlID0gUVVFUlk7XFxuICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGNoYXIgPT0gJyMnKSB7XFxuICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xcbiAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyICE9IEVPRikge1xcbiAgICAgICAgICBzdGF0ZSA9IFBBVEg7XFxuICAgICAgICAgIGlmIChjaGFyICE9ICcvJykgY29udGludWU7XFxuICAgICAgICB9IGJyZWFrO1xcblxcbiAgICAgIGNhc2UgUEFUSDpcXG4gICAgICAgIGlmIChcXG4gICAgICAgICAgY2hhciA9PSBFT0YgfHwgY2hhciA9PSAnLycgfHxcXG4gICAgICAgICAgKGNoYXIgPT0gJ1xcXFxcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkgfHxcXG4gICAgICAgICAgKCFzdGF0ZU92ZXJyaWRlICYmIChjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJykpXFxuICAgICAgICApIHtcXG4gICAgICAgICAgaWYgKGlzRG91YmxlRG90KGJ1ZmZlcikpIHtcXG4gICAgICAgICAgICBzaG9ydGVuVVJMc1BhdGgodXJsKTtcXG4gICAgICAgICAgICBpZiAoY2hhciAhPSAnLycgJiYgIShjaGFyID09ICdcXFxcXFxcXCcgJiYgaXNTcGVjaWFsKHVybCkpKSB7XFxuICAgICAgICAgICAgICB1cmwucGF0aC5wdXNoKCcnKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNTaW5nbGVEb3QoYnVmZmVyKSkge1xcbiAgICAgICAgICAgIGlmIChjaGFyICE9ICcvJyAmJiAhKGNoYXIgPT0gJ1xcXFxcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkpIHtcXG4gICAgICAgICAgICAgIHVybC5wYXRoLnB1c2goJycpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSAnZmlsZScgJiYgIXVybC5wYXRoLmxlbmd0aCAmJiBpc1dpbmRvd3NEcml2ZUxldHRlcihidWZmZXIpKSB7XFxuICAgICAgICAgICAgICBpZiAodXJsLmhvc3QpIHVybC5ob3N0ID0gJyc7XFxuICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuY2hhckF0KDApICsgJzonOyAvLyBub3JtYWxpemUgd2luZG93cyBkcml2ZSBsZXR0ZXJcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdXJsLnBhdGgucHVzaChidWZmZXIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJ1ZmZlciA9ICcnO1xcbiAgICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSAnZmlsZScgJiYgKGNoYXIgPT0gRU9GIHx8IGNoYXIgPT0gJz8nIHx8IGNoYXIgPT0gJyMnKSkge1xcbiAgICAgICAgICAgIHdoaWxlICh1cmwucGF0aC5sZW5ndGggPiAxICYmIHVybC5wYXRoWzBdID09PSAnJykge1xcbiAgICAgICAgICAgICAgdXJsLnBhdGguc2hpZnQoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGNoYXIgPT0gJz8nKSB7XFxuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XFxuICAgICAgICAgICAgc3RhdGUgPSBRVUVSWTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICcjJykge1xcbiAgICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xcbiAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGJ1ZmZlciArPSBwZXJjZW50RW5jb2RlKGNoYXIsIHBhdGhQZXJjZW50RW5jb2RlU2V0KTtcXG4gICAgICAgIH0gYnJlYWs7XFxuXFxuICAgICAgY2FzZSBDQU5OT1RfQkVfQV9CQVNFX1VSTF9QQVRIOlxcbiAgICAgICAgaWYgKGNoYXIgPT0gJz8nKSB7XFxuICAgICAgICAgIHVybC5xdWVyeSA9ICcnO1xcbiAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICcjJykge1xcbiAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcXG4gICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciAhPSBFT0YpIHtcXG4gICAgICAgICAgdXJsLnBhdGhbMF0gKz0gcGVyY2VudEVuY29kZShjaGFyLCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0KTtcXG4gICAgICAgIH0gYnJlYWs7XFxuXFxuICAgICAgY2FzZSBRVUVSWTpcXG4gICAgICAgIGlmICghc3RhdGVPdmVycmlkZSAmJiBjaGFyID09ICcjJykge1xcbiAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcXG4gICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciAhPSBFT0YpIHtcXG4gICAgICAgICAgaWYgKGNoYXIgPT0gXFxcIidcXFwiICYmIGlzU3BlY2lhbCh1cmwpKSB1cmwucXVlcnkgKz0gJyUyNyc7XFxuICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT0gJyMnKSB1cmwucXVlcnkgKz0gJyUyMyc7XFxuICAgICAgICAgIGVsc2UgdXJsLnF1ZXJ5ICs9IHBlcmNlbnRFbmNvZGUoY2hhciwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XFxuICAgICAgICB9IGJyZWFrO1xcblxcbiAgICAgIGNhc2UgRlJBR01FTlQ6XFxuICAgICAgICBpZiAoY2hhciAhPSBFT0YpIHVybC5mcmFnbWVudCArPSBwZXJjZW50RW5jb2RlKGNoYXIsIGZyYWdtZW50UGVyY2VudEVuY29kZVNldCk7XFxuICAgICAgICBicmVhaztcXG4gICAgfVxcblxcbiAgICBwb2ludGVyKys7XFxuICB9XFxufTtcXG5cXG4vLyBgVVJMYCBjb25zdHJ1Y3Rvclxcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLWNsYXNzXFxudmFyIFVSTENvbnN0cnVjdG9yID0gZnVuY3Rpb24gVVJMKHVybCAvKiAsIGJhc2UgKi8pIHtcXG4gIHZhciB0aGF0ID0gYW5JbnN0YW5jZSh0aGlzLCBVUkxDb25zdHJ1Y3RvciwgJ1VSTCcpO1xcbiAgdmFyIGJhc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcXG4gIHZhciB1cmxTdHJpbmcgPSBTdHJpbmcodXJsKTtcXG4gIHZhciBzdGF0ZSA9IHNldEludGVybmFsU3RhdGUodGhhdCwgeyB0eXBlOiAnVVJMJyB9KTtcXG4gIHZhciBiYXNlU3RhdGUsIGZhaWx1cmU7XFxuICBpZiAoYmFzZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIGlmIChiYXNlIGluc3RhbmNlb2YgVVJMQ29uc3RydWN0b3IpIGJhc2VTdGF0ZSA9IGdldEludGVybmFsVVJMU3RhdGUoYmFzZSk7XFxuICAgIGVsc2Uge1xcbiAgICAgIGZhaWx1cmUgPSBwYXJzZVVSTChiYXNlU3RhdGUgPSB7fSwgU3RyaW5nKGJhc2UpKTtcXG4gICAgICBpZiAoZmFpbHVyZSkgdGhyb3cgVHlwZUVycm9yKGZhaWx1cmUpO1xcbiAgICB9XFxuICB9XFxuICBmYWlsdXJlID0gcGFyc2VVUkwoc3RhdGUsIHVybFN0cmluZywgbnVsbCwgYmFzZVN0YXRlKTtcXG4gIGlmIChmYWlsdXJlKSB0aHJvdyBUeXBlRXJyb3IoZmFpbHVyZSk7XFxuICB2YXIgc2VhcmNoUGFyYW1zID0gc3RhdGUuc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xcbiAgdmFyIHNlYXJjaFBhcmFtc1N0YXRlID0gZ2V0SW50ZXJuYWxTZWFyY2hQYXJhbXNTdGF0ZShzZWFyY2hQYXJhbXMpO1xcbiAgc2VhcmNoUGFyYW1zU3RhdGUudXBkYXRlU2VhcmNoUGFyYW1zKHN0YXRlLnF1ZXJ5KTtcXG4gIHNlYXJjaFBhcmFtc1N0YXRlLnVwZGF0ZVVSTCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgc3RhdGUucXVlcnkgPSBTdHJpbmcoc2VhcmNoUGFyYW1zKSB8fCBudWxsO1xcbiAgfTtcXG4gIGlmICghREVTQ1JJUFRPUlMpIHtcXG4gICAgdGhhdC5ocmVmID0gc2VyaWFsaXplVVJMLmNhbGwodGhhdCk7XFxuICAgIHRoYXQub3JpZ2luID0gZ2V0T3JpZ2luLmNhbGwodGhhdCk7XFxuICAgIHRoYXQucHJvdG9jb2wgPSBnZXRQcm90b2NvbC5jYWxsKHRoYXQpO1xcbiAgICB0aGF0LnVzZXJuYW1lID0gZ2V0VXNlcm5hbWUuY2FsbCh0aGF0KTtcXG4gICAgdGhhdC5wYXNzd29yZCA9IGdldFBhc3N3b3JkLmNhbGwodGhhdCk7XFxuICAgIHRoYXQuaG9zdCA9IGdldEhvc3QuY2FsbCh0aGF0KTtcXG4gICAgdGhhdC5ob3N0bmFtZSA9IGdldEhvc3RuYW1lLmNhbGwodGhhdCk7XFxuICAgIHRoYXQucG9ydCA9IGdldFBvcnQuY2FsbCh0aGF0KTtcXG4gICAgdGhhdC5wYXRobmFtZSA9IGdldFBhdGhuYW1lLmNhbGwodGhhdCk7XFxuICAgIHRoYXQuc2VhcmNoID0gZ2V0U2VhcmNoLmNhbGwodGhhdCk7XFxuICAgIHRoYXQuc2VhcmNoUGFyYW1zID0gZ2V0U2VhcmNoUGFyYW1zLmNhbGwodGhhdCk7XFxuICAgIHRoYXQuaGFzaCA9IGdldEhhc2guY2FsbCh0aGF0KTtcXG4gIH1cXG59O1xcblxcbnZhciBVUkxQcm90b3R5cGUgPSBVUkxDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XFxuXFxudmFyIHNlcmlhbGl6ZVVSTCA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xcbiAgdmFyIHNjaGVtZSA9IHVybC5zY2hlbWU7XFxuICB2YXIgdXNlcm5hbWUgPSB1cmwudXNlcm5hbWU7XFxuICB2YXIgcGFzc3dvcmQgPSB1cmwucGFzc3dvcmQ7XFxuICB2YXIgaG9zdCA9IHVybC5ob3N0O1xcbiAgdmFyIHBvcnQgPSB1cmwucG9ydDtcXG4gIHZhciBwYXRoID0gdXJsLnBhdGg7XFxuICB2YXIgcXVlcnkgPSB1cmwucXVlcnk7XFxuICB2YXIgZnJhZ21lbnQgPSB1cmwuZnJhZ21lbnQ7XFxuICB2YXIgb3V0cHV0ID0gc2NoZW1lICsgJzonO1xcbiAgaWYgKGhvc3QgIT09IG51bGwpIHtcXG4gICAgb3V0cHV0ICs9ICcvLyc7XFxuICAgIGlmIChpbmNsdWRlc0NyZWRlbnRpYWxzKHVybCkpIHtcXG4gICAgICBvdXRwdXQgKz0gdXNlcm5hbWUgKyAocGFzc3dvcmQgPyAnOicgKyBwYXNzd29yZCA6ICcnKSArICdAJztcXG4gICAgfVxcbiAgICBvdXRwdXQgKz0gc2VyaWFsaXplSG9zdChob3N0KTtcXG4gICAgaWYgKHBvcnQgIT09IG51bGwpIG91dHB1dCArPSAnOicgKyBwb3J0O1xcbiAgfSBlbHNlIGlmIChzY2hlbWUgPT0gJ2ZpbGUnKSBvdXRwdXQgKz0gJy8vJztcXG4gIG91dHB1dCArPSB1cmwuY2Fubm90QmVBQmFzZVVSTCA/IHBhdGhbMF0gOiBwYXRoLmxlbmd0aCA/ICcvJyArIHBhdGguam9pbignLycpIDogJyc7XFxuICBpZiAocXVlcnkgIT09IG51bGwpIG91dHB1dCArPSAnPycgKyBxdWVyeTtcXG4gIGlmIChmcmFnbWVudCAhPT0gbnVsbCkgb3V0cHV0ICs9ICcjJyArIGZyYWdtZW50O1xcbiAgcmV0dXJuIG91dHB1dDtcXG59O1xcblxcbnZhciBnZXRPcmlnaW4gPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcXG4gIHZhciBzY2hlbWUgPSB1cmwuc2NoZW1lO1xcbiAgdmFyIHBvcnQgPSB1cmwucG9ydDtcXG4gIGlmIChzY2hlbWUgPT0gJ2Jsb2InKSB0cnkge1xcbiAgICByZXR1cm4gbmV3IFVSTChzY2hlbWUucGF0aFswXSkub3JpZ2luO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgcmV0dXJuICdudWxsJztcXG4gIH1cXG4gIGlmIChzY2hlbWUgPT0gJ2ZpbGUnIHx8ICFpc1NwZWNpYWwodXJsKSkgcmV0dXJuICdudWxsJztcXG4gIHJldHVybiBzY2hlbWUgKyAnOi8vJyArIHNlcmlhbGl6ZUhvc3QodXJsLmhvc3QpICsgKHBvcnQgIT09IG51bGwgPyAnOicgKyBwb3J0IDogJycpO1xcbn07XFxuXFxudmFyIGdldFByb3RvY29sID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcykuc2NoZW1lICsgJzonO1xcbn07XFxuXFxudmFyIGdldFVzZXJuYW1lID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcykudXNlcm5hbWU7XFxufTtcXG5cXG52YXIgZ2V0UGFzc3dvcmQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5wYXNzd29yZDtcXG59O1xcblxcbnZhciBnZXRIb3N0ID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XFxuICB2YXIgaG9zdCA9IHVybC5ob3N0O1xcbiAgdmFyIHBvcnQgPSB1cmwucG9ydDtcXG4gIHJldHVybiBob3N0ID09PSBudWxsID8gJydcXG4gICAgOiBwb3J0ID09PSBudWxsID8gc2VyaWFsaXplSG9zdChob3N0KVxcbiAgICA6IHNlcmlhbGl6ZUhvc3QoaG9zdCkgKyAnOicgKyBwb3J0O1xcbn07XFxuXFxudmFyIGdldEhvc3RuYW1lID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIGhvc3QgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLmhvc3Q7XFxuICByZXR1cm4gaG9zdCA9PT0gbnVsbCA/ICcnIDogc2VyaWFsaXplSG9zdChob3N0KTtcXG59O1xcblxcbnZhciBnZXRQb3J0ID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHBvcnQgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnBvcnQ7XFxuICByZXR1cm4gcG9ydCA9PT0gbnVsbCA/ICcnIDogU3RyaW5nKHBvcnQpO1xcbn07XFxuXFxudmFyIGdldFBhdGhuYW1lID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XFxuICB2YXIgcGF0aCA9IHVybC5wYXRoO1xcbiAgcmV0dXJuIHVybC5jYW5ub3RCZUFCYXNlVVJMID8gcGF0aFswXSA6IHBhdGgubGVuZ3RoID8gJy8nICsgcGF0aC5qb2luKCcvJykgOiAnJztcXG59O1xcblxcbnZhciBnZXRTZWFyY2ggPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgcXVlcnkgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnF1ZXJ5O1xcbiAgcmV0dXJuIHF1ZXJ5ID8gJz8nICsgcXVlcnkgOiAnJztcXG59O1xcblxcbnZhciBnZXRTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5zZWFyY2hQYXJhbXM7XFxufTtcXG5cXG52YXIgZ2V0SGFzaCA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBmcmFnbWVudCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcykuZnJhZ21lbnQ7XFxuICByZXR1cm4gZnJhZ21lbnQgPyAnIycgKyBmcmFnbWVudCA6ICcnO1xcbn07XFxuXFxudmFyIGFjY2Vzc29yRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChnZXR0ZXIsIHNldHRlcikge1xcbiAgcmV0dXJuIHsgZ2V0OiBnZXR0ZXIsIHNldDogc2V0dGVyLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWUgfTtcXG59O1xcblxcbmlmIChERVNDUklQVE9SUykge1xcbiAgZGVmaW5lUHJvcGVydGllcyhVUkxQcm90b3R5cGUsIHtcXG4gICAgLy8gYFVSTC5wcm90b3R5cGUuaHJlZmAgYWNjZXNzb3JzIHBhaXJcXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhyZWZcXG4gICAgaHJlZjogYWNjZXNzb3JEZXNjcmlwdG9yKHNlcmlhbGl6ZVVSTCwgZnVuY3Rpb24gKGhyZWYpIHtcXG4gICAgICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcXG4gICAgICB2YXIgdXJsU3RyaW5nID0gU3RyaW5nKGhyZWYpO1xcbiAgICAgIHZhciBmYWlsdXJlID0gcGFyc2VVUkwodXJsLCB1cmxTdHJpbmcpO1xcbiAgICAgIGlmIChmYWlsdXJlKSB0aHJvdyBUeXBlRXJyb3IoZmFpbHVyZSk7XFxuICAgICAgZ2V0SW50ZXJuYWxTZWFyY2hQYXJhbXNTdGF0ZSh1cmwuc2VhcmNoUGFyYW1zKS51cGRhdGVTZWFyY2hQYXJhbXModXJsLnF1ZXJ5KTtcXG4gICAgfSksXFxuICAgIC8vIGBVUkwucHJvdG90eXBlLm9yaWdpbmAgZ2V0dGVyXFxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1vcmlnaW5cXG4gICAgb3JpZ2luOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0T3JpZ2luKSxcXG4gICAgLy8gYFVSTC5wcm90b3R5cGUucHJvdG9jb2xgIGFjY2Vzc29ycyBwYWlyXFxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wcm90b2NvbFxcbiAgICBwcm90b2NvbDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFByb3RvY29sLCBmdW5jdGlvbiAocHJvdG9jb2wpIHtcXG4gICAgICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcXG4gICAgICBwYXJzZVVSTCh1cmwsIFN0cmluZyhwcm90b2NvbCkgKyAnOicsIFNDSEVNRV9TVEFSVCk7XFxuICAgIH0pLFxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS51c2VybmFtZWAgYWNjZXNzb3JzIHBhaXJcXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXVzZXJuYW1lXFxuICAgIHVzZXJuYW1lOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0VXNlcm5hbWUsIGZ1bmN0aW9uICh1c2VybmFtZSkge1xcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xcbiAgICAgIHZhciBjb2RlUG9pbnRzID0gYXJyYXlGcm9tKFN0cmluZyh1c2VybmFtZSkpO1xcbiAgICAgIGlmIChjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQodXJsKSkgcmV0dXJuO1xcbiAgICAgIHVybC51c2VybmFtZSA9ICcnO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZVBvaW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdXJsLnVzZXJuYW1lICs9IHBlcmNlbnRFbmNvZGUoY29kZVBvaW50c1tpXSwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcXG4gICAgICB9XFxuICAgIH0pLFxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5wYXNzd29yZGAgYWNjZXNzb3JzIHBhaXJcXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBhc3N3b3JkXFxuICAgIHBhc3N3b3JkOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0UGFzc3dvcmQsIGZ1bmN0aW9uIChwYXNzd29yZCkge1xcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xcbiAgICAgIHZhciBjb2RlUG9pbnRzID0gYXJyYXlGcm9tKFN0cmluZyhwYXNzd29yZCkpO1xcbiAgICAgIGlmIChjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQodXJsKSkgcmV0dXJuO1xcbiAgICAgIHVybC5wYXNzd29yZCA9ICcnO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZVBvaW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdXJsLnBhc3N3b3JkICs9IHBlcmNlbnRFbmNvZGUoY29kZVBvaW50c1tpXSwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcXG4gICAgICB9XFxuICAgIH0pLFxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5ob3N0YCBhY2Nlc3NvcnMgcGFpclxcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaG9zdFxcbiAgICBob3N0OiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0SG9zdCwgZnVuY3Rpb24gKGhvc3QpIHtcXG4gICAgICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcXG4gICAgICBpZiAodXJsLmNhbm5vdEJlQUJhc2VVUkwpIHJldHVybjtcXG4gICAgICBwYXJzZVVSTCh1cmwsIFN0cmluZyhob3N0KSwgSE9TVCk7XFxuICAgIH0pLFxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5ob3N0bmFtZWAgYWNjZXNzb3JzIHBhaXJcXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLWhvc3RuYW1lXFxuICAgIGhvc3RuYW1lOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0SG9zdG5hbWUsIGZ1bmN0aW9uIChob3N0bmFtZSkge1xcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xcbiAgICAgIGlmICh1cmwuY2Fubm90QmVBQmFzZVVSTCkgcmV0dXJuO1xcbiAgICAgIHBhcnNlVVJMKHVybCwgU3RyaW5nKGhvc3RuYW1lKSwgSE9TVE5BTUUpO1xcbiAgICB9KSxcXG4gICAgLy8gYFVSTC5wcm90b3R5cGUucG9ydGAgYWNjZXNzb3JzIHBhaXJcXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBvcnRcXG4gICAgcG9ydDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFBvcnQsIGZ1bmN0aW9uIChwb3J0KSB7XFxuICAgICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XFxuICAgICAgaWYgKGNhbm5vdEhhdmVVc2VybmFtZVBhc3N3b3JkUG9ydCh1cmwpKSByZXR1cm47XFxuICAgICAgcG9ydCA9IFN0cmluZyhwb3J0KTtcXG4gICAgICBpZiAocG9ydCA9PSAnJykgdXJsLnBvcnQgPSBudWxsO1xcbiAgICAgIGVsc2UgcGFyc2VVUkwodXJsLCBwb3J0LCBQT1JUKTtcXG4gICAgfSksXFxuICAgIC8vIGBVUkwucHJvdG90eXBlLnBhdGhuYW1lYCBhY2Nlc3NvcnMgcGFpclxcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcGF0aG5hbWVcXG4gICAgcGF0aG5hbWU6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRQYXRobmFtZSwgZnVuY3Rpb24gKHBhdGhuYW1lKSB7XFxuICAgICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XFxuICAgICAgaWYgKHVybC5jYW5ub3RCZUFCYXNlVVJMKSByZXR1cm47XFxuICAgICAgdXJsLnBhdGggPSBbXTtcXG4gICAgICBwYXJzZVVSTCh1cmwsIHBhdGhuYW1lICsgJycsIFBBVEhfU1RBUlQpO1xcbiAgICB9KSxcXG4gICAgLy8gYFVSTC5wcm90b3R5cGUuc2VhcmNoYCBhY2Nlc3NvcnMgcGFpclxcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtc2VhcmNoXFxuICAgIHNlYXJjaDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFNlYXJjaCwgZnVuY3Rpb24gKHNlYXJjaCkge1xcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xcbiAgICAgIHNlYXJjaCA9IFN0cmluZyhzZWFyY2gpO1xcbiAgICAgIGlmIChzZWFyY2ggPT0gJycpIHtcXG4gICAgICAgIHVybC5xdWVyeSA9IG51bGw7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICgnPycgPT0gc2VhcmNoLmNoYXJBdCgwKSkgc2VhcmNoID0gc2VhcmNoLnNsaWNlKDEpO1xcbiAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XFxuICAgICAgICBwYXJzZVVSTCh1cmwsIHNlYXJjaCwgUVVFUlkpO1xcbiAgICAgIH1cXG4gICAgICBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlKHVybC5zZWFyY2hQYXJhbXMpLnVwZGF0ZVNlYXJjaFBhcmFtcyh1cmwucXVlcnkpO1xcbiAgICB9KSxcXG4gICAgLy8gYFVSTC5wcm90b3R5cGUuc2VhcmNoUGFyYW1zYCBnZXR0ZXJcXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXNlYXJjaHBhcmFtc1xcbiAgICBzZWFyY2hQYXJhbXM6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRTZWFyY2hQYXJhbXMpLFxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5oYXNoYCBhY2Nlc3NvcnMgcGFpclxcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaGFzaFxcbiAgICBoYXNoOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0SGFzaCwgZnVuY3Rpb24gKGhhc2gpIHtcXG4gICAgICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcXG4gICAgICBoYXNoID0gU3RyaW5nKGhhc2gpO1xcbiAgICAgIGlmIChoYXNoID09ICcnKSB7XFxuICAgICAgICB1cmwuZnJhZ21lbnQgPSBudWxsO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBpZiAoJyMnID09IGhhc2guY2hhckF0KDApKSBoYXNoID0gaGFzaC5zbGljZSgxKTtcXG4gICAgICB1cmwuZnJhZ21lbnQgPSAnJztcXG4gICAgICBwYXJzZVVSTCh1cmwsIGhhc2gsIEZSQUdNRU5UKTtcXG4gICAgfSlcXG4gIH0pO1xcbn1cXG5cXG4vLyBgVVJMLnByb3RvdHlwZS50b0pTT05gIG1ldGhvZFxcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC10b2pzb25cXG5yZWRlZmluZShVUkxQcm90b3R5cGUsICd0b0pTT04nLCBmdW5jdGlvbiB0b0pTT04oKSB7XFxuICByZXR1cm4gc2VyaWFsaXplVVJMLmNhbGwodGhpcyk7XFxufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xcblxcbi8vIGBVUkwucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2RcXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI1VSTC1zdHJpbmdpZmljYXRpb24tYmVoYXZpb3JcXG5yZWRlZmluZShVUkxQcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xcbiAgcmV0dXJuIHNlcmlhbGl6ZVVSTC5jYWxsKHRoaXMpO1xcbn0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcXG5cXG5pZiAoTmF0aXZlVVJMKSB7XFxuICB2YXIgbmF0aXZlQ3JlYXRlT2JqZWN0VVJMID0gTmF0aXZlVVJMLmNyZWF0ZU9iamVjdFVSTDtcXG4gIHZhciBuYXRpdmVSZXZva2VPYmplY3RVUkwgPSBOYXRpdmVVUkwucmV2b2tlT2JqZWN0VVJMO1xcbiAgLy8gYFVSTC5jcmVhdGVPYmplY3RVUkxgIG1ldGhvZFxcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9jcmVhdGVPYmplY3RVUkxcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXFxuICBpZiAobmF0aXZlQ3JlYXRlT2JqZWN0VVJMKSByZWRlZmluZShVUkxDb25zdHJ1Y3RvciwgJ2NyZWF0ZU9iamVjdFVSTCcsIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdFVSTChibG9iKSB7XFxuICAgIHJldHVybiBuYXRpdmVDcmVhdGVPYmplY3RVUkwuYXBwbHkoTmF0aXZlVVJMLCBhcmd1bWVudHMpO1xcbiAgfSk7XFxuICAvLyBgVVJMLnJldm9rZU9iamVjdFVSTGAgbWV0aG9kXFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJML3Jldm9rZU9iamVjdFVSTFxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcXG4gIGlmIChuYXRpdmVSZXZva2VPYmplY3RVUkwpIHJlZGVmaW5lKFVSTENvbnN0cnVjdG9yLCAncmV2b2tlT2JqZWN0VVJMJywgZnVuY3Rpb24gcmV2b2tlT2JqZWN0VVJMKHVybCkge1xcbiAgICByZXR1cm4gbmF0aXZlUmV2b2tlT2JqZWN0VVJMLmFwcGx5KE5hdGl2ZVVSTCwgYXJndW1lbnRzKTtcXG4gIH0pO1xcbn1cXG5cXG5zZXRUb1N0cmluZ1RhZyhVUkxDb25zdHJ1Y3RvciwgJ1VSTCcpO1xcblxcbiQoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogIVVTRV9OQVRJVkVfVVJMLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xcbiAgVVJMOiBVUkxDb25zdHJ1Y3Rvclxcbn0pO1xcblxcblxcbi8qKiovIH0pXFxuXFxuLyoqKioqKi8gXFx0fSk7XFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKioqKioqLyBcXHQvLyBUaGUgbW9kdWxlIGNhY2hlXFxuLyoqKioqKi8gXFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xcbi8qKioqKiovIFxcdFxcbi8qKioqKiovIFxcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXFxuLyoqKioqKi8gXFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xcbi8qKioqKiovIFxcdFxcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxcbi8qKioqKiovIFxcdFxcdGlmKF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0pIHtcXG4vKioqKioqLyBcXHRcXHRcXHRyZXR1cm4gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXS5leHBvcnRzO1xcbi8qKioqKiovIFxcdFxcdH1cXG4vKioqKioqLyBcXHRcXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxcbi8qKioqKiovIFxcdFxcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xcbi8qKioqKiovIFxcdFxcdFxcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcXG4vKioqKioqLyBcXHRcXHRcXHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxcbi8qKioqKiovIFxcdFxcdFxcdGV4cG9ydHM6IHt9XFxuLyoqKioqKi8gXFx0XFx0fTtcXG4vKioqKioqLyBcXHRcXG4vKioqKioqLyBcXHRcXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cXG4vKioqKioqLyBcXHRcXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcXG4vKioqKioqLyBcXHRcXG4vKioqKioqLyBcXHRcXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxcbi8qKioqKiovIFxcdFxcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcXG4vKioqKioqLyBcXHR9XFxuLyoqKioqKi8gXFx0XFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKioqKioqLyBcXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cXG4vKioqKioqLyBcXHQhZnVuY3Rpb24oKSB7XFxuLyoqKioqKi8gXFx0XFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xcbi8qKioqKiovIFxcdFxcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlZmluaXRpb24pIHtcXG4vKioqKioqLyBcXHRcXHRcXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XFxuLyoqKioqKi8gXFx0XFx0XFx0XFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XFxuLyoqKioqKi8gXFx0XFx0XFx0XFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcXG4vKioqKioqLyBcXHRcXHRcXHRcXHR9XFxuLyoqKioqKi8gXFx0XFx0XFx0fVxcbi8qKioqKiovIFxcdFxcdH07XFxuLyoqKioqKi8gXFx0fSgpO1xcbi8qKioqKiovIFxcdFxcbi8qKioqKiovIFxcdC8qIHdlYnBhY2svcnVudGltZS9nbG9iYWwgKi9cXG4vKioqKioqLyBcXHQhZnVuY3Rpb24oKSB7XFxuLyoqKioqKi8gXFx0XFx0X193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xcbi8qKioqKiovIFxcdFxcdFxcdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xcbi8qKioqKiovIFxcdFxcdFxcdHRyeSB7XFxuLyoqKioqKi8gXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XFxuLyoqKioqKi8gXFx0XFx0XFx0fSBjYXRjaCAoZSkge1xcbi8qKioqKiovIFxcdFxcdFxcdFxcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcXG4vKioqKioqLyBcXHRcXHRcXHR9XFxuLyoqKioqKi8gXFx0XFx0fSkoKTtcXG4vKioqKioqLyBcXHR9KCk7XFxuLyoqKioqKi8gXFx0XFxuLyoqKioqKi8gXFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xcbi8qKioqKiovIFxcdCFmdW5jdGlvbigpIHtcXG4vKioqKioqLyBcXHRcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9XFxuLyoqKioqKi8gXFx0fSgpO1xcbi8qKioqKiovIFxcdFxcbi8qKioqKiovIFxcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cXG4vKioqKioqLyBcXHQhZnVuY3Rpb24oKSB7XFxuLyoqKioqKi8gXFx0XFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xcbi8qKioqKiovIFxcdFxcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcXG4vKioqKioqLyBcXHRcXHRcXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcXG4vKioqKioqLyBcXHRcXHRcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcXG4vKioqKioqLyBcXHRcXHRcXHR9XFxuLyoqKioqKi8gXFx0XFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcXG4vKioqKioqLyBcXHRcXHR9O1xcbi8qKioqKiovIFxcdH0oKTtcXG4vKioqKioqLyBcXHRcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XFxuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaW4gc3RyaWN0IG1vZGUuXFxuIWZ1bmN0aW9uKCkge1xcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG4vLyBFU00gQ09NUEFUIEZMQUdcXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuXFxuLy8gRVhQT1JUU1xcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuICBcXFwiRHJvcHpvbmVcXFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIHJlZXhwb3J0ICovIERyb3B6b25lOyB9LFxcbiAgXFxcImRlZmF1bHRcXFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gZHJvcHpvbmVfZGlzdDsgfVxcbn0pO1xcblxcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qc1xcbnZhciBlc19hcnJheV9jb25jYXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyMjIpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlci5qc1xcbnZhciBlc19hcnJheV9maWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczMjcpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluZGV4LW9mLmpzXFxudmFyIGVzX2FycmF5X2luZGV4X29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNzcyKTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qc1xcbnZhciBlc19hcnJheV9pdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjk5Mik7XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzXFxudmFyIGVzX2FycmF5X21hcCA9IF9fd2VicGFja19yZXF1aXJlX18oMTI0OSk7XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanNcXG52YXIgZXNfYXJyYXlfc2xpY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwNDIpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZS5qc1xcbnZhciBlc19hcnJheV9zcGxpY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2MSk7XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXktYnVmZmVyLmNvbnN0cnVjdG9yLmpzXFxudmFyIGVzX2FycmF5X2J1ZmZlcl9jb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oODI2NCk7XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qc1xcbnZhciBlc19mdW5jdGlvbl9uYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MzA5KTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xcbnZhciBlc19vYmplY3RfZ2V0X3Byb3RvdHlwZV9vZiA9IF9fd2VicGFja19yZXF1aXJlX18oNDg5KTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzXFxudmFyIGVzX29iamVjdF90b19zdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1MzkpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzXFxudmFyIGVzX3JlZ2V4cF9leGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTE2KTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzXFxudmFyIGVzX3JlZ2V4cF90b19zdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3MTQpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qc1xcbnZhciBlc19zdHJpbmdfaXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3ODMpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qc1xcbnZhciBlc19zdHJpbmdfbWF0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3MjMpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlLmpzXFxudmFyIGVzX3N0cmluZ19yZXBsYWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MzA2KTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanNcXG52YXIgZXNfc3RyaW5nX3NwbGl0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTIzKTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbS5qc1xcbnZhciBlc19zdHJpbmdfdHJpbSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIxMCk7XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtYXJyYXkuanNcXG52YXIgZXNfdHlwZWRfYXJyYXlfdWludDhfYXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NzIpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluLmpzXFxudmFyIGVzX3R5cGVkX2FycmF5X2NvcHlfd2l0aGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTkwKTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeS5qc1xcbnZhciBlc190eXBlZF9hcnJheV9ldmVyeSA9IF9fd2VicGFja19yZXF1aXJlX18oODkyNyk7XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbC5qc1xcbnZhciBlc190eXBlZF9hcnJheV9maWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTA1KTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXIuanNcXG52YXIgZXNfdHlwZWRfYXJyYXlfZmlsdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDM1KTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLmpzXFxudmFyIGVzX3R5cGVkX2FycmF5X2ZpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNDUpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQtaW5kZXguanNcXG52YXIgZXNfdHlwZWRfYXJyYXlfZmluZF9pbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oNzE3NCk7XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZm9yLWVhY2guanNcXG52YXIgZXNfdHlwZWRfYXJyYXlfZm9yX2VhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4NDYpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluY2x1ZGVzLmpzXFxudmFyIGVzX3R5cGVkX2FycmF5X2luY2x1ZGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NzMxKTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZi5qc1xcbnZhciBlc190eXBlZF9hcnJheV9pbmRleF9vZiA9IF9fd2VicGFja19yZXF1aXJlX18oNzIwOSk7XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaXRlcmF0b3IuanNcXG52YXIgZXNfdHlwZWRfYXJyYXlfaXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzMTkpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmpvaW4uanNcXG52YXIgZXNfdHlwZWRfYXJyYXlfam9pbiA9IF9fd2VicGFja19yZXF1aXJlX18oODg2Nyk7XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubGFzdC1pbmRleC1vZi5qc1xcbnZhciBlc190eXBlZF9hcnJheV9sYXN0X2luZGV4X29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nzg5KTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXAuanNcXG52YXIgZXNfdHlwZWRfYXJyYXlfbWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzM5KTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UuanNcXG52YXIgZXNfdHlwZWRfYXJyYXlfcmVkdWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzY4KTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHQuanNcXG52YXIgZXNfdHlwZWRfYXJyYXlfcmVkdWNlX3JpZ2h0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NDgzKTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlLmpzXFxudmFyIGVzX3R5cGVkX2FycmF5X3JldmVyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNTYpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNldC5qc1xcbnZhciBlc190eXBlZF9hcnJheV9zZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NjIpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNsaWNlLmpzXFxudmFyIGVzX3R5cGVkX2FycmF5X3NsaWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzgpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvbWUuanNcXG52YXIgZXNfdHlwZWRfYXJyYXlfc29tZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzQ2Mik7XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydC5qc1xcbnZhciBlc190eXBlZF9hcnJheV9zb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODI0KTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zdWJhcnJheS5qc1xcbnZhciBlc190eXBlZF9hcnJheV9zdWJhcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNTAyMSk7XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZy5qc1xcbnZhciBlc190eXBlZF9hcnJheV90b19sb2NhbGVfc3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTc0KTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1zdHJpbmcuanNcXG52YXIgZXNfdHlwZWRfYXJyYXlfdG9fc3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDE2KTtcXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzXFxudmFyIHdlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3NDcpO1xcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcXG52YXIgd2ViX2RvbV9jb2xsZWN0aW9uc19pdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzk0OCk7XFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnVybC5qc1xcbnZhciB3ZWJfdXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyODUpO1xcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9lbWl0dGVyLmpzXFxuXFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcInVuZGVmaW5lZFxcXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXFxcIm51bWJlclxcXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXFxcIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxcblxcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXFxcInN0cmluZ1xcXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcXFwiT2JqZWN0XFxcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXFxcIk1hcFxcXCIgfHwgbiA9PT0gXFxcIlNldFxcXCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXFxcIkFyZ3VtZW50c1xcXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XFxuXFxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbi8vIFRoZSBFbWl0dGVyIGNsYXNzIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIGNhbGwgYC5vbigpYCBvbiBEcm9wem9uZSB0byBsaXN0ZW5cXG4vLyB0byBldmVudHMuXFxuLy8gSXQgaXMgc3Ryb25nbHkgYmFzZWQgb24gY29tcG9uZW50J3MgZW1pdHRlciBjbGFzcywgYW5kIEkgcmVtb3ZlZCB0aGVcXG4vLyBmdW5jdGlvbmFsaXR5IGJlY2F1c2Ugb2YgdGhlIGRlcGVuZGVuY3kgaGVsbCB3aXRoIGRpZmZlcmVudCBmcmFtZXdvcmtzLlxcbnZhciBFbWl0dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIEVtaXR0ZXIoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWl0dGVyKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhFbWl0dGVyLCBbe1xcbiAgICBrZXk6IFxcXCJvblxcXCIsXFxuICAgIHZhbHVlOiAvLyBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGdpdmVuIGV2ZW50XFxuICAgIGZ1bmN0aW9uIG9uKGV2ZW50LCBmbikge1xcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTsgLy8gQ3JlYXRlIG5hbWVzcGFjZSBmb3IgdGhpcyBldmVudFxcblxcbiAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSkge1xcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IFtdO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9jYWxsYmFja3NbZXZlbnRdLnB1c2goZm4pO1xcblxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImVtaXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChldmVudCkge1xcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcXG4gICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcXG5cXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XFxuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGNhbGxiYWNrcykge1xcbiAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGNhbGxiYWNrcywgdHJ1ZSksXFxuICAgICAgICAgICAgX3N0ZXA7XFxuXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IF9zdGVwLnZhbHVlO1xcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcXG4gICAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyB0cmlnZ2VyIGEgY29ycmVzcG9uZGluZyBET00gZXZlbnRcXG5cXG5cXG4gICAgICBpZiAodGhpcy5lbGVtZW50KSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudCh0aGlzLm1ha2VFdmVudChcXFwiZHJvcHpvbmU6XFxcIiArIGV2ZW50LCB7XFxuICAgICAgICAgIGFyZ3M6IGFyZ3NcXG4gICAgICAgIH0pKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwibWFrZUV2ZW50XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VFdmVudChldmVudE5hbWUsIGRldGFpbCkge1xcbiAgICAgIHZhciBwYXJhbXMgPSB7XFxuICAgICAgICBidWJibGVzOiB0cnVlLFxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcXG4gICAgICAgIGRldGFpbDogZGV0YWlsXFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHBhcmFtcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIElFIDExIHN1cHBvcnRcXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9DdXN0b21FdmVudFxcbiAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFxcXCJDdXN0b21FdmVudFxcXCIpO1xcbiAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudE5hbWUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XFxuICAgICAgICByZXR1cm4gZXZ0O1xcbiAgICAgIH1cXG4gICAgfSAvLyBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgZm9yIGdpdmVuIGV2ZW50LiBJZiBmbiBpcyBub3QgcHJvdmlkZWQsIGFsbCBldmVudFxcbiAgICAvLyBsaXN0ZW5lcnMgZm9yIHRoYXQgZXZlbnQgd2lsbCBiZSByZW1vdmVkLiBJZiBuZWl0aGVyIGlzIHByb3ZpZGVkLCBhbGxcXG4gICAgLy8gZXZlbnQgbGlzdGVuZXJzIHdpbGwgYmUgcmVtb3ZlZC5cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwib2ZmXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihldmVudCwgZm4pIHtcXG4gICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH0gLy8gc3BlY2lmaWMgZXZlbnRcXG5cXG5cXG4gICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcXG5cXG4gICAgICBpZiAoIWNhbGxiYWNrcykge1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfSAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXFxuXFxuXFxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfSAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxcblxcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XFxuXFxuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IGZuKSB7XFxuICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIEVtaXR0ZXI7XFxufSgpO1xcblxcblxcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9wcmV2aWV3LXRlbXBsYXRlLmh0bWxcXG4vLyBNb2R1bGVcXG52YXIgY29kZSA9IFxcXCI8ZGl2IGNsYXNzPVxcXFxcXFwiZHotcHJldmlldyBkei1maWxlLXByZXZpZXdcXFxcXFxcIj4gPGRpdiBjbGFzcz1cXFxcXFxcImR6LWltYWdlXFxcXFxcXCI+PGltZyBkYXRhLWR6LXRodW1ibmFpbC8+PC9kaXY+IDxkaXYgY2xhc3M9XFxcXFxcXCJkei1kZXRhaWxzXFxcXFxcXCI+IDxkaXYgY2xhc3M9XFxcXFxcXCJkei1zaXplXFxcXFxcXCI+PHNwYW4gZGF0YS1kei1zaXplPjwvc3Bhbj48L2Rpdj4gPGRpdiBjbGFzcz1cXFxcXFxcImR6LWZpbGVuYW1lXFxcXFxcXCI+PHNwYW4gZGF0YS1kei1uYW1lPjwvc3Bhbj48L2Rpdj4gPC9kaXY+IDxkaXYgY2xhc3M9XFxcXFxcXCJkei1wcm9ncmVzc1xcXFxcXFwiPiA8c3BhbiBjbGFzcz1cXFxcXFxcImR6LXVwbG9hZFxcXFxcXFwiIGRhdGEtZHotdXBsb2FkcHJvZ3Jlc3M+PC9zcGFuPiA8L2Rpdj4gPGRpdiBjbGFzcz1cXFxcXFxcImR6LWVycm9yLW1lc3NhZ2VcXFxcXFxcIj48c3BhbiBkYXRhLWR6LWVycm9ybWVzc2FnZT48L3NwYW4+PC9kaXY+IDxkaXYgY2xhc3M9XFxcXFxcXCJkei1zdWNjZXNzLW1hcmtcXFxcXFxcIj4gPHN2ZyB3aWR0aD1cXFxcXFxcIjU0cHhcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCI1NHB4XFxcXFxcXCIgdmlld0JveD1cXFxcXFxcIjAgMCA1NCA1NFxcXFxcXFwiIHZlcnNpb249XFxcXFxcXCIxLjFcXFxcXFxcIiB4bWxucz1cXFxcXFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcXFxcXCIgeG1sbnM6eGxpbms9XFxcXFxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcXFxcXCI+IDx0aXRsZT5DaGVjazwvdGl0bGU+IDxnIHN0cm9rZT1cXFxcXFxcIm5vbmVcXFxcXFxcIiBzdHJva2Utd2lkdGg9XFxcXFxcXCIxXFxcXFxcXCIgZmlsbD1cXFxcXFxcIm5vbmVcXFxcXFxcIiBmaWxsLXJ1bGU9XFxcXFxcXCJldmVub2RkXFxcXFxcXCI+IDxwYXRoIGQ9XFxcXFxcXCJNMjMuNSwzMS44NDMxNDU4IEwxNy41ODUyNDE5LDI1LjkyODM4NzcgQzE2LjAyNDgyNTMsMjQuMzY3OTcxMSAxMy40OTEwMjk0LDI0LjM2NjgzNSAxMS45Mjg5MzIyLDI1LjkyODkzMjIgQzEwLjM3MDAxMzYsMjcuNDg3ODUwOCAxMC4zNjY1OTEyLDMwLjAyMzQ0NTUgMTEuOTI4Mzg3NywzMS41ODUyNDE5IEwyMC40MTQ3NTgxLDQwLjA3MTYxMjMgQzIwLjUxMzM5OTksNDAuMTcwMjU0MSAyMC42MTU5MzE1LDQwLjI2MjY2NDkgMjAuNzIxODYxNSw0MC4zNDg4NDM1IEMyMi4yODM1NjY5LDQxLjg3MjU2NTEgMjQuNzk0MjM0LDQxLjg2MjYyMDIgMjYuMzQ2MTU2NCw0MC4zMTA2OTc4IEw0My4zMTA2OTc4LDIzLjM0NjE1NjQgQzQ0Ljg3NzEwMjEsMjEuNzc5NzUyMSA0NC44NzU4MDU3LDE5LjI0ODM4ODcgNDMuMzEzNzA4NSwxNy42ODYyOTE1IEM0MS43NTQ3ODk5LDE2LjEyNzM3MjkgMzkuMjE3NjAzNSwxNi4xMjU1NDIyIDM3LjY1Mzg0MzYsMTcuNjg5MzAyMiBMMjMuNSwzMS44NDMxNDU4IFogTTI3LDUzIEM0MS4zNTk0MDM1LDUzIDUzLDQxLjM1OTQwMzUgNTMsMjcgQzUzLDEyLjY0MDU5NjUgNDEuMzU5NDAzNSwxIDI3LDEgQzEyLjY0MDU5NjUsMSAxLDEyLjY0MDU5NjUgMSwyNyBDMSw0MS4zNTk0MDM1IDEyLjY0MDU5NjUsNTMgMjcsNTMgWlxcXFxcXFwiIHN0cm9rZS1vcGFjaXR5PVxcXFxcXFwiMC4xOTg3OTQxNThcXFxcXFxcIiBzdHJva2U9XFxcXFxcXCIjNzQ3NDc0XFxcXFxcXCIgZmlsbC1vcGFjaXR5PVxcXFxcXFwiMC44MTY1MTk0NzVcXFxcXFxcIiBmaWxsPVxcXFxcXFwiI0ZGRkZGRlxcXFxcXFwiPjwvcGF0aD4gPC9nPiA8L3N2Zz4gPC9kaXY+IDxkaXYgY2xhc3M9XFxcXFxcXCJkei1lcnJvci1tYXJrXFxcXFxcXCI+IDxzdmcgd2lkdGg9XFxcXFxcXCI1NHB4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiNTRweFxcXFxcXFwiIHZpZXdCb3g9XFxcXFxcXCIwIDAgNTQgNTRcXFxcXFxcIiB2ZXJzaW9uPVxcXFxcXFwiMS4xXFxcXFxcXCIgeG1sbnM9XFxcXFxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXFxcXFwiIHhtbG5zOnhsaW5rPVxcXFxcXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXFxcXFwiPiA8dGl0bGU+RXJyb3I8L3RpdGxlPiA8ZyBzdHJva2U9XFxcXFxcXCJub25lXFxcXFxcXCIgc3Ryb2tlLXdpZHRoPVxcXFxcXFwiMVxcXFxcXFwiIGZpbGw9XFxcXFxcXCJub25lXFxcXFxcXCIgZmlsbC1ydWxlPVxcXFxcXFwiZXZlbm9kZFxcXFxcXFwiPiA8ZyBzdHJva2U9XFxcXFxcXCIjNzQ3NDc0XFxcXFxcXCIgc3Ryb2tlLW9wYWNpdHk9XFxcXFxcXCIwLjE5ODc5NDE1OFxcXFxcXFwiIGZpbGw9XFxcXFxcXCIjRkZGRkZGXFxcXFxcXCIgZmlsbC1vcGFjaXR5PVxcXFxcXFwiMC44MTY1MTk0NzVcXFxcXFxcIj4gPHBhdGggZD1cXFxcXFxcIk0zMi42NTY4NTQyLDI5IEwzOC4zMTA2OTc4LDIzLjM0NjE1NjQgQzM5Ljg3NzEwMjEsMjEuNzc5NzUyMSAzOS44NzU4MDU3LDE5LjI0ODM4ODcgMzguMzEzNzA4NSwxNy42ODYyOTE1IEMzNi43NTQ3ODk5LDE2LjEyNzM3MjkgMzQuMjE3NjAzNSwxNi4xMjU1NDIyIDMyLjY1Mzg0MzYsMTcuNjg5MzAyMiBMMjcsMjMuMzQzMTQ1OCBMMjEuMzQ2MTU2NCwxNy42ODkzMDIyIEMxOS43ODIzOTY1LDE2LjEyNTU0MjIgMTcuMjQ1MjEwMSwxNi4xMjczNzI5IDE1LjY4NjI5MTUsMTcuNjg2MjkxNSBDMTQuMTI0MTk0MywxOS4yNDgzODg3IDE0LjEyMjg5NzksMjEuNzc5NzUyMSAxNS42ODkzMDIyLDIzLjM0NjE1NjQgTDIxLjM0MzE0NTgsMjkgTDE1LjY4OTMwMjIsMzQuNjUzODQzNiBDMTQuMTIyODk3OSwzNi4yMjAyNDc5IDE0LjEyNDE5NDMsMzguNzUxNjExMyAxNS42ODYyOTE1LDQwLjMxMzcwODUgQzE3LjI0NTIxMDEsNDEuODcyNjI3MSAxOS43ODIzOTY1LDQxLjg3NDQ1NzggMjEuMzQ2MTU2NCw0MC4zMTA2OTc4IEwyNywzNC42NTY4NTQyIEwzMi42NTM4NDM2LDQwLjMxMDY5NzggQzM0LjIxNzYwMzUsNDEuODc0NDU3OCAzNi43NTQ3ODk5LDQxLjg3MjYyNzEgMzguMzEzNzA4NSw0MC4zMTM3MDg1IEMzOS44NzU4MDU3LDM4Ljc1MTYxMTMgMzkuODc3MTAyMSwzNi4yMjAyNDc5IDM4LjMxMDY5NzgsMzQuNjUzODQzNiBMMzIuNjU2ODU0MiwyOSBaIE0yNyw1MyBDNDEuMzU5NDAzNSw1MyA1Myw0MS4zNTk0MDM1IDUzLDI3IEM1MywxMi42NDA1OTY1IDQxLjM1OTQwMzUsMSAyNywxIEMxMi42NDA1OTY1LDEgMSwxMi42NDA1OTY1IDEsMjcgQzEsNDEuMzU5NDAzNSAxMi42NDA1OTY1LDUzIDI3LDUzIFpcXFxcXFxcIj48L3BhdGg+IDwvZz4gPC9nPiA8L3N2Zz4gPC9kaXY+IDwvZGl2PiBcXFwiO1xcbi8vIEV4cG9ydHNcXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwcmV2aWV3X3RlbXBsYXRlID0gKGNvZGUpO1xcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9vcHRpb25zLmpzXFxuXFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gb3B0aW9uc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJ1bmRlZmluZWRcXFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IG9wdGlvbnNfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcXFwibnVtYmVyXFxcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cXFwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XFxuXFxuZnVuY3Rpb24gb3B0aW9uc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXFxcInN0cmluZ1xcXCIpIHJldHVybiBvcHRpb25zX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXFxcIk9iamVjdFxcXCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFxcXCJNYXBcXFwiIHx8IG4gPT09IFxcXCJTZXRcXFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFxcXCJBcmd1bWVudHNcXFwiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gb3B0aW9uc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cXG5cXG5mdW5jdGlvbiBvcHRpb25zX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XFxuXFxuXFxuXFxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xcbiAgLyoqXFxuICAgKiBIYXMgdG8gYmUgc3BlY2lmaWVkIG9uIGVsZW1lbnRzIG90aGVyIHRoYW4gZm9ybSAob3Igd2hlbiB0aGUgZm9ybVxcbiAgICogZG9lc24ndCBoYXZlIGFuIGBhY3Rpb25gIGF0dHJpYnV0ZSkuIFlvdSBjYW4gYWxzb1xcbiAgICogcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBgZmlsZXNgIGFuZFxcbiAgICogbXVzdCByZXR1cm4gdGhlIHVybCAoc2luY2UgYHYzLjEyLjBgKVxcbiAgICovXFxuICB1cmw6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIENhbiBiZSBjaGFuZ2VkIHRvIGBcXFwicHV0XFxcImAgaWYgbmVjZXNzYXJ5LiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIGZ1bmN0aW9uXFxuICAgKiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYGZpbGVzYCBhbmQgbXVzdCByZXR1cm4gdGhlIG1ldGhvZCAoc2luY2UgYHYzLjEyLjBgKS5cXG4gICAqL1xcbiAgbWV0aG9kOiBcXFwicG9zdFxcXCIsXFxuXFxuICAvKipcXG4gICAqIFdpbGwgYmUgc2V0IG9uIHRoZSBYSFJlcXVlc3QuXFxuICAgKi9cXG4gIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIFRoZSB0aW1lb3V0IGZvciB0aGUgWEhSIHJlcXVlc3RzIGluIG1pbGxpc2Vjb25kcyAoc2luY2UgYHY0LjQuMGApLlxcbiAgICogSWYgc2V0IHRvIG51bGwgb3IgMCwgbm8gdGltZW91dCBpcyBnb2luZyB0byBiZSBzZXQuXFxuICAgKi9cXG4gIHRpbWVvdXQ6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIEhvdyBtYW55IGZpbGUgdXBsb2FkcyB0byBwcm9jZXNzIGluIHBhcmFsbGVsIChTZWUgdGhlXFxuICAgKiBFbnF1ZXVpbmcgZmlsZSB1cGxvYWRzIGRvY3VtZW50YXRpb24gc2VjdGlvbiBmb3IgbW9yZSBpbmZvKVxcbiAgICovXFxuICBwYXJhbGxlbFVwbG9hZHM6IDIsXFxuXFxuICAvKipcXG4gICAqIFdoZXRoZXIgdG8gc2VuZCBtdWx0aXBsZSBmaWxlcyBpbiBvbmUgcmVxdWVzdC4gSWZcXG4gICAqIHRoaXMgaXQgc2V0IHRvIHRydWUsIHRoZW4gdGhlIGZhbGxiYWNrIGZpbGUgaW5wdXQgZWxlbWVudCB3aWxsXFxuICAgKiBoYXZlIHRoZSBgbXVsdGlwbGVgIGF0dHJpYnV0ZSBhcyB3ZWxsLiBUaGlzIG9wdGlvbiB3aWxsXFxuICAgKiBhbHNvIHRyaWdnZXIgYWRkaXRpb25hbCBldmVudHMgKGxpa2UgYHByb2Nlc3NpbmdtdWx0aXBsZWApLiBTZWUgdGhlIGV2ZW50c1xcbiAgICogZG9jdW1lbnRhdGlvbiBzZWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxcbiAgICovXFxuICB1cGxvYWRNdWx0aXBsZTogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIFdoZXRoZXIgeW91IHdhbnQgZmlsZXMgdG8gYmUgdXBsb2FkZWQgaW4gY2h1bmtzIHRvIHlvdXIgc2VydmVyLiBUaGlzIGNhbid0IGJlXFxuICAgKiB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYHVwbG9hZE11bHRpcGxlYC5cXG4gICAqXFxuICAgKiBTZWUgW2NodW5rc1VwbG9hZGVkXSgjY29uZmlnLWNodW5rc1VwbG9hZGVkKSBmb3IgdGhlIGNhbGxiYWNrIHRvIGZpbmFsaXNlIGFuIHVwbG9hZC5cXG4gICAqL1xcbiAgY2h1bmtpbmc6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBJZiBgY2h1bmtpbmdgIGlzIGVuYWJsZWQsIHRoaXMgZGVmaW5lcyB3aGV0aGVyICoqZXZlcnkqKiBmaWxlIHNob3VsZCBiZSBjaHVua2VkLFxcbiAgICogZXZlbiBpZiB0aGUgZmlsZSBzaXplIGlzIGJlbG93IGNodW5rU2l6ZS4gVGhpcyBtZWFucywgdGhhdCB0aGUgYWRkaXRpb25hbCBjaHVua1xcbiAgICogZm9ybSBkYXRhIHdpbGwgYmUgc3VibWl0dGVkIGFuZCB0aGUgYGNodW5rc1VwbG9hZGVkYCBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQuXFxuICAgKi9cXG4gIGZvcmNlQ2h1bmtpbmc6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBJZiBgY2h1bmtpbmdgIGlzIGB0cnVlYCwgdGhlbiB0aGlzIGRlZmluZXMgdGhlIGNodW5rIHNpemUgaW4gYnl0ZXMuXFxuICAgKi9cXG4gIGNodW5rU2l6ZTogMjAwMDAwMCxcXG5cXG4gIC8qKlxcbiAgICogSWYgYHRydWVgLCB0aGUgaW5kaXZpZHVhbCBjaHVua3Mgb2YgYSBmaWxlIGFyZSBiZWluZyB1cGxvYWRlZCBzaW11bHRhbmVvdXNseS5cXG4gICAqL1xcbiAgcGFyYWxsZWxDaHVua1VwbG9hZHM6IGZhbHNlLFxcblxcbiAgLyoqXFxuICAgKiBXaGV0aGVyIGEgY2h1bmsgc2hvdWxkIGJlIHJldHJpZWQgaWYgaXQgZmFpbHMuXFxuICAgKi9cXG4gIHJldHJ5Q2h1bmtzOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogSWYgYHJldHJ5Q2h1bmtzYCBpcyB0cnVlLCBob3cgbWFueSB0aW1lcyBzaG91bGQgaXQgYmUgcmV0cmllZC5cXG4gICAqL1xcbiAgcmV0cnlDaHVua3NMaW1pdDogMyxcXG5cXG4gIC8qKlxcbiAgICogVGhlIG1heGltdW0gZmlsZXNpemUgKGluIGJ5dGVzKSB0aGF0IGlzIGFsbG93ZWQgdG8gYmUgdXBsb2FkZWQuXFxuICAgKi9cXG4gIG1heEZpbGVzaXplOiAyNTYsXFxuXFxuICAvKipcXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHBhcmFtIHRoYXQgZ2V0cyB0cmFuc2ZlcnJlZC5cXG4gICAqICoqTk9URSoqOiBJZiB5b3UgaGF2ZSB0aGUgb3B0aW9uICBgdXBsb2FkTXVsdGlwbGVgIHNldCB0byBgdHJ1ZWAsIHRoZW5cXG4gICAqIERyb3B6b25lIHdpbGwgYXBwZW5kIGBbXWAgdG8gdGhlIG5hbWUuXFxuICAgKi9cXG4gIHBhcmFtTmFtZTogXFxcImZpbGVcXFwiLFxcblxcbiAgLyoqXFxuICAgKiBXaGV0aGVyIHRodW1ibmFpbHMgZm9yIGltYWdlcyBzaG91bGQgYmUgZ2VuZXJhdGVkXFxuICAgKi9cXG4gIGNyZWF0ZUltYWdlVGh1bWJuYWlsczogdHJ1ZSxcXG5cXG4gIC8qKlxcbiAgICogSW4gTUIuIFdoZW4gdGhlIGZpbGVuYW1lIGV4Y2VlZHMgdGhpcyBsaW1pdCwgdGhlIHRodW1ibmFpbCB3aWxsIG5vdCBiZSBnZW5lcmF0ZWQuXFxuICAgKi9cXG4gIG1heFRodW1ibmFpbEZpbGVzaXplOiAxMCxcXG5cXG4gIC8qKlxcbiAgICogSWYgYG51bGxgLCB0aGUgcmF0aW8gb2YgdGhlIGltYWdlIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgaXQuXFxuICAgKi9cXG4gIHRodW1ibmFpbFdpZHRoOiAxMjAsXFxuXFxuICAvKipcXG4gICAqIFRoZSBzYW1lIGFzIGB0aHVtYm5haWxXaWR0aGAuIElmIGJvdGggYXJlIG51bGwsIGltYWdlcyB3aWxsIG5vdCBiZSByZXNpemVkLlxcbiAgICovXFxuICB0aHVtYm5haWxIZWlnaHQ6IDEyMCxcXG5cXG4gIC8qKlxcbiAgICogSG93IHRoZSBpbWFnZXMgc2hvdWxkIGJlIHNjYWxlZCBkb3duIGluIGNhc2UgYm90aCwgYHRodW1ibmFpbFdpZHRoYCBhbmQgYHRodW1ibmFpbEhlaWdodGAgYXJlIHByb3ZpZGVkLlxcbiAgICogQ2FuIGJlIGVpdGhlciBgY29udGFpbmAgb3IgYGNyb3BgLlxcbiAgICovXFxuICB0aHVtYm5haWxNZXRob2Q6IFxcXCJjcm9wXFxcIixcXG5cXG4gIC8qKlxcbiAgICogSWYgc2V0LCBpbWFnZXMgd2lsbCBiZSByZXNpemVkIHRvIHRoZXNlIGRpbWVuc2lvbnMgYmVmb3JlIGJlaW5nICoqdXBsb2FkZWQqKi5cXG4gICAqIElmIG9ubHkgb25lLCBgcmVzaXplV2lkdGhgICoqb3IqKiBgcmVzaXplSGVpZ2h0YCBpcyBwcm92aWRlZCwgdGhlIG9yaWdpbmFsIGFzcGVjdFxcbiAgICogcmF0aW8gb2YgdGhlIGZpbGUgd2lsbCBiZSBwcmVzZXJ2ZWQuXFxuICAgKlxcbiAgICogVGhlIGBvcHRpb25zLnRyYW5zZm9ybUZpbGVgIGZ1bmN0aW9uIHVzZXMgdGhlc2Ugb3B0aW9ucywgc28gaWYgdGhlIGB0cmFuc2Zvcm1GaWxlYCBmdW5jdGlvblxcbiAgICogaXMgb3ZlcnJpZGRlbiwgdGhlc2Ugb3B0aW9ucyBkb24ndCBkbyBhbnl0aGluZy5cXG4gICAqL1xcbiAgcmVzaXplV2lkdGg6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIFNlZSBgcmVzaXplV2lkdGhgLlxcbiAgICovXFxuICByZXNpemVIZWlnaHQ6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIFRoZSBtaW1lIHR5cGUgb2YgdGhlIHJlc2l6ZWQgaW1hZ2UgKGJlZm9yZSBpdCBnZXRzIHVwbG9hZGVkIHRvIHRoZSBzZXJ2ZXIpLlxcbiAgICogSWYgYG51bGxgIHRoZSBvcmlnaW5hbCBtaW1lIHR5cGUgd2lsbCBiZSB1c2VkLiBUbyBmb3JjZSBqcGVnLCBmb3IgZXhhbXBsZSwgdXNlIGBpbWFnZS9qcGVnYC5cXG4gICAqIFNlZSBgcmVzaXplV2lkdGhgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxcbiAgICovXFxuICByZXNpemVNaW1lVHlwZTogbnVsbCxcXG5cXG4gIC8qKlxcbiAgICogVGhlIHF1YWxpdHkgb2YgdGhlIHJlc2l6ZWQgaW1hZ2VzLiBTZWUgYHJlc2l6ZVdpZHRoYC5cXG4gICAqL1xcbiAgcmVzaXplUXVhbGl0eTogMC44LFxcblxcbiAgLyoqXFxuICAgKiBIb3cgdGhlIGltYWdlcyBzaG91bGQgYmUgc2NhbGVkIGRvd24gaW4gY2FzZSBib3RoLCBgcmVzaXplV2lkdGhgIGFuZCBgcmVzaXplSGVpZ2h0YCBhcmUgcHJvdmlkZWQuXFxuICAgKiBDYW4gYmUgZWl0aGVyIGBjb250YWluYCBvciBgY3JvcGAuXFxuICAgKi9cXG4gIHJlc2l6ZU1ldGhvZDogXFxcImNvbnRhaW5cXFwiLFxcblxcbiAgLyoqXFxuICAgKiBUaGUgYmFzZSB0aGF0IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSAqKmRpc3BsYXllZCoqIGZpbGVzaXplLiBZb3UgY2FuXFxuICAgKiBjaGFuZ2UgdGhpcyB0byAxMDI0IGlmIHlvdSB3b3VsZCByYXRoZXIgZGlzcGxheSBraWJpYnl0ZXMsIG1lYmlieXRlcyxcXG4gICAqIGV0Yy4uLiAxMDI0IGlzIHRlY2huaWNhbGx5IGluY29ycmVjdCwgYmVjYXVzZSBgMTAyNCBieXRlc2AgYXJlIGAxIGtpYmlieXRlYFxcbiAgICogbm90IGAxIGtpbG9ieXRlYC4gWW91IGNhbiBjaGFuZ2UgdGhpcyB0byBgMTAyNGAgaWYgeW91IGRvbid0IGNhcmUgYWJvdXRcXG4gICAqIHZhbGlkaXR5LlxcbiAgICovXFxuICBmaWxlc2l6ZUJhc2U6IDEwMDAsXFxuXFxuICAvKipcXG4gICAqIElmIG5vdCBgbnVsbGAgZGVmaW5lcyBob3cgbWFueSBmaWxlcyB0aGlzIERyb3B6b25lIGhhbmRsZXMuIElmIGl0IGV4Y2VlZHMsXFxuICAgKiB0aGUgZXZlbnQgYG1heGZpbGVzZXhjZWVkZWRgIHdpbGwgYmUgY2FsbGVkLiBUaGUgZHJvcHpvbmUgZWxlbWVudCBnZXRzIHRoZVxcbiAgICogY2xhc3MgYGR6LW1heC1maWxlcy1yZWFjaGVkYCBhY2NvcmRpbmdseSBzbyB5b3UgY2FuIHByb3ZpZGUgdmlzdWFsXFxuICAgKiBmZWVkYmFjay5cXG4gICAqL1xcbiAgbWF4RmlsZXM6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIEFuIG9wdGlvbmFsIG9iamVjdCB0byBzZW5kIGFkZGl0aW9uYWwgaGVhZGVycyB0byB0aGUgc2VydmVyLiBFZzpcXG4gICAqIGB7IFxcXCJNeS1Bd2Vzb21lLUhlYWRlclxcXCI6IFxcXCJoZWFkZXIgdmFsdWVcXFwiIH1gXFxuICAgKi9cXG4gIGhlYWRlcnM6IG51bGwsXFxuXFxuICAvKipcXG4gICAqIElmIGB0cnVlYCwgdGhlIGRyb3B6b25lIGVsZW1lbnQgaXRzZWxmIHdpbGwgYmUgY2xpY2thYmxlLCBpZiBgZmFsc2VgXFxuICAgKiBub3RoaW5nIHdpbGwgYmUgY2xpY2thYmxlLlxcbiAgICpcXG4gICAqIFlvdSBjYW4gYWxzbyBwYXNzIGFuIEhUTUwgZWxlbWVudCwgYSBDU1Mgc2VsZWN0b3IgKGZvciBtdWx0aXBsZSBlbGVtZW50cylcXG4gICAqIG9yIGFuIGFycmF5IG9mIHRob3NlLiBJbiB0aGF0IGNhc2UsIGFsbCBvZiB0aG9zZSBlbGVtZW50cyB3aWxsIHRyaWdnZXIgYW5cXG4gICAqIHVwbG9hZCB3aGVuIGNsaWNrZWQuXFxuICAgKi9cXG4gIGNsaWNrYWJsZTogdHJ1ZSxcXG5cXG4gIC8qKlxcbiAgICogV2hldGhlciBoaWRkZW4gZmlsZXMgaW4gZGlyZWN0b3JpZXMgc2hvdWxkIGJlIGlnbm9yZWQuXFxuICAgKi9cXG4gIGlnbm9yZUhpZGRlbkZpbGVzOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgYWNjZXB0YCBjaGVja3MgdGhlIGZpbGUncyBtaW1lIHR5cGUgb3JcXG4gICAqIGV4dGVuc2lvbiBhZ2FpbnN0IHRoaXMgbGlzdC4gVGhpcyBpcyBhIGNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIG1pbWVcXG4gICAqIHR5cGVzIG9yIGZpbGUgZXh0ZW5zaW9ucy5cXG4gICAqXFxuICAgKiBFZy46IGBpbWFnZS8qLGFwcGxpY2F0aW9uL3BkZiwucHNkYFxcbiAgICpcXG4gICAqIElmIHRoZSBEcm9wem9uZSBpcyBgY2xpY2thYmxlYCB0aGlzIG9wdGlvbiB3aWxsIGFsc28gYmUgdXNlZCBhc1xcbiAgICogW2BhY2NlcHRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0hUTUwvRWxlbWVudC9pbnB1dCNhdHRyLWFjY2VwdClcXG4gICAqIHBhcmFtZXRlciBvbiB0aGUgaGlkZGVuIGZpbGUgaW5wdXQgYXMgd2VsbC5cXG4gICAqL1xcbiAgYWNjZXB0ZWRGaWxlczogbnVsbCxcXG5cXG4gIC8qKlxcbiAgICogKipEZXByZWNhdGVkISoqXFxuICAgKiBVc2UgYWNjZXB0ZWRGaWxlcyBpbnN0ZWFkLlxcbiAgICovXFxuICBhY2NlcHRlZE1pbWVUeXBlczogbnVsbCxcXG5cXG4gIC8qKlxcbiAgICogSWYgZmFsc2UsIGZpbGVzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHF1ZXVlIGJ1dCB0aGUgcXVldWUgd2lsbCBub3QgYmVcXG4gICAqIHByb2Nlc3NlZCBhdXRvbWF0aWNhbGx5LlxcbiAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGlmIHlvdSBuZWVkIHNvbWUgYWRkaXRpb25hbCB1c2VyIGlucHV0IGJlZm9yZSBzZW5kaW5nXFxuICAgKiBmaWxlcyAob3IgaWYgeW91IHdhbnQgd2FudCBhbGwgZmlsZXMgc2VudCBhdCBvbmNlKS5cXG4gICAqIElmIHlvdSdyZSByZWFkeSB0byBzZW5kIHRoZSBmaWxlIHNpbXBseSBjYWxsIGBteURyb3B6b25lLnByb2Nlc3NRdWV1ZSgpYC5cXG4gICAqXFxuICAgKiBTZWUgdGhlIFtlbnF1ZXVpbmcgZmlsZSB1cGxvYWRzXSgjZW5xdWV1aW5nLWZpbGUtdXBsb2FkcykgZG9jdW1lbnRhdGlvblxcbiAgICogc2VjdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cXG4gICAqL1xcbiAgYXV0b1Byb2Nlc3NRdWV1ZTogdHJ1ZSxcXG5cXG4gIC8qKlxcbiAgICogSWYgZmFsc2UsIGZpbGVzIGFkZGVkIHRvIHRoZSBkcm9wem9uZSB3aWxsIG5vdCBiZSBxdWV1ZWQgYnkgZGVmYXVsdC5cXG4gICAqIFlvdSdsbCBoYXZlIHRvIGNhbGwgYGVucXVldWVGaWxlKGZpbGUpYCBtYW51YWxseS5cXG4gICAqL1xcbiAgYXV0b1F1ZXVlOiB0cnVlLFxcblxcbiAgLyoqXFxuICAgKiBJZiBgdHJ1ZWAsIHRoaXMgd2lsbCBhZGQgYSBsaW5rIHRvIGV2ZXJ5IGZpbGUgcHJldmlldyB0byByZW1vdmUgb3IgY2FuY2VsIChpZlxcbiAgICogYWxyZWFkeSB1cGxvYWRpbmcpIHRoZSBmaWxlLiBUaGUgYGRpY3RDYW5jZWxVcGxvYWRgLCBgZGljdENhbmNlbFVwbG9hZENvbmZpcm1hdGlvbmBcXG4gICAqIGFuZCBgZGljdFJlbW92ZUZpbGVgIG9wdGlvbnMgYXJlIHVzZWQgZm9yIHRoZSB3b3JkaW5nLlxcbiAgICovXFxuICBhZGRSZW1vdmVMaW5rczogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIERlZmluZXMgd2hlcmUgdG8gZGlzcGxheSB0aGUgZmlsZSBwcmV2aWV3cyBcXHUyMDEzIGlmIGBudWxsYCB0aGVcXG4gICAqIERyb3B6b25lIGVsZW1lbnQgaXRzZWxmIGlzIHVzZWQuIENhbiBiZSBhIHBsYWluIGBIVE1MRWxlbWVudGAgb3IgYSBDU1NcXG4gICAqIHNlbGVjdG9yLiBUaGUgZWxlbWVudCBzaG91bGQgaGF2ZSB0aGUgYGRyb3B6b25lLXByZXZpZXdzYCBjbGFzcyBzb1xcbiAgICogdGhlIHByZXZpZXdzIGFyZSBkaXNwbGF5ZWQgcHJvcGVybHkuXFxuICAgKi9cXG4gIHByZXZpZXdzQ29udGFpbmVyOiBudWxsLFxcblxcbiAgLyoqXFxuICAgKiBTZXQgdGhpcyB0byBgdHJ1ZWAgaWYgeW91IGRvbid0IHdhbnQgcHJldmlld3MgdG8gYmUgc2hvd24uXFxuICAgKi9cXG4gIGRpc2FibGVQcmV2aWV3czogZmFsc2UsXFxuXFxuICAvKipcXG4gICAqIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhlIGhpZGRlbiBpbnB1dCBmaWVsZCAod2hpY2ggaXMgdXNlZCB3aGVuIGNsaWNraW5nIG9uIHRoZVxcbiAgICogZHJvcHpvbmUgdG8gdHJpZ2dlciBmaWxlIHNlbGVjdGlvbikgd2lsbCBiZSBhcHBlbmRlZCB0by4gVGhpcyBtaWdodFxcbiAgICogYmUgaW1wb3J0YW50IGluIGNhc2UgeW91IHVzZSBmcmFtZXdvcmtzIHRvIHN3aXRjaCB0aGUgY29udGVudCBvZiB5b3VyIHBhZ2UuXFxuICAgKlxcbiAgICogQ2FuIGJlIGEgc2VsZWN0b3Igc3RyaW5nLCBvciBhbiBlbGVtZW50IGRpcmVjdGx5LlxcbiAgICovXFxuICBoaWRkZW5JbnB1dENvbnRhaW5lcjogXFxcImJvZHlcXFwiLFxcblxcbiAgLyoqXFxuICAgKiBJZiBudWxsLCBubyBjYXB0dXJlIHR5cGUgd2lsbCBiZSBzcGVjaWZpZWRcXG4gICAqIElmIGNhbWVyYSwgbW9iaWxlIGRldmljZXMgd2lsbCBza2lwIHRoZSBmaWxlIHNlbGVjdGlvbiBhbmQgY2hvb3NlIGNhbWVyYVxcbiAgICogSWYgbWljcm9waG9uZSwgbW9iaWxlIGRldmljZXMgd2lsbCBza2lwIHRoZSBmaWxlIHNlbGVjdGlvbiBhbmQgY2hvb3NlIHRoZSBtaWNyb3Bob25lXFxuICAgKiBJZiBjYW1jb3JkZXIsIG1vYmlsZSBkZXZpY2VzIHdpbGwgc2tpcCB0aGUgZmlsZSBzZWxlY3Rpb24gYW5kIGNob29zZSB0aGUgY2FtZXJhIGluIHZpZGVvIG1vZGVcXG4gICAqIE9uIGFwcGxlIGRldmljZXMgbXVsdGlwbGUgbXVzdCBiZSBzZXQgdG8gZmFsc2UuICBBY2NlcHRlZEZpbGVzIG1heSBuZWVkIHRvXFxuICAgKiBiZSBzZXQgdG8gYW4gYXBwcm9wcmlhdGUgbWltZSB0eXBlIChlLmcuIFxcXCJpbWFnZS8qXFxcIiwgXFxcImF1ZGlvLypcXFwiLCBvciBcXFwidmlkZW8vKlxcXCIpLlxcbiAgICovXFxuICBjYXB0dXJlOiBudWxsLFxcblxcbiAgLyoqXFxuICAgKiAqKkRlcHJlY2F0ZWQqKi4gVXNlIGByZW5hbWVGaWxlYCBpbnN0ZWFkLlxcbiAgICovXFxuICByZW5hbWVGaWxlbmFtZTogbnVsbCxcXG5cXG4gIC8qKlxcbiAgICogQSBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWQgYmVmb3JlIHRoZSBmaWxlIGlzIHVwbG9hZGVkIHRvIHRoZSBzZXJ2ZXIgYW5kIHJlbmFtZXMgdGhlIGZpbGUuXFxuICAgKiBUaGlzIGZ1bmN0aW9uIGdldHMgdGhlIGBGaWxlYCBhcyBhcmd1bWVudCBhbmQgY2FuIHVzZSB0aGUgYGZpbGUubmFtZWAuIFRoZSBhY3R1YWwgbmFtZSBvZiB0aGVcXG4gICAqIGZpbGUgdGhhdCBnZXRzIHVzZWQgZHVyaW5nIHRoZSB1cGxvYWQgY2FuIGJlIGFjY2Vzc2VkIHRocm91Z2ggYGZpbGUudXBsb2FkLmZpbGVuYW1lYC5cXG4gICAqL1xcbiAgcmVuYW1lRmlsZTogbnVsbCxcXG5cXG4gIC8qKlxcbiAgICogSWYgYHRydWVgIHRoZSBmYWxsYmFjayB3aWxsIGJlIGZvcmNlZC4gVGhpcyBpcyB2ZXJ5IHVzZWZ1bCB0byB0ZXN0IHlvdXIgc2VydmVyXFxuICAgKiBpbXBsZW1lbnRhdGlvbnMgZmlyc3QgYW5kIG1ha2Ugc3VyZSB0aGF0IGV2ZXJ5dGhpbmcgd29ya3MgYXNcXG4gICAqIGV4cGVjdGVkIHdpdGhvdXQgZHJvcHpvbmUgaWYgeW91IGV4cGVyaWVuY2UgcHJvYmxlbXMsIGFuZCB0byB0ZXN0XFxuICAgKiBob3cgeW91ciBmYWxsYmFja3Mgd2lsbCBsb29rLlxcbiAgICovXFxuICBmb3JjZUZhbGxiYWNrOiBmYWxzZSxcXG5cXG4gIC8qKlxcbiAgICogVGhlIHRleHQgdXNlZCBiZWZvcmUgYW55IGZpbGVzIGFyZSBkcm9wcGVkLlxcbiAgICovXFxuICBkaWN0RGVmYXVsdE1lc3NhZ2U6IFxcXCJEcm9wIGZpbGVzIGhlcmUgdG8gdXBsb2FkXFxcIixcXG5cXG4gIC8qKlxcbiAgICogVGhlIHRleHQgdGhhdCByZXBsYWNlcyB0aGUgZGVmYXVsdCBtZXNzYWdlIHRleHQgaXQgdGhlIGJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZC5cXG4gICAqL1xcbiAgZGljdEZhbGxiYWNrTWVzc2FnZTogXFxcIllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGRyYWcnbidkcm9wIGZpbGUgdXBsb2Fkcy5cXFwiLFxcblxcbiAgLyoqXFxuICAgKiBUaGUgdGV4dCB0aGF0IHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoZSBmYWxsYmFjayBmb3JtLlxcbiAgICogSWYgeW91IHByb3ZpZGUgYSAgZmFsbGJhY2sgZWxlbWVudCB5b3Vyc2VsZiwgb3IgaWYgdGhpcyBvcHRpb24gaXMgYG51bGxgIHRoaXMgd2lsbFxcbiAgICogYmUgaWdub3JlZC5cXG4gICAqL1xcbiAgZGljdEZhbGxiYWNrVGV4dDogXFxcIlBsZWFzZSB1c2UgdGhlIGZhbGxiYWNrIGZvcm0gYmVsb3cgdG8gdXBsb2FkIHlvdXIgZmlsZXMgbGlrZSBpbiB0aGUgb2xkZW4gZGF5cy5cXFwiLFxcblxcbiAgLyoqXFxuICAgKiBJZiB0aGUgZmlsZXNpemUgaXMgdG9vIGJpZy5cXG4gICAqIGB7e2ZpbGVzaXplfX1gIGFuZCBge3ttYXhGaWxlc2l6ZX19YCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIHJlc3BlY3RpdmUgY29uZmlndXJhdGlvbiB2YWx1ZXMuXFxuICAgKi9cXG4gIGRpY3RGaWxlVG9vQmlnOiBcXFwiRmlsZSBpcyB0b28gYmlnICh7e2ZpbGVzaXplfX1NaUIpLiBNYXggZmlsZXNpemU6IHt7bWF4RmlsZXNpemV9fU1pQi5cXFwiLFxcblxcbiAgLyoqXFxuICAgKiBJZiB0aGUgZmlsZSBkb2Vzbid0IG1hdGNoIHRoZSBmaWxlIHR5cGUuXFxuICAgKi9cXG4gIGRpY3RJbnZhbGlkRmlsZVR5cGU6IFxcXCJZb3UgY2FuJ3QgdXBsb2FkIGZpbGVzIG9mIHRoaXMgdHlwZS5cXFwiLFxcblxcbiAgLyoqXFxuICAgKiBJZiB0aGUgc2VydmVyIHJlc3BvbnNlIHdhcyBpbnZhbGlkLlxcbiAgICogYHt7c3RhdHVzQ29kZX19YCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIHNlcnZlcnMgc3RhdHVzIGNvZGUuXFxuICAgKi9cXG4gIGRpY3RSZXNwb25zZUVycm9yOiBcXFwiU2VydmVyIHJlc3BvbmRlZCB3aXRoIHt7c3RhdHVzQ29kZX19IGNvZGUuXFxcIixcXG5cXG4gIC8qKlxcbiAgICogSWYgYGFkZFJlbW92ZUxpbmtzYCBpcyB0cnVlLCB0aGUgdGV4dCB0byBiZSB1c2VkIGZvciB0aGUgY2FuY2VsIHVwbG9hZCBsaW5rLlxcbiAgICovXFxuICBkaWN0Q2FuY2VsVXBsb2FkOiBcXFwiQ2FuY2VsIHVwbG9hZFxcXCIsXFxuXFxuICAvKipcXG4gICAqIFRoZSB0ZXh0IHRoYXQgaXMgZGlzcGxheWVkIGlmIGFuIHVwbG9hZCB3YXMgbWFudWFsbHkgY2FuY2VsZWRcXG4gICAqL1xcbiAgZGljdFVwbG9hZENhbmNlbGVkOiBcXFwiVXBsb2FkIGNhbmNlbGVkLlxcXCIsXFxuXFxuICAvKipcXG4gICAqIElmIGBhZGRSZW1vdmVMaW5rc2AgaXMgdHJ1ZSwgdGhlIHRleHQgdG8gYmUgdXNlZCBmb3IgY29uZmlybWF0aW9uIHdoZW4gY2FuY2VsbGluZyB1cGxvYWQuXFxuICAgKi9cXG4gIGRpY3RDYW5jZWxVcGxvYWRDb25maXJtYXRpb246IFxcXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY2FuY2VsIHRoaXMgdXBsb2FkP1xcXCIsXFxuXFxuICAvKipcXG4gICAqIElmIGBhZGRSZW1vdmVMaW5rc2AgaXMgdHJ1ZSwgdGhlIHRleHQgdG8gYmUgdXNlZCB0byByZW1vdmUgYSBmaWxlLlxcbiAgICovXFxuICBkaWN0UmVtb3ZlRmlsZTogXFxcIlJlbW92ZSBmaWxlXFxcIixcXG5cXG4gIC8qKlxcbiAgICogSWYgdGhpcyBpcyBub3QgbnVsbCwgdGhlbiB0aGUgdXNlciB3aWxsIGJlIHByb21wdGVkIGJlZm9yZSByZW1vdmluZyBhIGZpbGUuXFxuICAgKi9cXG4gIGRpY3RSZW1vdmVGaWxlQ29uZmlybWF0aW9uOiBudWxsLFxcblxcbiAgLyoqXFxuICAgKiBEaXNwbGF5ZWQgaWYgYG1heEZpbGVzYCBpcyBzdCBhbmQgZXhjZWVkZWQuXFxuICAgKiBUaGUgc3RyaW5nIGB7e21heEZpbGVzfX1gIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGNvbmZpZ3VyYXRpb24gdmFsdWUuXFxuICAgKi9cXG4gIGRpY3RNYXhGaWxlc0V4Y2VlZGVkOiBcXFwiWW91IGNhbiBub3QgdXBsb2FkIGFueSBtb3JlIGZpbGVzLlxcXCIsXFxuXFxuICAvKipcXG4gICAqIEFsbG93cyB5b3UgdG8gdHJhbnNsYXRlIHRoZSBkaWZmZXJlbnQgdW5pdHMuIFN0YXJ0aW5nIHdpdGggYHRiYCBmb3IgdGVyYWJ5dGVzIGFuZCBnb2luZyBkb3duIHRvXFxuICAgKiBgYmAgZm9yIGJ5dGVzLlxcbiAgICovXFxuICBkaWN0RmlsZVNpemVVbml0czoge1xcbiAgICB0YjogXFxcIlRCXFxcIixcXG4gICAgZ2I6IFxcXCJHQlxcXCIsXFxuICAgIG1iOiBcXFwiTUJcXFwiLFxcbiAgICBrYjogXFxcIktCXFxcIixcXG4gICAgYjogXFxcImJcXFwiXFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBDYWxsZWQgd2hlbiBkcm9wem9uZSBpbml0aWFsaXplZFxcbiAgICogWW91IGNhbiBhZGQgZXZlbnQgbGlzdGVuZXJzIGhlcmVcXG4gICAqL1xcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHt9LFxcblxcbiAgLyoqXFxuICAgKiBDYW4gYmUgYW4gKipvYmplY3QqKiBvZiBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gdHJhbnNmZXIgdG8gdGhlIHNlcnZlciwgKipvcioqIGEgYEZ1bmN0aW9uYFxcbiAgICogdGhhdCBnZXRzIGludm9rZWQgd2l0aCB0aGUgYGZpbGVzYCwgYHhocmAgYW5kLCBpZiBpdCdzIGEgY2h1bmtlZCB1cGxvYWQsIGBjaHVua2AgYXJndW1lbnRzLiBJbiBjYXNlXFxuICAgKiBvZiBhIGZ1bmN0aW9uLCB0aGlzIG5lZWRzIHRvIHJldHVybiBhIG1hcC5cXG4gICAqXFxuICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdGhpbmcgZm9yIG5vcm1hbCB1cGxvYWRzLCBidXQgYWRkcyByZWxldmFudCBpbmZvcm1hdGlvbiBmb3JcXG4gICAqIGNodW5rZWQgdXBsb2Fkcy5cXG4gICAqXFxuICAgKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGFkZGluZyBoaWRkZW4gaW5wdXQgZmllbGRzIGluIHRoZSBmb3JtIGVsZW1lbnQuXFxuICAgKi9cXG4gIHBhcmFtczogZnVuY3Rpb24gcGFyYW1zKGZpbGVzLCB4aHIsIGNodW5rKSB7XFxuICAgIGlmIChjaHVuaykge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBkenV1aWQ6IGNodW5rLmZpbGUudXBsb2FkLnV1aWQsXFxuICAgICAgICBkemNodW5raW5kZXg6IGNodW5rLmluZGV4LFxcbiAgICAgICAgZHp0b3RhbGZpbGVzaXplOiBjaHVuay5maWxlLnNpemUsXFxuICAgICAgICBkemNodW5rc2l6ZTogdGhpcy5vcHRpb25zLmNodW5rU2l6ZSxcXG4gICAgICAgIGR6dG90YWxjaHVua2NvdW50OiBjaHVuay5maWxlLnVwbG9hZC50b3RhbENodW5rQ291bnQsXFxuICAgICAgICBkemNodW5rYnl0ZW9mZnNldDogY2h1bmsuaW5kZXggKiB0aGlzLm9wdGlvbnMuY2h1bmtTaXplXFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQSBmdW5jdGlvbiB0aGF0IGdldHMgYSBbZmlsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vRmlsZSlcXG4gICAqIGFuZCBhIGBkb25lYCBmdW5jdGlvbiBhcyBwYXJhbWV0ZXJzLlxcbiAgICpcXG4gICAqIElmIHRoZSBkb25lIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIHRoZSBmaWxlIGlzIFxcXCJhY2NlcHRlZFxcXCIgYW5kIHdpbGxcXG4gICAqIGJlIHByb2Nlc3NlZC4gSWYgeW91IHBhc3MgYW4gZXJyb3IgbWVzc2FnZSwgdGhlIGZpbGUgaXMgcmVqZWN0ZWQsIGFuZCB0aGUgZXJyb3JcXG4gICAqIG1lc3NhZ2Ugd2lsbCBiZSBkaXNwbGF5ZWQuXFxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGNhbGxlZCBpZiB0aGUgZmlsZSBpcyB0b28gYmlnIG9yIGRvZXNuJ3QgbWF0Y2ggdGhlIG1pbWUgdHlwZXMuXFxuICAgKi9cXG4gIGFjY2VwdDogZnVuY3Rpb24gYWNjZXB0KGZpbGUsIGRvbmUpIHtcXG4gICAgcmV0dXJuIGRvbmUoKTtcXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIFRoZSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGFsbCBjaHVua3MgaGF2ZSBiZWVuIHVwbG9hZGVkIGZvciBhIGZpbGUuXFxuICAgKiBJdCBnZXRzIHRoZSBmaWxlIGZvciB3aGljaCB0aGUgY2h1bmtzIGhhdmUgYmVlbiB1cGxvYWRlZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLFxcbiAgICogYW5kIHRoZSBgZG9uZWAgZnVuY3Rpb24gYXMgc2Vjb25kLiBgZG9uZSgpYCBuZWVkcyB0byBiZSBpbnZva2VkIHdoZW4gZXZlcnl0aGluZ1xcbiAgICogbmVlZGVkIHRvIGZpbmlzaCB0aGUgdXBsb2FkIHByb2Nlc3MgaXMgZG9uZS5cXG4gICAqL1xcbiAgY2h1bmtzVXBsb2FkZWQ6IGZ1bmN0aW9uIGNodW5rc1VwbG9hZGVkKGZpbGUsIGRvbmUpIHtcXG4gICAgZG9uZSgpO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkLlxcbiAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2hvd3MgdGhlIGZhbGxiYWNrIGlucHV0IGZpZWxkIGFuZCBhZGRzXFxuICAgKiBhIHRleHQuXFxuICAgKi9cXG4gIGZhbGxiYWNrOiBmdW5jdGlvbiBmYWxsYmFjaygpIHtcXG4gICAgLy8gVGhpcyBjb2RlIHNob3VsZCBwYXNzIGluIElFNy4uLiA6KFxcbiAgICB2YXIgbWVzc2FnZUVsZW1lbnQ7XFxuICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSBcXFwiXFxcIi5jb25jYXQodGhpcy5lbGVtZW50LmNsYXNzTmFtZSwgXFxcIiBkei1icm93c2VyLW5vdC1zdXBwb3J0ZWRcXFwiKTtcXG5cXG4gICAgdmFyIF9pdGVyYXRvciA9IG9wdGlvbnNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImRpdlxcXCIpLCB0cnVlKSxcXG4gICAgICAgIF9zdGVwO1xcblxcbiAgICB0cnkge1xcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XFxuICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcXG5cXG4gICAgICAgIGlmICgvKF58IClkei1tZXNzYWdlKCR8ICkvLnRlc3QoY2hpbGQuY2xhc3NOYW1lKSkge1xcbiAgICAgICAgICBtZXNzYWdlRWxlbWVudCA9IGNoaWxkO1xcbiAgICAgICAgICBjaGlsZC5jbGFzc05hbWUgPSBcXFwiZHotbWVzc2FnZVxcXCI7IC8vIFJlbW92ZXMgdGhlICdkei1kZWZhdWx0JyBjbGFzc1xcblxcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XFxuICAgIH0gZmluYWxseSB7XFxuICAgICAgX2l0ZXJhdG9yLmYoKTtcXG4gICAgfVxcblxcbiAgICBpZiAoIW1lc3NhZ2VFbGVtZW50KSB7XFxuICAgICAgbWVzc2FnZUVsZW1lbnQgPSBEcm9wem9uZS5jcmVhdGVFbGVtZW50KCc8ZGl2IGNsYXNzPVxcXCJkei1tZXNzYWdlXFxcIj48c3Bhbj48L3NwYW4+PC9kaXY+Jyk7XFxuICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKG1lc3NhZ2VFbGVtZW50KTtcXG4gICAgfVxcblxcbiAgICB2YXIgc3BhbiA9IG1lc3NhZ2VFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJzcGFuXFxcIilbMF07XFxuXFxuICAgIGlmIChzcGFuKSB7XFxuICAgICAgaWYgKHNwYW4udGV4dENvbnRlbnQgIT0gbnVsbCkge1xcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHRoaXMub3B0aW9ucy5kaWN0RmFsbGJhY2tNZXNzYWdlO1xcbiAgICAgIH0gZWxzZSBpZiAoc3Bhbi5pbm5lclRleHQgIT0gbnVsbCkge1xcbiAgICAgICAgc3Bhbi5pbm5lclRleHQgPSB0aGlzLm9wdGlvbnMuZGljdEZhbGxiYWNrTWVzc2FnZTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmdldEZhbGxiYWNrRm9ybSgpKTtcXG4gIH0sXFxuXFxuICAvKipcXG4gICAqIEdldHMgY2FsbGVkIHRvIGNhbGN1bGF0ZSB0aGUgdGh1bWJuYWlsIGRpbWVuc2lvbnMuXFxuICAgKlxcbiAgICogSXQgZ2V0cyBgZmlsZWAsIGB3aWR0aGAgYW5kIGBoZWlnaHRgIChib3RoIG1heSBiZSBgbnVsbGApIGFzIHBhcmFtZXRlcnMgYW5kIG11c3QgcmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nOlxcbiAgICpcXG4gICAqICAtIGBzcmNXaWR0aGAgJiBgc3JjSGVpZ2h0YCAocmVxdWlyZWQpXFxuICAgKiAgLSBgdHJnV2lkdGhgICYgYHRyZ0hlaWdodGAgKHJlcXVpcmVkKVxcbiAgICogIC0gYHNyY1hgICYgYHNyY1lgIChvcHRpb25hbCwgZGVmYXVsdCBgMGApXFxuICAgKiAgLSBgdHJnWGAgJiBgdHJnWWAgKG9wdGlvbmFsLCBkZWZhdWx0IGAwYClcXG4gICAqXFxuICAgKiBUaG9zZSB2YWx1ZXMgYXJlIGdvaW5nIHRvIGJlIHVzZWQgYnkgYGN0eC5kcmF3SW1hZ2UoKWAuXFxuICAgKi9cXG4gIHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCkge1xcbiAgICB2YXIgaW5mbyA9IHtcXG4gICAgICBzcmNYOiAwLFxcbiAgICAgIHNyY1k6IDAsXFxuICAgICAgc3JjV2lkdGg6IGZpbGUud2lkdGgsXFxuICAgICAgc3JjSGVpZ2h0OiBmaWxlLmhlaWdodFxcbiAgICB9O1xcbiAgICB2YXIgc3JjUmF0aW8gPSBmaWxlLndpZHRoIC8gZmlsZS5oZWlnaHQ7IC8vIEF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlIGRpbWVuc2lvbnMgaWYgbm90IHNwZWNpZmllZFxcblxcbiAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgPT0gbnVsbCkge1xcbiAgICAgIHdpZHRoID0gaW5mby5zcmNXaWR0aDtcXG4gICAgICBoZWlnaHQgPSBpbmZvLnNyY0hlaWdodDtcXG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsKSB7XFxuICAgICAgd2lkdGggPSBoZWlnaHQgKiBzcmNSYXRpbztcXG4gICAgfSBlbHNlIGlmIChoZWlnaHQgPT0gbnVsbCkge1xcbiAgICAgIGhlaWdodCA9IHdpZHRoIC8gc3JjUmF0aW87XFxuICAgIH0gLy8gTWFrZSBzdXJlIGltYWdlcyBhcmVuJ3QgdXBzY2FsZWRcXG5cXG5cXG4gICAgd2lkdGggPSBNYXRoLm1pbih3aWR0aCwgaW5mby5zcmNXaWR0aCk7XFxuICAgIGhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgaW5mby5zcmNIZWlnaHQpO1xcbiAgICB2YXIgdHJnUmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcXG5cXG4gICAgaWYgKGluZm8uc3JjV2lkdGggPiB3aWR0aCB8fCBpbmZvLnNyY0hlaWdodCA+IGhlaWdodCkge1xcbiAgICAgIC8vIEltYWdlIGlzIGJpZ2dlciBhbmQgbmVlZHMgcmVzY2FsaW5nXFxuICAgICAgaWYgKHJlc2l6ZU1ldGhvZCA9PT0gXFxcImNyb3BcXFwiKSB7XFxuICAgICAgICBpZiAoc3JjUmF0aW8gPiB0cmdSYXRpbykge1xcbiAgICAgICAgICBpbmZvLnNyY0hlaWdodCA9IGZpbGUuaGVpZ2h0O1xcbiAgICAgICAgICBpbmZvLnNyY1dpZHRoID0gaW5mby5zcmNIZWlnaHQgKiB0cmdSYXRpbztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGluZm8uc3JjV2lkdGggPSBmaWxlLndpZHRoO1xcbiAgICAgICAgICBpbmZvLnNyY0hlaWdodCA9IGluZm8uc3JjV2lkdGggLyB0cmdSYXRpbztcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKHJlc2l6ZU1ldGhvZCA9PT0gXFxcImNvbnRhaW5cXFwiKSB7XFxuICAgICAgICAvLyBNZXRob2QgJ2NvbnRhaW4nXFxuICAgICAgICBpZiAoc3JjUmF0aW8gPiB0cmdSYXRpbykge1xcbiAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIHNyY1JhdGlvO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiBzcmNSYXRpbztcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJVbmtub3duIHJlc2l6ZU1ldGhvZCAnXFxcIi5jb25jYXQocmVzaXplTWV0aG9kLCBcXFwiJ1xcXCIpKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaW5mby5zcmNYID0gKGZpbGUud2lkdGggLSBpbmZvLnNyY1dpZHRoKSAvIDI7XFxuICAgIGluZm8uc3JjWSA9IChmaWxlLmhlaWdodCAtIGluZm8uc3JjSGVpZ2h0KSAvIDI7XFxuICAgIGluZm8udHJnV2lkdGggPSB3aWR0aDtcXG4gICAgaW5mby50cmdIZWlnaHQgPSBoZWlnaHQ7XFxuICAgIHJldHVybiBpbmZvO1xcbiAgfSxcXG5cXG4gIC8qKlxcbiAgICogQ2FuIGJlIHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBmaWxlIChmb3IgZXhhbXBsZSwgcmVzaXplIGFuIGltYWdlIGlmIG5lY2Vzc2FyeSkuXFxuICAgKlxcbiAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gdXNlcyBgcmVzaXplV2lkdGhgIGFuZCBgcmVzaXplSGVpZ2h0YCAoaWYgcHJvdmlkZWQpIGFuZCByZXNpemVzXFxuICAgKiBpbWFnZXMgYWNjb3JkaW5nIHRvIHRob3NlIGRpbWVuc2lvbnMuXFxuICAgKlxcbiAgICogR2V0cyB0aGUgYGZpbGVgIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIGFuZCBhIGBkb25lKClgIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQsIHRoYXQgbmVlZHNcXG4gICAqIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgZmlsZSB3aGVuIHRoZSB0cmFuc2Zvcm1hdGlvbiBpcyBkb25lLlxcbiAgICovXFxuICB0cmFuc2Zvcm1GaWxlOiBmdW5jdGlvbiB0cmFuc2Zvcm1GaWxlKGZpbGUsIGRvbmUpIHtcXG4gICAgaWYgKCh0aGlzLm9wdGlvbnMucmVzaXplV2lkdGggfHwgdGhpcy5vcHRpb25zLnJlc2l6ZUhlaWdodCkgJiYgZmlsZS50eXBlLm1hdGNoKC9pbWFnZS4qLykpIHtcXG4gICAgICByZXR1cm4gdGhpcy5yZXNpemVJbWFnZShmaWxlLCB0aGlzLm9wdGlvbnMucmVzaXplV2lkdGgsIHRoaXMub3B0aW9ucy5yZXNpemVIZWlnaHQsIHRoaXMub3B0aW9ucy5yZXNpemVNZXRob2QsIGRvbmUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBkb25lKGZpbGUpO1xcbiAgICB9XFxuICB9LFxcblxcbiAgLyoqXFxuICAgKiBBIHN0cmluZyB0aGF0IGNvbnRhaW5zIHRoZSB0ZW1wbGF0ZSB1c2VkIGZvciBlYWNoIGRyb3BwZWRcXG4gICAqIGZpbGUuIENoYW5nZSBpdCB0byBmdWxmaWxsIHlvdXIgbmVlZHMgYnV0IG1ha2Ugc3VyZSB0byBwcm9wZXJseVxcbiAgICogcHJvdmlkZSBhbGwgZWxlbWVudHMuXFxuICAgKlxcbiAgICogSWYgeW91IHdhbnQgdG8gdXNlIGFuIGFjdHVhbCBIVE1MIGVsZW1lbnQgaW5zdGVhZCBvZiBwcm92aWRpbmcgYSBTdHJpbmdcXG4gICAqIGFzIGEgY29uZmlnIG9wdGlvbiwgeW91IGNvdWxkIGNyZWF0ZSBhIGRpdiB3aXRoIHRoZSBpZCBgdHBsYCxcXG4gICAqIHB1dCB0aGUgdGVtcGxhdGUgaW5zaWRlIGl0IGFuZCBwcm92aWRlIHRoZSBlbGVtZW50IGxpa2UgdGhpczpcXG4gICAqXFxuICAgKiAgICAgZG9jdW1lbnRcXG4gICAqICAgICAgIC5xdWVyeVNlbGVjdG9yKCcjdHBsJylcXG4gICAqICAgICAgIC5pbm5lckhUTUxcXG4gICAqXFxuICAgKi9cXG4gIHByZXZpZXdUZW1wbGF0ZTogcHJldmlld190ZW1wbGF0ZSxcXG5cXG4gIC8qXFxuICAgVGhvc2UgZnVuY3Rpb25zIHJlZ2lzdGVyIHRoZW1zZWx2ZXMgdG8gdGhlIGV2ZW50cyBvbiBpbml0IGFuZCBoYW5kbGUgYWxsXFxuICAgdGhlIHVzZXIgaW50ZXJmYWNlIHNwZWNpZmljIHN0dWZmLiBPdmVyd3JpdGluZyB0aGVtIHdvbid0IGJyZWFrIHRoZSB1cGxvYWRcXG4gICBidXQgY2FuIGJyZWFrIHRoZSB3YXkgaXQncyBkaXNwbGF5ZWQuXFxuICAgWW91IGNhbiBvdmVyd3JpdGUgdGhlbSBpZiB5b3UgZG9uJ3QgbGlrZSB0aGUgZGVmYXVsdCBiZWhhdmlvci4gSWYgeW91IGp1c3RcXG4gICB3YW50IHRvIGFkZCBhbiBhZGRpdGlvbmFsIGV2ZW50IGhhbmRsZXIsIHJlZ2lzdGVyIGl0IG9uIHRoZSBkcm9wem9uZSBvYmplY3RcXG4gICBhbmQgZG9uJ3Qgb3ZlcndyaXRlIHRob3NlIG9wdGlvbnMuXFxuICAgKi9cXG4gIC8vIFRob3NlIGFyZSBzZWxmIGV4cGxhbmF0b3J5IGFuZCBzaW1wbHkgY29uY2VybiB0aGUgRHJhZ25Ecm9wLlxcbiAgZHJvcDogZnVuY3Rpb24gZHJvcChlKSB7XFxuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcXFwiZHotZHJhZy1ob3ZlclxcXCIpO1xcbiAgfSxcXG4gIGRyYWdzdGFydDogZnVuY3Rpb24gZHJhZ3N0YXJ0KGUpIHt9LFxcbiAgZHJhZ2VuZDogZnVuY3Rpb24gZHJhZ2VuZChlKSB7XFxuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcXFwiZHotZHJhZy1ob3ZlclxcXCIpO1xcbiAgfSxcXG4gIGRyYWdlbnRlcjogZnVuY3Rpb24gZHJhZ2VudGVyKGUpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFxcXCJkei1kcmFnLWhvdmVyXFxcIik7XFxuICB9LFxcbiAgZHJhZ292ZXI6IGZ1bmN0aW9uIGRyYWdvdmVyKGUpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFxcXCJkei1kcmFnLWhvdmVyXFxcIik7XFxuICB9LFxcbiAgZHJhZ2xlYXZlOiBmdW5jdGlvbiBkcmFnbGVhdmUoZSkge1xcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXFxcImR6LWRyYWctaG92ZXJcXFwiKTtcXG4gIH0sXFxuICBwYXN0ZTogZnVuY3Rpb24gcGFzdGUoZSkge30sXFxuICAvLyBDYWxsZWQgd2hlbmV2ZXIgdGhlcmUgYXJlIG5vIGZpbGVzIGxlZnQgaW4gdGhlIGRyb3B6b25lIGFueW1vcmUsIGFuZCB0aGVcXG4gIC8vIGRyb3B6b25lIHNob3VsZCBiZSBkaXNwbGF5ZWQgYXMgaWYgaW4gdGhlIGluaXRpYWwgc3RhdGUuXFxuICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XFxuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcXFwiZHotc3RhcnRlZFxcXCIpO1xcbiAgfSxcXG4gIC8vIENhbGxlZCB3aGVuIGEgZmlsZSBpcyBhZGRlZCB0byB0aGUgcXVldWVcXG4gIC8vIFJlY2VpdmVzIGBmaWxlYFxcbiAgYWRkZWRmaWxlOiBmdW5jdGlvbiBhZGRlZGZpbGUoZmlsZSkge1xcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICBpZiAodGhpcy5lbGVtZW50ID09PSB0aGlzLnByZXZpZXdzQ29udGFpbmVyKSB7XFxuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoXFxcImR6LXN0YXJ0ZWRcXFwiKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5wcmV2aWV3c0NvbnRhaW5lciAmJiAhdGhpcy5vcHRpb25zLmRpc2FibGVQcmV2aWV3cykge1xcbiAgICAgIGZpbGUucHJldmlld0VsZW1lbnQgPSBEcm9wem9uZS5jcmVhdGVFbGVtZW50KHRoaXMub3B0aW9ucy5wcmV2aWV3VGVtcGxhdGUudHJpbSgpKTtcXG4gICAgICBmaWxlLnByZXZpZXdUZW1wbGF0ZSA9IGZpbGUucHJldmlld0VsZW1lbnQ7IC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XFxuXFxuICAgICAgdGhpcy5wcmV2aWV3c0NvbnRhaW5lci5hcHBlbmRDaGlsZChmaWxlLnByZXZpZXdFbGVtZW50KTtcXG5cXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IG9wdGlvbnNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihmaWxlLnByZXZpZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltkYXRhLWR6LW5hbWVdXFxcIiksIHRydWUpLFxcbiAgICAgICAgICBfc3RlcDI7XFxuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XFxuICAgICAgICAgIHZhciBub2RlID0gX3N0ZXAyLnZhbHVlO1xcbiAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gZmlsZS5uYW1lO1xcbiAgICAgICAgfVxcbiAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XFxuICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IG9wdGlvbnNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihmaWxlLnByZXZpZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltkYXRhLWR6LXNpemVdXFxcIiksIHRydWUpLFxcbiAgICAgICAgICBfc3RlcDM7XFxuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XFxuICAgICAgICAgIG5vZGUgPSBfc3RlcDMudmFsdWU7XFxuICAgICAgICAgIG5vZGUuaW5uZXJIVE1MID0gdGhpcy5maWxlc2l6ZShmaWxlLnNpemUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XFxuICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFkZFJlbW92ZUxpbmtzKSB7XFxuICAgICAgICBmaWxlLl9yZW1vdmVMaW5rID0gRHJvcHpvbmUuY3JlYXRlRWxlbWVudChcXFwiPGEgY2xhc3M9XFxcXFxcXCJkei1yZW1vdmVcXFxcXFxcIiBocmVmPVxcXFxcXFwiamF2YXNjcmlwdDp1bmRlZmluZWQ7XFxcXFxcXCIgZGF0YS1kei1yZW1vdmU+XFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmRpY3RSZW1vdmVGaWxlLCBcXFwiPC9hPlxcXCIpKTtcXG4gICAgICAgIGZpbGUucHJldmlld0VsZW1lbnQuYXBwZW5kQ2hpbGQoZmlsZS5fcmVtb3ZlTGluayk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciByZW1vdmVGaWxlRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVGaWxlRXZlbnQoZSkge1xcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXG4gICAgICAgIGlmIChmaWxlLnN0YXR1cyA9PT0gRHJvcHpvbmUuVVBMT0FESU5HKSB7XFxuICAgICAgICAgIHJldHVybiBEcm9wem9uZS5jb25maXJtKF90aGlzLm9wdGlvbnMuZGljdENhbmNlbFVwbG9hZENvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW1vdmVGaWxlKGZpbGUpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRpY3RSZW1vdmVGaWxlQ29uZmlybWF0aW9uKSB7XFxuICAgICAgICAgICAgcmV0dXJuIERyb3B6b25lLmNvbmZpcm0oX3RoaXMub3B0aW9ucy5kaWN0UmVtb3ZlRmlsZUNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlbW92ZUZpbGUoZmlsZSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlbW92ZUZpbGUoZmlsZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIHZhciBfaXRlcmF0b3I0ID0gb3B0aW9uc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGZpbGUucHJldmlld0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcXFwiW2RhdGEtZHotcmVtb3ZlXVxcXCIpLCB0cnVlKSxcXG4gICAgICAgICAgX3N0ZXA0O1xcblxcbiAgICAgIHRyeSB7XFxuICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xcbiAgICAgICAgICB2YXIgcmVtb3ZlTGluayA9IF9zdGVwNC52YWx1ZTtcXG4gICAgICAgICAgcmVtb3ZlTGluay5hZGRFdmVudExpc3RlbmVyKFxcXCJjbGlja1xcXCIsIHJlbW92ZUZpbGVFdmVudCk7XFxuICAgICAgICB9XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LFxcbiAgLy8gQ2FsbGVkIHdoZW5ldmVyIGEgZmlsZSBpcyByZW1vdmVkLlxcbiAgcmVtb3ZlZGZpbGU6IGZ1bmN0aW9uIHJlbW92ZWRmaWxlKGZpbGUpIHtcXG4gICAgaWYgKGZpbGUucHJldmlld0VsZW1lbnQgIT0gbnVsbCAmJiBmaWxlLnByZXZpZXdFbGVtZW50LnBhcmVudE5vZGUgIT0gbnVsbCkge1xcbiAgICAgIGZpbGUucHJldmlld0VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmaWxlLnByZXZpZXdFbGVtZW50KTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlTWF4RmlsZXNSZWFjaGVkQ2xhc3MoKTtcXG4gIH0sXFxuICAvLyBDYWxsZWQgd2hlbiBhIHRodW1ibmFpbCBoYXMgYmVlbiBnZW5lcmF0ZWRcXG4gIC8vIFJlY2VpdmVzIGBmaWxlYCBhbmQgYGRhdGFVcmxgXFxuICB0aHVtYm5haWw6IGZ1bmN0aW9uIHRodW1ibmFpbChmaWxlLCBkYXRhVXJsKSB7XFxuICAgIGlmIChmaWxlLnByZXZpZXdFbGVtZW50KSB7XFxuICAgICAgZmlsZS5wcmV2aWV3RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFxcXCJkei1maWxlLXByZXZpZXdcXFwiKTtcXG5cXG4gICAgICB2YXIgX2l0ZXJhdG9yNSA9IG9wdGlvbnNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihmaWxlLnByZXZpZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltkYXRhLWR6LXRodW1ibmFpbF1cXFwiKSwgdHJ1ZSksXFxuICAgICAgICAgIF9zdGVwNTtcXG5cXG4gICAgICB0cnkge1xcbiAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcXG4gICAgICAgICAgdmFyIHRodW1ibmFpbEVsZW1lbnQgPSBfc3RlcDUudmFsdWU7XFxuICAgICAgICAgIHRodW1ibmFpbEVsZW1lbnQuYWx0ID0gZmlsZS5uYW1lO1xcbiAgICAgICAgICB0aHVtYm5haWxFbGVtZW50LnNyYyA9IGRhdGFVcmw7XFxuICAgICAgICB9XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBmaWxlLnByZXZpZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoXFxcImR6LWltYWdlLXByZXZpZXdcXFwiKTtcXG4gICAgICB9LCAxKTtcXG4gICAgfVxcbiAgfSxcXG4gIC8vIENhbGxlZCB3aGVuZXZlciBhbiBlcnJvciBvY2N1cnNcXG4gIC8vIFJlY2VpdmVzIGBmaWxlYCBhbmQgYG1lc3NhZ2VgXFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoZmlsZSwgbWVzc2FnZSkge1xcbiAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCkge1xcbiAgICAgIGZpbGUucHJldmlld0VsZW1lbnQuY2xhc3NMaXN0LmFkZChcXFwiZHotZXJyb3JcXFwiKTtcXG5cXG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFxcXCJzdHJpbmdcXFwiICYmIG1lc3NhZ2UuZXJyb3IpIHtcXG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLmVycm9yO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgX2l0ZXJhdG9yNiA9IG9wdGlvbnNfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihmaWxlLnByZXZpZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltkYXRhLWR6LWVycm9ybWVzc2FnZV1cXFwiKSwgdHJ1ZSksXFxuICAgICAgICAgIF9zdGVwNjtcXG5cXG4gICAgICB0cnkge1xcbiAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcXG4gICAgICAgICAgdmFyIG5vZGUgPSBfc3RlcDYudmFsdWU7XFxuICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xcbiAgICAgICAgfVxcbiAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7XFxuICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgIF9pdGVyYXRvcjYuZigpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSxcXG4gIGVycm9ybXVsdGlwbGU6IGZ1bmN0aW9uIGVycm9ybXVsdGlwbGUoKSB7fSxcXG4gIC8vIENhbGxlZCB3aGVuIGEgZmlsZSBnZXRzIHByb2Nlc3NlZC4gU2luY2UgdGhlcmUgaXMgYSBjdWUsIG5vdCBhbGwgYWRkZWRcXG4gIC8vIGZpbGVzIGFyZSBwcm9jZXNzZWQgaW1tZWRpYXRlbHkuXFxuICAvLyBSZWNlaXZlcyBgZmlsZWBcXG4gIHByb2Nlc3Npbmc6IGZ1bmN0aW9uIHByb2Nlc3NpbmcoZmlsZSkge1xcbiAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCkge1xcbiAgICAgIGZpbGUucHJldmlld0VsZW1lbnQuY2xhc3NMaXN0LmFkZChcXFwiZHotcHJvY2Vzc2luZ1xcXCIpO1xcblxcbiAgICAgIGlmIChmaWxlLl9yZW1vdmVMaW5rKSB7XFxuICAgICAgICByZXR1cm4gZmlsZS5fcmVtb3ZlTGluay5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuZGljdENhbmNlbFVwbG9hZDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuICBwcm9jZXNzaW5nbXVsdGlwbGU6IGZ1bmN0aW9uIHByb2Nlc3NpbmdtdWx0aXBsZSgpIHt9LFxcbiAgLy8gQ2FsbGVkIHdoZW5ldmVyIHRoZSB1cGxvYWQgcHJvZ3Jlc3MgZ2V0cyB1cGRhdGVkLlxcbiAgLy8gUmVjZWl2ZXMgYGZpbGVgLCBgcHJvZ3Jlc3NgIChwZXJjZW50YWdlIDAtMTAwKSBhbmQgYGJ5dGVzU2VudGAuXFxuICAvLyBUbyBnZXQgdGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBvZiB0aGUgZmlsZSwgdXNlIGBmaWxlLnNpemVgXFxuICB1cGxvYWRwcm9ncmVzczogZnVuY3Rpb24gdXBsb2FkcHJvZ3Jlc3MoZmlsZSwgcHJvZ3Jlc3MsIGJ5dGVzU2VudCkge1xcbiAgICBpZiAoZmlsZS5wcmV2aWV3RWxlbWVudCkge1xcbiAgICAgIHZhciBfaXRlcmF0b3I3ID0gb3B0aW9uc19jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGZpbGUucHJldmlld0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcXFwiW2RhdGEtZHotdXBsb2FkcHJvZ3Jlc3NdXFxcIiksIHRydWUpLFxcbiAgICAgICAgICBfc3RlcDc7XFxuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XFxuICAgICAgICAgIHZhciBub2RlID0gX3N0ZXA3LnZhbHVlO1xcbiAgICAgICAgICBub2RlLm5vZGVOYW1lID09PSBcXFwiUFJPR1JFU1NcXFwiID8gbm9kZS52YWx1ZSA9IHByb2dyZXNzIDogbm9kZS5zdHlsZS53aWR0aCA9IFxcXCJcXFwiLmNvbmNhdChwcm9ncmVzcywgXFxcIiVcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgIF9pdGVyYXRvcjcuZShlcnIpO1xcbiAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICBfaXRlcmF0b3I3LmYoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sXFxuICAvLyBDYWxsZWQgd2hlbmV2ZXIgdGhlIHRvdGFsIHVwbG9hZCBwcm9ncmVzcyBnZXRzIHVwZGF0ZWQuXFxuICAvLyBDYWxsZWQgd2l0aCB0b3RhbFVwbG9hZFByb2dyZXNzICgwLTEwMCksIHRvdGFsQnl0ZXMgYW5kIHRvdGFsQnl0ZXNTZW50XFxuICB0b3RhbHVwbG9hZHByb2dyZXNzOiBmdW5jdGlvbiB0b3RhbHVwbG9hZHByb2dyZXNzKCkge30sXFxuICAvLyBDYWxsZWQganVzdCBiZWZvcmUgdGhlIGZpbGUgaXMgc2VudC4gR2V0cyB0aGUgYHhocmAgb2JqZWN0IGFzIHNlY29uZFxcbiAgLy8gcGFyYW1ldGVyLCBzbyB5b3UgY2FuIG1vZGlmeSBpdCAoZm9yIGV4YW1wbGUgdG8gYWRkIGEgQ1NSRiB0b2tlbikgYW5kIGFcXG4gIC8vIGBmb3JtRGF0YWAgb2JqZWN0IHRvIGFkZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxcbiAgc2VuZGluZzogZnVuY3Rpb24gc2VuZGluZygpIHt9LFxcbiAgc2VuZGluZ211bHRpcGxlOiBmdW5jdGlvbiBzZW5kaW5nbXVsdGlwbGUoKSB7fSxcXG4gIC8vIFdoZW4gdGhlIGNvbXBsZXRlIHVwbG9hZCBpcyBmaW5pc2hlZCBhbmQgc3VjY2Vzc2Z1bFxcbiAgLy8gUmVjZWl2ZXMgYGZpbGVgXFxuICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGZpbGUpIHtcXG4gICAgaWYgKGZpbGUucHJldmlld0VsZW1lbnQpIHtcXG4gICAgICByZXR1cm4gZmlsZS5wcmV2aWV3RWxlbWVudC5jbGFzc0xpc3QuYWRkKFxcXCJkei1zdWNjZXNzXFxcIik7XFxuICAgIH1cXG4gIH0sXFxuICBzdWNjZXNzbXVsdGlwbGU6IGZ1bmN0aW9uIHN1Y2Nlc3NtdWx0aXBsZSgpIHt9LFxcbiAgLy8gV2hlbiB0aGUgdXBsb2FkIGlzIGNhbmNlbGVkLlxcbiAgY2FuY2VsZWQ6IGZ1bmN0aW9uIGNhbmNlbGVkKGZpbGUpIHtcXG4gICAgcmV0dXJuIHRoaXMuZW1pdChcXFwiZXJyb3JcXFwiLCBmaWxlLCB0aGlzLm9wdGlvbnMuZGljdFVwbG9hZENhbmNlbGVkKTtcXG4gIH0sXFxuICBjYW5jZWxlZG11bHRpcGxlOiBmdW5jdGlvbiBjYW5jZWxlZG11bHRpcGxlKCkge30sXFxuICAvLyBXaGVuIHRoZSB1cGxvYWQgaXMgZmluaXNoZWQsIGVpdGhlciB3aXRoIHN1Y2Nlc3Mgb3IgYW4gZXJyb3IuXFxuICAvLyBSZWNlaXZlcyBgZmlsZWBcXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShmaWxlKSB7XFxuICAgIGlmIChmaWxlLl9yZW1vdmVMaW5rKSB7XFxuICAgICAgZmlsZS5fcmVtb3ZlTGluay5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuZGljdFJlbW92ZUZpbGU7XFxuICAgIH1cXG5cXG4gICAgaWYgKGZpbGUucHJldmlld0VsZW1lbnQpIHtcXG4gICAgICByZXR1cm4gZmlsZS5wcmV2aWV3RWxlbWVudC5jbGFzc0xpc3QuYWRkKFxcXCJkei1jb21wbGV0ZVxcXCIpO1xcbiAgICB9XFxuICB9LFxcbiAgY29tcGxldGVtdWx0aXBsZTogZnVuY3Rpb24gY29tcGxldGVtdWx0aXBsZSgpIHt9LFxcbiAgbWF4ZmlsZXNleGNlZWRlZDogZnVuY3Rpb24gbWF4ZmlsZXNleGNlZWRlZCgpIHt9LFxcbiAgbWF4ZmlsZXNyZWFjaGVkOiBmdW5jdGlvbiBtYXhmaWxlc3JlYWNoZWQoKSB7fSxcXG4gIHF1ZXVlY29tcGxldGU6IGZ1bmN0aW9uIHF1ZXVlY29tcGxldGUoKSB7fSxcXG4gIGFkZGVkZmlsZXM6IGZ1bmN0aW9uIGFkZGVkZmlsZXMoKSB7fVxcbn07XFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX29wdGlvbnMgPSAoZGVmYXVsdE9wdGlvbnMpO1xcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9kcm9wem9uZS5qc1xcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFxcXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlxcXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbmZ1bmN0aW9uIGRyb3B6b25lX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcInVuZGVmaW5lZFxcXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gZHJvcHpvbmVfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcXFwibnVtYmVyXFxcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cXFwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XFxuXFxuZnVuY3Rpb24gZHJvcHpvbmVfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFxcXCJzdHJpbmdcXFwiKSByZXR1cm4gZHJvcHpvbmVfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcXFwiT2JqZWN0XFxcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXFxcIk1hcFxcXCIgfHwgbiA9PT0gXFxcIlNldFxcXCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXFxcIkFyZ3VtZW50c1xcXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBkcm9wem9uZV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cXG5cXG5mdW5jdGlvbiBkcm9wem9uZV9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxcblxcbmZ1bmN0aW9uIGRyb3B6b25lX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gZHJvcHpvbmVfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIGRyb3B6b25lX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZHJvcHpvbmVfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRyb3B6b25lX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxcblxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cXG5cXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcXFwidW5kZWZpbmVkXFxcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXFxcImZ1bmN0aW9uXFxcIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XFxuXFxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxcblxcblxcblxcblxcbnZhciBEcm9wem9uZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VtaXR0ZXIpIHtcXG4gIF9pbmhlcml0cyhEcm9wem9uZSwgX0VtaXR0ZXIpO1xcblxcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihEcm9wem9uZSk7XFxuXFxuICBmdW5jdGlvbiBEcm9wem9uZShlbCwgb3B0aW9ucykge1xcbiAgICB2YXIgX3RoaXM7XFxuXFxuICAgIGRyb3B6b25lX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyb3B6b25lKTtcXG5cXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcXG4gICAgdmFyIGZhbGxiYWNrLCBsZWZ0O1xcbiAgICBfdGhpcy5lbGVtZW50ID0gZWw7IC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBzaW5jZSB0aGUgdmVyc2lvbiB3YXMgaW4gdGhlIHByb3RvdHlwZSBwcmV2aW91c2x5XFxuXFxuICAgIF90aGlzLnZlcnNpb24gPSBEcm9wem9uZS52ZXJzaW9uO1xcbiAgICBfdGhpcy5jbGlja2FibGVFbGVtZW50cyA9IFtdO1xcbiAgICBfdGhpcy5saXN0ZW5lcnMgPSBbXTtcXG4gICAgX3RoaXMuZmlsZXMgPSBbXTsgLy8gQWxsIGZpbGVzXFxuXFxuICAgIGlmICh0eXBlb2YgX3RoaXMuZWxlbWVudCA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICBfdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihfdGhpcy5lbGVtZW50KTtcXG4gICAgfSAvLyBOb3QgY2hlY2tpbmcgaWYgaW5zdGFuY2Ugb2YgSFRNTEVsZW1lbnQgb3IgRWxlbWVudCBzaW5jZSBJRTkgaXMgZXh0cmVtZWx5IHdlaXJkLlxcblxcblxcbiAgICBpZiAoIV90aGlzLmVsZW1lbnQgfHwgX3RoaXMuZWxlbWVudC5ub2RlVHlwZSA9PSBudWxsKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJJbnZhbGlkIGRyb3B6b25lIGVsZW1lbnQuXFxcIik7XFxuICAgIH1cXG5cXG4gICAgaWYgKF90aGlzLmVsZW1lbnQuZHJvcHpvbmUpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkRyb3B6b25lIGFscmVhZHkgYXR0YWNoZWQuXFxcIik7XFxuICAgIH0gLy8gTm93IGFkZCB0aGlzIGRyb3B6b25lIHRvIHRoZSBpbnN0YW5jZXMuXFxuXFxuXFxuICAgIERyb3B6b25lLmluc3RhbmNlcy5wdXNoKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTsgLy8gUHV0IHRoZSBkcm9wem9uZSBpbnNpZGUgdGhlIGVsZW1lbnQgaXRzZWxmLlxcblxcbiAgICBfdGhpcy5lbGVtZW50LmRyb3B6b25lID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyk7XFxuICAgIHZhciBlbGVtZW50T3B0aW9ucyA9IChsZWZ0ID0gRHJvcHpvbmUub3B0aW9uc0ZvckVsZW1lbnQoX3RoaXMuZWxlbWVudCkpICE9IG51bGwgPyBsZWZ0IDoge307XFxuICAgIF90aGlzLm9wdGlvbnMgPSBEcm9wem9uZS5leHRlbmQoe30sIHNyY19vcHRpb25zLCBlbGVtZW50T3B0aW9ucywgb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9KTtcXG4gICAgX3RoaXMub3B0aW9ucy5wcmV2aWV3VGVtcGxhdGUgPSBfdGhpcy5vcHRpb25zLnByZXZpZXdUZW1wbGF0ZS5yZXBsYWNlKC9cXFxcbiovZywgXFxcIlxcXCIpOyAvLyBJZiB0aGUgYnJvd3NlciBmYWlsZWQsIGp1c3QgY2FsbCB0aGUgZmFsbGJhY2sgYW5kIGxlYXZlXFxuXFxuICAgIGlmIChfdGhpcy5vcHRpb25zLmZvcmNlRmFsbGJhY2sgfHwgIURyb3B6b25lLmlzQnJvd3NlclN1cHBvcnRlZCgpKSB7XFxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfdGhpcy5vcHRpb25zLmZhbGxiYWNrLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpKTtcXG4gICAgfSAvLyBAb3B0aW9ucy51cmwgPSBAZWxlbWVudC5nZXRBdHRyaWJ1dGUgXFxcImFjdGlvblxcXCIgdW5sZXNzIEBvcHRpb25zLnVybD9cXG5cXG5cXG4gICAgaWYgKF90aGlzLm9wdGlvbnMudXJsID09IG51bGwpIHtcXG4gICAgICBfdGhpcy5vcHRpb25zLnVybCA9IF90aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFxcXCJhY3Rpb25cXFwiKTtcXG4gICAgfVxcblxcbiAgICBpZiAoIV90aGlzLm9wdGlvbnMudXJsKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJObyBVUkwgcHJvdmlkZWQuXFxcIik7XFxuICAgIH1cXG5cXG4gICAgaWYgKF90aGlzLm9wdGlvbnMuYWNjZXB0ZWRGaWxlcyAmJiBfdGhpcy5vcHRpb25zLmFjY2VwdGVkTWltZVR5cGVzKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJZb3UgY2FuJ3QgcHJvdmlkZSBib3RoICdhY2NlcHRlZEZpbGVzJyBhbmQgJ2FjY2VwdGVkTWltZVR5cGVzJy4gJ2FjY2VwdGVkTWltZVR5cGVzJyBpcyBkZXByZWNhdGVkLlxcXCIpO1xcbiAgICB9XFxuXFxuICAgIGlmIChfdGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlICYmIF90aGlzLm9wdGlvbnMuY2h1bmtpbmcpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIllvdSBjYW5ub3Qgc2V0IGJvdGg6IHVwbG9hZE11bHRpcGxlIGFuZCBjaHVua2luZy5cXFwiKTtcXG4gICAgfSAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxcblxcblxcbiAgICBpZiAoX3RoaXMub3B0aW9ucy5hY2NlcHRlZE1pbWVUeXBlcykge1xcbiAgICAgIF90aGlzLm9wdGlvbnMuYWNjZXB0ZWRGaWxlcyA9IF90aGlzLm9wdGlvbnMuYWNjZXB0ZWRNaW1lVHlwZXM7XFxuICAgICAgZGVsZXRlIF90aGlzLm9wdGlvbnMuYWNjZXB0ZWRNaW1lVHlwZXM7XFxuICAgIH0gLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcXG5cXG5cXG4gICAgaWYgKF90aGlzLm9wdGlvbnMucmVuYW1lRmlsZW5hbWUgIT0gbnVsbCkge1xcbiAgICAgIF90aGlzLm9wdGlvbnMucmVuYW1lRmlsZSA9IGZ1bmN0aW9uIChmaWxlKSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5yZW5hbWVGaWxlbmFtZS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBmaWxlLm5hbWUsIGZpbGUpO1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBfdGhpcy5vcHRpb25zLm1ldGhvZCA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICBfdGhpcy5vcHRpb25zLm1ldGhvZCA9IF90aGlzLm9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKChmYWxsYmFjayA9IF90aGlzLmdldEV4aXN0aW5nRmFsbGJhY2soKSkgJiYgZmFsbGJhY2sucGFyZW50Tm9kZSkge1xcbiAgICAgIC8vIFJlbW92ZSB0aGUgZmFsbGJhY2tcXG4gICAgICBmYWxsYmFjay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZhbGxiYWNrKTtcXG4gICAgfSAvLyBEaXNwbGF5IHByZXZpZXdzIGluIHRoZSBwcmV2aWV3c0NvbnRhaW5lciBlbGVtZW50IG9yIHRoZSBEcm9wem9uZSBlbGVtZW50IHVubGVzcyBleHBsaWNpdGx5IHNldCB0byBmYWxzZVxcblxcblxcbiAgICBpZiAoX3RoaXMub3B0aW9ucy5wcmV2aWV3c0NvbnRhaW5lciAhPT0gZmFsc2UpIHtcXG4gICAgICBpZiAoX3RoaXMub3B0aW9ucy5wcmV2aWV3c0NvbnRhaW5lcikge1xcbiAgICAgICAgX3RoaXMucHJldmlld3NDb250YWluZXIgPSBEcm9wem9uZS5nZXRFbGVtZW50KF90aGlzLm9wdGlvbnMucHJldmlld3NDb250YWluZXIsIFxcXCJwcmV2aWV3c0NvbnRhaW5lclxcXCIpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBfdGhpcy5wcmV2aWV3c0NvbnRhaW5lciA9IF90aGlzLmVsZW1lbnQ7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChfdGhpcy5vcHRpb25zLmNsaWNrYWJsZSkge1xcbiAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNsaWNrYWJsZSA9PT0gdHJ1ZSkge1xcbiAgICAgICAgX3RoaXMuY2xpY2thYmxlRWxlbWVudHMgPSBbX3RoaXMuZWxlbWVudF07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIF90aGlzLmNsaWNrYWJsZUVsZW1lbnRzID0gRHJvcHpvbmUuZ2V0RWxlbWVudHMoX3RoaXMub3B0aW9ucy5jbGlja2FibGUsIFxcXCJjbGlja2FibGVcXFwiKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX3RoaXMuaW5pdCgpO1xcblxcbiAgICByZXR1cm4gX3RoaXM7XFxuICB9IC8vIFJldHVybnMgYWxsIGZpbGVzIHRoYXQgaGF2ZSBiZWVuIGFjY2VwdGVkXFxuXFxuXFxuICBkcm9wem9uZV9jcmVhdGVDbGFzcyhEcm9wem9uZSwgW3tcXG4gICAga2V5OiBcXFwiZ2V0QWNjZXB0ZWRGaWxlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBY2NlcHRlZEZpbGVzKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmZpbGVzLmZpbHRlcihmdW5jdGlvbiAoZmlsZSkge1xcbiAgICAgICAgcmV0dXJuIGZpbGUuYWNjZXB0ZWQ7XFxuICAgICAgfSkubWFwKGZ1bmN0aW9uIChmaWxlKSB7XFxuICAgICAgICByZXR1cm4gZmlsZTtcXG4gICAgICB9KTtcXG4gICAgfSAvLyBSZXR1cm5zIGFsbCBmaWxlcyB0aGF0IGhhdmUgYmVlbiByZWplY3RlZFxcbiAgICAvLyBOb3Qgc3VyZSB3aGVuIHRoYXQncyBnb2luZyB0byBiZSB1c2VmdWwsIGJ1dCBhZGRlZCBmb3IgY29tcGxldGVuZXNzLlxcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZXRSZWplY3RlZEZpbGVzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlamVjdGVkRmlsZXMoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZmlsZXMuZmlsdGVyKGZ1bmN0aW9uIChmaWxlKSB7XFxuICAgICAgICByZXR1cm4gIWZpbGUuYWNjZXB0ZWQ7XFxuICAgICAgfSkubWFwKGZ1bmN0aW9uIChmaWxlKSB7XFxuICAgICAgICByZXR1cm4gZmlsZTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZXRGaWxlc1dpdGhTdGF0dXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsZXNXaXRoU3RhdHVzKHN0YXR1cykge1xcbiAgICAgIHJldHVybiB0aGlzLmZpbGVzLmZpbHRlcihmdW5jdGlvbiAoZmlsZSkge1xcbiAgICAgICAgcmV0dXJuIGZpbGUuc3RhdHVzID09PSBzdGF0dXM7XFxuICAgICAgfSkubWFwKGZ1bmN0aW9uIChmaWxlKSB7XFxuICAgICAgICByZXR1cm4gZmlsZTtcXG4gICAgICB9KTtcXG4gICAgfSAvLyBSZXR1cm5zIGFsbCBmaWxlcyB0aGF0IGFyZSBpbiB0aGUgcXVldWVcXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0UXVldWVkRmlsZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UXVldWVkRmlsZXMoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsZXNXaXRoU3RhdHVzKERyb3B6b25lLlFVRVVFRCk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0VXBsb2FkaW5nRmlsZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VXBsb2FkaW5nRmlsZXMoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RmlsZXNXaXRoU3RhdHVzKERyb3B6b25lLlVQTE9BRElORyk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0QWRkZWRGaWxlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBZGRlZEZpbGVzKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmdldEZpbGVzV2l0aFN0YXR1cyhEcm9wem9uZS5BRERFRCk7XFxuICAgIH0gLy8gRmlsZXMgdGhhdCBhcmUgZWl0aGVyIHF1ZXVlZCBvciB1cGxvYWRpbmdcXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0QWN0aXZlRmlsZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWN0aXZlRmlsZXMoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZmlsZXMuZmlsdGVyKGZ1bmN0aW9uIChmaWxlKSB7XFxuICAgICAgICByZXR1cm4gZmlsZS5zdGF0dXMgPT09IERyb3B6b25lLlVQTE9BRElORyB8fCBmaWxlLnN0YXR1cyA9PT0gRHJvcHpvbmUuUVVFVUVEO1xcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoZmlsZSkge1xcbiAgICAgICAgcmV0dXJuIGZpbGU7XFxuICAgICAgfSk7XFxuICAgIH0gLy8gVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiBEcm9wem9uZSBpcyBpbml0aWFsaXplZC4gWW91XFxuICAgIC8vIGNhbiAoYW5kIHNob3VsZCkgc2V0dXAgZXZlbnQgbGlzdGVuZXJzIGluc2lkZSB0aGlzIGZ1bmN0aW9uLlxcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJpbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgLy8gSW4gY2FzZSBpdCBpc24ndCBzZXQgYWxyZWFkeVxcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQudGFnTmFtZSA9PT0gXFxcImZvcm1cXFwiKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFxcXCJlbmN0eXBlXFxcIiwgXFxcIm11bHRpcGFydC9mb3JtLWRhdGFcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXFxcImRyb3B6b25lXFxcIikgJiYgIXRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFxcXCIuZHotbWVzc2FnZVxcXCIpKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoRHJvcHpvbmUuY3JlYXRlRWxlbWVudChcXFwiPGRpdiBjbGFzcz1cXFxcXFxcImR6LWRlZmF1bHQgZHotbWVzc2FnZVxcXFxcXFwiPjxidXR0b24gY2xhc3M9XFxcXFxcXCJkei1idXR0b25cXFxcXFxcIiB0eXBlPVxcXFxcXFwiYnV0dG9uXFxcXFxcXCI+XFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmRpY3REZWZhdWx0TWVzc2FnZSwgXFxcIjwvYnV0dG9uPjwvZGl2PlxcXCIpKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLmNsaWNrYWJsZUVsZW1lbnRzLmxlbmd0aCkge1xcbiAgICAgICAgdmFyIHNldHVwSGlkZGVuRmlsZUlucHV0ID0gZnVuY3Rpb24gc2V0dXBIaWRkZW5GaWxlSW5wdXQoKSB7XFxuICAgICAgICAgIGlmIChfdGhpczIuaGlkZGVuRmlsZUlucHV0KSB7XFxuICAgICAgICAgICAgX3RoaXMyLmhpZGRlbkZpbGVJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF90aGlzMi5oaWRkZW5GaWxlSW5wdXQpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIF90aGlzMi5oaWRkZW5GaWxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpO1xcblxcbiAgICAgICAgICBfdGhpczIuaGlkZGVuRmlsZUlucHV0LnNldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIsIFxcXCJmaWxlXFxcIik7XFxuXFxuICAgICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5tYXhGaWxlcyA9PT0gbnVsbCB8fCBfdGhpczIub3B0aW9ucy5tYXhGaWxlcyA+IDEpIHtcXG4gICAgICAgICAgICBfdGhpczIuaGlkZGVuRmlsZUlucHV0LnNldEF0dHJpYnV0ZShcXFwibXVsdGlwbGVcXFwiLCBcXFwibXVsdGlwbGVcXFwiKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBfdGhpczIuaGlkZGVuRmlsZUlucHV0LmNsYXNzTmFtZSA9IFxcXCJkei1oaWRkZW4taW5wdXRcXFwiO1xcblxcbiAgICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMuYWNjZXB0ZWRGaWxlcyAhPT0gbnVsbCkge1xcbiAgICAgICAgICAgIF90aGlzMi5oaWRkZW5GaWxlSW5wdXQuc2V0QXR0cmlidXRlKFxcXCJhY2NlcHRcXFwiLCBfdGhpczIub3B0aW9ucy5hY2NlcHRlZEZpbGVzKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMuY2FwdHVyZSAhPT0gbnVsbCkge1xcbiAgICAgICAgICAgIF90aGlzMi5oaWRkZW5GaWxlSW5wdXQuc2V0QXR0cmlidXRlKFxcXCJjYXB0dXJlXFxcIiwgX3RoaXMyLm9wdGlvbnMuY2FwdHVyZSk7XFxuICAgICAgICAgIH0gLy8gTWFraW5nIHN1cmUgdGhhdCBubyBvbmUgY2FuIFxcXCJ0YWJcXFwiIGludG8gdGhpcyBmaWVsZC5cXG5cXG5cXG4gICAgICAgICAgX3RoaXMyLmhpZGRlbkZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoXFxcInRhYmluZGV4XFxcIiwgXFxcIi0xXFxcIik7IC8vIE5vdCBzZXR0aW5nIGBkaXNwbGF5PVxcXCJub25lXFxcImAgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGRvbid0IGFjY2VwdCBjbGlja3NcXG4gICAgICAgICAgLy8gb24gZWxlbWVudHMgdGhhdCBhcmVuJ3QgZGlzcGxheWVkLlxcblxcblxcbiAgICAgICAgICBfdGhpczIuaGlkZGVuRmlsZUlucHV0LnN0eWxlLnZpc2liaWxpdHkgPSBcXFwiaGlkZGVuXFxcIjtcXG4gICAgICAgICAgX3RoaXMyLmhpZGRlbkZpbGVJbnB1dC5zdHlsZS5wb3NpdGlvbiA9IFxcXCJhYnNvbHV0ZVxcXCI7XFxuICAgICAgICAgIF90aGlzMi5oaWRkZW5GaWxlSW5wdXQuc3R5bGUudG9wID0gXFxcIjBcXFwiO1xcbiAgICAgICAgICBfdGhpczIuaGlkZGVuRmlsZUlucHV0LnN0eWxlLmxlZnQgPSBcXFwiMFxcXCI7XFxuICAgICAgICAgIF90aGlzMi5oaWRkZW5GaWxlSW5wdXQuc3R5bGUuaGVpZ2h0ID0gXFxcIjBcXFwiO1xcbiAgICAgICAgICBfdGhpczIuaGlkZGVuRmlsZUlucHV0LnN0eWxlLndpZHRoID0gXFxcIjBcXFwiO1xcbiAgICAgICAgICBEcm9wem9uZS5nZXRFbGVtZW50KF90aGlzMi5vcHRpb25zLmhpZGRlbklucHV0Q29udGFpbmVyLCBcXFwiaGlkZGVuSW5wdXRDb250YWluZXJcXFwiKS5hcHBlbmRDaGlsZChfdGhpczIuaGlkZGVuRmlsZUlucHV0KTtcXG5cXG4gICAgICAgICAgX3RoaXMyLmhpZGRlbkZpbGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKFxcXCJjaGFuZ2VcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIGZpbGVzID0gX3RoaXMyLmhpZGRlbkZpbGVJbnB1dC5maWxlcztcXG5cXG4gICAgICAgICAgICBpZiAoZmlsZXMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gZHJvcHpvbmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihmaWxlcywgdHJ1ZSksXFxuICAgICAgICAgICAgICAgICAgX3N0ZXA7XFxuXFxuICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xcbiAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gX3N0ZXAudmFsdWU7XFxuXFxuICAgICAgICAgICAgICAgICAgX3RoaXMyLmFkZEZpbGUoZmlsZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgX3RoaXMyLmVtaXQoXFxcImFkZGVkZmlsZXNcXFwiLCBmaWxlcyk7XFxuXFxuICAgICAgICAgICAgc2V0dXBIaWRkZW5GaWxlSW5wdXQoKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgc2V0dXBIaWRkZW5GaWxlSW5wdXQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5VUkwgPSB3aW5kb3cuVVJMICE9PSBudWxsID8gd2luZG93LlVSTCA6IHdpbmRvdy53ZWJraXRVUkw7IC8vIFNldHVwIGFsbCBldmVudCBsaXN0ZW5lcnMgb24gdGhlIERyb3B6b25lIG9iamVjdCBpdHNlbGYuXFxuICAgICAgLy8gVGhleSdyZSBub3QgaW4gQHNldHVwRXZlbnRMaXN0ZW5lcnMoKSBiZWNhdXNlIHRoZXkgc2hvdWxkbid0IGJlIHJlbW92ZWRcXG4gICAgICAvLyBhZ2FpbiB3aGVuIHRoZSBkcm9wem9uZSBnZXRzIGRpc2FibGVkLlxcblxcbiAgICAgIHZhciBfaXRlcmF0b3IyID0gZHJvcHpvbmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmV2ZW50cywgdHJ1ZSksXFxuICAgICAgICAgIF9zdGVwMjtcXG5cXG4gICAgICB0cnkge1xcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcXG4gICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IF9zdGVwMi52YWx1ZTtcXG4gICAgICAgICAgdGhpcy5vbihldmVudE5hbWUsIHRoaXMub3B0aW9uc1tldmVudE5hbWVdKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xcbiAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5vbihcXFwidXBsb2FkcHJvZ3Jlc3NcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMyLnVwZGF0ZVRvdGFsVXBsb2FkUHJvZ3Jlc3MoKTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLm9uKFxcXCJyZW1vdmVkZmlsZVxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBfdGhpczIudXBkYXRlVG90YWxVcGxvYWRQcm9ncmVzcygpO1xcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMub24oXFxcImNhbmNlbGVkXFxcIiwgZnVuY3Rpb24gKGZpbGUpIHtcXG4gICAgICAgIHJldHVybiBfdGhpczIuZW1pdChcXFwiY29tcGxldGVcXFwiLCBmaWxlKTtcXG4gICAgICB9KTsgLy8gRW1pdCBhIGBxdWV1ZWNvbXBsZXRlYCBldmVudCBpZiBhbGwgZmlsZXMgZmluaXNoZWQgdXBsb2FkaW5nLlxcblxcbiAgICAgIHRoaXMub24oXFxcImNvbXBsZXRlXFxcIiwgZnVuY3Rpb24gKGZpbGUpIHtcXG4gICAgICAgIGlmIChfdGhpczIuZ2V0QWRkZWRGaWxlcygpLmxlbmd0aCA9PT0gMCAmJiBfdGhpczIuZ2V0VXBsb2FkaW5nRmlsZXMoKS5sZW5ndGggPT09IDAgJiYgX3RoaXMyLmdldFF1ZXVlZEZpbGVzKCkubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVmZXJyZWQgc28gdGhhdCBgcXVldWVjb21wbGV0ZWAgcmVhbGx5IHRyaWdnZXJzIGFmdGVyIGBjb21wbGV0ZWBcXG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuZW1pdChcXFwicXVldWVjb21wbGV0ZVxcXCIpO1xcbiAgICAgICAgICB9LCAwKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICB2YXIgY29udGFpbnNGaWxlcyA9IGZ1bmN0aW9uIGNvbnRhaW5zRmlsZXMoZSkge1xcbiAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyLnR5cGVzKSB7XFxuICAgICAgICAgIC8vIEJlY2F1c2UgZS5kYXRhVHJhbnNmZXIudHlwZXMgaXMgYW4gT2JqZWN0IGluXFxuICAgICAgICAgIC8vIElFLCB3ZSBuZWVkIHRvIGl0ZXJhdGUgbGlrZSB0aGlzIGluc3RlYWQgb2ZcXG4gICAgICAgICAgLy8gdXNpbmcgZS5kYXRhVHJhbnNmZXIudHlwZXMuc29tZSgpXFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5kYXRhVHJhbnNmZXIudHlwZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIudHlwZXNbaV0gPT09IFxcXCJGaWxlc1xcXCIpIHJldHVybiB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfTtcXG5cXG4gICAgICB2YXIgbm9Qcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIG5vUHJvcGFnYXRpb24oZSkge1xcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGZpbGVzLCB3ZSBkb24ndCB3YW50IHRvIHN0b3BcXG4gICAgICAgIC8vIHByb3BhZ2F0aW9uIHNvIHdlIGRvbid0IGludGVyZmVyZSB3aXRoIG90aGVyXFxuICAgICAgICAvLyBkcmFnIGFuZCBkcm9wIGJlaGF2aW91ci5cXG4gICAgICAgIGlmICghY29udGFpbnNGaWxlcyhlKSkgcmV0dXJuO1xcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XFxuICAgICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXR1cm4gZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH07IC8vIENyZWF0ZSB0aGUgbGlzdGVuZXJzXFxuXFxuXFxuICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbe1xcbiAgICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50LFxcbiAgICAgICAgZXZlbnRzOiB7XFxuICAgICAgICAgIGRyYWdzdGFydDogZnVuY3Rpb24gZHJhZ3N0YXJ0KGUpIHtcXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLmVtaXQoXFxcImRyYWdzdGFydFxcXCIsIGUpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBkcmFnZW50ZXI6IGZ1bmN0aW9uIGRyYWdlbnRlcihlKSB7XFxuICAgICAgICAgICAgbm9Qcm9wYWdhdGlvbihlKTtcXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLmVtaXQoXFxcImRyYWdlbnRlclxcXCIsIGUpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBkcmFnb3ZlcjogZnVuY3Rpb24gZHJhZ292ZXIoZSkge1xcbiAgICAgICAgICAgIC8vIE1ha2VzIGl0IHBvc3NpYmxlIHRvIGRyYWcgZmlsZXMgZnJvbSBjaHJvbWUncyBkb3dubG9hZCBiYXJcXG4gICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE5NTI2NDMwL2RyYWctYW5kLWRyb3AtZmlsZS11cGxvYWRzLWZyb20tY2hyb21lLWRvd25sb2Fkcy1iYXJcXG4gICAgICAgICAgICAvLyBUcnkgaXMgcmVxdWlyZWQgdG8gcHJldmVudCBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTEgKFNDUklQVDY1NTM1IGV4Y2VwdGlvbilcXG4gICAgICAgICAgICB2YXIgZWZjdDtcXG5cXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgZWZjdCA9IGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQ7XFxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XFxuXFxuICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFxcXCJtb3ZlXFxcIiA9PT0gZWZjdCB8fCBcXFwibGlua01vdmVcXFwiID09PSBlZmN0ID8gXFxcIm1vdmVcXFwiIDogXFxcImNvcHlcXFwiO1xcbiAgICAgICAgICAgIG5vUHJvcGFnYXRpb24oZSk7XFxuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5lbWl0KFxcXCJkcmFnb3ZlclxcXCIsIGUpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBkcmFnbGVhdmU6IGZ1bmN0aW9uIGRyYWdsZWF2ZShlKSB7XFxuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5lbWl0KFxcXCJkcmFnbGVhdmVcXFwiLCBlKTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgZHJvcDogZnVuY3Rpb24gZHJvcChlKSB7XFxuICAgICAgICAgICAgbm9Qcm9wYWdhdGlvbihlKTtcXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLmRyb3AoZSk7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGRyYWdlbmQ6IGZ1bmN0aW9uIGRyYWdlbmQoZSkge1xcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuZW1pdChcXFwiZHJhZ2VuZFxcXCIsIGUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IC8vIFRoaXMgaXMgZGlzYWJsZWQgcmlnaHQgbm93LCBiZWNhdXNlIHRoZSBicm93c2VycyBkb24ndCBpbXBsZW1lbnQgaXQgcHJvcGVybHkuXFxuICAgICAgICAvLyBcXFwicGFzdGVcXFwiOiAoZSkgPT5cXG4gICAgICAgIC8vICAgbm9Qcm9wYWdhdGlvbiBlXFxuICAgICAgICAvLyAgIEBwYXN0ZSBlXFxuXFxuICAgICAgfV07XFxuICAgICAgdGhpcy5jbGlja2FibGVFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjbGlja2FibGVFbGVtZW50KSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMyLmxpc3RlbmVycy5wdXNoKHtcXG4gICAgICAgICAgZWxlbWVudDogY2xpY2thYmxlRWxlbWVudCxcXG4gICAgICAgICAgZXZlbnRzOiB7XFxuICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGV2dCkge1xcbiAgICAgICAgICAgICAgLy8gT25seSB0aGUgYWN0dWFsIGRyb3B6b25lIG9yIHRoZSBtZXNzYWdlIGVsZW1lbnQgc2hvdWxkIHRyaWdnZXIgZmlsZSBzZWxlY3Rpb25cXG4gICAgICAgICAgICAgIGlmIChjbGlja2FibGVFbGVtZW50ICE9PSBfdGhpczIuZWxlbWVudCB8fCBldnQudGFyZ2V0ID09PSBfdGhpczIuZWxlbWVudCB8fCBEcm9wem9uZS5lbGVtZW50SW5zaWRlKGV2dC50YXJnZXQsIF90aGlzMi5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXFxcIi5kei1tZXNzYWdlXFxcIikpKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzMi5oaWRkZW5GaWxlSW5wdXQuY2xpY2soKTsgLy8gRm9yd2FyZCB0aGUgY2xpY2tcXG5cXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5lbmFibGUoKTtcXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmluaXQuY2FsbCh0aGlzKTtcXG4gICAgfSAvLyBOb3QgZnVsbHkgdGVzdGVkIHlldFxcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJkZXN0cm95XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgdGhpcy5kaXNhYmxlKCk7XFxuICAgICAgdGhpcy5yZW1vdmVBbGxGaWxlcyh0cnVlKTtcXG5cXG4gICAgICBpZiAodGhpcy5oaWRkZW5GaWxlSW5wdXQgIT0gbnVsbCA/IHRoaXMuaGlkZGVuRmlsZUlucHV0LnBhcmVudE5vZGUgOiB1bmRlZmluZWQpIHtcXG4gICAgICAgIHRoaXMuaGlkZGVuRmlsZUlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5oaWRkZW5GaWxlSW5wdXQpO1xcbiAgICAgICAgdGhpcy5oaWRkZW5GaWxlSW5wdXQgPSBudWxsO1xcbiAgICAgIH1cXG5cXG4gICAgICBkZWxldGUgdGhpcy5lbGVtZW50LmRyb3B6b25lO1xcbiAgICAgIHJldHVybiBEcm9wem9uZS5pbnN0YW5jZXMuc3BsaWNlKERyb3B6b25lLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpLCAxKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ1cGRhdGVUb3RhbFVwbG9hZFByb2dyZXNzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVRvdGFsVXBsb2FkUHJvZ3Jlc3MoKSB7XFxuICAgICAgdmFyIHRvdGFsVXBsb2FkUHJvZ3Jlc3M7XFxuICAgICAgdmFyIHRvdGFsQnl0ZXNTZW50ID0gMDtcXG4gICAgICB2YXIgdG90YWxCeXRlcyA9IDA7XFxuICAgICAgdmFyIGFjdGl2ZUZpbGVzID0gdGhpcy5nZXRBY3RpdmVGaWxlcygpO1xcblxcbiAgICAgIGlmIChhY3RpdmVGaWxlcy5sZW5ndGgpIHtcXG4gICAgICAgIHZhciBfaXRlcmF0b3IzID0gZHJvcHpvbmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmdldEFjdGl2ZUZpbGVzKCksIHRydWUpLFxcbiAgICAgICAgICAgIF9zdGVwMztcXG5cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XFxuICAgICAgICAgICAgdmFyIGZpbGUgPSBfc3RlcDMudmFsdWU7XFxuICAgICAgICAgICAgdG90YWxCeXRlc1NlbnQgKz0gZmlsZS51cGxvYWQuYnl0ZXNTZW50O1xcbiAgICAgICAgICAgIHRvdGFsQnl0ZXMgKz0gZmlsZS51cGxvYWQudG90YWw7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcXG4gICAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdG90YWxVcGxvYWRQcm9ncmVzcyA9IDEwMCAqIHRvdGFsQnl0ZXNTZW50IC8gdG90YWxCeXRlcztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdG90YWxVcGxvYWRQcm9ncmVzcyA9IDEwMDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuZW1pdChcXFwidG90YWx1cGxvYWRwcm9ncmVzc1xcXCIsIHRvdGFsVXBsb2FkUHJvZ3Jlc3MsIHRvdGFsQnl0ZXMsIHRvdGFsQnl0ZXNTZW50KTtcXG4gICAgfSAvLyBAb3B0aW9ucy5wYXJhbU5hbWUgY2FuIGJlIGEgZnVuY3Rpb24gdGFraW5nIG9uZSBwYXJhbWV0ZXIgcmF0aGVyIHRoYW4gYSBzdHJpbmcuXFxuICAgIC8vIEEgcGFyYW1ldGVyIG5hbWUgZm9yIGEgZmlsZSBpcyBvYnRhaW5lZCBzaW1wbHkgYnkgY2FsbGluZyB0aGlzIHdpdGggYW4gaW5kZXggbnVtYmVyLlxcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZ2V0UGFyYW1OYW1lXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRQYXJhbU5hbWUobikge1xcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnBhcmFtTmFtZSA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wYXJhbU5hbWUobik7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBcXFwiXFxcIi5jb25jYXQodGhpcy5vcHRpb25zLnBhcmFtTmFtZSkuY29uY2F0KHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSA/IFxcXCJbXFxcIi5jb25jYXQobiwgXFxcIl1cXFwiKSA6IFxcXCJcXFwiKTtcXG4gICAgICB9XFxuICAgIH0gLy8gSWYgQG9wdGlvbnMucmVuYW1lRmlsZSBpcyBhIGZ1bmN0aW9uLFxcbiAgICAvLyB0aGUgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIHJlbmFtZSB0aGUgZmlsZS5uYW1lIGJlZm9yZSBhcHBlbmRpbmcgaXQgdG8gdGhlIGZvcm1EYXRhXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9yZW5hbWVGaWxlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5hbWVGaWxlKGZpbGUpIHtcXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5yZW5hbWVGaWxlICE9PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgICByZXR1cm4gZmlsZS5uYW1lO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJlbmFtZUZpbGUoZmlsZSk7XFxuICAgIH0gLy8gUmV0dXJucyBhIGZvcm0gdGhhdCBjYW4gYmUgdXNlZCBhcyBmYWxsYmFjayBpZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IERyYWduRHJvcFxcbiAgICAvL1xcbiAgICAvLyBJZiB0aGUgZHJvcHpvbmUgaXMgYWxyZWFkeSBhIGZvcm0sIG9ubHkgdGhlIGlucHV0IGZpZWxkIGFuZCBidXR0b24gYXJlIHJldHVybmVkLiBPdGhlcndpc2UgYSBjb21wbGV0ZSBmb3JtIGVsZW1lbnQgaXMgcHJvdmlkZWQuXFxuICAgIC8vIFRoaXMgY29kZSBoYXMgdG8gcGFzcyBpbiBJRTcgOihcXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0RmFsbGJhY2tGb3JtXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZhbGxiYWNrRm9ybSgpIHtcXG4gICAgICB2YXIgZXhpc3RpbmdGYWxsYmFjaywgZm9ybTtcXG5cXG4gICAgICBpZiAoZXhpc3RpbmdGYWxsYmFjayA9IHRoaXMuZ2V0RXhpc3RpbmdGYWxsYmFjaygpKSB7XFxuICAgICAgICByZXR1cm4gZXhpc3RpbmdGYWxsYmFjaztcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGZpZWxkc1N0cmluZyA9ICc8ZGl2IGNsYXNzPVxcXCJkei1mYWxsYmFja1xcXCI+JztcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRpY3RGYWxsYmFja1RleHQpIHtcXG4gICAgICAgIGZpZWxkc1N0cmluZyArPSBcXFwiPHA+XFxcIi5jb25jYXQodGhpcy5vcHRpb25zLmRpY3RGYWxsYmFja1RleHQsIFxcXCI8L3A+XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGZpZWxkc1N0cmluZyArPSBcXFwiPGlucHV0IHR5cGU9XFxcXFxcXCJmaWxlXFxcXFxcXCIgbmFtZT1cXFxcXFxcIlxcXCIuY29uY2F0KHRoaXMuX2dldFBhcmFtTmFtZSgwKSwgXFxcIlxcXFxcXFwiIFxcXCIpLmNvbmNhdCh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUgPyAnbXVsdGlwbGU9XFxcIm11bHRpcGxlXFxcIicgOiB1bmRlZmluZWQsIFxcXCIgLz48aW5wdXQgdHlwZT1cXFxcXFxcInN1Ym1pdFxcXFxcXFwiIHZhbHVlPVxcXFxcXFwiVXBsb2FkIVxcXFxcXFwiPjwvZGl2PlxcXCIpO1xcbiAgICAgIHZhciBmaWVsZHMgPSBEcm9wem9uZS5jcmVhdGVFbGVtZW50KGZpZWxkc1N0cmluZyk7XFxuXFxuICAgICAgaWYgKHRoaXMuZWxlbWVudC50YWdOYW1lICE9PSBcXFwiRk9STVxcXCIpIHtcXG4gICAgICAgIGZvcm0gPSBEcm9wem9uZS5jcmVhdGVFbGVtZW50KFxcXCI8Zm9ybSBhY3Rpb249XFxcXFxcXCJcXFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMudXJsLCBcXFwiXFxcXFxcXCIgZW5jdHlwZT1cXFxcXFxcIm11bHRpcGFydC9mb3JtLWRhdGFcXFxcXFxcIiBtZXRob2Q9XFxcXFxcXCJcXFwiKS5jb25jYXQodGhpcy5vcHRpb25zLm1ldGhvZCwgXFxcIlxcXFxcXFwiPjwvZm9ybT5cXFwiKSk7XFxuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGZpZWxkcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBlbmN0eXBlIGFuZCBtZXRob2QgYXR0cmlidXRlcyBhcmUgc2V0IHByb3Blcmx5XFxuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFxcXCJlbmN0eXBlXFxcIiwgXFxcIm11bHRpcGFydC9mb3JtLWRhdGFcXFwiKTtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXFxcIm1ldGhvZFxcXCIsIHRoaXMub3B0aW9ucy5tZXRob2QpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZm9ybSAhPSBudWxsID8gZm9ybSA6IGZpZWxkcztcXG4gICAgfSAvLyBSZXR1cm5zIHRoZSBmYWxsYmFjayBlbGVtZW50cyBpZiB0aGV5IGV4aXN0IGFscmVhZHlcXG4gICAgLy9cXG4gICAgLy8gVGhpcyBjb2RlIGhhcyB0byBwYXNzIGluIElFNyA6KFxcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZXRFeGlzdGluZ0ZhbGxiYWNrXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEV4aXN0aW5nRmFsbGJhY2soKSB7XFxuICAgICAgdmFyIGdldEZhbGxiYWNrID0gZnVuY3Rpb24gZ2V0RmFsbGJhY2soZWxlbWVudHMpIHtcXG4gICAgICAgIHZhciBfaXRlcmF0b3I0ID0gZHJvcHpvbmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihlbGVtZW50cywgdHJ1ZSksXFxuICAgICAgICAgICAgX3N0ZXA0O1xcblxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcXG4gICAgICAgICAgICB2YXIgZWwgPSBfc3RlcDQudmFsdWU7XFxuXFxuICAgICAgICAgICAgaWYgKC8oXnwgKWZhbGxiYWNrKCR8ICkvLnRlc3QoZWwuY2xhc3NOYW1lKSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGVsO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xcbiAgICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9hcnIgPSBbXFxcImRpdlxcXCIsIFxcXCJmb3JtXFxcIl07IF9pIDwgX2Fyci5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgIHZhciB0YWdOYW1lID0gX2FycltfaV07XFxuICAgICAgICB2YXIgZmFsbGJhY2s7XFxuXFxuICAgICAgICBpZiAoZmFsbGJhY2sgPSBnZXRGYWxsYmFjayh0aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSkpKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gLy8gQWN0aXZhdGVzIGFsbCBsaXN0ZW5lcnMgc3RvcmVkIGluIEBsaXN0ZW5lcnNcXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2V0dXBFdmVudExpc3RlbmVyc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5tYXAoZnVuY3Rpb24gKGVsZW1lbnRMaXN0ZW5lcnMpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcXG5cXG4gICAgICAgICAgZm9yICh2YXIgZXZlbnQgaW4gZWxlbWVudExpc3RlbmVycy5ldmVudHMpIHtcXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBlbGVtZW50TGlzdGVuZXJzLmV2ZW50c1tldmVudF07XFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudExpc3RlbmVycy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgICB9KCk7XFxuICAgICAgfSk7XFxuICAgIH0gLy8gRGVhY3RpdmF0ZXMgYWxsIGxpc3RlbmVycyBzdG9yZWQgaW4gQGxpc3RlbmVyc1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZW1vdmVFdmVudExpc3RlbmVyc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycygpIHtcXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMubWFwKGZ1bmN0aW9uIChlbGVtZW50TGlzdGVuZXJzKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XFxuXFxuICAgICAgICAgIGZvciAodmFyIGV2ZW50IGluIGVsZW1lbnRMaXN0ZW5lcnMuZXZlbnRzKSB7XFxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZWxlbWVudExpc3RlbmVycy5ldmVudHNbZXZlbnRdO1xcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnRMaXN0ZW5lcnMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgICAgfSgpO1xcbiAgICAgIH0pO1xcbiAgICB9IC8vIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVycyBhbmQgY2FuY2VscyBhbGwgZmlsZXMgaW4gdGhlIHF1ZXVlIG9yIGJlaW5nIHByb2Nlc3NlZC5cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZGlzYWJsZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuY2xpY2thYmxlRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcXFwiZHotY2xpY2thYmxlXFxcIik7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycygpO1xcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xcbiAgICAgIHJldHVybiB0aGlzLmZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSkge1xcbiAgICAgICAgcmV0dXJuIF90aGlzMy5jYW5jZWxVcGxvYWQoZmlsZSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZW5hYmxlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcXG4gICAgICBkZWxldGUgdGhpcy5kaXNhYmxlZDtcXG4gICAgICB0aGlzLmNsaWNrYWJsZUVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXFxcImR6LWNsaWNrYWJsZVxcXCIpO1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcXG4gICAgfSAvLyBSZXR1cm5zIGEgbmljZWx5IGZvcm1hdHRlZCBmaWxlc2l6ZVxcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJmaWxlc2l6ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxlc2l6ZShzaXplKSB7XFxuICAgICAgdmFyIHNlbGVjdGVkU2l6ZSA9IDA7XFxuICAgICAgdmFyIHNlbGVjdGVkVW5pdCA9IFxcXCJiXFxcIjtcXG5cXG4gICAgICBpZiAoc2l6ZSA+IDApIHtcXG4gICAgICAgIHZhciB1bml0cyA9IFtcXFwidGJcXFwiLCBcXFwiZ2JcXFwiLCBcXFwibWJcXFwiLCBcXFwia2JcXFwiLCBcXFwiYlxcXCJdO1xcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bml0cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB2YXIgdW5pdCA9IHVuaXRzW2ldO1xcbiAgICAgICAgICB2YXIgY3V0b2ZmID0gTWF0aC5wb3codGhpcy5vcHRpb25zLmZpbGVzaXplQmFzZSwgNCAtIGkpIC8gMTA7XFxuXFxuICAgICAgICAgIGlmIChzaXplID49IGN1dG9mZikge1xcbiAgICAgICAgICAgIHNlbGVjdGVkU2l6ZSA9IHNpemUgLyBNYXRoLnBvdyh0aGlzLm9wdGlvbnMuZmlsZXNpemVCYXNlLCA0IC0gaSk7XFxuICAgICAgICAgICAgc2VsZWN0ZWRVbml0ID0gdW5pdDtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2VsZWN0ZWRTaXplID0gTWF0aC5yb3VuZCgxMCAqIHNlbGVjdGVkU2l6ZSkgLyAxMDsgLy8gQ3V0dGluZyBvZiBkaWdpdHNcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIFxcXCI8c3Ryb25nPlxcXCIuY29uY2F0KHNlbGVjdGVkU2l6ZSwgXFxcIjwvc3Ryb25nPiBcXFwiKS5jb25jYXQodGhpcy5vcHRpb25zLmRpY3RGaWxlU2l6ZVVuaXRzW3NlbGVjdGVkVW5pdF0pO1xcbiAgICB9IC8vIEFkZHMgb3IgcmVtb3ZlcyB0aGUgYGR6LW1heC1maWxlcy1yZWFjaGVkYCBjbGFzcyBmcm9tIHRoZSBmb3JtLlxcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfdXBkYXRlTWF4RmlsZXNSZWFjaGVkQ2xhc3NcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZU1heEZpbGVzUmVhY2hlZENsYXNzKCkge1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4RmlsZXMgIT0gbnVsbCAmJiB0aGlzLmdldEFjY2VwdGVkRmlsZXMoKS5sZW5ndGggPj0gdGhpcy5vcHRpb25zLm1heEZpbGVzKSB7XFxuICAgICAgICBpZiAodGhpcy5nZXRBY2NlcHRlZEZpbGVzKCkubGVuZ3RoID09PSB0aGlzLm9wdGlvbnMubWF4RmlsZXMpIHtcXG4gICAgICAgICAgdGhpcy5lbWl0KFxcXCJtYXhmaWxlc3JlYWNoZWRcXFwiLCB0aGlzLmZpbGVzKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChcXFwiZHotbWF4LWZpbGVzLXJlYWNoZWRcXFwiKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFxcXCJkei1tYXgtZmlsZXMtcmVhY2hlZFxcXCIpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJkcm9wXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyb3AoZSkge1xcbiAgICAgIGlmICghZS5kYXRhVHJhbnNmZXIpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5lbWl0KFxcXCJkcm9wXFxcIiwgZSk7IC8vIENvbnZlcnQgdGhlIEZpbGVMaXN0IHRvIGFuIEFycmF5XFxuICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIElFMTFcXG5cXG4gICAgICB2YXIgZmlsZXMgPSBbXTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGUuZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBmaWxlc1tpXSA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzW2ldO1xcbiAgICAgIH0gLy8gRXZlbiBpZiBpdCdzIGEgZm9sZGVyLCBmaWxlcy5sZW5ndGggd2lsbCBjb250YWluIHRoZSBmb2xkZXJzLlxcblxcblxcbiAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcXG4gICAgICAgIHZhciBpdGVtcyA9IGUuZGF0YVRyYW5zZmVyLml0ZW1zO1xcblxcbiAgICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1swXS53ZWJraXRHZXRBc0VudHJ5ICE9IG51bGwpIHtcXG4gICAgICAgICAgLy8gVGhlIGJyb3dzZXIgc3VwcG9ydHMgZHJvcHBpbmcgb2YgZm9sZGVycywgc28gaGFuZGxlIGl0ZW1zIGluc3RlYWQgb2YgZmlsZXNcXG4gICAgICAgICAgdGhpcy5fYWRkRmlsZXNGcm9tSXRlbXMoaXRlbXMpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5oYW5kbGVGaWxlcyhmaWxlcyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuZW1pdChcXFwiYWRkZWRmaWxlc1xcXCIsIGZpbGVzKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwYXN0ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXN0ZShlKSB7XFxuICAgICAgaWYgKF9fZ3VhcmRfXyhlICE9IG51bGwgPyBlLmNsaXBib2FyZERhdGEgOiB1bmRlZmluZWQsIGZ1bmN0aW9uICh4KSB7XFxuICAgICAgICByZXR1cm4geC5pdGVtcztcXG4gICAgICB9KSA9PSBudWxsKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuZW1pdChcXFwicGFzdGVcXFwiLCBlKTtcXG4gICAgICB2YXIgaXRlbXMgPSBlLmNsaXBib2FyZERhdGEuaXRlbXM7XFxuXFxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEZpbGVzRnJvbUl0ZW1zKGl0ZW1zKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiaGFuZGxlRmlsZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRmlsZXMoZmlsZXMpIHtcXG4gICAgICB2YXIgX2l0ZXJhdG9yNSA9IGRyb3B6b25lX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZmlsZXMsIHRydWUpLFxcbiAgICAgICAgICBfc3RlcDU7XFxuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XFxuICAgICAgICAgIHZhciBmaWxlID0gX3N0ZXA1LnZhbHVlO1xcbiAgICAgICAgICB0aGlzLmFkZEZpbGUoZmlsZSk7XFxuICAgICAgICB9XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XFxuICAgICAgfVxcbiAgICB9IC8vIFdoZW4gYSBmb2xkZXIgaXMgZHJvcHBlZCAob3IgZmlsZXMgYXJlIHBhc3RlZCksIGl0ZW1zIG11c3QgYmUgaGFuZGxlZFxcbiAgICAvLyBpbnN0ZWFkIG9mIGZpbGVzLlxcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfYWRkRmlsZXNGcm9tSXRlbXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEZpbGVzRnJvbUl0ZW1zKGl0ZW1zKSB7XFxuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcXG5cXG4gICAgICAgIHZhciBfaXRlcmF0b3I2ID0gZHJvcHpvbmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpdGVtcywgdHJ1ZSksXFxuICAgICAgICAgICAgX3N0ZXA2O1xcblxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcXG4gICAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwNi52YWx1ZTtcXG4gICAgICAgICAgICB2YXIgZW50cnk7XFxuXFxuICAgICAgICAgICAgaWYgKGl0ZW0ud2Via2l0R2V0QXNFbnRyeSAhPSBudWxsICYmIChlbnRyeSA9IGl0ZW0ud2Via2l0R2V0QXNFbnRyeSgpKSkge1xcbiAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRmlsZSkge1xcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChfdGhpczQuYWRkRmlsZShpdGVtLmdldEFzRmlsZSgpKSk7XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XFxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBhbGwgZmlsZXMgZnJvbSB0aGF0IGRpcmVjdG9yeSB0byBmaWxlc1xcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChfdGhpczQuX2FkZEZpbGVzRnJvbURpcmVjdG9yeShlbnRyeSwgZW50cnkubmFtZSkpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godW5kZWZpbmVkKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uZ2V0QXNGaWxlICE9IG51bGwpIHtcXG4gICAgICAgICAgICAgIGlmIChpdGVtLmtpbmQgPT0gbnVsbCB8fCBpdGVtLmtpbmQgPT09IFxcXCJmaWxlXFxcIikge1xcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChfdGhpczQuYWRkRmlsZShpdGVtLmdldEFzRmlsZSgpKSk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh1bmRlZmluZWQpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICByZXN1bHQucHVzaCh1bmRlZmluZWQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xcbiAgICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH0oKTtcXG4gICAgfSAvLyBHb2VzIHRocm91Z2ggdGhlIGRpcmVjdG9yeSwgYW5kIGFkZHMgZWFjaCBmaWxlIGl0IGZpbmRzIHJlY3Vyc2l2ZWx5XFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9hZGRGaWxlc0Zyb21EaXJlY3RvcnlcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEZpbGVzRnJvbURpcmVjdG9yeShkaXJlY3RvcnksIHBhdGgpIHtcXG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcXG5cXG4gICAgICB2YXIgZGlyUmVhZGVyID0gZGlyZWN0b3J5LmNyZWF0ZVJlYWRlcigpO1xcblxcbiAgICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbiBlcnJvckhhbmRsZXIoZXJyb3IpIHtcXG4gICAgICAgIHJldHVybiBfX2d1YXJkTWV0aG9kX18oY29uc29sZSwgXFxcImxvZ1xcXCIsIGZ1bmN0aW9uIChvKSB7XFxuICAgICAgICAgIHJldHVybiBvLmxvZyhlcnJvcik7XFxuICAgICAgICB9KTtcXG4gICAgICB9O1xcblxcbiAgICAgIHZhciByZWFkRW50cmllcyA9IGZ1bmN0aW9uIHJlYWRFbnRyaWVzKCkge1xcbiAgICAgICAgcmV0dXJuIGRpclJlYWRlci5yZWFkRW50cmllcyhmdW5jdGlvbiAoZW50cmllcykge1xcbiAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjcgPSBkcm9wem9uZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGVudHJpZXMsIHRydWUpLFxcbiAgICAgICAgICAgICAgICBfc3RlcDc7XFxuXFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XFxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9zdGVwNy52YWx1ZTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRmlsZSkge1xcbiAgICAgICAgICAgICAgICAgIGVudHJ5LmZpbGUoZnVuY3Rpb24gKGZpbGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczUub3B0aW9ucy5pZ25vcmVIaWRkZW5GaWxlcyAmJiBmaWxlLm5hbWUuc3Vic3RyaW5nKDAsIDEpID09PSBcXFwiLlxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5mdWxsUGF0aCA9IFxcXCJcXFwiLmNvbmNhdChwYXRoLCBcXFwiL1xcXCIpLmNvbmNhdChmaWxlLm5hbWUpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNS5hZGRGaWxlKGZpbGUpO1xcbiAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XFxuICAgICAgICAgICAgICAgICAgX3RoaXM1Ll9hZGRGaWxlc0Zyb21EaXJlY3RvcnkoZW50cnksIFxcXCJcXFwiLmNvbmNhdChwYXRoLCBcXFwiL1xcXCIpLmNvbmNhdChlbnRyeS5uYW1lKSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gLy8gUmVjdXJzaXZlbHkgY2FsbCByZWFkRW50cmllcygpIGFnYWluLCBzaW5jZSBicm93c2VyIG9ubHkgaGFuZGxlXFxuICAgICAgICAgICAgICAvLyB0aGUgZmlyc3QgMTAwIGVudHJpZXMuXFxuICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9EaXJlY3RvcnlSZWFkZXIjcmVhZEVudHJpZXNcXG5cXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICAgIF9pdGVyYXRvcjcuZShlcnIpO1xcbiAgICAgICAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICAgICAgICBfaXRlcmF0b3I3LmYoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmVhZEVudHJpZXMoKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH0sIGVycm9ySGFuZGxlcik7XFxuICAgICAgfTtcXG5cXG4gICAgICByZXR1cm4gcmVhZEVudHJpZXMoKTtcXG4gICAgfSAvLyBJZiBgZG9uZSgpYCBpcyBjYWxsZWQgd2l0aG91dCBhcmd1bWVudCB0aGUgZmlsZSBpcyBhY2NlcHRlZFxcbiAgICAvLyBJZiB5b3UgY2FsbCBpdCB3aXRoIGFuIGVycm9yIG1lc3NhZ2UsIHRoZSBmaWxlIGlzIHJlamVjdGVkXFxuICAgIC8vIChUaGlzIGFsbG93cyBmb3IgYXN5bmNocm9ub3VzIHZhbGlkYXRpb24pXFxuICAgIC8vXFxuICAgIC8vIFRoaXMgZnVuY3Rpb24gY2hlY2tzIHRoZSBmaWxlc2l6ZSwgYW5kIGlmIHRoZSBmaWxlLnR5cGUgcGFzc2VzIHRoZVxcbiAgICAvLyBgYWNjZXB0ZWRGaWxlc2AgY2hlY2suXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFjY2VwdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2NlcHQoZmlsZSwgZG9uZSkge1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4RmlsZXNpemUgJiYgZmlsZS5zaXplID4gdGhpcy5vcHRpb25zLm1heEZpbGVzaXplICogMTAyNCAqIDEwMjQpIHtcXG4gICAgICAgIGRvbmUodGhpcy5vcHRpb25zLmRpY3RGaWxlVG9vQmlnLnJlcGxhY2UoXFxcInt7ZmlsZXNpemV9fVxcXCIsIE1hdGgucm91bmQoZmlsZS5zaXplIC8gMTAyNCAvIDEwLjI0KSAvIDEwMCkucmVwbGFjZShcXFwie3ttYXhGaWxlc2l6ZX19XFxcIiwgdGhpcy5vcHRpb25zLm1heEZpbGVzaXplKSk7XFxuICAgICAgfSBlbHNlIGlmICghRHJvcHpvbmUuaXNWYWxpZEZpbGUoZmlsZSwgdGhpcy5vcHRpb25zLmFjY2VwdGVkRmlsZXMpKSB7XFxuICAgICAgICBkb25lKHRoaXMub3B0aW9ucy5kaWN0SW52YWxpZEZpbGVUeXBlKTtcXG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5tYXhGaWxlcyAhPSBudWxsICYmIHRoaXMuZ2V0QWNjZXB0ZWRGaWxlcygpLmxlbmd0aCA+PSB0aGlzLm9wdGlvbnMubWF4RmlsZXMpIHtcXG4gICAgICAgIGRvbmUodGhpcy5vcHRpb25zLmRpY3RNYXhGaWxlc0V4Y2VlZGVkLnJlcGxhY2UoXFxcInt7bWF4RmlsZXN9fVxcXCIsIHRoaXMub3B0aW9ucy5tYXhGaWxlcykpO1xcbiAgICAgICAgdGhpcy5lbWl0KFxcXCJtYXhmaWxlc2V4Y2VlZGVkXFxcIiwgZmlsZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMub3B0aW9ucy5hY2NlcHQuY2FsbCh0aGlzLCBmaWxlLCBkb25lKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYWRkRmlsZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGaWxlKGZpbGUpIHtcXG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcXG5cXG4gICAgICBmaWxlLnVwbG9hZCA9IHtcXG4gICAgICAgIHV1aWQ6IERyb3B6b25lLnV1aWR2NCgpLFxcbiAgICAgICAgcHJvZ3Jlc3M6IDAsXFxuICAgICAgICAvLyBTZXR0aW5nIHRoZSB0b3RhbCB1cGxvYWQgc2l6ZSB0byBmaWxlLnNpemUgZm9yIHRoZSBiZWdpbm5pbmdcXG4gICAgICAgIC8vIEl0J3MgYWN0dWFsIGRpZmZlcmVudCB0aGFuIHRoZSBzaXplIHRvIGJlIHRyYW5zbWl0dGVkLlxcbiAgICAgICAgdG90YWw6IGZpbGUuc2l6ZSxcXG4gICAgICAgIGJ5dGVzU2VudDogMCxcXG4gICAgICAgIGZpbGVuYW1lOiB0aGlzLl9yZW5hbWVGaWxlKGZpbGUpIC8vIE5vdCBzZXR0aW5nIGNodW5raW5nIGluZm9ybWF0aW9uIGhlcmUsIGJlY2F1c2UgdGhlIGFjdXRhbCBkYXRhIFxcdTIwMTQgYW5kXFxuICAgICAgICAvLyB0aHVzIHRoZSBjaHVua3MgXFx1MjAxNCBtaWdodCBjaGFuZ2UgaWYgYG9wdGlvbnMudHJhbnNmb3JtRmlsZWAgaXMgc2V0XFxuICAgICAgICAvLyBhbmQgZG9lcyBzb21ldGhpbmcgdG8gdGhlIGRhdGEuXFxuXFxuICAgICAgfTtcXG4gICAgICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XFxuICAgICAgZmlsZS5zdGF0dXMgPSBEcm9wem9uZS5BRERFRDtcXG4gICAgICB0aGlzLmVtaXQoXFxcImFkZGVkZmlsZVxcXCIsIGZpbGUpO1xcblxcbiAgICAgIHRoaXMuX2VucXVldWVUaHVtYm5haWwoZmlsZSk7XFxuXFxuICAgICAgdGhpcy5hY2NlcHQoZmlsZSwgZnVuY3Rpb24gKGVycm9yKSB7XFxuICAgICAgICBpZiAoZXJyb3IpIHtcXG4gICAgICAgICAgZmlsZS5hY2NlcHRlZCA9IGZhbHNlO1xcblxcbiAgICAgICAgICBfdGhpczYuX2Vycm9yUHJvY2Vzc2luZyhbZmlsZV0sIGVycm9yKTsgLy8gV2lsbCBzZXQgdGhlIGZpbGUuc3RhdHVzXFxuXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBmaWxlLmFjY2VwdGVkID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgaWYgKF90aGlzNi5vcHRpb25zLmF1dG9RdWV1ZSkge1xcbiAgICAgICAgICAgIF90aGlzNi5lbnF1ZXVlRmlsZShmaWxlKTtcXG4gICAgICAgICAgfSAvLyBXaWxsIHNldCAuYWNjZXB0ZWQgPSB0cnVlXFxuXFxuICAgICAgICB9XFxuXFxuICAgICAgICBfdGhpczYuX3VwZGF0ZU1heEZpbGVzUmVhY2hlZENsYXNzKCk7XFxuICAgICAgfSk7XFxuICAgIH0gLy8gV3JhcHBlciBmb3IgZW5xdWV1ZUZpbGVcXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZW5xdWV1ZUZpbGVzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVucXVldWVGaWxlcyhmaWxlcykge1xcbiAgICAgIHZhciBfaXRlcmF0b3I4ID0gZHJvcHpvbmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihmaWxlcywgdHJ1ZSksXFxuICAgICAgICAgIF9zdGVwODtcXG5cXG4gICAgICB0cnkge1xcbiAgICAgICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHtcXG4gICAgICAgICAgdmFyIGZpbGUgPSBfc3RlcDgudmFsdWU7XFxuICAgICAgICAgIHRoaXMuZW5xdWV1ZUZpbGUoZmlsZSk7XFxuICAgICAgICB9XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICBfaXRlcmF0b3I4LmUoZXJyKTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgX2l0ZXJhdG9yOC5mKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImVucXVldWVGaWxlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVucXVldWVGaWxlKGZpbGUpIHtcXG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcXG5cXG4gICAgICBpZiAoZmlsZS5zdGF0dXMgPT09IERyb3B6b25lLkFEREVEICYmIGZpbGUuYWNjZXB0ZWQgPT09IHRydWUpIHtcXG4gICAgICAgIGZpbGUuc3RhdHVzID0gRHJvcHpvbmUuUVVFVUVEO1xcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUHJvY2Vzc1F1ZXVlKSB7XFxuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM3LnByb2Nlc3NRdWV1ZSgpO1xcbiAgICAgICAgICB9LCAwKTsgLy8gRGVmZXJyaW5nIHRoZSBjYWxsXFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiVGhpcyBmaWxlIGNhbid0IGJlIHF1ZXVlZCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkIG9yIHdhcyByZWplY3RlZC5cXFwiKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2VucXVldWVUaHVtYm5haWxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VucXVldWVUaHVtYm5haWwoZmlsZSkge1xcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3JlYXRlSW1hZ2VUaHVtYm5haWxzICYmIGZpbGUudHlwZS5tYXRjaCgvaW1hZ2UuKi8pICYmIGZpbGUuc2l6ZSA8PSB0aGlzLm9wdGlvbnMubWF4VGh1bWJuYWlsRmlsZXNpemUgKiAxMDI0ICogMTAyNCkge1xcbiAgICAgICAgdGhpcy5fdGh1bWJuYWlsUXVldWUucHVzaChmaWxlKTtcXG5cXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIF90aGlzOC5fcHJvY2Vzc1RodW1ibmFpbFF1ZXVlKCk7XFxuICAgICAgICB9LCAwKTsgLy8gRGVmZXJyaW5nIHRoZSBjYWxsXFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9wcm9jZXNzVGh1bWJuYWlsUXVldWVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NUaHVtYm5haWxRdWV1ZSgpIHtcXG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcXG5cXG4gICAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1RodW1ibmFpbCB8fCB0aGlzLl90aHVtYm5haWxRdWV1ZS5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fcHJvY2Vzc2luZ1RodW1ibmFpbCA9IHRydWU7XFxuXFxuICAgICAgdmFyIGZpbGUgPSB0aGlzLl90aHVtYm5haWxRdWV1ZS5zaGlmdCgpO1xcblxcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRodW1ibmFpbChmaWxlLCB0aGlzLm9wdGlvbnMudGh1bWJuYWlsV2lkdGgsIHRoaXMub3B0aW9ucy50aHVtYm5haWxIZWlnaHQsIHRoaXMub3B0aW9ucy50aHVtYm5haWxNZXRob2QsIHRydWUsIGZ1bmN0aW9uIChkYXRhVXJsKSB7XFxuICAgICAgICBfdGhpczkuZW1pdChcXFwidGh1bWJuYWlsXFxcIiwgZmlsZSwgZGF0YVVybCk7XFxuXFxuICAgICAgICBfdGhpczkuX3Byb2Nlc3NpbmdUaHVtYm5haWwgPSBmYWxzZTtcXG4gICAgICAgIHJldHVybiBfdGhpczkuX3Byb2Nlc3NUaHVtYm5haWxRdWV1ZSgpO1xcbiAgICAgIH0pO1xcbiAgICB9IC8vIENhbiBiZSBjYWxsZWQgYnkgdGhlIHVzZXIgdG8gcmVtb3ZlIGEgZmlsZVxcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZW1vdmVGaWxlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUZpbGUoZmlsZSkge1xcbiAgICAgIGlmIChmaWxlLnN0YXR1cyA9PT0gRHJvcHpvbmUuVVBMT0FESU5HKSB7XFxuICAgICAgICB0aGlzLmNhbmNlbFVwbG9hZChmaWxlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5maWxlcyA9IHdpdGhvdXQodGhpcy5maWxlcywgZmlsZSk7XFxuICAgICAgdGhpcy5lbWl0KFxcXCJyZW1vdmVkZmlsZVxcXCIsIGZpbGUpO1xcblxcbiAgICAgIGlmICh0aGlzLmZpbGVzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChcXFwicmVzZXRcXFwiKTtcXG4gICAgICB9XFxuICAgIH0gLy8gUmVtb3ZlcyBhbGwgZmlsZXMgdGhhdCBhcmVuJ3QgY3VycmVudGx5IHByb2Nlc3NlZCBmcm9tIHRoZSBsaXN0XFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInJlbW92ZUFsbEZpbGVzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUFsbEZpbGVzKGNhbmNlbElmTmVjZXNzYXJ5KSB7XFxuICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiBmaWxlcyBzaW5jZSByZW1vdmVGaWxlKCkgY2hhbmdlcyB0aGUgQGZpbGVzIGFycmF5LlxcbiAgICAgIGlmIChjYW5jZWxJZk5lY2Vzc2FyeSA9PSBudWxsKSB7XFxuICAgICAgICBjYW5jZWxJZk5lY2Vzc2FyeSA9IGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgX2l0ZXJhdG9yOSA9IGRyb3B6b25lX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5maWxlcy5zbGljZSgpLCB0cnVlKSxcXG4gICAgICAgICAgX3N0ZXA5O1xcblxcbiAgICAgIHRyeSB7XFxuICAgICAgICBmb3IgKF9pdGVyYXRvcjkucygpOyAhKF9zdGVwOSA9IF9pdGVyYXRvcjkubigpKS5kb25lOykge1xcbiAgICAgICAgICB2YXIgZmlsZSA9IF9zdGVwOS52YWx1ZTtcXG5cXG4gICAgICAgICAgaWYgKGZpbGUuc3RhdHVzICE9PSBEcm9wem9uZS5VUExPQURJTkcgfHwgY2FuY2VsSWZOZWNlc3NhcnkpIHtcXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZpbGUoZmlsZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgIF9pdGVyYXRvcjkuZShlcnIpO1xcbiAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICBfaXRlcmF0b3I5LmYoKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH0gLy8gUmVzaXplcyBhbiBpbWFnZSBiZWZvcmUgaXQgZ2V0cyBzZW50IHRvIHRoZSBzZXJ2ZXIuIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2ZcXG4gICAgLy8gYG9wdGlvbnMudHJhbnNmb3JtRmlsZWAgaWYgYHJlc2l6ZVdpZHRoYCBvciBgcmVzaXplSGVpZ2h0YCBhcmUgc2V0LiBUaGUgY2FsbGJhY2sgaXMgaW52b2tlZCB3aXRoXFxuICAgIC8vIHRoZSByZXNpemVkIGJsb2IuXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInJlc2l6ZUltYWdlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZUltYWdlKGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCwgY2FsbGJhY2spIHtcXG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGh1bWJuYWlsKGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCwgdHJ1ZSwgZnVuY3Rpb24gKGRhdGFVcmwsIGNhbnZhcykge1xcbiAgICAgICAgaWYgKGNhbnZhcyA9PSBudWxsKSB7XFxuICAgICAgICAgIC8vIFRoZSBpbWFnZSBoYXMgbm90IGJlZW4gcmVzaXplZFxcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZmlsZSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgcmVzaXplTWltZVR5cGUgPSBfdGhpczEwLm9wdGlvbnMucmVzaXplTWltZVR5cGU7XFxuXFxuICAgICAgICAgIGlmIChyZXNpemVNaW1lVHlwZSA9PSBudWxsKSB7XFxuICAgICAgICAgICAgcmVzaXplTWltZVR5cGUgPSBmaWxlLnR5cGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFyIHJlc2l6ZWREYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTChyZXNpemVNaW1lVHlwZSwgX3RoaXMxMC5vcHRpb25zLnJlc2l6ZVF1YWxpdHkpO1xcblxcbiAgICAgICAgICBpZiAocmVzaXplTWltZVR5cGUgPT09IFxcXCJpbWFnZS9qcGVnXFxcIiB8fCByZXNpemVNaW1lVHlwZSA9PT0gXFxcImltYWdlL2pwZ1xcXCIpIHtcXG4gICAgICAgICAgICAvLyBOb3cgYWRkIHRoZSBvcmlnaW5hbCBFWElGIGluZm9ybWF0aW9uXFxuICAgICAgICAgICAgcmVzaXplZERhdGFVUkwgPSBFeGlmUmVzdG9yZS5yZXN0b3JlKGZpbGUuZGF0YVVSTCwgcmVzaXplZERhdGFVUkwpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhEcm9wem9uZS5kYXRhVVJJdG9CbG9iKHJlc2l6ZWREYXRhVVJMKSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY3JlYXRlVGh1bWJuYWlsXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRodW1ibmFpbChmaWxlLCB3aWR0aCwgaGVpZ2h0LCByZXNpemVNZXRob2QsIGZpeE9yaWVudGF0aW9uLCBjYWxsYmFjaykge1xcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcXG5cXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XFxuXFxuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBmaWxlLmRhdGFVUkwgPSBmaWxlUmVhZGVyLnJlc3VsdDsgLy8gRG9uJ3QgYm90aGVyIGNyZWF0aW5nIGEgdGh1bWJuYWlsIGZvciBTVkcgaW1hZ2VzIHNpbmNlIHRoZXkncmUgdmVjdG9yXFxuXFxuICAgICAgICBpZiAoZmlsZS50eXBlID09PSBcXFwiaW1hZ2Uvc3ZnK3htbFxcXCIpIHtcXG4gICAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcXG4gICAgICAgICAgICBjYWxsYmFjayhmaWxlUmVhZGVyLnJlc3VsdCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgX3RoaXMxMS5jcmVhdGVUaHVtYm5haWxGcm9tVXJsKGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCwgZml4T3JpZW50YXRpb24sIGNhbGxiYWNrKTtcXG4gICAgICB9O1xcblxcbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcXG4gICAgfSAvLyBgbW9ja0ZpbGVgIG5lZWRzIHRvIGhhdmUgdGhlc2UgYXR0cmlidXRlczpcXG4gICAgLy9cXG4gICAgLy8gICAgIHsgbmFtZTogJ25hbWUnLCBzaXplOiAxMjM0NSwgaW1hZ2VVcmw6ICcnIH1cXG4gICAgLy9cXG4gICAgLy8gYGNhbGxiYWNrYCB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgaW1hZ2UgaGFzIGJlZW4gZG93bmxvYWRlZCBhbmQgZGlzcGxheWVkLlxcbiAgICAvLyBgY3Jvc3NPcmlnaW5gIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGBpbWdgIHRhZyB3aGVuIGFjY2Vzc2luZyB0aGUgZmlsZS5cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZGlzcGxheUV4aXN0aW5nRmlsZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwbGF5RXhpc3RpbmdGaWxlKG1vY2tGaWxlLCBpbWFnZVVybCwgY2FsbGJhY2ssIGNyb3NzT3JpZ2luKSB7XFxuICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xcblxcbiAgICAgIHZhciByZXNpemVUaHVtYm5haWwgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XFxuICAgICAgdGhpcy5lbWl0KFxcXCJhZGRlZGZpbGVcXFwiLCBtb2NrRmlsZSk7XFxuICAgICAgdGhpcy5lbWl0KFxcXCJjb21wbGV0ZVxcXCIsIG1vY2tGaWxlKTtcXG5cXG4gICAgICBpZiAoIXJlc2l6ZVRodW1ibmFpbCkge1xcbiAgICAgICAgdGhpcy5lbWl0KFxcXCJ0aHVtYm5haWxcXFwiLCBtb2NrRmlsZSwgaW1hZ2VVcmwpO1xcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgb25Eb25lID0gZnVuY3Rpb24gb25Eb25lKHRodW1ibmFpbCkge1xcbiAgICAgICAgICBfdGhpczEyLmVtaXQoXFxcInRodW1ibmFpbFxcXCIsIG1vY2tGaWxlLCB0aHVtYm5haWwpO1xcblxcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgbW9ja0ZpbGUuZGF0YVVSTCA9IGltYWdlVXJsO1xcbiAgICAgICAgdGhpcy5jcmVhdGVUaHVtYm5haWxGcm9tVXJsKG1vY2tGaWxlLCB0aGlzLm9wdGlvbnMudGh1bWJuYWlsV2lkdGgsIHRoaXMub3B0aW9ucy50aHVtYm5haWxIZWlnaHQsIHRoaXMub3B0aW9ucy5yZXNpemVNZXRob2QsIHRoaXMub3B0aW9ucy5maXhPcmllbnRhdGlvbiwgb25Eb25lLCBjcm9zc09yaWdpbik7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImNyZWF0ZVRodW1ibmFpbEZyb21VcmxcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVGh1bWJuYWlsRnJvbVVybChmaWxlLCB3aWR0aCwgaGVpZ2h0LCByZXNpemVNZXRob2QsIGZpeE9yaWVudGF0aW9uLCBjYWxsYmFjaywgY3Jvc3NPcmlnaW4pIHtcXG4gICAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XFxuXFxuICAgICAgLy8gTm90IHVzaW5nIGBuZXcgSW1hZ2VgIGhlcmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBsYXRlc3QgQ2hyb21lIHZlcnNpb25zLlxcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZW55by9kcm9wem9uZS9wdWxsLzIyNlxcbiAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJpbWdcXFwiKTtcXG5cXG4gICAgICBpZiAoY3Jvc3NPcmlnaW4pIHtcXG4gICAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xcbiAgICAgIH0gLy8gZml4T3JpZW50YXRpb24gaXMgbm90IG5lZWRlZCBhbnltb3JlIHdpdGggYnJvd3NlcnMgaGFuZGxpbmcgaW1hZ2VPcmllbnRhdGlvblxcblxcblxcbiAgICAgIGZpeE9yaWVudGF0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KVtcXFwiaW1hZ2VPcmllbnRhdGlvblxcXCJdID09IFxcXCJmcm9tLWltYWdlXFxcIiA/IGZhbHNlIDogZml4T3JpZW50YXRpb247XFxuXFxuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBsb2FkRXhpZiA9IGZ1bmN0aW9uIGxvYWRFeGlmKGNhbGxiYWNrKSB7XFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygxKTtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBpZiAodHlwZW9mIEVYSUYgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIEVYSUYgIT09IG51bGwgJiYgZml4T3JpZW50YXRpb24pIHtcXG4gICAgICAgICAgbG9hZEV4aWYgPSBmdW5jdGlvbiBsb2FkRXhpZihjYWxsYmFjaykge1xcbiAgICAgICAgICAgIHJldHVybiBFWElGLmdldERhdGEoaW1nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soRVhJRi5nZXRUYWcodGhpcywgXFxcIk9yaWVudGF0aW9uXFxcIikpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGxvYWRFeGlmKGZ1bmN0aW9uIChvcmllbnRhdGlvbikge1xcbiAgICAgICAgICBmaWxlLndpZHRoID0gaW1nLndpZHRoO1xcbiAgICAgICAgICBmaWxlLmhlaWdodCA9IGltZy5oZWlnaHQ7XFxuXFxuICAgICAgICAgIHZhciByZXNpemVJbmZvID0gX3RoaXMxMy5vcHRpb25zLnJlc2l6ZS5jYWxsKF90aGlzMTMsIGZpbGUsIHdpZHRoLCBoZWlnaHQsIHJlc2l6ZU1ldGhvZCk7XFxuXFxuICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJjYW52YXNcXFwiKTtcXG4gICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFxcXCIyZFxcXCIpO1xcbiAgICAgICAgICBjYW52YXMud2lkdGggPSByZXNpemVJbmZvLnRyZ1dpZHRoO1xcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcmVzaXplSW5mby50cmdIZWlnaHQ7XFxuXFxuICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA+IDQpIHtcXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSByZXNpemVJbmZvLnRyZ0hlaWdodDtcXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcmVzaXplSW5mby50cmdXaWR0aDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XFxuICAgICAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCBmbGlwXFxuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNhbnZhcy53aWR0aCwgMCk7XFxuICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgY2FzZSAzOlxcbiAgICAgICAgICAgICAgLy8gMTgwXFx4QjAgcm90YXRlIGxlZnRcXG4gICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcXG4gICAgICAgICAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSk7XFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgICAgICAvLyB2ZXJ0aWNhbCBmbGlwXFxuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGNhbnZhcy5oZWlnaHQpO1xcbiAgICAgICAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgIGNhc2UgNTpcXG4gICAgICAgICAgICAgIC8vIHZlcnRpY2FsIGZsaXAgKyA5MCByb3RhdGUgcmlnaHRcXG4gICAgICAgICAgICAgIGN0eC5yb3RhdGUoMC41ICogTWF0aC5QSSk7XFxuICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgLy8gOTBcXHhCMCByb3RhdGUgcmlnaHRcXG4gICAgICAgICAgICAgIGN0eC5yb3RhdGUoMC41ICogTWF0aC5QSSk7XFxuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIC1jYW52YXMud2lkdGgpO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgY2FzZSA3OlxcbiAgICAgICAgICAgICAgLy8gaG9yaXpvbnRhbCBmbGlwICsgOTAgcm90YXRlIHJpZ2h0XFxuICAgICAgICAgICAgICBjdHgucm90YXRlKDAuNSAqIE1hdGguUEkpO1xcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjYW52YXMuaGVpZ2h0LCAtY2FudmFzLndpZHRoKTtcXG4gICAgICAgICAgICAgIGN0eC5zY2FsZSgtMSwgMSk7XFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIDg6XFxuICAgICAgICAgICAgICAvLyA5MFxceEIwIHJvdGF0ZSBsZWZ0XFxuICAgICAgICAgICAgICBjdHgucm90YXRlKC0wLjUgKiBNYXRoLlBJKTtcXG4gICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWNhbnZhcy5oZWlnaHQsIDApO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH0gLy8gVGhpcyBpcyBhIGJ1Z2ZpeCBmb3IgaU9TJyBzY2FsaW5nIGJ1Zy5cXG5cXG5cXG4gICAgICAgICAgZHJhd0ltYWdlSU9TRml4KGN0eCwgaW1nLCByZXNpemVJbmZvLnNyY1ggIT0gbnVsbCA/IHJlc2l6ZUluZm8uc3JjWCA6IDAsIHJlc2l6ZUluZm8uc3JjWSAhPSBudWxsID8gcmVzaXplSW5mby5zcmNZIDogMCwgcmVzaXplSW5mby5zcmNXaWR0aCwgcmVzaXplSW5mby5zcmNIZWlnaHQsIHJlc2l6ZUluZm8udHJnWCAhPSBudWxsID8gcmVzaXplSW5mby50cmdYIDogMCwgcmVzaXplSW5mby50cmdZICE9IG51bGwgPyByZXNpemVJbmZvLnRyZ1kgOiAwLCByZXNpemVJbmZvLnRyZ1dpZHRoLCByZXNpemVJbmZvLnRyZ0hlaWdodCk7XFxuICAgICAgICAgIHZhciB0aHVtYm5haWwgPSBjYW52YXMudG9EYXRhVVJMKFxcXCJpbWFnZS9wbmdcXFwiKTtcXG5cXG4gICAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGh1bWJuYWlsLCBjYW52YXMpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9O1xcblxcbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XFxuICAgICAgICBpbWcub25lcnJvciA9IGNhbGxiYWNrO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gaW1nLnNyYyA9IGZpbGUuZGF0YVVSTDtcXG4gICAgfSAvLyBHb2VzIHRocm91Z2ggdGhlIHF1ZXVlIGFuZCBwcm9jZXNzZXMgZmlsZXMgaWYgdGhlcmUgYXJlbid0IHRvbyBtYW55IGFscmVhZHkuXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInByb2Nlc3NRdWV1ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzUXVldWUoKSB7XFxuICAgICAgdmFyIHBhcmFsbGVsVXBsb2FkcyA9IHRoaXMub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHM7XFxuICAgICAgdmFyIHByb2Nlc3NpbmdMZW5ndGggPSB0aGlzLmdldFVwbG9hZGluZ0ZpbGVzKCkubGVuZ3RoO1xcbiAgICAgIHZhciBpID0gcHJvY2Vzc2luZ0xlbmd0aDsgLy8gVGhlcmUgYXJlIGFscmVhZHkgYXQgbGVhc3QgYXMgbWFueSBmaWxlcyB1cGxvYWRpbmcgdGhhbiBzaG91bGQgYmVcXG5cXG4gICAgICBpZiAocHJvY2Vzc2luZ0xlbmd0aCA+PSBwYXJhbGxlbFVwbG9hZHMpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHF1ZXVlZEZpbGVzID0gdGhpcy5nZXRRdWV1ZWRGaWxlcygpO1xcblxcbiAgICAgIGlmICghKHF1ZXVlZEZpbGVzLmxlbmd0aCA+IDApKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTXVsdGlwbGUpIHtcXG4gICAgICAgIC8vIFRoZSBmaWxlcyBzaG91bGQgYmUgdXBsb2FkZWQgaW4gb25lIHJlcXVlc3RcXG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NGaWxlcyhxdWV1ZWRGaWxlcy5zbGljZSgwLCBwYXJhbGxlbFVwbG9hZHMgLSBwcm9jZXNzaW5nTGVuZ3RoKSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHdoaWxlIChpIDwgcGFyYWxsZWxVcGxvYWRzKSB7XFxuICAgICAgICAgIGlmICghcXVldWVkRmlsZXMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9IC8vIE5vdGhpbmcgbGVmdCB0byBwcm9jZXNzXFxuXFxuXFxuICAgICAgICAgIHRoaXMucHJvY2Vzc0ZpbGUocXVldWVkRmlsZXMuc2hpZnQoKSk7XFxuICAgICAgICAgIGkrKztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gLy8gV3JhcHBlciBmb3IgYHByb2Nlc3NGaWxlc2BcXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicHJvY2Vzc0ZpbGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0ZpbGUoZmlsZSkge1xcbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NGaWxlcyhbZmlsZV0pO1xcbiAgICB9IC8vIExvYWRzIHRoZSBmaWxlLCB0aGVuIGNhbGxzIGZpbmlzaGVkTG9hZGluZygpXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInByb2Nlc3NGaWxlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzRmlsZXMoZmlsZXMpIHtcXG4gICAgICB2YXIgX2l0ZXJhdG9yMTAgPSBkcm9wem9uZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGZpbGVzLCB0cnVlKSxcXG4gICAgICAgICAgX3N0ZXAxMDtcXG5cXG4gICAgICB0cnkge1xcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxMC5zKCk7ICEoX3N0ZXAxMCA9IF9pdGVyYXRvcjEwLm4oKSkuZG9uZTspIHtcXG4gICAgICAgICAgdmFyIGZpbGUgPSBfc3RlcDEwLnZhbHVlO1xcbiAgICAgICAgICBmaWxlLnByb2Nlc3NpbmcgPSB0cnVlOyAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxcblxcbiAgICAgICAgICBmaWxlLnN0YXR1cyA9IERyb3B6b25lLlVQTE9BRElORztcXG4gICAgICAgICAgdGhpcy5lbWl0KFxcXCJwcm9jZXNzaW5nXFxcIiwgZmlsZSk7XFxuICAgICAgICB9XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICBfaXRlcmF0b3IxMC5lKGVycik7XFxuICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgIF9pdGVyYXRvcjEwLmYoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkge1xcbiAgICAgICAgdGhpcy5lbWl0KFxcXCJwcm9jZXNzaW5nbXVsdGlwbGVcXFwiLCBmaWxlcyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLnVwbG9hZEZpbGVzKGZpbGVzKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZ2V0RmlsZXNXaXRoWGhyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRGaWxlc1dpdGhYaHIoeGhyKSB7XFxuICAgICAgdmFyIGZpbGVzO1xcbiAgICAgIHJldHVybiBmaWxlcyA9IHRoaXMuZmlsZXMuZmlsdGVyKGZ1bmN0aW9uIChmaWxlKSB7XFxuICAgICAgICByZXR1cm4gZmlsZS54aHIgPT09IHhocjtcXG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcXG4gICAgICAgIHJldHVybiBmaWxlO1xcbiAgICAgIH0pO1xcbiAgICB9IC8vIENhbmNlbHMgdGhlIGZpbGUgdXBsb2FkIGFuZCBzZXRzIHRoZSBzdGF0dXMgdG8gQ0FOQ0VMRURcXG4gICAgLy8gKippZioqIHRoZSBmaWxlIGlzIGFjdHVhbGx5IGJlaW5nIHVwbG9hZGVkLlxcbiAgICAvLyBJZiBpdCdzIHN0aWxsIGluIHRoZSBxdWV1ZSwgdGhlIGZpbGUgaXMgYmVpbmcgcmVtb3ZlZCBmcm9tIGl0IGFuZCB0aGUgc3RhdHVzXFxuICAgIC8vIHNldCB0byBDQU5DRUxFRC5cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY2FuY2VsVXBsb2FkXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbFVwbG9hZChmaWxlKSB7XFxuICAgICAgaWYgKGZpbGUuc3RhdHVzID09PSBEcm9wem9uZS5VUExPQURJTkcpIHtcXG4gICAgICAgIHZhciBncm91cGVkRmlsZXMgPSB0aGlzLl9nZXRGaWxlc1dpdGhYaHIoZmlsZS54aHIpO1xcblxcbiAgICAgICAgdmFyIF9pdGVyYXRvcjExID0gZHJvcHpvbmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihncm91cGVkRmlsZXMsIHRydWUpLFxcbiAgICAgICAgICAgIF9zdGVwMTE7XFxuXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjExLnMoKTsgIShfc3RlcDExID0gX2l0ZXJhdG9yMTEubigpKS5kb25lOykge1xcbiAgICAgICAgICAgIHZhciBncm91cGVkRmlsZSA9IF9zdGVwMTEudmFsdWU7XFxuICAgICAgICAgICAgZ3JvdXBlZEZpbGUuc3RhdHVzID0gRHJvcHpvbmUuQ0FOQ0VMRUQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICBfaXRlcmF0b3IxMS5lKGVycik7XFxuICAgICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgICBfaXRlcmF0b3IxMS5mKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGZpbGUueGhyICE9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICBmaWxlLnhoci5hYm9ydCgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIF9pdGVyYXRvcjEyID0gZHJvcHpvbmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihncm91cGVkRmlsZXMsIHRydWUpLFxcbiAgICAgICAgICAgIF9zdGVwMTI7XFxuXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjEyLnMoKTsgIShfc3RlcDEyID0gX2l0ZXJhdG9yMTIubigpKS5kb25lOykge1xcbiAgICAgICAgICAgIHZhciBfZ3JvdXBlZEZpbGUgPSBfc3RlcDEyLnZhbHVlO1xcbiAgICAgICAgICAgIHRoaXMuZW1pdChcXFwiY2FuY2VsZWRcXFwiLCBfZ3JvdXBlZEZpbGUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgX2l0ZXJhdG9yMTIuZShlcnIpO1xcbiAgICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgICAgX2l0ZXJhdG9yMTIuZigpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkge1xcbiAgICAgICAgICB0aGlzLmVtaXQoXFxcImNhbmNlbGVkbXVsdGlwbGVcXFwiLCBncm91cGVkRmlsZXMpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoZmlsZS5zdGF0dXMgPT09IERyb3B6b25lLkFEREVEIHx8IGZpbGUuc3RhdHVzID09PSBEcm9wem9uZS5RVUVVRUQpIHtcXG4gICAgICAgIGZpbGUuc3RhdHVzID0gRHJvcHpvbmUuQ0FOQ0VMRUQ7XFxuICAgICAgICB0aGlzLmVtaXQoXFxcImNhbmNlbGVkXFxcIiwgZmlsZSk7XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB7XFxuICAgICAgICAgIHRoaXMuZW1pdChcXFwiY2FuY2VsZWRtdWx0aXBsZVxcXCIsIFtmaWxlXSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1Byb2Nlc3NRdWV1ZSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1F1ZXVlKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcInJlc29sdmVPcHRpb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZU9wdGlvbihvcHRpb24pIHtcXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBvcHRpb24uYXBwbHkodGhpcywgYXJncyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvcHRpb247XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidXBsb2FkRmlsZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGxvYWRGaWxlKGZpbGUpIHtcXG4gICAgICByZXR1cm4gdGhpcy51cGxvYWRGaWxlcyhbZmlsZV0pO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcInVwbG9hZEZpbGVzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwbG9hZEZpbGVzKGZpbGVzKSB7XFxuICAgICAgdmFyIF90aGlzMTQgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuX3RyYW5zZm9ybUZpbGVzKGZpbGVzLCBmdW5jdGlvbiAodHJhbnNmb3JtZWRGaWxlcykge1xcbiAgICAgICAgaWYgKF90aGlzMTQub3B0aW9ucy5jaHVua2luZykge1xcbiAgICAgICAgICAvLyBDaHVua2luZyBpcyBub3QgYWxsb3dlZCB0byBiZSB1c2VkIHdpdGggYHVwbG9hZE11bHRpcGxlYCBzbyB3ZSBrbm93XFxuICAgICAgICAgIC8vIHRoYXQgdGhlcmUgaXMgb25seSBfX29uZV9fZmlsZS5cXG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVkRmlsZSA9IHRyYW5zZm9ybWVkRmlsZXNbMF07XFxuICAgICAgICAgIGZpbGVzWzBdLnVwbG9hZC5jaHVua2VkID0gX3RoaXMxNC5vcHRpb25zLmNodW5raW5nICYmIChfdGhpczE0Lm9wdGlvbnMuZm9yY2VDaHVua2luZyB8fCB0cmFuc2Zvcm1lZEZpbGUuc2l6ZSA+IF90aGlzMTQub3B0aW9ucy5jaHVua1NpemUpO1xcbiAgICAgICAgICBmaWxlc1swXS51cGxvYWQudG90YWxDaHVua0NvdW50ID0gTWF0aC5jZWlsKHRyYW5zZm9ybWVkRmlsZS5zaXplIC8gX3RoaXMxNC5vcHRpb25zLmNodW5rU2l6ZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZmlsZXNbMF0udXBsb2FkLmNodW5rZWQpIHtcXG4gICAgICAgICAgLy8gVGhpcyBmaWxlIHNob3VsZCBiZSBzZW50IGluIGNodW5rcyFcXG4gICAgICAgICAgLy8gSWYgdGhlIGNodW5raW5nIG9wdGlvbiBpcyBzZXQsIHdlICoqa25vdyoqIHRoYXQgdGhlcmUgY2FuIG9ubHkgYmUgKipvbmUqKiBmaWxlLCBzaW5jZVxcbiAgICAgICAgICAvLyB1cGxvYWRNdWx0aXBsZSBpcyBub3QgYWxsb3dlZCB3aXRoIHRoaXMgb3B0aW9uLlxcbiAgICAgICAgICB2YXIgZmlsZSA9IGZpbGVzWzBdO1xcbiAgICAgICAgICB2YXIgX3RyYW5zZm9ybWVkRmlsZSA9IHRyYW5zZm9ybWVkRmlsZXNbMF07XFxuICAgICAgICAgIHZhciBzdGFydGVkQ2h1bmtDb3VudCA9IDA7XFxuICAgICAgICAgIGZpbGUudXBsb2FkLmNodW5rcyA9IFtdO1xcblxcbiAgICAgICAgICB2YXIgaGFuZGxlTmV4dENodW5rID0gZnVuY3Rpb24gaGFuZGxlTmV4dENodW5rKCkge1xcbiAgICAgICAgICAgIHZhciBjaHVua0luZGV4ID0gMDsgLy8gRmluZCB0aGUgbmV4dCBpdGVtIGluIGZpbGUudXBsb2FkLmNodW5rcyB0aGF0IGlzIG5vdCBkZWZpbmVkIHlldC5cXG5cXG4gICAgICAgICAgICB3aGlsZSAoZmlsZS51cGxvYWQuY2h1bmtzW2NodW5rSW5kZXhdICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgIGNodW5rSW5kZXgrKztcXG4gICAgICAgICAgICB9IC8vIFRoaXMgbWVhbnMsIHRoYXQgYWxsIGNodW5rcyBoYXZlIGFscmVhZHkgYmVlbiBzdGFydGVkLlxcblxcblxcbiAgICAgICAgICAgIGlmIChjaHVua0luZGV4ID49IGZpbGUudXBsb2FkLnRvdGFsQ2h1bmtDb3VudCkgcmV0dXJuO1xcbiAgICAgICAgICAgIHN0YXJ0ZWRDaHVua0NvdW50Kys7XFxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY2h1bmtJbmRleCAqIF90aGlzMTQub3B0aW9ucy5jaHVua1NpemU7XFxuICAgICAgICAgICAgdmFyIGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgX3RoaXMxNC5vcHRpb25zLmNodW5rU2l6ZSwgX3RyYW5zZm9ybWVkRmlsZS5zaXplKTtcXG4gICAgICAgICAgICB2YXIgZGF0YUJsb2NrID0ge1xcbiAgICAgICAgICAgICAgbmFtZTogX3RoaXMxNC5fZ2V0UGFyYW1OYW1lKDApLFxcbiAgICAgICAgICAgICAgZGF0YTogX3RyYW5zZm9ybWVkRmlsZS53ZWJraXRTbGljZSA/IF90cmFuc2Zvcm1lZEZpbGUud2Via2l0U2xpY2Uoc3RhcnQsIGVuZCkgOiBfdHJhbnNmb3JtZWRGaWxlLnNsaWNlKHN0YXJ0LCBlbmQpLFxcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGUudXBsb2FkLmZpbGVuYW1lLFxcbiAgICAgICAgICAgICAgY2h1bmtJbmRleDogY2h1bmtJbmRleFxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgZmlsZS51cGxvYWQuY2h1bmtzW2NodW5rSW5kZXhdID0ge1xcbiAgICAgICAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgICAgICAgIGluZGV4OiBjaHVua0luZGV4LFxcbiAgICAgICAgICAgICAgZGF0YUJsb2NrOiBkYXRhQmxvY2ssXFxuICAgICAgICAgICAgICAvLyBJbiBjYXNlIHdlIHdhbnQgdG8gcmV0cnkuXFxuICAgICAgICAgICAgICBzdGF0dXM6IERyb3B6b25lLlVQTE9BRElORyxcXG4gICAgICAgICAgICAgIHByb2dyZXNzOiAwLFxcbiAgICAgICAgICAgICAgcmV0cmllczogMCAvLyBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoaXMgYmxvY2sgaGFzIGJlZW4gcmV0cmllZC5cXG5cXG4gICAgICAgICAgICB9O1xcblxcbiAgICAgICAgICAgIF90aGlzMTQuX3VwbG9hZERhdGEoZmlsZXMsIFtkYXRhQmxvY2tdKTtcXG4gICAgICAgICAgfTtcXG5cXG4gICAgICAgICAgZmlsZS51cGxvYWQuZmluaXNoZWRDaHVua1VwbG9hZCA9IGZ1bmN0aW9uIChjaHVuaywgcmVzcG9uc2UpIHtcXG4gICAgICAgICAgICB2YXIgYWxsRmluaXNoZWQgPSB0cnVlO1xcbiAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IERyb3B6b25lLlNVQ0NFU1M7IC8vIENsZWFyIHRoZSBkYXRhIGZyb20gdGhlIGNodW5rXFxuXFxuICAgICAgICAgICAgY2h1bmsuZGF0YUJsb2NrID0gbnVsbDsgLy8gTGVhdmluZyB0aGlzIHJlZmVyZW5jZSB0byB4aHIgaW50YWN0IGhlcmUgd2lsbCBjYXVzZSBtZW1vcnkgbGVha3MgaW4gc29tZSBicm93c2Vyc1xcblxcbiAgICAgICAgICAgIGNodW5rLnhociA9IG51bGw7XFxuXFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlLnVwbG9hZC50b3RhbENodW5rQ291bnQ7IGkrKykge1xcbiAgICAgICAgICAgICAgaWYgKGZpbGUudXBsb2FkLmNodW5rc1tpXSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVOZXh0Q2h1bmsoKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGlmIChmaWxlLnVwbG9hZC5jaHVua3NbaV0uc3RhdHVzICE9PSBEcm9wem9uZS5TVUNDRVNTKSB7XFxuICAgICAgICAgICAgICAgIGFsbEZpbmlzaGVkID0gZmFsc2U7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChhbGxGaW5pc2hlZCkge1xcbiAgICAgICAgICAgICAgX3RoaXMxNC5vcHRpb25zLmNodW5rc1VwbG9hZGVkKGZpbGUsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMxNC5fZmluaXNoZWQoZmlsZXMsIHJlc3BvbnNlLCBudWxsKTtcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfTtcXG5cXG4gICAgICAgICAgaWYgKF90aGlzMTQub3B0aW9ucy5wYXJhbGxlbENodW5rVXBsb2Fkcykge1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZS51cGxvYWQudG90YWxDaHVua0NvdW50OyBpKyspIHtcXG4gICAgICAgICAgICAgIGhhbmRsZU5leHRDaHVuaygpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBoYW5kbGVOZXh0Q2h1bmsoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdmFyIGRhdGFCbG9ja3MgPSBbXTtcXG5cXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZmlsZXMubGVuZ3RoOyBfaTIrKykge1xcbiAgICAgICAgICAgIGRhdGFCbG9ja3NbX2kyXSA9IHtcXG4gICAgICAgICAgICAgIG5hbWU6IF90aGlzMTQuX2dldFBhcmFtTmFtZShfaTIpLFxcbiAgICAgICAgICAgICAgZGF0YTogdHJhbnNmb3JtZWRGaWxlc1tfaTJdLFxcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVzW19pMl0udXBsb2FkLmZpbGVuYW1lXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBfdGhpczE0Ll91cGxvYWREYXRhKGZpbGVzLCBkYXRhQmxvY2tzKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSAvLy8gUmV0dXJucyB0aGUgcmlnaHQgY2h1bmsgZm9yIGdpdmVuIGZpbGUgYW5kIHhoclxcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZ2V0Q2h1bmtcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENodW5rKGZpbGUsIHhocikge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZS51cGxvYWQudG90YWxDaHVua0NvdW50OyBpKyspIHtcXG4gICAgICAgIGlmIChmaWxlLnVwbG9hZC5jaHVua3NbaV0gIT09IHVuZGVmaW5lZCAmJiBmaWxlLnVwbG9hZC5jaHVua3NbaV0ueGhyID09PSB4aHIpIHtcXG4gICAgICAgICAgcmV0dXJuIGZpbGUudXBsb2FkLmNodW5rc1tpXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gLy8gVGhpcyBmdW5jdGlvbiBhY3R1YWxseSB1cGxvYWRzIHRoZSBmaWxlKHMpIHRvIHRoZSBzZXJ2ZXIuXFxuICAgIC8vIElmIGRhdGFCbG9ja3MgY29udGFpbnMgdGhlIGFjdHVhbCBkYXRhIHRvIHVwbG9hZCAobWVhbmluZywgdGhhdCB0aGlzIGNvdWxkIGVpdGhlciBiZSB0cmFuc2Zvcm1lZFxcbiAgICAvLyBmaWxlcywgb3IgaW5kaXZpZHVhbCBjaHVua3MgZm9yIGNodW5rZWQgdXBsb2FkKS5cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX3VwbG9hZERhdGFcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwbG9hZERhdGEoZmlsZXMsIGRhdGFCbG9ja3MpIHtcXG4gICAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XFxuXFxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOyAvLyBQdXQgdGhlIHhociBvYmplY3QgaW4gdGhlIGZpbGUgb2JqZWN0cyB0byBiZSBhYmxlIHRvIHJlZmVyZW5jZSBpdCBsYXRlci5cXG5cXG4gICAgICB2YXIgX2l0ZXJhdG9yMTMgPSBkcm9wem9uZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGZpbGVzLCB0cnVlKSxcXG4gICAgICAgICAgX3N0ZXAxMztcXG5cXG4gICAgICB0cnkge1xcbiAgICAgICAgZm9yIChfaXRlcmF0b3IxMy5zKCk7ICEoX3N0ZXAxMyA9IF9pdGVyYXRvcjEzLm4oKSkuZG9uZTspIHtcXG4gICAgICAgICAgdmFyIGZpbGUgPSBfc3RlcDEzLnZhbHVlO1xcbiAgICAgICAgICBmaWxlLnhociA9IHhocjtcXG4gICAgICAgIH1cXG4gICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgIF9pdGVyYXRvcjEzLmUoZXJyKTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgX2l0ZXJhdG9yMTMuZigpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZmlsZXNbMF0udXBsb2FkLmNodW5rZWQpIHtcXG4gICAgICAgIC8vIFB1dCB0aGUgeGhyIG9iamVjdCBpbiB0aGUgcmlnaHQgY2h1bmsgb2JqZWN0LCBzbyBpdCBjYW4gYmUgYXNzb2NpYXRlZCBsYXRlciwgYW5kIGZvdW5kIHdpdGggX2dldENodW5rXFxuICAgICAgICBmaWxlc1swXS51cGxvYWQuY2h1bmtzW2RhdGFCbG9ja3NbMF0uY2h1bmtJbmRleF0ueGhyID0geGhyO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbWV0aG9kID0gdGhpcy5yZXNvbHZlT3B0aW9uKHRoaXMub3B0aW9ucy5tZXRob2QsIGZpbGVzKTtcXG4gICAgICB2YXIgdXJsID0gdGhpcy5yZXNvbHZlT3B0aW9uKHRoaXMub3B0aW9ucy51cmwsIGZpbGVzKTtcXG4gICAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7IC8vIFNldHRpbmcgdGhlIHRpbWVvdXQgYWZ0ZXIgb3BlbiBiZWNhdXNlIG9mIElFMTEgaXNzdWU6IGh0dHBzOi8vZ2l0bGFiLmNvbS9tZW5vL2Ryb3B6b25lL2lzc3Vlcy84XFxuXFxuICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLnJlc29sdmVPcHRpb24odGhpcy5vcHRpb25zLnRpbWVvdXQsIGZpbGVzKTtcXG4gICAgICBpZiAodGltZW91dCkgeGhyLnRpbWVvdXQgPSB0aGlzLnJlc29sdmVPcHRpb24odGhpcy5vcHRpb25zLnRpbWVvdXQsIGZpbGVzKTsgLy8gSGFzIHRvIGJlIGFmdGVyIGAub3BlbigpYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbnlvL2Ryb3B6b25lL2lzc3Vlcy8xNzlcXG5cXG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISF0aGlzLm9wdGlvbnMud2l0aENyZWRlbnRpYWxzO1xcblxcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgX3RoaXMxNS5fZmluaXNoZWRVcGxvYWRpbmcoZmlsZXMsIHhociwgZSk7XFxuICAgICAgfTtcXG5cXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgX3RoaXMxNS5faGFuZGxlVXBsb2FkRXJyb3IoZmlsZXMsIHhociwgXFxcIlJlcXVlc3QgdGltZWRvdXQgYWZ0ZXIgXFxcIi5jb25jYXQoX3RoaXMxNS5vcHRpb25zLnRpbWVvdXQgLyAxMDAwLCBcXFwiIHNlY29uZHNcXFwiKSk7XFxuICAgICAgfTtcXG5cXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF90aGlzMTUuX2hhbmRsZVVwbG9hZEVycm9yKGZpbGVzLCB4aHIpO1xcbiAgICAgIH07IC8vIFNvbWUgYnJvd3NlcnMgZG8gbm90IGhhdmUgdGhlIC51cGxvYWQgcHJvcGVydHlcXG5cXG5cXG4gICAgICB2YXIgcHJvZ3Jlc3NPYmogPSB4aHIudXBsb2FkICE9IG51bGwgPyB4aHIudXBsb2FkIDogeGhyO1xcblxcbiAgICAgIHByb2dyZXNzT2JqLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgcmV0dXJuIF90aGlzMTUuX3VwZGF0ZUZpbGVzVXBsb2FkUHJvZ3Jlc3MoZmlsZXMsIHhociwgZSk7XFxuICAgICAgfTtcXG5cXG4gICAgICB2YXIgaGVhZGVycyA9IHtcXG4gICAgICAgIEFjY2VwdDogXFxcImFwcGxpY2F0aW9uL2pzb25cXFwiLFxcbiAgICAgICAgXFxcIkNhY2hlLUNvbnRyb2xcXFwiOiBcXFwibm8tY2FjaGVcXFwiLFxcbiAgICAgICAgXFxcIlgtUmVxdWVzdGVkLVdpdGhcXFwiOiBcXFwiWE1MSHR0cFJlcXVlc3RcXFwiXFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcnMpIHtcXG4gICAgICAgIERyb3B6b25lLmV4dGVuZChoZWFkZXJzLCB0aGlzLm9wdGlvbnMuaGVhZGVycyk7XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAodmFyIGhlYWRlck5hbWUgaW4gaGVhZGVycykge1xcbiAgICAgICAgdmFyIGhlYWRlclZhbHVlID0gaGVhZGVyc1toZWFkZXJOYW1lXTtcXG5cXG4gICAgICAgIGlmIChoZWFkZXJWYWx1ZSkge1xcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpOyAvLyBBZGRpbmcgYWxsIEBvcHRpb25zIHBhcmFtZXRlcnNcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmFtcykge1xcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxQYXJhbXMgPSB0aGlzLm9wdGlvbnMucGFyYW1zO1xcblxcbiAgICAgICAgaWYgKHR5cGVvZiBhZGRpdGlvbmFsUGFyYW1zID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgICAgIGFkZGl0aW9uYWxQYXJhbXMgPSBhZGRpdGlvbmFsUGFyYW1zLmNhbGwodGhpcywgZmlsZXMsIHhociwgZmlsZXNbMF0udXBsb2FkLmNodW5rZWQgPyB0aGlzLl9nZXRDaHVuayhmaWxlc1swXSwgeGhyKSA6IG51bGwpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGFkZGl0aW9uYWxQYXJhbXMpIHtcXG4gICAgICAgICAgdmFyIHZhbHVlID0gYWRkaXRpb25hbFBhcmFtc1trZXldO1xcblxcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgICAgICAgICAvLyBUaGUgYWRkaXRpb25hbCBwYXJhbWV0ZXIgY29udGFpbnMgYW4gYXJyYXksXFxuICAgICAgICAgICAgLy8gc28gbGV0cyBpdGVyYXRlIG92ZXIgaXQgdG8gYXR0YWNoIGVhY2ggdmFsdWVcXG4gICAgICAgICAgICAvLyBpbmRpdmlkdWFsbHkuXFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsdWVbaV0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IC8vIExldCB0aGUgdXNlciBhZGQgYWRkaXRpb25hbCBkYXRhIGlmIG5lY2Vzc2FyeVxcblxcblxcbiAgICAgIHZhciBfaXRlcmF0b3IxNCA9IGRyb3B6b25lX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZmlsZXMsIHRydWUpLFxcbiAgICAgICAgICBfc3RlcDE0O1xcblxcbiAgICAgIHRyeSB7XFxuICAgICAgICBmb3IgKF9pdGVyYXRvcjE0LnMoKTsgIShfc3RlcDE0ID0gX2l0ZXJhdG9yMTQubigpKS5kb25lOykge1xcbiAgICAgICAgICB2YXIgX2ZpbGUgPSBfc3RlcDE0LnZhbHVlO1xcbiAgICAgICAgICB0aGlzLmVtaXQoXFxcInNlbmRpbmdcXFwiLCBfZmlsZSwgeGhyLCBmb3JtRGF0YSk7XFxuICAgICAgICB9XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICBfaXRlcmF0b3IxNC5lKGVycik7XFxuICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgIF9pdGVyYXRvcjE0LmYoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkge1xcbiAgICAgICAgdGhpcy5lbWl0KFxcXCJzZW5kaW5nbXVsdGlwbGVcXFwiLCBmaWxlcywgeGhyLCBmb3JtRGF0YSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2FkZEZvcm1FbGVtZW50RGF0YShmb3JtRGF0YSk7IC8vIEZpbmFsbHkgYWRkIHRoZSBmaWxlc1xcbiAgICAgIC8vIEhhcyB0byBiZSBsYXN0IGJlY2F1c2Ugc29tZSBzZXJ2ZXJzIChlZzogUzMpIGV4cGVjdCB0aGUgZmlsZSB0byBiZSB0aGUgbGFzdCBwYXJhbWV0ZXJcXG5cXG5cXG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBkYXRhQmxvY2tzLmxlbmd0aDsgX2kzKyspIHtcXG4gICAgICAgIHZhciBkYXRhQmxvY2sgPSBkYXRhQmxvY2tzW19pM107XFxuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoZGF0YUJsb2NrLm5hbWUsIGRhdGFCbG9jay5kYXRhLCBkYXRhQmxvY2suZmlsZW5hbWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnN1Ym1pdFJlcXVlc3QoeGhyLCBmb3JtRGF0YSwgZmlsZXMpO1xcbiAgICB9IC8vIFRyYW5zZm9ybXMgYWxsIGZpbGVzIHdpdGggdGhpcy5vcHRpb25zLnRyYW5zZm9ybUZpbGUgYW5kIGludm9rZXMgZG9uZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBmaWxlcyB3aGVuIGRvbmUuXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl90cmFuc2Zvcm1GaWxlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJhbnNmb3JtRmlsZXMoZmlsZXMsIGRvbmUpIHtcXG4gICAgICB2YXIgX3RoaXMxNiA9IHRoaXM7XFxuXFxuICAgICAgdmFyIHRyYW5zZm9ybWVkRmlsZXMgPSBbXTsgLy8gQ2x1bXN5IHdheSBvZiBoYW5kbGluZyBhc3luY2hyb25vdXMgY2FsbHMsIHVudGlsIEkgZ2V0IHRvIGFkZCBhIHByb3BlciBGdXR1cmUgbGlicmFyeS5cXG5cXG4gICAgICB2YXIgZG9uZUNvdW50ZXIgPSAwO1xcblxcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcXG4gICAgICAgIF90aGlzMTYub3B0aW9ucy50cmFuc2Zvcm1GaWxlLmNhbGwoX3RoaXMxNiwgZmlsZXNbaV0sIGZ1bmN0aW9uICh0cmFuc2Zvcm1lZEZpbGUpIHtcXG4gICAgICAgICAgdHJhbnNmb3JtZWRGaWxlc1tpXSA9IHRyYW5zZm9ybWVkRmlsZTtcXG5cXG4gICAgICAgICAgaWYgKCsrZG9uZUNvdW50ZXIgPT09IGZpbGVzLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGRvbmUodHJhbnNmb3JtZWRGaWxlcyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH07XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgX2xvb3AoaSk7XFxuICAgICAgfVxcbiAgICB9IC8vIFRha2VzIGNhcmUgb2YgYWRkaW5nIG90aGVyIGlucHV0IGVsZW1lbnRzIG9mIHRoZSBmb3JtIHRvIHRoZSBBSkFYIHJlcXVlc3RcXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2FkZEZvcm1FbGVtZW50RGF0YVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkRm9ybUVsZW1lbnREYXRhKGZvcm1EYXRhKSB7XFxuICAgICAgLy8gVGFrZSBjYXJlIG9mIG90aGVyIGlucHV0IGVsZW1lbnRzXFxuICAgICAgaWYgKHRoaXMuZWxlbWVudC50YWdOYW1lID09PSBcXFwiRk9STVxcXCIpIHtcXG4gICAgICAgIHZhciBfaXRlcmF0b3IxNSA9IGRyb3B6b25lX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImlucHV0LCB0ZXh0YXJlYSwgc2VsZWN0LCBidXR0b25cXFwiKSwgdHJ1ZSksXFxuICAgICAgICAgICAgX3N0ZXAxNTtcXG5cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMTUucygpOyAhKF9zdGVwMTUgPSBfaXRlcmF0b3IxNS5uKCkpLmRvbmU7KSB7XFxuICAgICAgICAgICAgdmFyIGlucHV0ID0gX3N0ZXAxNS52YWx1ZTtcXG4gICAgICAgICAgICB2YXIgaW5wdXROYW1lID0gaW5wdXQuZ2V0QXR0cmlidXRlKFxcXCJuYW1lXFxcIik7XFxuICAgICAgICAgICAgdmFyIGlucHV0VHlwZSA9IGlucHV0LmdldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIpO1xcbiAgICAgICAgICAgIGlmIChpbnB1dFR5cGUpIGlucHV0VHlwZSA9IGlucHV0VHlwZS50b0xvd2VyQ2FzZSgpOyAvLyBJZiB0aGUgaW5wdXQgZG9lc24ndCBoYXZlIGEgbmFtZSwgd2UgY2FuJ3QgdXNlIGl0LlxcblxcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXROYW1lID09PSBcXFwidW5kZWZpbmVkXFxcIiB8fCBpbnB1dE5hbWUgPT09IG51bGwpIGNvbnRpbnVlO1xcblxcbiAgICAgICAgICAgIGlmIChpbnB1dC50YWdOYW1lID09PSBcXFwiU0VMRUNUXFxcIiAmJiBpbnB1dC5oYXNBdHRyaWJ1dGUoXFxcIm11bHRpcGxlXFxcIikpIHtcXG4gICAgICAgICAgICAgIC8vIFBvc3NpYmx5IG11bHRpcGxlIHZhbHVlc1xcbiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjE2ID0gZHJvcHpvbmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpbnB1dC5vcHRpb25zLCB0cnVlKSxcXG4gICAgICAgICAgICAgICAgICBfc3RlcDE2O1xcblxcbiAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IxNi5zKCk7ICEoX3N0ZXAxNiA9IF9pdGVyYXRvcjE2Lm4oKSkuZG9uZTspIHtcXG4gICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gX3N0ZXAxNi52YWx1ZTtcXG5cXG4gICAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XFxuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoaW5wdXROYW1lLCBvcHRpb24udmFsdWUpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjE2LmUoZXJyKTtcXG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjE2LmYoKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpbnB1dFR5cGUgfHwgaW5wdXRUeXBlICE9PSBcXFwiY2hlY2tib3hcXFwiICYmIGlucHV0VHlwZSAhPT0gXFxcInJhZGlvXFxcIiB8fCBpbnB1dC5jaGVja2VkKSB7XFxuICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoaW5wdXROYW1lLCBpbnB1dC52YWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgX2l0ZXJhdG9yMTUuZShlcnIpO1xcbiAgICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgICAgX2l0ZXJhdG9yMTUuZigpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSAvLyBJbnZva2VkIHdoZW4gdGhlcmUgaXMgbmV3IHByb2dyZXNzIGluZm9ybWF0aW9uIGFib3V0IGdpdmVuIGZpbGVzLlxcbiAgICAvLyBJZiBlIGlzIG5vdCBwcm92aWRlZCwgaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB1cGxvYWQgaXMgZmluaXNoZWQuXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl91cGRhdGVGaWxlc1VwbG9hZFByb2dyZXNzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVGaWxlc1VwbG9hZFByb2dyZXNzKGZpbGVzLCB4aHIsIGUpIHtcXG4gICAgICBpZiAoIWZpbGVzWzBdLnVwbG9hZC5jaHVua2VkKSB7XFxuICAgICAgICAvLyBIYW5kbGUgZmlsZSB1cGxvYWRzIHdpdGhvdXQgY2h1bmtpbmdcXG4gICAgICAgIHZhciBfaXRlcmF0b3IxNyA9IGRyb3B6b25lX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZmlsZXMsIHRydWUpLFxcbiAgICAgICAgICAgIF9zdGVwMTc7XFxuXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjE3LnMoKTsgIShfc3RlcDE3ID0gX2l0ZXJhdG9yMTcubigpKS5kb25lOykge1xcbiAgICAgICAgICAgIHZhciBmaWxlID0gX3N0ZXAxNy52YWx1ZTtcXG5cXG4gICAgICAgICAgICBpZiAoZmlsZS51cGxvYWQudG90YWwgJiYgZmlsZS51cGxvYWQuYnl0ZXNTZW50ICYmIGZpbGUudXBsb2FkLmJ5dGVzU2VudCA9PSBmaWxlLnVwbG9hZC50b3RhbCkge1xcbiAgICAgICAgICAgICAgLy8gSWYgYm90aCwgdGhlIGB0b3RhbGAgYW5kIGBieXRlc1NlbnRgIGhhdmUgYWxyZWFkeSBiZWVuIHNldCwgYW5kXFxuICAgICAgICAgICAgICAvLyB0aGV5IGFyZSBlcXVhbCAobWVhbmluZyBwcm9ncmVzcyBpcyBhdCAxMDAlKSwgd2UgY2FuIHNraXAgdGhpc1xcbiAgICAgICAgICAgICAgLy8gZmlsZSwgc2luY2UgYW4gdXBsb2FkIHByb2dyZXNzIHNob3VsZG4ndCBnbyBkb3duLlxcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChlKSB7XFxuICAgICAgICAgICAgICBmaWxlLnVwbG9hZC5wcm9ncmVzcyA9IDEwMCAqIGUubG9hZGVkIC8gZS50b3RhbDtcXG4gICAgICAgICAgICAgIGZpbGUudXBsb2FkLnRvdGFsID0gZS50b3RhbDtcXG4gICAgICAgICAgICAgIGZpbGUudXBsb2FkLmJ5dGVzU2VudCA9IGUubG9hZGVkO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAvLyBObyBldmVudCwgc28gd2UncmUgYXQgMTAwJVxcbiAgICAgICAgICAgICAgZmlsZS51cGxvYWQucHJvZ3Jlc3MgPSAxMDA7XFxuICAgICAgICAgICAgICBmaWxlLnVwbG9hZC5ieXRlc1NlbnQgPSBmaWxlLnVwbG9hZC50b3RhbDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy5lbWl0KFxcXCJ1cGxvYWRwcm9ncmVzc1xcXCIsIGZpbGUsIGZpbGUudXBsb2FkLnByb2dyZXNzLCBmaWxlLnVwbG9hZC5ieXRlc1NlbnQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgX2l0ZXJhdG9yMTcuZShlcnIpO1xcbiAgICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgICAgX2l0ZXJhdG9yMTcuZigpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyBIYW5kbGUgY2h1bmtlZCBmaWxlIHVwbG9hZHNcXG4gICAgICAgIC8vIENodW5rZWQgdXBsb2FkIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdXBsb2FkaW5nIG11bHRpcGxlIGZpbGVzIGluIG9uZVxcbiAgICAgICAgLy8gcmVxdWVzdCwgc28gd2Uga25vdyB0aGVyZSdzIG9ubHkgb25lIGZpbGUuXFxuICAgICAgICB2YXIgX2ZpbGUyID0gZmlsZXNbMF07IC8vIFNpbmNlIHRoaXMgaXMgYSBjaHVua2VkIHVwbG9hZCwgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGFwcHJvcHJpYXRlIGNodW5rXFxuICAgICAgICAvLyBwcm9ncmVzcy5cXG5cXG4gICAgICAgIHZhciBjaHVuayA9IHRoaXMuX2dldENodW5rKF9maWxlMiwgeGhyKTtcXG5cXG4gICAgICAgIGlmIChlKSB7XFxuICAgICAgICAgIGNodW5rLnByb2dyZXNzID0gMTAwICogZS5sb2FkZWQgLyBlLnRvdGFsO1xcbiAgICAgICAgICBjaHVuay50b3RhbCA9IGUudG90YWw7XFxuICAgICAgICAgIGNodW5rLmJ5dGVzU2VudCA9IGUubG9hZGVkO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gTm8gZXZlbnQsIHNvIHdlJ3JlIGF0IDEwMCVcXG4gICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSAxMDA7XFxuICAgICAgICAgIGNodW5rLmJ5dGVzU2VudCA9IGNodW5rLnRvdGFsO1xcbiAgICAgICAgfSAvLyBOb3cgdGFsbHkgdGhlICpmaWxlKiB1cGxvYWQgcHJvZ3Jlc3MgZnJvbSBpdHMgaW5kaXZpZHVhbCBjaHVua3NcXG5cXG5cXG4gICAgICAgIF9maWxlMi51cGxvYWQucHJvZ3Jlc3MgPSAwO1xcbiAgICAgICAgX2ZpbGUyLnVwbG9hZC50b3RhbCA9IDA7XFxuICAgICAgICBfZmlsZTIudXBsb2FkLmJ5dGVzU2VudCA9IDA7XFxuXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9maWxlMi51cGxvYWQudG90YWxDaHVua0NvdW50OyBpKyspIHtcXG4gICAgICAgICAgaWYgKF9maWxlMi51cGxvYWQuY2h1bmtzW2ldICYmIHR5cGVvZiBfZmlsZTIudXBsb2FkLmNodW5rc1tpXS5wcm9ncmVzcyAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICBfZmlsZTIudXBsb2FkLnByb2dyZXNzICs9IF9maWxlMi51cGxvYWQuY2h1bmtzW2ldLnByb2dyZXNzO1xcbiAgICAgICAgICAgIF9maWxlMi51cGxvYWQudG90YWwgKz0gX2ZpbGUyLnVwbG9hZC5jaHVua3NbaV0udG90YWw7XFxuICAgICAgICAgICAgX2ZpbGUyLnVwbG9hZC5ieXRlc1NlbnQgKz0gX2ZpbGUyLnVwbG9hZC5jaHVua3NbaV0uYnl0ZXNTZW50O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IC8vIFNpbmNlIHRoZSBwcm9jZXNzIGlzIGEgcGVyY2VudGFnZSwgd2UgbmVlZCB0byBkaXZpZGUgYnkgdGhlIGFtb3VudCBvZlxcbiAgICAgICAgLy8gY2h1bmtzIHdlJ3ZlIHVzZWQuXFxuXFxuXFxuICAgICAgICBfZmlsZTIudXBsb2FkLnByb2dyZXNzID0gX2ZpbGUyLnVwbG9hZC5wcm9ncmVzcyAvIF9maWxlMi51cGxvYWQudG90YWxDaHVua0NvdW50O1xcbiAgICAgICAgdGhpcy5lbWl0KFxcXCJ1cGxvYWRwcm9ncmVzc1xcXCIsIF9maWxlMiwgX2ZpbGUyLnVwbG9hZC5wcm9ncmVzcywgX2ZpbGUyLnVwbG9hZC5ieXRlc1NlbnQpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJfZmluaXNoZWRVcGxvYWRpbmdcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmlzaGVkVXBsb2FkaW5nKGZpbGVzLCB4aHIsIGUpIHtcXG4gICAgICB2YXIgcmVzcG9uc2U7XFxuXFxuICAgICAgaWYgKGZpbGVzWzBdLnN0YXR1cyA9PT0gRHJvcHpvbmUuQ0FOQ0VMRUQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh4aHIucmVzcG9uc2VUeXBlICE9PSBcXFwiYXJyYXlidWZmZXJcXFwiICYmIHhoci5yZXNwb25zZVR5cGUgIT09IFxcXCJibG9iXFxcIikge1xcbiAgICAgICAgcmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUZXh0O1xcblxcbiAgICAgICAgaWYgKHhoci5nZXRSZXNwb25zZUhlYWRlcihcXFwiY29udGVudC10eXBlXFxcIikgJiYgfnhoci5nZXRSZXNwb25zZUhlYWRlcihcXFwiY29udGVudC10eXBlXFxcIikuaW5kZXhPZihcXFwiYXBwbGljYXRpb24vanNvblxcXCIpKSB7XFxuICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3BvbnNlKTtcXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgICAgICAgICBlID0gZXJyb3I7XFxuICAgICAgICAgICAgcmVzcG9uc2UgPSBcXFwiSW52YWxpZCBKU09OIHJlc3BvbnNlIGZyb20gc2VydmVyLlxcXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fdXBkYXRlRmlsZXNVcGxvYWRQcm9ncmVzcyhmaWxlcywgeGhyKTtcXG5cXG4gICAgICBpZiAoISgyMDAgPD0geGhyLnN0YXR1cyAmJiB4aHIuc3RhdHVzIDwgMzAwKSkge1xcbiAgICAgICAgdGhpcy5faGFuZGxlVXBsb2FkRXJyb3IoZmlsZXMsIHhociwgcmVzcG9uc2UpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoZmlsZXNbMF0udXBsb2FkLmNodW5rZWQpIHtcXG4gICAgICAgICAgZmlsZXNbMF0udXBsb2FkLmZpbmlzaGVkQ2h1bmtVcGxvYWQodGhpcy5fZ2V0Q2h1bmsoZmlsZXNbMF0sIHhociksIHJlc3BvbnNlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkKGZpbGVzLCByZXNwb25zZSwgZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9oYW5kbGVVcGxvYWRFcnJvclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVXBsb2FkRXJyb3IoZmlsZXMsIHhociwgcmVzcG9uc2UpIHtcXG4gICAgICBpZiAoZmlsZXNbMF0uc3RhdHVzID09PSBEcm9wem9uZS5DQU5DRUxFRCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZmlsZXNbMF0udXBsb2FkLmNodW5rZWQgJiYgdGhpcy5vcHRpb25zLnJldHJ5Q2h1bmtzKSB7XFxuICAgICAgICB2YXIgY2h1bmsgPSB0aGlzLl9nZXRDaHVuayhmaWxlc1swXSwgeGhyKTtcXG5cXG4gICAgICAgIGlmIChjaHVuay5yZXRyaWVzKysgPCB0aGlzLm9wdGlvbnMucmV0cnlDaHVua3NMaW1pdCkge1xcbiAgICAgICAgICB0aGlzLl91cGxvYWREYXRhKGZpbGVzLCBbY2h1bmsuZGF0YUJsb2NrXSk7XFxuXFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGNvbnNvbGUud2FybihcXFwiUmV0cmllZCB0aGlzIGNodW5rIHRvbyBvZnRlbi4gR2l2aW5nIHVwLlxcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9lcnJvclByb2Nlc3NpbmcoZmlsZXMsIHJlc3BvbnNlIHx8IHRoaXMub3B0aW9ucy5kaWN0UmVzcG9uc2VFcnJvci5yZXBsYWNlKFxcXCJ7e3N0YXR1c0NvZGV9fVxcXCIsIHhoci5zdGF0dXMpLCB4aHIpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcInN1Ym1pdFJlcXVlc3RcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VibWl0UmVxdWVzdCh4aHIsIGZvcm1EYXRhLCBmaWxlcykge1xcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPSAxKSB7XFxuICAgICAgICBjb25zb2xlLndhcm4oXFxcIkNhbm5vdCBzZW5kIHRoaXMgcmVxdWVzdCBiZWNhdXNlIHRoZSBYTUxIdHRwUmVxdWVzdC5yZWFkeVN0YXRlIGlzIG5vdCBPUEVORUQuXFxcIik7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHhoci5zZW5kKGZvcm1EYXRhKTtcXG4gICAgfSAvLyBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHByb2Nlc3NpbmcgaXMgZmluaXNoZWQuXFxuICAgIC8vIEluZGl2aWR1YWwgY2FsbGJhY2tzIGhhdmUgdG8gYmUgY2FsbGVkIGluIHRoZSBhcHByb3ByaWF0ZSBzZWN0aW9ucy5cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiX2ZpbmlzaGVkXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5pc2hlZChmaWxlcywgcmVzcG9uc2VUZXh0LCBlKSB7XFxuICAgICAgdmFyIF9pdGVyYXRvcjE4ID0gZHJvcHpvbmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihmaWxlcywgdHJ1ZSksXFxuICAgICAgICAgIF9zdGVwMTg7XFxuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTgucygpOyAhKF9zdGVwMTggPSBfaXRlcmF0b3IxOC5uKCkpLmRvbmU7KSB7XFxuICAgICAgICAgIHZhciBmaWxlID0gX3N0ZXAxOC52YWx1ZTtcXG4gICAgICAgICAgZmlsZS5zdGF0dXMgPSBEcm9wem9uZS5TVUNDRVNTO1xcbiAgICAgICAgICB0aGlzLmVtaXQoXFxcInN1Y2Nlc3NcXFwiLCBmaWxlLCByZXNwb25zZVRleHQsIGUpO1xcbiAgICAgICAgICB0aGlzLmVtaXQoXFxcImNvbXBsZXRlXFxcIiwgZmlsZSk7XFxuICAgICAgICB9XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICBfaXRlcmF0b3IxOC5lKGVycik7XFxuICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgIF9pdGVyYXRvcjE4LmYoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRNdWx0aXBsZSkge1xcbiAgICAgICAgdGhpcy5lbWl0KFxcXCJzdWNjZXNzbXVsdGlwbGVcXFwiLCBmaWxlcywgcmVzcG9uc2VUZXh0LCBlKTtcXG4gICAgICAgIHRoaXMuZW1pdChcXFwiY29tcGxldGVtdWx0aXBsZVxcXCIsIGZpbGVzKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUHJvY2Vzc1F1ZXVlKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUXVldWUoKTtcXG4gICAgICB9XFxuICAgIH0gLy8gQ2FsbGVkIGludGVybmFsbHkgd2hlbiBwcm9jZXNzaW5nIGlzIGZpbmlzaGVkLlxcbiAgICAvLyBJbmRpdmlkdWFsIGNhbGxiYWNrcyBoYXZlIHRvIGJlIGNhbGxlZCBpbiB0aGUgYXBwcm9wcmlhdGUgc2VjdGlvbnMuXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIl9lcnJvclByb2Nlc3NpbmdcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Vycm9yUHJvY2Vzc2luZyhmaWxlcywgbWVzc2FnZSwgeGhyKSB7XFxuICAgICAgdmFyIF9pdGVyYXRvcjE5ID0gZHJvcHpvbmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihmaWxlcywgdHJ1ZSksXFxuICAgICAgICAgIF9zdGVwMTk7XFxuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTkucygpOyAhKF9zdGVwMTkgPSBfaXRlcmF0b3IxOS5uKCkpLmRvbmU7KSB7XFxuICAgICAgICAgIHZhciBmaWxlID0gX3N0ZXAxOS52YWx1ZTtcXG4gICAgICAgICAgZmlsZS5zdGF0dXMgPSBEcm9wem9uZS5FUlJPUjtcXG4gICAgICAgICAgdGhpcy5lbWl0KFxcXCJlcnJvclxcXCIsIGZpbGUsIG1lc3NhZ2UsIHhocik7XFxuICAgICAgICAgIHRoaXMuZW1pdChcXFwiY29tcGxldGVcXFwiLCBmaWxlKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgIF9pdGVyYXRvcjE5LmUoZXJyKTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgX2l0ZXJhdG9yMTkuZigpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZE11bHRpcGxlKSB7XFxuICAgICAgICB0aGlzLmVtaXQoXFxcImVycm9ybXVsdGlwbGVcXFwiLCBmaWxlcywgbWVzc2FnZSwgeGhyKTtcXG4gICAgICAgIHRoaXMuZW1pdChcXFwiY29tcGxldGVtdWx0aXBsZVxcXCIsIGZpbGVzKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUHJvY2Vzc1F1ZXVlKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUXVldWUoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1dLCBbe1xcbiAgICBrZXk6IFxcXCJpbml0Q2xhc3NcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdENsYXNzKCkge1xcbiAgICAgIC8vIEV4cG9zaW5nIHRoZSBlbWl0dGVyIGNsYXNzLCBtYWlubHkgZm9yIHRlc3RzXFxuICAgICAgdGhpcy5wcm90b3R5cGUuRW1pdHRlciA9IEVtaXR0ZXI7XFxuICAgICAgLypcXG4gICAgICAgVGhpcyBpcyBhIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSBldmVudHMgeW91IGNhbiByZWdpc3RlciBvbiBhIGRyb3B6b25lIG9iamVjdC5cXG4gICAgICAgIFlvdSBjYW4gcmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlciBsaWtlIHRoaXM6XFxuICAgICAgICBkcm9wem9uZS5vbihcXFwiZHJhZ0VudGVyXFxcIiwgZnVuY3Rpb24oKSB7IH0pO1xcbiAgICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnByb3RvdHlwZS5ldmVudHMgPSBbXFxcImRyb3BcXFwiLCBcXFwiZHJhZ3N0YXJ0XFxcIiwgXFxcImRyYWdlbmRcXFwiLCBcXFwiZHJhZ2VudGVyXFxcIiwgXFxcImRyYWdvdmVyXFxcIiwgXFxcImRyYWdsZWF2ZVxcXCIsIFxcXCJhZGRlZGZpbGVcXFwiLCBcXFwiYWRkZWRmaWxlc1xcXCIsIFxcXCJyZW1vdmVkZmlsZVxcXCIsIFxcXCJ0aHVtYm5haWxcXFwiLCBcXFwiZXJyb3JcXFwiLCBcXFwiZXJyb3JtdWx0aXBsZVxcXCIsIFxcXCJwcm9jZXNzaW5nXFxcIiwgXFxcInByb2Nlc3NpbmdtdWx0aXBsZVxcXCIsIFxcXCJ1cGxvYWRwcm9ncmVzc1xcXCIsIFxcXCJ0b3RhbHVwbG9hZHByb2dyZXNzXFxcIiwgXFxcInNlbmRpbmdcXFwiLCBcXFwic2VuZGluZ211bHRpcGxlXFxcIiwgXFxcInN1Y2Nlc3NcXFwiLCBcXFwic3VjY2Vzc211bHRpcGxlXFxcIiwgXFxcImNhbmNlbGVkXFxcIiwgXFxcImNhbmNlbGVkbXVsdGlwbGVcXFwiLCBcXFwiY29tcGxldGVcXFwiLCBcXFwiY29tcGxldGVtdWx0aXBsZVxcXCIsIFxcXCJyZXNldFxcXCIsIFxcXCJtYXhmaWxlc2V4Y2VlZGVkXFxcIiwgXFxcIm1heGZpbGVzcmVhY2hlZFxcXCIsIFxcXCJxdWV1ZWNvbXBsZXRlXFxcIl07XFxuICAgICAgdGhpcy5wcm90b3R5cGUuX3RodW1ibmFpbFF1ZXVlID0gW107XFxuICAgICAgdGhpcy5wcm90b3R5cGUuX3Byb2Nlc3NpbmdUaHVtYm5haWwgPSBmYWxzZTtcXG4gICAgfSAvLyBnbG9iYWwgdXRpbGl0eVxcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJleHRlbmRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCkge1xcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgb2JqZWN0cyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XFxuICAgICAgICBvYmplY3RzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKHZhciBfaTQgPSAwLCBfb2JqZWN0cyA9IG9iamVjdHM7IF9pNCA8IF9vYmplY3RzLmxlbmd0aDsgX2k0KyspIHtcXG4gICAgICAgIHZhciBvYmplY3QgPSBfb2JqZWN0c1tfaTRdO1xcblxcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xcbiAgICAgICAgICB2YXIgdmFsID0gb2JqZWN0W2tleV07XFxuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGFyZ2V0O1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcInV1aWR2NFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1dWlkdjQoKSB7XFxuICAgICAgcmV0dXJuIFxcXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcXFwiLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCxcXG4gICAgICAgICAgICB2ID0gYyA9PT0gXFxcInhcXFwiID8gciA6IHIgJiAweDMgfCAweDg7XFxuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBEcm9wem9uZTtcXG59KEVtaXR0ZXIpO1xcblxcblxcbkRyb3B6b25lLmluaXRDbGFzcygpO1xcbkRyb3B6b25lLnZlcnNpb24gPSBcXFwiNS45LjJcXFwiOyAvLyBUaGlzIGlzIGEgbWFwIG9mIG9wdGlvbnMgZm9yIHlvdXIgZGlmZmVyZW50IGRyb3B6b25lcy4gQWRkIGNvbmZpZ3VyYXRpb25zXFxuLy8gdG8gdGhpcyBvYmplY3QgZm9yIHlvdXIgZGlmZmVyZW50IGRyb3B6b25lIGVsZW1lbnMuXFxuLy9cXG4vLyBFeGFtcGxlOlxcbi8vXFxuLy8gICAgIERyb3B6b25lLm9wdGlvbnMubXlEcm9wem9uZUVsZW1lbnRJZCA9IHsgbWF4RmlsZXNpemU6IDEgfTtcXG4vL1xcbi8vIFRvIGRpc2FibGUgYXV0b0Rpc2NvdmVyIGZvciBhIHNwZWNpZmljIGVsZW1lbnQsIHlvdSBjYW4gc2V0IGBmYWxzZWAgYXMgYW4gb3B0aW9uOlxcbi8vXFxuLy8gICAgIERyb3B6b25lLm9wdGlvbnMubXlEaXNhYmxlZEVsZW1lbnRJZCA9IGZhbHNlO1xcbi8vXFxuLy8gQW5kIGluIGh0bWw6XFxuLy9cXG4vLyAgICAgPGZvcm0gYWN0aW9uPVxcXCIvdXBsb2FkXFxcIiBpZD1cXFwibXktZHJvcHpvbmUtZWxlbWVudC1pZFxcXCIgY2xhc3M9XFxcImRyb3B6b25lXFxcIj48L2Zvcm0+XFxuXFxuRHJvcHpvbmUub3B0aW9ucyA9IHt9OyAvLyBSZXR1cm5zIHRoZSBvcHRpb25zIGZvciBhbiBlbGVtZW50IG9yIHVuZGVmaW5lZCBpZiBub25lIGF2YWlsYWJsZS5cXG5cXG5Ecm9wem9uZS5vcHRpb25zRm9yRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XFxuICAvLyBHZXQgdGhlIGBEcm9wem9uZS5vcHRpb25zLmVsZW1lbnRJZGAgZm9yIHRoaXMgZWxlbWVudCBpZiBpdCBleGlzdHNcXG4gIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcXFwiaWRcXFwiKSkge1xcbiAgICByZXR1cm4gRHJvcHpvbmUub3B0aW9uc1tjYW1lbGl6ZShlbGVtZW50LmdldEF0dHJpYnV0ZShcXFwiaWRcXFwiKSldO1xcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gIH1cXG59OyAvLyBIb2xkcyBhIGxpc3Qgb2YgYWxsIGRyb3B6b25lIGluc3RhbmNlc1xcblxcblxcbkRyb3B6b25lLmluc3RhbmNlcyA9IFtdOyAvLyBSZXR1cm5zIHRoZSBkcm9wem9uZSBmb3IgZ2l2ZW4gZWxlbWVudCBpZiBhbnlcXG5cXG5Ecm9wem9uZS5mb3JFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCk7XFxuICB9XFxuXFxuICBpZiAoKGVsZW1lbnQgIT0gbnVsbCA/IGVsZW1lbnQuZHJvcHpvbmUgOiB1bmRlZmluZWQpID09IG51bGwpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKFxcXCJObyBEcm9wem9uZSBmb3VuZCBmb3IgZ2l2ZW4gZWxlbWVudC4gVGhpcyBpcyBwcm9iYWJseSBiZWNhdXNlIHlvdSdyZSB0cnlpbmcgdG8gYWNjZXNzIGl0IGJlZm9yZSBEcm9wem9uZSBoYWQgdGhlIHRpbWUgdG8gaW5pdGlhbGl6ZS4gVXNlIHRoZSBgaW5pdGAgb3B0aW9uIHRvIHNldHVwIGFueSBhZGRpdGlvbmFsIG9ic2VydmVycyBvbiB5b3VyIERyb3B6b25lLlxcXCIpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGVsZW1lbnQuZHJvcHpvbmU7XFxufTsgLy8gU2V0IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50IERyb3B6b25lIHRvIGF1dG9tYXRpY2FsbHkgZmluZCBhbmQgYXR0YWNoIHRvIC5kcm9wem9uZSBlbGVtZW50cy5cXG5cXG5cXG5Ecm9wem9uZS5hdXRvRGlzY292ZXIgPSB0cnVlOyAvLyBMb29rcyBmb3IgYWxsIC5kcm9wem9uZSBlbGVtZW50cyBhbmQgY3JlYXRlcyBhIGRyb3B6b25lIGZvciB0aGVtXFxuXFxuRHJvcHpvbmUuZGlzY292ZXIgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgZHJvcHpvbmVzO1xcblxcbiAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwpIHtcXG4gICAgZHJvcHpvbmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcXFwiLmRyb3B6b25lXFxcIik7XFxuICB9IGVsc2Uge1xcbiAgICBkcm9wem9uZXMgPSBbXTsgLy8gSUUgOihcXG5cXG4gICAgdmFyIGNoZWNrRWxlbWVudHMgPSBmdW5jdGlvbiBjaGVja0VsZW1lbnRzKGVsZW1lbnRzKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcXG5cXG4gICAgICAgIHZhciBfaXRlcmF0b3IyMCA9IGRyb3B6b25lX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZWxlbWVudHMsIHRydWUpLFxcbiAgICAgICAgICAgIF9zdGVwMjA7XFxuXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIwLnMoKTsgIShfc3RlcDIwID0gX2l0ZXJhdG9yMjAubigpKS5kb25lOykge1xcbiAgICAgICAgICAgIHZhciBlbCA9IF9zdGVwMjAudmFsdWU7XFxuXFxuICAgICAgICAgICAgaWYgKC8oXnwgKWRyb3B6b25lKCR8ICkvLnRlc3QoZWwuY2xhc3NOYW1lKSkge1xcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZHJvcHpvbmVzLnB1c2goZWwpKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2godW5kZWZpbmVkKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICBfaXRlcmF0b3IyMC5lKGVycik7XFxuICAgICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgICBfaXRlcmF0b3IyMC5mKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH0oKTtcXG4gICAgfTtcXG5cXG4gICAgY2hlY2tFbGVtZW50cyhkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiZGl2XFxcIikpO1xcbiAgICBjaGVja0VsZW1lbnRzKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJmb3JtXFxcIikpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xcblxcbiAgICB2YXIgX2l0ZXJhdG9yMjEgPSBkcm9wem9uZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRyb3B6b25lcywgdHJ1ZSksXFxuICAgICAgICBfc3RlcDIxO1xcblxcbiAgICB0cnkge1xcbiAgICAgIGZvciAoX2l0ZXJhdG9yMjEucygpOyAhKF9zdGVwMjEgPSBfaXRlcmF0b3IyMS5uKCkpLmRvbmU7KSB7XFxuICAgICAgICB2YXIgZHJvcHpvbmUgPSBfc3RlcDIxLnZhbHVlO1xcblxcbiAgICAgICAgLy8gQ3JlYXRlIGEgZHJvcHpvbmUgdW5sZXNzIGF1dG8gZGlzY292ZXIgaGFzIGJlZW4gZGlzYWJsZWQgZm9yIHNwZWNpZmljIGVsZW1lbnRcXG4gICAgICAgIGlmIChEcm9wem9uZS5vcHRpb25zRm9yRWxlbWVudChkcm9wem9uZSkgIT09IGZhbHNlKSB7XFxuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEcm9wem9uZShkcm9wem9uZSkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmVzdWx0LnB1c2godW5kZWZpbmVkKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIF9pdGVyYXRvcjIxLmUoZXJyKTtcXG4gICAgfSBmaW5hbGx5IHtcXG4gICAgICBfaXRlcmF0b3IyMS5mKCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH0oKTtcXG59OyAvLyBTb21lIGJyb3dzZXJzIHN1cHBvcnQgZHJhZyBhbmQgZHJvZyBmdW5jdGlvbmFsaXR5LCBidXQgbm90IGNvcnJlY3RseS5cXG4vL1xcbi8vIFNvIEkgY3JlYXRlZCBhIGJsb2NrbGlzdCBvZiB1c2VyQWdlbnRzLiBZZXMsIHllcy4gQnJvd3NlciBzbmlmZmluZywgSSBrbm93Llxcbi8vIEJ1dCB3aGF0IHRvIGRvIHdoZW4gYnJvd3NlcnMgKnRoZW9yZXRpY2FsbHkqIHN1cHBvcnQgYW4gQVBJLCBidXQgY3Jhc2hcXG4vLyB3aGVuIHVzaW5nIGl0Llxcbi8vXFxuLy8gVGhpcyBpcyBhIGxpc3Qgb2YgcmVndWxhciBleHByZXNzaW9ucyB0ZXN0ZWQgYWdhaW5zdCBuYXZpZ2F0b3IudXNlckFnZW50XFxuLy9cXG4vLyAqKiBJdCBzaG91bGQgb25seSBiZSB1c2VkIG9uIGJyb3dzZXIgdGhhdCAqZG8qIHN1cHBvcnQgdGhlIEFQSSwgYnV0XFxuLy8gaW5jb3JyZWN0bHkgKipcXG5cXG5cXG5Ecm9wem9uZS5ibG9ja2VkQnJvd3NlcnMgPSBbLy8gVGhlIG1hYyBvcyBhbmQgd2luZG93cyBwaG9uZSB2ZXJzaW9uIG9mIG9wZXJhIDEyIHNlZW1zIHRvIGhhdmUgYSBwcm9ibGVtIHdpdGggdGhlIEZpbGUgZHJhZyduJ2Ryb3AgQVBJLlxcbi9vcGVyYS4qKE1hY2ludG9zaHxXaW5kb3dzIFBob25lKS4qdmVyc2lvblxcXFwvMTIvaV07IC8vIENoZWNrcyBpZiB0aGUgYnJvd3NlciBpcyBzdXBwb3J0ZWRcXG5cXG5Ecm9wem9uZS5pc0Jyb3dzZXJTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgY2FwYWJsZUJyb3dzZXIgPSB0cnVlO1xcblxcbiAgaWYgKHdpbmRvdy5GaWxlICYmIHdpbmRvdy5GaWxlUmVhZGVyICYmIHdpbmRvdy5GaWxlTGlzdCAmJiB3aW5kb3cuQmxvYiAmJiB3aW5kb3cuRm9ybURhdGEgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcikge1xcbiAgICBpZiAoIShcXFwiY2xhc3NMaXN0XFxcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJhXFxcIikpKSB7XFxuICAgICAgY2FwYWJsZUJyb3dzZXIgPSBmYWxzZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAoRHJvcHpvbmUuYmxhY2tsaXN0ZWRCcm93c2VycyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAvLyBTaW5jZSB0aGlzIGhhcyBiZWVuIHJlbmFtZWQsIHRoaXMgbWFrZXMgc3VyZSB3ZSBkb24ndCBicmVhayBvbGRlclxcbiAgICAgICAgLy8gY29uZmlndXJhdGlvbi5cXG4gICAgICAgIERyb3B6b25lLmJsb2NrZWRCcm93c2VycyA9IERyb3B6b25lLmJsYWNrbGlzdGVkQnJvd3NlcnM7XFxuICAgICAgfSAvLyBUaGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgQVBJLCBidXQgbWF5IGJlIGJsb2NrZWQuXFxuXFxuXFxuICAgICAgdmFyIF9pdGVyYXRvcjIyID0gZHJvcHpvbmVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihEcm9wem9uZS5ibG9ja2VkQnJvd3NlcnMsIHRydWUpLFxcbiAgICAgICAgICBfc3RlcDIyO1xcblxcbiAgICAgIHRyeSB7XFxuICAgICAgICBmb3IgKF9pdGVyYXRvcjIyLnMoKTsgIShfc3RlcDIyID0gX2l0ZXJhdG9yMjIubigpKS5kb25lOykge1xcbiAgICAgICAgICB2YXIgcmVnZXggPSBfc3RlcDIyLnZhbHVlO1xcblxcbiAgICAgICAgICBpZiAocmVnZXgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xcbiAgICAgICAgICAgIGNhcGFibGVCcm93c2VyID0gZmFsc2U7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgIF9pdGVyYXRvcjIyLmUoZXJyKTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgX2l0ZXJhdG9yMjIuZigpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgY2FwYWJsZUJyb3dzZXIgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIHJldHVybiBjYXBhYmxlQnJvd3NlcjtcXG59O1xcblxcbkRyb3B6b25lLmRhdGFVUkl0b0Jsb2IgPSBmdW5jdGlvbiAoZGF0YVVSSSkge1xcbiAgLy8gY29udmVydCBiYXNlNjQgdG8gcmF3IGJpbmFyeSBkYXRhIGhlbGQgaW4gYSBzdHJpbmdcXG4gIC8vIGRvZXNuJ3QgaGFuZGxlIFVSTEVuY29kZWQgRGF0YVVSSXMgLSBzZWUgU08gYW5zd2VyICM2ODUwMjc2IGZvciBjb2RlIHRoYXQgZG9lcyB0aGlzXFxuICB2YXIgYnl0ZVN0cmluZyA9IGF0b2IoZGF0YVVSSS5zcGxpdChcXFwiLFxcXCIpWzFdKTsgLy8gc2VwYXJhdGUgb3V0IHRoZSBtaW1lIGNvbXBvbmVudFxcblxcbiAgdmFyIG1pbWVTdHJpbmcgPSBkYXRhVVJJLnNwbGl0KFxcXCIsXFxcIilbMF0uc3BsaXQoXFxcIjpcXFwiKVsxXS5zcGxpdChcXFwiO1xcXCIpWzBdOyAvLyB3cml0ZSB0aGUgYnl0ZXMgb2YgdGhlIHN0cmluZyB0byBhbiBBcnJheUJ1ZmZlclxcblxcbiAgdmFyIGFiID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTdHJpbmcubGVuZ3RoKTtcXG4gIHZhciBpYSA9IG5ldyBVaW50OEFycmF5KGFiKTtcXG5cXG4gIGZvciAodmFyIGkgPSAwLCBlbmQgPSBieXRlU3RyaW5nLmxlbmd0aCwgYXNjID0gMCA8PSBlbmQ7IGFzYyA/IGkgPD0gZW5kIDogaSA+PSBlbmQ7IGFzYyA/IGkrKyA6IGktLSkge1xcbiAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcXG4gIH0gLy8gd3JpdGUgdGhlIEFycmF5QnVmZmVyIHRvIGEgYmxvYlxcblxcblxcbiAgcmV0dXJuIG5ldyBCbG9iKFthYl0sIHtcXG4gICAgdHlwZTogbWltZVN0cmluZ1xcbiAgfSk7XFxufTsgLy8gUmV0dXJucyBhbiBhcnJheSB3aXRob3V0IHRoZSByZWplY3RlZCBpdGVtXFxuXFxuXFxudmFyIHdpdGhvdXQgPSBmdW5jdGlvbiB3aXRob3V0KGxpc3QsIHJlamVjdGVkSXRlbSkge1xcbiAgcmV0dXJuIGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XFxuICAgIHJldHVybiBpdGVtICE9PSByZWplY3RlZEl0ZW07XFxuICB9KS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcXG4gICAgcmV0dXJuIGl0ZW07XFxuICB9KTtcXG59OyAvLyBhYmMtZGVmX2doaSAtPiBhYmNEZWZHaGlcXG5cXG5cXG52YXIgY2FtZWxpemUgPSBmdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcXG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xcXFwtX10oXFxcXHcpL2csIGZ1bmN0aW9uIChtYXRjaCkge1xcbiAgICByZXR1cm4gbWF0Y2guY2hhckF0KDEpLnRvVXBwZXJDYXNlKCk7XFxuICB9KTtcXG59OyAvLyBDcmVhdGVzIGFuIGVsZW1lbnQgZnJvbSBzdHJpbmdcXG5cXG5cXG5Ecm9wem9uZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHN0cmluZykge1xcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO1xcbiAgZGl2LmlubmVySFRNTCA9IHN0cmluZztcXG4gIHJldHVybiBkaXYuY2hpbGROb2Rlc1swXTtcXG59OyAvLyBUZXN0cyBpZiBnaXZlbiBlbGVtZW50IGlzIGluc2lkZSAob3Igc2ltcGx5IGlzKSB0aGUgY29udGFpbmVyXFxuXFxuXFxuRHJvcHpvbmUuZWxlbWVudEluc2lkZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIpIHtcXG4gIGlmIChlbGVtZW50ID09PSBjb250YWluZXIpIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9IC8vIENvZmZlZXNjcmlwdCBkb2Vzbid0IHN1cHBvcnQgZG8vd2hpbGUgbG9vcHNcXG5cXG5cXG4gIHdoaWxlIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlKSB7XFxuICAgIGlmIChlbGVtZW50ID09PSBjb250YWluZXIpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIGZhbHNlO1xcbn07XFxuXFxuRHJvcHpvbmUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xcbiAgdmFyIGVsZW1lbnQ7XFxuXFxuICBpZiAodHlwZW9mIGVsID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XFxuICB9IGVsc2UgaWYgKGVsLm5vZGVUeXBlICE9IG51bGwpIHtcXG4gICAgZWxlbWVudCA9IGVsO1xcbiAgfVxcblxcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkludmFsaWQgYFxcXCIuY29uY2F0KG5hbWUsIFxcXCJgIG9wdGlvbiBwcm92aWRlZC4gUGxlYXNlIHByb3ZpZGUgYSBDU1Mgc2VsZWN0b3Igb3IgYSBwbGFpbiBIVE1MIGVsZW1lbnQuXFxcIikpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGVsZW1lbnQ7XFxufTtcXG5cXG5Ecm9wem9uZS5nZXRFbGVtZW50cyA9IGZ1bmN0aW9uIChlbHMsIG5hbWUpIHtcXG4gIHZhciBlbCwgZWxlbWVudHM7XFxuXFxuICBpZiAoZWxzIGluc3RhbmNlb2YgQXJyYXkpIHtcXG4gICAgZWxlbWVudHMgPSBbXTtcXG5cXG4gICAgdHJ5IHtcXG4gICAgICB2YXIgX2l0ZXJhdG9yMjMgPSBkcm9wem9uZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGVscywgdHJ1ZSksXFxuICAgICAgICAgIF9zdGVwMjM7XFxuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMjMucygpOyAhKF9zdGVwMjMgPSBfaXRlcmF0b3IyMy5uKCkpLmRvbmU7KSB7XFxuICAgICAgICAgIGVsID0gX3N0ZXAyMy52YWx1ZTtcXG4gICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLmdldEVsZW1lbnQoZWwsIG5hbWUpKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgIF9pdGVyYXRvcjIzLmUoZXJyKTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgX2l0ZXJhdG9yMjMuZigpO1xcbiAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgIGVsZW1lbnRzID0gbnVsbDtcXG4gICAgfVxcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxzID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICBlbGVtZW50cyA9IFtdO1xcblxcbiAgICB2YXIgX2l0ZXJhdG9yMjQgPSBkcm9wem9uZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxzKSwgdHJ1ZSksXFxuICAgICAgICBfc3RlcDI0O1xcblxcbiAgICB0cnkge1xcbiAgICAgIGZvciAoX2l0ZXJhdG9yMjQucygpOyAhKF9zdGVwMjQgPSBfaXRlcmF0b3IyNC5uKCkpLmRvbmU7KSB7XFxuICAgICAgICBlbCA9IF9zdGVwMjQudmFsdWU7XFxuICAgICAgICBlbGVtZW50cy5wdXNoKGVsKTtcXG4gICAgICB9XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIF9pdGVyYXRvcjI0LmUoZXJyKTtcXG4gICAgfSBmaW5hbGx5IHtcXG4gICAgICBfaXRlcmF0b3IyNC5mKCk7XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAoZWxzLm5vZGVUeXBlICE9IG51bGwpIHtcXG4gICAgZWxlbWVudHMgPSBbZWxzXTtcXG4gIH1cXG5cXG4gIGlmIChlbGVtZW50cyA9PSBudWxsIHx8ICFlbGVtZW50cy5sZW5ndGgpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKFxcXCJJbnZhbGlkIGBcXFwiLmNvbmNhdChuYW1lLCBcXFwiYCBvcHRpb24gcHJvdmlkZWQuIFBsZWFzZSBwcm92aWRlIGEgQ1NTIHNlbGVjdG9yLCBhIHBsYWluIEhUTUwgZWxlbWVudCBvciBhIGxpc3Qgb2YgdGhvc2UuXFxcIikpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGVsZW1lbnRzO1xcbn07IC8vIEFza3MgdGhlIHVzZXIgdGhlIHF1ZXN0aW9uIGFuZCBjYWxscyBhY2NlcHRlZCBvciByZWplY3RlZCBhY2NvcmRpbmdseVxcbi8vXFxuLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdCB1c2VzIGB3aW5kb3cuY29uZmlybWAgYW5kIHRoZW4gY2FsbHMgdGhlXFxuLy8gYXBwcm9wcmlhdGUgY2FsbGJhY2suXFxuXFxuXFxuRHJvcHpvbmUuY29uZmlybSA9IGZ1bmN0aW9uIChxdWVzdGlvbiwgYWNjZXB0ZWQsIHJlamVjdGVkKSB7XFxuICBpZiAod2luZG93LmNvbmZpcm0ocXVlc3Rpb24pKSB7XFxuICAgIHJldHVybiBhY2NlcHRlZCgpO1xcbiAgfSBlbHNlIGlmIChyZWplY3RlZCAhPSBudWxsKSB7XFxuICAgIHJldHVybiByZWplY3RlZCgpO1xcbiAgfVxcbn07IC8vIFZhbGlkYXRlcyB0aGUgbWltZSB0eXBlIGxpa2UgdGhpczpcXG4vL1xcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9FbGVtZW50L2lucHV0I2F0dHItYWNjZXB0XFxuXFxuXFxuRHJvcHpvbmUuaXNWYWxpZEZpbGUgPSBmdW5jdGlvbiAoZmlsZSwgYWNjZXB0ZWRGaWxlcykge1xcbiAgaWYgKCFhY2NlcHRlZEZpbGVzKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfSAvLyBJZiB0aGVyZSBhcmUgbm8gYWNjZXB0ZWQgbWltZSB0eXBlcywgaXQncyBPS1xcblxcblxcbiAgYWNjZXB0ZWRGaWxlcyA9IGFjY2VwdGVkRmlsZXMuc3BsaXQoXFxcIixcXFwiKTtcXG4gIHZhciBtaW1lVHlwZSA9IGZpbGUudHlwZTtcXG4gIHZhciBiYXNlTWltZVR5cGUgPSBtaW1lVHlwZS5yZXBsYWNlKC9cXFxcLy4qJC8sIFxcXCJcXFwiKTtcXG5cXG4gIHZhciBfaXRlcmF0b3IyNSA9IGRyb3B6b25lX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYWNjZXB0ZWRGaWxlcywgdHJ1ZSksXFxuICAgICAgX3N0ZXAyNTtcXG5cXG4gIHRyeSB7XFxuICAgIGZvciAoX2l0ZXJhdG9yMjUucygpOyAhKF9zdGVwMjUgPSBfaXRlcmF0b3IyNS5uKCkpLmRvbmU7KSB7XFxuICAgICAgdmFyIHZhbGlkVHlwZSA9IF9zdGVwMjUudmFsdWU7XFxuICAgICAgdmFsaWRUeXBlID0gdmFsaWRUeXBlLnRyaW0oKTtcXG5cXG4gICAgICBpZiAodmFsaWRUeXBlLmNoYXJBdCgwKSA9PT0gXFxcIi5cXFwiKSB7XFxuICAgICAgICBpZiAoZmlsZS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWxpZFR5cGUudG9Mb3dlckNhc2UoKSwgZmlsZS5uYW1lLmxlbmd0aCAtIHZhbGlkVHlwZS5sZW5ndGgpICE9PSAtMSkge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKC9cXFxcL1xcXFwqJC8udGVzdCh2YWxpZFR5cGUpKSB7XFxuICAgICAgICAvLyBUaGlzIGlzIHNvbWV0aGluZyBsaWtlIGEgaW1hZ2UvKiBtaW1lIHR5cGVcXG4gICAgICAgIGlmIChiYXNlTWltZVR5cGUgPT09IHZhbGlkVHlwZS5yZXBsYWNlKC9cXFxcLy4qJC8sIFxcXCJcXFwiKSkge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKG1pbWVUeXBlID09PSB2YWxpZFR5cGUpIHtcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgX2l0ZXJhdG9yMjUuZShlcnIpO1xcbiAgfSBmaW5hbGx5IHtcXG4gICAgX2l0ZXJhdG9yMjUuZigpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGZhbHNlO1xcbn07IC8vIEF1Z21lbnQgalF1ZXJ5XFxuXFxuXFxuaWYgKHR5cGVvZiBqUXVlcnkgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIGpRdWVyeSAhPT0gbnVsbCkge1xcbiAgalF1ZXJ5LmZuLmRyb3B6b25lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIG5ldyBEcm9wem9uZSh0aGlzLCBvcHRpb25zKTtcXG4gICAgfSk7XFxuICB9O1xcbn0gLy8gRHJvcHpvbmUgZmlsZSBzdGF0dXMgY29kZXNcXG5cXG5cXG5Ecm9wem9uZS5BRERFRCA9IFxcXCJhZGRlZFxcXCI7XFxuRHJvcHpvbmUuUVVFVUVEID0gXFxcInF1ZXVlZFxcXCI7IC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gTm93LCBpZiBhIGZpbGUgaXMgYWNjZXB0ZWQsIGl0J3MgZWl0aGVyIHF1ZXVlZFxcbi8vIG9yIHVwbG9hZGluZy5cXG5cXG5Ecm9wem9uZS5BQ0NFUFRFRCA9IERyb3B6b25lLlFVRVVFRDtcXG5Ecm9wem9uZS5VUExPQURJTkcgPSBcXFwidXBsb2FkaW5nXFxcIjtcXG5Ecm9wem9uZS5QUk9DRVNTSU5HID0gRHJvcHpvbmUuVVBMT0FESU5HOyAvLyBhbGlhc1xcblxcbkRyb3B6b25lLkNBTkNFTEVEID0gXFxcImNhbmNlbGVkXFxcIjtcXG5Ecm9wem9uZS5FUlJPUiA9IFxcXCJlcnJvclxcXCI7XFxuRHJvcHpvbmUuU1VDQ0VTUyA9IFxcXCJzdWNjZXNzXFxcIjtcXG4vKlxcblxcbiBCdWdmaXggZm9yIGlPUyA2IGFuZCA3XFxuIFNvdXJjZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTkyOTA5OS9odG1sNS1jYW52YXMtZHJhd2ltYWdlLXJhdGlvLWJ1Zy1pb3NcXG4gYmFzZWQgb24gdGhlIHdvcmsgb2YgaHR0cHM6Ly9naXRodWIuY29tL3N0b21pdGEvaW9zLWltYWdlZmlsZS1tZWdhcGl4ZWxcXG5cXG4gKi9cXG4vLyBEZXRlY3RpbmcgdmVydGljYWwgc3F1YXNoIGluIGxvYWRlZCBpbWFnZS5cXG4vLyBGaXhlcyBhIGJ1ZyB3aGljaCBzcXVhc2ggaW1hZ2UgdmVydGljYWxseSB3aGlsZSBkcmF3aW5nIGludG8gY2FudmFzIGZvciBzb21lIGltYWdlcy5cXG4vLyBUaGlzIGlzIGEgYnVnIGluIGlPUzYgZGV2aWNlcy4gVGhpcyBmdW5jdGlvbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zdG9taXRhL2lvcy1pbWFnZWZpbGUtbWVnYXBpeGVsXFxuXFxudmFyIGRldGVjdFZlcnRpY2FsU3F1YXNoID0gZnVuY3Rpb24gZGV0ZWN0VmVydGljYWxTcXVhc2goaW1nKSB7XFxuICB2YXIgaXcgPSBpbWcubmF0dXJhbFdpZHRoO1xcbiAgdmFyIGloID0gaW1nLm5hdHVyYWxIZWlnaHQ7XFxuICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiY2FudmFzXFxcIik7XFxuICBjYW52YXMud2lkdGggPSAxO1xcbiAgY2FudmFzLmhlaWdodCA9IGloO1xcbiAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFxcXCIyZFxcXCIpO1xcbiAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xcblxcbiAgdmFyIF9jdHgkZ2V0SW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgxLCAwLCAxLCBpaCksXFxuICAgICAgZGF0YSA9IF9jdHgkZ2V0SW1hZ2VEYXRhLmRhdGE7IC8vIHNlYXJjaCBpbWFnZSBlZGdlIHBpeGVsIHBvc2l0aW9uIGluIGNhc2UgaXQgaXMgc3F1YXNoZWQgdmVydGljYWxseS5cXG5cXG5cXG4gIHZhciBzeSA9IDA7XFxuICB2YXIgZXkgPSBpaDtcXG4gIHZhciBweSA9IGloO1xcblxcbiAgd2hpbGUgKHB5ID4gc3kpIHtcXG4gICAgdmFyIGFscGhhID0gZGF0YVsocHkgLSAxKSAqIDQgKyAzXTtcXG5cXG4gICAgaWYgKGFscGhhID09PSAwKSB7XFxuICAgICAgZXkgPSBweTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzeSA9IHB5O1xcbiAgICB9XFxuXFxuICAgIHB5ID0gZXkgKyBzeSA+PiAxO1xcbiAgfVxcblxcbiAgdmFyIHJhdGlvID0gcHkgLyBpaDtcXG5cXG4gIGlmIChyYXRpbyA9PT0gMCkge1xcbiAgICByZXR1cm4gMTtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiByYXRpbztcXG4gIH1cXG59OyAvLyBBIHJlcGxhY2VtZW50IGZvciBjb250ZXh0LmRyYXdJbWFnZVxcbi8vIChhcmdzIGFyZSBmb3Igc291cmNlIGFuZCBkZXN0aW5hdGlvbikuXFxuXFxuXFxudmFyIGRyYXdJbWFnZUlPU0ZpeCA9IGZ1bmN0aW9uIGRyYXdJbWFnZUlPU0ZpeChjdHgsIGltZywgc3gsIHN5LCBzdywgc2gsIGR4LCBkeSwgZHcsIGRoKSB7XFxuICB2YXIgdmVydFNxdWFzaFJhdGlvID0gZGV0ZWN0VmVydGljYWxTcXVhc2goaW1nKTtcXG4gIHJldHVybiBjdHguZHJhd0ltYWdlKGltZywgc3gsIHN5LCBzdywgc2gsIGR4LCBkeSwgZHcsIGRoIC8gdmVydFNxdWFzaFJhdGlvKTtcXG59OyAvLyBCYXNlZCBvbiBNaW5pZnlKcGVnXFxuLy8gU291cmNlOiBodHRwOi8vd3d3LnBlcnJ5LmN6L2ZpbGVzL0V4aWZSZXN0b3Jlci5qc1xcbi8vIGh0dHA6Ly9lbGljb24uYmxvZzU3LmZjMi5jb20vYmxvZy1lbnRyeS0yMDYuaHRtbFxcblxcblxcbnZhciBFeGlmUmVzdG9yZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBFeGlmUmVzdG9yZSgpIHtcXG4gICAgZHJvcHpvbmVfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhpZlJlc3RvcmUpO1xcbiAgfVxcblxcbiAgZHJvcHpvbmVfY3JlYXRlQ2xhc3MoRXhpZlJlc3RvcmUsIG51bGwsIFt7XFxuICAgIGtleTogXFxcImluaXRDbGFzc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0Q2xhc3MoKSB7XFxuICAgICAgdGhpcy5LRVlfU1RSID0gXFxcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxcIjtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJlbmNvZGU2NFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNvZGU2NChpbnB1dCkge1xcbiAgICAgIHZhciBvdXRwdXQgPSBcXFwiXFxcIjtcXG4gICAgICB2YXIgY2hyMSA9IHVuZGVmaW5lZDtcXG4gICAgICB2YXIgY2hyMiA9IHVuZGVmaW5lZDtcXG4gICAgICB2YXIgY2hyMyA9IFxcXCJcXFwiO1xcbiAgICAgIHZhciBlbmMxID0gdW5kZWZpbmVkO1xcbiAgICAgIHZhciBlbmMyID0gdW5kZWZpbmVkO1xcbiAgICAgIHZhciBlbmMzID0gdW5kZWZpbmVkO1xcbiAgICAgIHZhciBlbmM0ID0gXFxcIlxcXCI7XFxuICAgICAgdmFyIGkgPSAwO1xcblxcbiAgICAgIHdoaWxlICh0cnVlKSB7XFxuICAgICAgICBjaHIxID0gaW5wdXRbaSsrXTtcXG4gICAgICAgIGNocjIgPSBpbnB1dFtpKytdO1xcbiAgICAgICAgY2hyMyA9IGlucHV0W2krK107XFxuICAgICAgICBlbmMxID0gY2hyMSA+PiAyO1xcbiAgICAgICAgZW5jMiA9IChjaHIxICYgMykgPDwgNCB8IGNocjIgPj4gNDtcXG4gICAgICAgIGVuYzMgPSAoY2hyMiAmIDE1KSA8PCAyIHwgY2hyMyA+PiA2O1xcbiAgICAgICAgZW5jNCA9IGNocjMgJiA2MztcXG5cXG4gICAgICAgIGlmIChpc05hTihjaHIyKSkge1xcbiAgICAgICAgICBlbmMzID0gZW5jNCA9IDY0O1xcbiAgICAgICAgfSBlbHNlIGlmIChpc05hTihjaHIzKSkge1xcbiAgICAgICAgICBlbmM0ID0gNjQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyB0aGlzLktFWV9TVFIuY2hhckF0KGVuYzEpICsgdGhpcy5LRVlfU1RSLmNoYXJBdChlbmMyKSArIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jMykgKyB0aGlzLktFWV9TVFIuY2hhckF0KGVuYzQpO1xcbiAgICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gXFxcIlxcXCI7XFxuICAgICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gXFxcIlxcXCI7XFxuXFxuICAgICAgICBpZiAoIShpIDwgaW5wdXQubGVuZ3RoKSkge1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG91dHB1dDtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZXN0b3JlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3RvcmUob3JpZ0ZpbGVCYXNlNjQsIHJlc2l6ZWRGaWxlQmFzZTY0KSB7XFxuICAgICAgaWYgKCFvcmlnRmlsZUJhc2U2NC5tYXRjaChcXFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxcXFwiKSkge1xcbiAgICAgICAgcmV0dXJuIHJlc2l6ZWRGaWxlQmFzZTY0O1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgcmF3SW1hZ2UgPSB0aGlzLmRlY29kZTY0KG9yaWdGaWxlQmFzZTY0LnJlcGxhY2UoXFxcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsXFxcIiwgXFxcIlxcXCIpKTtcXG4gICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNsaWNlMlNlZ21lbnRzKHJhd0ltYWdlKTtcXG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLmV4aWZNYW5pcHVsYXRpb24ocmVzaXplZEZpbGVCYXNlNjQsIHNlZ21lbnRzKTtcXG4gICAgICByZXR1cm4gXFxcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsXFxcIi5jb25jYXQodGhpcy5lbmNvZGU2NChpbWFnZSkpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcImV4aWZNYW5pcHVsYXRpb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhpZk1hbmlwdWxhdGlvbihyZXNpemVkRmlsZUJhc2U2NCwgc2VnbWVudHMpIHtcXG4gICAgICB2YXIgZXhpZkFycmF5ID0gdGhpcy5nZXRFeGlmQXJyYXkoc2VnbWVudHMpO1xcbiAgICAgIHZhciBuZXdJbWFnZUFycmF5ID0gdGhpcy5pbnNlcnRFeGlmKHJlc2l6ZWRGaWxlQmFzZTY0LCBleGlmQXJyYXkpO1xcbiAgICAgIHZhciBhQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmV3SW1hZ2VBcnJheSk7XFxuICAgICAgcmV0dXJuIGFCdWZmZXI7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0RXhpZkFycmF5XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEV4aWZBcnJheShzZWdtZW50cykge1xcbiAgICAgIHZhciBzZWcgPSB1bmRlZmluZWQ7XFxuICAgICAgdmFyIHggPSAwO1xcblxcbiAgICAgIHdoaWxlICh4IDwgc2VnbWVudHMubGVuZ3RoKSB7XFxuICAgICAgICBzZWcgPSBzZWdtZW50c1t4XTtcXG5cXG4gICAgICAgIGlmIChzZWdbMF0gPT09IDI1NSAmIHNlZ1sxXSA9PT0gMjI1KSB7XFxuICAgICAgICAgIHJldHVybiBzZWc7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB4Kys7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBbXTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJpbnNlcnRFeGlmXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEV4aWYocmVzaXplZEZpbGVCYXNlNjQsIGV4aWZBcnJheSkge1xcbiAgICAgIHZhciBpbWFnZURhdGEgPSByZXNpemVkRmlsZUJhc2U2NC5yZXBsYWNlKFxcXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICB2YXIgYnVmID0gdGhpcy5kZWNvZGU2NChpbWFnZURhdGEpO1xcbiAgICAgIHZhciBzZXBhcmF0ZVBvaW50ID0gYnVmLmluZGV4T2YoMjU1LCAzKTtcXG4gICAgICB2YXIgbWFlID0gYnVmLnNsaWNlKDAsIHNlcGFyYXRlUG9pbnQpO1xcbiAgICAgIHZhciBhdG8gPSBidWYuc2xpY2Uoc2VwYXJhdGVQb2ludCk7XFxuICAgICAgdmFyIGFycmF5ID0gbWFlO1xcbiAgICAgIGFycmF5ID0gYXJyYXkuY29uY2F0KGV4aWZBcnJheSk7XFxuICAgICAgYXJyYXkgPSBhcnJheS5jb25jYXQoYXRvKTtcXG4gICAgICByZXR1cm4gYXJyYXk7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2xpY2UyU2VnbWVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2xpY2UyU2VnbWVudHMocmF3SW1hZ2VBcnJheSkge1xcbiAgICAgIHZhciBoZWFkID0gMDtcXG4gICAgICB2YXIgc2VnbWVudHMgPSBbXTtcXG5cXG4gICAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgICAgdmFyIGxlbmd0aDtcXG5cXG4gICAgICAgIGlmIChyYXdJbWFnZUFycmF5W2hlYWRdID09PSAyNTUgJiByYXdJbWFnZUFycmF5W2hlYWQgKyAxXSA9PT0gMjE4KSB7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHJhd0ltYWdlQXJyYXlbaGVhZF0gPT09IDI1NSAmIHJhd0ltYWdlQXJyYXlbaGVhZCArIDFdID09PSAyMTYpIHtcXG4gICAgICAgICAgaGVhZCArPSAyO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgbGVuZ3RoID0gcmF3SW1hZ2VBcnJheVtoZWFkICsgMl0gKiAyNTYgKyByYXdJbWFnZUFycmF5W2hlYWQgKyAzXTtcXG4gICAgICAgICAgdmFyIGVuZFBvaW50ID0gaGVhZCArIGxlbmd0aCArIDI7XFxuICAgICAgICAgIHZhciBzZWcgPSByYXdJbWFnZUFycmF5LnNsaWNlKGhlYWQsIGVuZFBvaW50KTtcXG4gICAgICAgICAgc2VnbWVudHMucHVzaChzZWcpO1xcbiAgICAgICAgICBoZWFkID0gZW5kUG9pbnQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoaGVhZCA+IHJhd0ltYWdlQXJyYXkubGVuZ3RoKSB7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gc2VnbWVudHM7XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZGVjb2RlNjRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlNjQoaW5wdXQpIHtcXG4gICAgICB2YXIgb3V0cHV0ID0gXFxcIlxcXCI7XFxuICAgICAgdmFyIGNocjEgPSB1bmRlZmluZWQ7XFxuICAgICAgdmFyIGNocjIgPSB1bmRlZmluZWQ7XFxuICAgICAgdmFyIGNocjMgPSBcXFwiXFxcIjtcXG4gICAgICB2YXIgZW5jMSA9IHVuZGVmaW5lZDtcXG4gICAgICB2YXIgZW5jMiA9IHVuZGVmaW5lZDtcXG4gICAgICB2YXIgZW5jMyA9IHVuZGVmaW5lZDtcXG4gICAgICB2YXIgZW5jNCA9IFxcXCJcXFwiO1xcbiAgICAgIHZhciBpID0gMDtcXG4gICAgICB2YXIgYnVmID0gW107IC8vIHJlbW92ZSBhbGwgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgQS1aLCBhLXosIDAtOSwgKywgLywgb3IgPVxcblxcbiAgICAgIHZhciBiYXNlNjR0ZXN0ID0gL1teQS1aYS16MC05XFxcXCtcXFxcL1xcXFw9XS9nO1xcblxcbiAgICAgIGlmIChiYXNlNjR0ZXN0LmV4ZWMoaW5wdXQpKSB7XFxuICAgICAgICBjb25zb2xlLndhcm4oXFxcIlRoZXJlIHdlcmUgaW52YWxpZCBiYXNlNjQgY2hhcmFjdGVycyBpbiB0aGUgaW5wdXQgdGV4dC5cXFxcblZhbGlkIGJhc2U2NCBjaGFyYWN0ZXJzIGFyZSBBLVosIGEteiwgMC05LCAnKycsICcvJyxhbmQgJz0nXFxcXG5FeHBlY3QgZXJyb3JzIGluIGRlY29kaW5nLlxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFxcXCtcXFxcL1xcXFw9XS9nLCBcXFwiXFxcIik7XFxuXFxuICAgICAgd2hpbGUgKHRydWUpIHtcXG4gICAgICAgIGVuYzEgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XFxuICAgICAgICBlbmMyID0gdGhpcy5LRVlfU1RSLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xcbiAgICAgICAgZW5jMyA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcXG4gICAgICAgIGVuYzQgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XFxuICAgICAgICBjaHIxID0gZW5jMSA8PCAyIHwgZW5jMiA+PiA0O1xcbiAgICAgICAgY2hyMiA9IChlbmMyICYgMTUpIDw8IDQgfCBlbmMzID4+IDI7XFxuICAgICAgICBjaHIzID0gKGVuYzMgJiAzKSA8PCA2IHwgZW5jNDtcXG4gICAgICAgIGJ1Zi5wdXNoKGNocjEpO1xcblxcbiAgICAgICAgaWYgKGVuYzMgIT09IDY0KSB7XFxuICAgICAgICAgIGJ1Zi5wdXNoKGNocjIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGVuYzQgIT09IDY0KSB7XFxuICAgICAgICAgIGJ1Zi5wdXNoKGNocjMpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gXFxcIlxcXCI7XFxuICAgICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gXFxcIlxcXCI7XFxuXFxuICAgICAgICBpZiAoIShpIDwgaW5wdXQubGVuZ3RoKSkge1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGJ1ZjtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIEV4aWZSZXN0b3JlO1xcbn0oKTtcXG5cXG5FeGlmUmVzdG9yZS5pbml0Q2xhc3MoKTtcXG4vKlxcbiAqIGNvbnRlbnRsb2FkZWQuanNcXG4gKlxcbiAqIEF1dGhvcjogRGllZ28gUGVyaW5pIChkaWVnby5wZXJpbmkgYXQgZ21haWwuY29tKVxcbiAqIFN1bW1hcnk6IGNyb3NzLWJyb3dzZXIgd3JhcHBlciBmb3IgRE9NQ29udGVudExvYWRlZFxcbiAqIFVwZGF0ZWQ6IDIwMTAxMDIwXFxuICogTGljZW5zZTogTUlUXFxuICogVmVyc2lvbjogMS4yXFxuICpcXG4gKiBVUkw6XFxuICogaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0NvbnRlbnRMb2FkZWQvXFxuICogaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0NvbnRlbnRMb2FkZWQvTUlULUxJQ0VOU0VcXG4gKi9cXG4vLyBAd2luIHdpbmRvdyByZWZlcmVuY2VcXG4vLyBAZm4gZnVuY3Rpb24gcmVmZXJlbmNlXFxuXFxudmFyIGNvbnRlbnRMb2FkZWQgPSBmdW5jdGlvbiBjb250ZW50TG9hZGVkKHdpbiwgZm4pIHtcXG4gIHZhciBkb25lID0gZmFsc2U7XFxuICB2YXIgdG9wID0gdHJ1ZTtcXG4gIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XFxuICB2YXIgcm9vdCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XFxuICB2YXIgYWRkID0gZG9jLmFkZEV2ZW50TGlzdGVuZXIgPyBcXFwiYWRkRXZlbnRMaXN0ZW5lclxcXCIgOiBcXFwiYXR0YWNoRXZlbnRcXFwiO1xcbiAgdmFyIHJlbSA9IGRvYy5hZGRFdmVudExpc3RlbmVyID8gXFxcInJlbW92ZUV2ZW50TGlzdGVuZXJcXFwiIDogXFxcImRldGFjaEV2ZW50XFxcIjtcXG4gIHZhciBwcmUgPSBkb2MuYWRkRXZlbnRMaXN0ZW5lciA/IFxcXCJcXFwiIDogXFxcIm9uXFxcIjtcXG5cXG4gIHZhciBpbml0ID0gZnVuY3Rpb24gaW5pdChlKSB7XFxuICAgIGlmIChlLnR5cGUgPT09IFxcXCJyZWFkeXN0YXRlY2hhbmdlXFxcIiAmJiBkb2MucmVhZHlTdGF0ZSAhPT0gXFxcImNvbXBsZXRlXFxcIikge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICAoZS50eXBlID09PSBcXFwibG9hZFxcXCIgPyB3aW4gOiBkb2MpW3JlbV0ocHJlICsgZS50eXBlLCBpbml0LCBmYWxzZSk7XFxuXFxuICAgIGlmICghZG9uZSAmJiAoZG9uZSA9IHRydWUpKSB7XFxuICAgICAgcmV0dXJuIGZuLmNhbGwod2luLCBlLnR5cGUgfHwgZSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICB2YXIgcG9sbCA9IGZ1bmN0aW9uIHBvbGwoKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcm9vdC5kb1Njcm9sbChcXFwibGVmdFxcXCIpO1xcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgc2V0VGltZW91dChwb2xsLCA1MCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBpbml0KFxcXCJwb2xsXFxcIik7XFxuICB9O1xcblxcbiAgaWYgKGRvYy5yZWFkeVN0YXRlICE9PSBcXFwiY29tcGxldGVcXFwiKSB7XFxuICAgIGlmIChkb2MuY3JlYXRlRXZlbnRPYmplY3QgJiYgcm9vdC5kb1Njcm9sbCkge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICB0b3AgPSAhd2luLmZyYW1lRWxlbWVudDtcXG4gICAgICB9IGNhdGNoIChlcnJvcikge31cXG5cXG4gICAgICBpZiAodG9wKSB7XFxuICAgICAgICBwb2xsKCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGRvY1thZGRdKHByZSArIFxcXCJET01Db250ZW50TG9hZGVkXFxcIiwgaW5pdCwgZmFsc2UpO1xcbiAgICBkb2NbYWRkXShwcmUgKyBcXFwicmVhZHlzdGF0ZWNoYW5nZVxcXCIsIGluaXQsIGZhbHNlKTtcXG4gICAgcmV0dXJuIHdpblthZGRdKHByZSArIFxcXCJsb2FkXFxcIiwgaW5pdCwgZmFsc2UpO1xcbiAgfVxcbn07IC8vIEFzIGEgc2luZ2xlIGZ1bmN0aW9uIHRvIGJlIGFibGUgdG8gd3JpdGUgdGVzdHMuXFxuXFxuXFxuRHJvcHpvbmUuX2F1dG9EaXNjb3ZlckZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xcbiAgaWYgKERyb3B6b25lLmF1dG9EaXNjb3Zlcikge1xcbiAgICByZXR1cm4gRHJvcHpvbmUuZGlzY292ZXIoKTtcXG4gIH1cXG59O1xcblxcbmNvbnRlbnRMb2FkZWQod2luZG93LCBEcm9wem9uZS5fYXV0b0Rpc2NvdmVyRnVuY3Rpb24pO1xcblxcbmZ1bmN0aW9uIF9fZ3VhcmRfXyh2YWx1ZSwgdHJhbnNmb3JtKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiB2YWx1ZSAhPT0gbnVsbCA/IHRyYW5zZm9ybSh2YWx1ZSkgOiB1bmRlZmluZWQ7XFxufVxcblxcbmZ1bmN0aW9uIF9fZ3VhcmRNZXRob2RfXyhvYmosIG1ldGhvZE5hbWUsIHRyYW5zZm9ybSkge1xcbiAgaWYgKHR5cGVvZiBvYmogIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqW21ldGhvZE5hbWVdID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgIHJldHVybiB0cmFuc2Zvcm0ob2JqLCBtZXRob2ROYW1lKTtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICB9XFxufVxcblxcblxcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3Rvb2wvZHJvcHpvbmUuZGlzdC5qc1xcbiAvLy8gTWFrZSBEcm9wem9uZSBhIGdsb2JhbCB2YXJpYWJsZS5cXG5cXG53aW5kb3cuRHJvcHpvbmUgPSBEcm9wem9uZTtcXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkcm9wem9uZV9kaXN0ID0gKERyb3B6b25lKTtcXG5cXG59KCk7XFxuLyoqKioqKi8gXFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XFxuLyoqKioqKi8gfSkoKVxcbjtcXG59KTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJvcHpvbmUvZGlzdC9kcm9wem9uZS5qcz9cIik7LyoqKi99LC8qKiovXCIuL25vZGVfbW9kdWxlcy9mZWF0aGVyLWljb25zL2Rpc3QvZmVhdGhlci5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L2ZlYXRoZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqLyAvKioqL2Z1bmN0aW9uIG5vZGVfbW9kdWxlc0ZlYXRoZXJJY29uc0Rpc3RGZWF0aGVySnMobW9kdWxlLGV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyl7ZXZhbChcIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XFxuXFx0aWYodHJ1ZSlcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcXG5cXHRlbHNlIHt9XFxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXFxuLyoqKioqKi8gXFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxcbi8qKioqKiovIFxcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxcbi8qKioqKiovIFxcdFxcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XFxuLyoqKioqKi8gXFx0XFx0XFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XFxuLyoqKioqKi8gXFx0XFx0fVxcbi8qKioqKiovIFxcdFxcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXFxuLyoqKioqKi8gXFx0XFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xcbi8qKioqKiovIFxcdFxcdFxcdGk6IG1vZHVsZUlkLFxcbi8qKioqKiovIFxcdFxcdFxcdGw6IGZhbHNlLFxcbi8qKioqKiovIFxcdFxcdFxcdGV4cG9ydHM6IHt9XFxuLyoqKioqKi8gXFx0XFx0fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdFxcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0XFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxcbi8qKioqKiovIFxcdFxcdG1vZHVsZS5sID0gdHJ1ZTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdFxcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXFxuLyoqKioqKi8gXFx0XFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xcbi8qKioqKiovIFxcdH1cXG4vKioqKioqL1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xcbi8qKioqKiovXFxuLyoqKioqKi8gXFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XFxuLyoqKioqKi8gXFx0XFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xcbi8qKioqKiovIFxcdFxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XFxuLyoqKioqKi8gXFx0XFx0XFx0XFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcXG4vKioqKioqLyBcXHRcXHRcXHRcXHRlbnVtZXJhYmxlOiB0cnVlLFxcbi8qKioqKiovIFxcdFxcdFxcdFxcdGdldDogZ2V0dGVyXFxuLyoqKioqKi8gXFx0XFx0XFx0fSk7XFxuLyoqKioqKi8gXFx0XFx0fVxcbi8qKioqKiovIFxcdH07XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xcbi8qKioqKiovIFxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XFxuLyoqKioqKi8gXFx0fTtcXG4vKioqKioqL1xcbi8qKioqKiovIFxcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XFxuLyoqKioqKi8gXFx0XFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XFxuLyoqKioqKi8gXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcXG4vKioqKioqLyBcXHRcXHRcXHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xcbi8qKioqKiovIFxcdFxcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcXG4vKioqKioqLyBcXHRcXHRyZXR1cm4gZ2V0dGVyO1xcbi8qKioqKiovIFxcdH07XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFxcXCJcXFwiO1xcbi8qKioqKiovXFxuLyoqKioqKi9cXG4vKioqKioqLyBcXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcXG4vKioqKioqLyBcXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcXG4vKioqKioqLyB9KVxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqKioqKi8gKHtcXG5cXG4vKioqLyBcXFwiLi9kaXN0L2ljb25zLmpzb25cXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9kaXN0L2ljb25zLmpzb24gKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGFjdGl2aXR5LCBhaXJwbGF5LCBhbGVydC1jaXJjbGUsIGFsZXJ0LW9jdGFnb24sIGFsZXJ0LXRyaWFuZ2xlLCBhbGlnbi1jZW50ZXIsIGFsaWduLWp1c3RpZnksIGFsaWduLWxlZnQsIGFsaWduLXJpZ2h0LCBhbmNob3IsIGFwZXJ0dXJlLCBhcmNoaXZlLCBhcnJvdy1kb3duLWNpcmNsZSwgYXJyb3ctZG93bi1sZWZ0LCBhcnJvdy1kb3duLXJpZ2h0LCBhcnJvdy1kb3duLCBhcnJvdy1sZWZ0LWNpcmNsZSwgYXJyb3ctbGVmdCwgYXJyb3ctcmlnaHQtY2lyY2xlLCBhcnJvdy1yaWdodCwgYXJyb3ctdXAtY2lyY2xlLCBhcnJvdy11cC1sZWZ0LCBhcnJvdy11cC1yaWdodCwgYXJyb3ctdXAsIGF0LXNpZ24sIGF3YXJkLCBiYXItY2hhcnQtMiwgYmFyLWNoYXJ0LCBiYXR0ZXJ5LWNoYXJnaW5nLCBiYXR0ZXJ5LCBiZWxsLW9mZiwgYmVsbCwgYmx1ZXRvb3RoLCBib2xkLCBib29rLW9wZW4sIGJvb2ssIGJvb2ttYXJrLCBib3gsIGJyaWVmY2FzZSwgY2FsZW5kYXIsIGNhbWVyYS1vZmYsIGNhbWVyYSwgY2FzdCwgY2hlY2stY2lyY2xlLCBjaGVjay1zcXVhcmUsIGNoZWNrLCBjaGV2cm9uLWRvd24sIGNoZXZyb24tbGVmdCwgY2hldnJvbi1yaWdodCwgY2hldnJvbi11cCwgY2hldnJvbnMtZG93biwgY2hldnJvbnMtbGVmdCwgY2hldnJvbnMtcmlnaHQsIGNoZXZyb25zLXVwLCBjaHJvbWUsIGNpcmNsZSwgY2xpcGJvYXJkLCBjbG9jaywgY2xvdWQtZHJpenpsZSwgY2xvdWQtbGlnaHRuaW5nLCBjbG91ZC1vZmYsIGNsb3VkLXJhaW4sIGNsb3VkLXNub3csIGNsb3VkLCBjb2RlLCBjb2RlcGVuLCBjb2Rlc2FuZGJveCwgY29mZmVlLCBjb2x1bW5zLCBjb21tYW5kLCBjb21wYXNzLCBjb3B5LCBjb3JuZXItZG93bi1sZWZ0LCBjb3JuZXItZG93bi1yaWdodCwgY29ybmVyLWxlZnQtZG93biwgY29ybmVyLWxlZnQtdXAsIGNvcm5lci1yaWdodC1kb3duLCBjb3JuZXItcmlnaHQtdXAsIGNvcm5lci11cC1sZWZ0LCBjb3JuZXItdXAtcmlnaHQsIGNwdSwgY3JlZGl0LWNhcmQsIGNyb3AsIGNyb3NzaGFpciwgZGF0YWJhc2UsIGRlbGV0ZSwgZGlzYywgZGl2aWRlLWNpcmNsZSwgZGl2aWRlLXNxdWFyZSwgZGl2aWRlLCBkb2xsYXItc2lnbiwgZG93bmxvYWQtY2xvdWQsIGRvd25sb2FkLCBkcmliYmJsZSwgZHJvcGxldCwgZWRpdC0yLCBlZGl0LTMsIGVkaXQsIGV4dGVybmFsLWxpbmssIGV5ZS1vZmYsIGV5ZSwgZmFjZWJvb2ssIGZhc3QtZm9yd2FyZCwgZmVhdGhlciwgZmlnbWEsIGZpbGUtbWludXMsIGZpbGUtcGx1cywgZmlsZS10ZXh0LCBmaWxlLCBmaWxtLCBmaWx0ZXIsIGZsYWcsIGZvbGRlci1taW51cywgZm9sZGVyLXBsdXMsIGZvbGRlciwgZnJhbWVyLCBmcm93biwgZ2lmdCwgZ2l0LWJyYW5jaCwgZ2l0LWNvbW1pdCwgZ2l0LW1lcmdlLCBnaXQtcHVsbC1yZXF1ZXN0LCBnaXRodWIsIGdpdGxhYiwgZ2xvYmUsIGdyaWQsIGhhcmQtZHJpdmUsIGhhc2gsIGhlYWRwaG9uZXMsIGhlYXJ0LCBoZWxwLWNpcmNsZSwgaGV4YWdvbiwgaG9tZSwgaW1hZ2UsIGluYm94LCBpbmZvLCBpbnN0YWdyYW0sIGl0YWxpYywga2V5LCBsYXllcnMsIGxheW91dCwgbGlmZS1idW95LCBsaW5rLTIsIGxpbmssIGxpbmtlZGluLCBsaXN0LCBsb2FkZXIsIGxvY2ssIGxvZy1pbiwgbG9nLW91dCwgbWFpbCwgbWFwLXBpbiwgbWFwLCBtYXhpbWl6ZS0yLCBtYXhpbWl6ZSwgbWVoLCBtZW51LCBtZXNzYWdlLWNpcmNsZSwgbWVzc2FnZS1zcXVhcmUsIG1pYy1vZmYsIG1pYywgbWluaW1pemUtMiwgbWluaW1pemUsIG1pbnVzLWNpcmNsZSwgbWludXMtc3F1YXJlLCBtaW51cywgbW9uaXRvciwgbW9vbiwgbW9yZS1ob3Jpem9udGFsLCBtb3JlLXZlcnRpY2FsLCBtb3VzZS1wb2ludGVyLCBtb3ZlLCBtdXNpYywgbmF2aWdhdGlvbi0yLCBuYXZpZ2F0aW9uLCBvY3RhZ29uLCBwYWNrYWdlLCBwYXBlcmNsaXAsIHBhdXNlLWNpcmNsZSwgcGF1c2UsIHBlbi10b29sLCBwZXJjZW50LCBwaG9uZS1jYWxsLCBwaG9uZS1mb3J3YXJkZWQsIHBob25lLWluY29taW5nLCBwaG9uZS1taXNzZWQsIHBob25lLW9mZiwgcGhvbmUtb3V0Z29pbmcsIHBob25lLCBwaWUtY2hhcnQsIHBsYXktY2lyY2xlLCBwbGF5LCBwbHVzLWNpcmNsZSwgcGx1cy1zcXVhcmUsIHBsdXMsIHBvY2tldCwgcG93ZXIsIHByaW50ZXIsIHJhZGlvLCByZWZyZXNoLWNjdywgcmVmcmVzaC1jdywgcmVwZWF0LCByZXdpbmQsIHJvdGF0ZS1jY3csIHJvdGF0ZS1jdywgcnNzLCBzYXZlLCBzY2lzc29ycywgc2VhcmNoLCBzZW5kLCBzZXJ2ZXIsIHNldHRpbmdzLCBzaGFyZS0yLCBzaGFyZSwgc2hpZWxkLW9mZiwgc2hpZWxkLCBzaG9wcGluZy1iYWcsIHNob3BwaW5nLWNhcnQsIHNodWZmbGUsIHNpZGViYXIsIHNraXAtYmFjaywgc2tpcC1mb3J3YXJkLCBzbGFjaywgc2xhc2gsIHNsaWRlcnMsIHNtYXJ0cGhvbmUsIHNtaWxlLCBzcGVha2VyLCBzcXVhcmUsIHN0YXIsIHN0b3AtY2lyY2xlLCBzdW4sIHN1bnJpc2UsIHN1bnNldCwgdGFibGV0LCB0YWcsIHRhcmdldCwgdGVybWluYWwsIHRoZXJtb21ldGVyLCB0aHVtYnMtZG93biwgdGh1bWJzLXVwLCB0b2dnbGUtbGVmdCwgdG9nZ2xlLXJpZ2h0LCB0b29sLCB0cmFzaC0yLCB0cmFzaCwgdHJlbGxvLCB0cmVuZGluZy1kb3duLCB0cmVuZGluZy11cCwgdHJpYW5nbGUsIHRydWNrLCB0diwgdHdpdGNoLCB0d2l0dGVyLCB0eXBlLCB1bWJyZWxsYSwgdW5kZXJsaW5lLCB1bmxvY2ssIHVwbG9hZC1jbG91ZCwgdXBsb2FkLCB1c2VyLWNoZWNrLCB1c2VyLW1pbnVzLCB1c2VyLXBsdXMsIHVzZXIteCwgdXNlciwgdXNlcnMsIHZpZGVvLW9mZiwgdmlkZW8sIHZvaWNlbWFpbCwgdm9sdW1lLTEsIHZvbHVtZS0yLCB2b2x1bWUteCwgdm9sdW1lLCB3YXRjaCwgd2lmaS1vZmYsIHdpZmksIHdpbmQsIHgtY2lyY2xlLCB4LW9jdGFnb24sIHgtc3F1YXJlLCB4LCB5b3V0dWJlLCB6YXAtb2ZmLCB6YXAsIHpvb20taW4sIHpvb20tb3V0LCBkZWZhdWx0ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcXCJhY3Rpdml0eVxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIyMiAxMiAxOCAxMiAxNSAyMSA5IDMgNiAxMiAyIDEyXFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJhaXJwbGF5XFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk01IDE3SDRhMiAyIDAgMCAxLTItMlY1YTIgMiAwIDAgMSAyLTJoMTZhMiAyIDAgMCAxIDIgMnYxMGEyIDIgMCAwIDEtMiAyaC0xXFxcXFxcXCI+PC9wYXRoPjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjEyIDE1IDE3IDIxIDcgMjEgMTIgMTVcXFxcXFxcIj48L3BvbHlnb24+XFxcIixcXFwiYWxlcnQtY2lyY2xlXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxNlxcXFxcXFwiIHgyPVxcXFxcXFwiMTIuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjE2XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImFsZXJ0LW9jdGFnb25cXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCI3Ljg2IDIgMTYuMTQgMiAyMiA3Ljg2IDIyIDE2LjE0IDE2LjE0IDIyIDcuODYgMjIgMiAxNi4xNCAyIDcuODYgNy44NiAyXFxcXFxcXCI+PC9wb2x5Z29uPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxNlxcXFxcXFwiIHgyPVxcXFxcXFwiMTIuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjE2XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImFsZXJ0LXRyaWFuZ2xlXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xMC4yOSAzLjg2TDEuODIgMThhMiAyIDAgMCAwIDEuNzEgM2gxNi45NGEyIDIgMCAwIDAgMS43MS0zTDEzLjcxIDMuODZhMiAyIDAgMCAwLTMuNDIgMHpcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjEzXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjE3XFxcXFxcXCIgeDI9XFxcXFxcXCIxMi4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMTdcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiYWxpZ24tY2VudGVyXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxOFxcXFxcXFwiIHkxPVxcXFxcXFwiMTBcXFxcXFxcIiB4Mj1cXFxcXFxcIjZcXFxcXFxcIiB5Mj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjZcXFxcXFxcIiB4Mj1cXFxcXFxcIjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyMVxcXFxcXFwiIHkxPVxcXFxcXFwiMTRcXFxcXFxcIiB4Mj1cXFxcXFxcIjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjE0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMThcXFxcXFxcIiB5MT1cXFxcXFxcIjE4XFxcXFxcXCIgeDI9XFxcXFxcXCI2XFxcXFxcXCIgeTI9XFxcXFxcXCIxOFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJhbGlnbi1qdXN0aWZ5XFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIyMVxcXFxcXFwiIHkxPVxcXFxcXFwiMTBcXFxcXFxcIiB4Mj1cXFxcXFxcIjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjZcXFxcXFxcIiB4Mj1cXFxcXFxcIjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyMVxcXFxcXFwiIHkxPVxcXFxcXFwiMTRcXFxcXFxcIiB4Mj1cXFxcXFxcIjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjE0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjE4XFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxOFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJhbGlnbi1sZWZ0XFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxN1xcXFxcXFwiIHkxPVxcXFxcXFwiMTBcXFxcXFxcIiB4Mj1cXFxcXFxcIjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjZcXFxcXFxcIiB4Mj1cXFxcXFxcIjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyMVxcXFxcXFwiIHkxPVxcXFxcXFwiMTRcXFxcXFxcIiB4Mj1cXFxcXFxcIjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjE0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTdcXFxcXFxcIiB5MT1cXFxcXFxcIjE4XFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxOFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJhbGlnbi1yaWdodFxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjEwXFxcXFxcXCIgeDI9XFxcXFxcXCI3XFxcXFxcXCIgeTI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCI2XFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCI2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjE0XFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxNFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiN1xcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiYW5jaG9yXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCI1XFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjhcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk01IDEySDJhMTAgMTAgMCAwIDAgMjAgMGgtM1xcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJhcGVydHVyZVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjE0LjMxXFxcXFxcXCIgeTE9XFxcXFxcXCI4XFxcXFxcXCIgeDI9XFxcXFxcXCIyMC4wNVxcXFxcXFwiIHkyPVxcXFxcXFwiMTcuOTRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI5LjY5XFxcXFxcXCIgeTE9XFxcXFxcXCI4XFxcXFxcXCIgeDI9XFxcXFxcXCIyMS4xN1xcXFxcXFwiIHkyPVxcXFxcXFwiOFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjcuMzhcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIxMy4xMlxcXFxcXFwiIHkyPVxcXFxcXFwiMi4wNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjkuNjlcXFxcXFxcIiB5MT1cXFxcXFxcIjE2XFxcXFxcXCIgeDI9XFxcXFxcXCIzLjk1XFxcXFxcXCIgeTI9XFxcXFxcXCI2LjA2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTQuMzFcXFxcXFxcIiB5MT1cXFxcXFxcIjE2XFxcXFxcXCIgeDI9XFxcXFxcXCIyLjgzXFxcXFxcXCIgeTI9XFxcXFxcXCIxNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE2LjYyXFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTAuODhcXFxcXFxcIiB5Mj1cXFxcXFxcIjIxLjk0XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImFyY2hpdmVcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMjEgOCAyMSAyMSAzIDIxIDMgOFxcXFxcXFwiPjwvcG9seWxpbmU+PHJlY3QgeD1cXFxcXFxcIjFcXFxcXFxcIiB5PVxcXFxcXFwiM1xcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMjJcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCI1XFxcXFxcXCI+PC9yZWN0PjxsaW5lIHgxPVxcXFxcXFwiMTBcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIxNFxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiYXJyb3ctZG93bi1jaXJjbGVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjggMTIgMTIgMTYgMTYgMTJcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxNlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJhcnJvdy1kb3duLWxlZnRcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjE3XFxcXFxcXCIgeTE9XFxcXFxcXCI3XFxcXFxcXCIgeDI9XFxcXFxcXCI3XFxcXFxcXCIgeTI9XFxcXFxcXCIxN1xcXFxcXFwiPjwvbGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTcgMTcgNyAxNyA3IDdcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImFycm93LWRvd24tcmlnaHRcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjdcXFxcXFxcIiB5MT1cXFxcXFxcIjdcXFxcXFxcIiB4Mj1cXFxcXFxcIjE3XFxcXFxcXCIgeTI9XFxcXFxcXCIxN1xcXFxcXFwiPjwvbGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTcgNyAxNyAxNyA3IDE3XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJhcnJvdy1kb3duXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiNVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjE5XFxcXFxcXCI+PC9saW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxOSAxMiAxMiAxOSA1IDEyXFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJhcnJvdy1sZWZ0LWNpcmNsZVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTIgOCA4IDEyIDEyIDE2XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjE2XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiOFxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiYXJyb3ctbGVmdFxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMTlcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCI1XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTIgMTkgNSAxMiAxMiA1XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJhcnJvdy1yaWdodC1jaXJjbGVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjEyIDE2IDE2IDEyIDEyIDhcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJhcnJvdy1yaWdodFxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiNVxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjE5XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTIgNSAxOSAxMiAxMiAxOVxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiYXJyb3ctdXAtY2lyY2xlXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNiAxMiAxMiA4IDggMTJcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjE2XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiOFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJhcnJvdy11cC1sZWZ0XFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxN1xcXFxcXFwiIHkxPVxcXFxcXFwiMTdcXFxcXFxcIiB4Mj1cXFxcXFxcIjdcXFxcXFxcIiB5Mj1cXFxcXFxcIjdcXFxcXFxcIj48L2xpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjcgMTcgNyA3IDE3IDdcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImFycm93LXVwLXJpZ2h0XFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCI3XFxcXFxcXCIgeTE9XFxcXFxcXCIxN1xcXFxcXFwiIHgyPVxcXFxcXFwiMTdcXFxcXFxcIiB5Mj1cXFxcXFxcIjdcXFxcXFxcIj48L2xpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjcgNyAxNyA3IDE3IDE3XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJhcnJvdy11cFxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjE5XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiNVxcXFxcXFwiPjwvbGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiNSAxMiAxMiA1IDE5IDEyXFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJhdC1zaWduXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCI0XFxcXFxcXCI+PC9jaXJjbGU+PHBhdGggZD1cXFxcXFxcIk0xNiA4djVhMyAzIDAgMCAwIDYgMHYtMWExMCAxMCAwIDEgMC0zLjkyIDcuOTRcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiYXdhcmRcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjhcXFxcXFxcIiByPVxcXFxcXFwiN1xcXFxcXFwiPjwvY2lyY2xlPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI4LjIxIDEzLjg5IDcgMjMgMTIgMjAgMTcgMjMgMTUuNzkgMTMuODhcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImJhci1jaGFydC0yXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxOFxcXFxcXFwiIHkxPVxcXFxcXFwiMjBcXFxcXFxcIiB4Mj1cXFxcXFxcIjE4XFxcXFxcXCIgeTI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMFxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI2XFxcXFxcXCIgeTE9XFxcXFxcXCIyMFxcXFxcXFwiIHgyPVxcXFxcXFwiNlxcXFxcXFwiIHkyPVxcXFxcXFwiMTRcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiYmFyLWNoYXJ0XFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMjBcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE4XFxcXFxcXCIgeTE9XFxcXFxcXCIyMFxcXFxcXFwiIHgyPVxcXFxcXFwiMThcXFxcXFxcIiB5Mj1cXFxcXFxcIjRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI2XFxcXFxcXCIgeTE9XFxcXFxcXCIyMFxcXFxcXFwiIHgyPVxcXFxcXFwiNlxcXFxcXFwiIHkyPVxcXFxcXFwiMTZcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiYmF0dGVyeS1jaGFyZ2luZ1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNNSAxOEgzYTIgMiAwIDAgMS0yLTJWOGEyIDIgMCAwIDEgMi0yaDMuMTlNMTUgNmgyYTIgMiAwIDAgMSAyIDJ2OGEyIDIgMCAwIDEtMiAyaC0zLjE5XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMjNcXFxcXFxcIiB5MT1cXFxcXFxcIjEzXFxcXFxcXCIgeDI9XFxcXFxcXCIyM1xcXFxcXFwiIHkyPVxcXFxcXFwiMTFcXFxcXFxcIj48L2xpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjExIDYgNyAxMiAxMyAxMiA5IDE4XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJiYXR0ZXJ5XFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjFcXFxcXFxcIiB5PVxcXFxcXFwiNlxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMThcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxMlxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD48bGluZSB4MT1cXFxcXFxcIjIzXFxcXFxcXCIgeTE9XFxcXFxcXCIxM1xcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjExXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImJlbGwtb2ZmXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xMy43MyAyMWEyIDIgMCAwIDEtMy40NiAwXFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMTguNjMgMTNBMTcuODkgMTcuODkgMCAwIDEgMTggOFxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTYuMjYgNi4yNkE1Ljg2IDUuODYgMCAwIDAgNiA4YzAgNy0zIDktMyA5aDE0XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMTggOGE2IDYgMCAwIDAtOS4zMy01XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMVxcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImJlbGxcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE4IDhBNiA2IDAgMCAwIDYgOGMwIDctMyA5LTMgOWgxOHMtMy0yLTMtOVxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTEzLjczIDIxYTIgMiAwIDAgMS0zLjQ2IDBcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiYmx1ZXRvb3RoXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjYuNSA2LjUgMTcuNSAxNy41IDEyIDIzIDEyIDEgMTcuNSA2LjUgNi41IDE3LjVcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImJvbGRcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTYgNGg4YTQgNCAwIDAgMSA0IDQgNCA0IDAgMCAxLTQgNEg2elxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTYgMTJoOWE0IDQgMCAwIDEgNCA0IDQgNCAwIDAgMS00IDRINnpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiYm9vay1vcGVuXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yIDNoNmE0IDQgMCAwIDEgNCA0djE0YTMgMyAwIDAgMC0zLTNIMnpcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0yMiAzaC02YTQgNCAwIDAgMC00IDR2MTRhMyAzIDAgMCAxIDMtM2g3elxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJib29rXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk00IDE5LjVBMi41IDIuNSAwIDAgMSA2LjUgMTdIMjBcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk02LjUgMkgyMHYyMEg2LjVBMi41IDIuNSAwIDAgMSA0IDE5LjV2LTE1QTIuNSAyLjUgMCAwIDEgNi41IDJ6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImJvb2ttYXJrXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xOSAyMWwtNy01LTcgNVY1YTIgMiAwIDAgMSAyLTJoMTBhMiAyIDAgMCAxIDIgMnpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiYm94XFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMSAxNlY4YTIgMiAwIDAgMC0xLTEuNzNsLTctNGEyIDIgMCAwIDAtMiAwbC03IDRBMiAyIDAgMCAwIDMgOHY4YTIgMiAwIDAgMCAxIDEuNzNsNyA0YTIgMiAwIDAgMCAyIDBsNy00QTIgMiAwIDAgMCAyMSAxNnpcXFxcXFxcIj48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjMuMjcgNi45NiAxMiAxMi4wMSAyMC43MyA2Ljk2XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMi4wOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImJyaWVmY2FzZVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIyXFxcXFxcXCIgeT1cXFxcXFxcIjdcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjIwXFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMTRcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PHBhdGggZD1cXFxcXFxcIk0xNiAyMVY1YTIgMiAwIDAgMC0yLTJoLTRhMiAyIDAgMCAwLTIgMnYxNlxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjYWxlbmRhclxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjRcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMThcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PGxpbmUgeDE9XFxcXFxcXCIxNlxcXFxcXFwiIHkxPVxcXFxcXFwiMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTZcXFxcXFxcIiB5Mj1cXFxcXFxcIjZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIyXFxcXFxcXCIgeDI9XFxcXFxcXCI4XFxcXFxcXCIgeTI9XFxcXFxcXCI2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiM1xcXFxcXFwiIHkxPVxcXFxcXFwiMTBcXFxcXFxcIiB4Mj1cXFxcXFxcIjIxXFxcXFxcXCIgeTI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJjYW1lcmEtb2ZmXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxXFxcXFxcXCIgeDI9XFxcXFxcXCIyM1xcXFxcXFwiIHkyPVxcXFxcXFwiMjNcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk0yMSAyMUgzYTIgMiAwIDAgMS0yLTJWOGEyIDIgMCAwIDEgMi0yaDNtMy0zaDZsMiAzaDRhMiAyIDAgMCAxIDIgMnY5LjM0bS03LjcyLTIuMDZhNCA0IDAgMSAxLTUuNTYtNS41NlxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjYW1lcmFcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIzIDE5YTIgMiAwIDAgMS0yIDJIM2EyIDIgMCAwIDEtMi0yVjhhMiAyIDAgMCAxIDItMmg0bDItM2g2bDIgM2g0YTIgMiAwIDAgMSAyIDJ6XFxcXFxcXCI+PC9wYXRoPjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTNcXFxcXFxcIiByPVxcXFxcXFwiNFxcXFxcXFwiPjwvY2lyY2xlPlxcXCIsXFxcImNhc3RcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIgMTYuMUE1IDUgMCAwIDEgNS45IDIwTTIgMTIuMDVBOSA5IDAgMCAxIDkuOTUgMjBNMiA4VjZhMiAyIDAgMCAxIDItMmgxNmEyIDIgMCAwIDEgMiAydjEyYTIgMiAwIDAgMS0yIDJoLTZcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMFxcXFxcXFwiIHgyPVxcXFxcXFwiMi4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMjBcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiY2hlY2stY2lyY2xlXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMiAxMS4wOFYxMmExMCAxMCAwIDEgMS01LjkzLTkuMTRcXFxcXFxcIj48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIyIDQgMTIgMTQuMDEgOSAxMS4wMVxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiY2hlY2stc3F1YXJlXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjkgMTEgMTIgMTQgMjIgNFxcXFxcXFwiPjwvcG9seWxpbmU+PHBhdGggZD1cXFxcXFxcIk0yMSAxMnY3YTIgMiAwIDAgMS0yIDJINWEyIDIgMCAwIDEtMi0yVjVhMiAyIDAgMCAxIDItMmgxMVxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjaGVja1xcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIyMCA2IDkgMTcgNCAxMlxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiY2hldnJvbi1kb3duXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjYgOSAxMiAxNSAxOCA5XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJjaGV2cm9uLWxlZnRcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTUgMTggOSAxMiAxNSA2XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJjaGV2cm9uLXJpZ2h0XFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjkgMTggMTUgMTIgOSA2XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJjaGV2cm9uLXVwXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE4IDE1IDEyIDkgNiAxNVxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiY2hldnJvbnMtZG93blxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI3IDEzIDEyIDE4IDE3IDEzXFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiNyA2IDEyIDExIDE3IDZcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImNoZXZyb25zLWxlZnRcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTEgMTcgNiAxMiAxMSA3XFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTggMTcgMTMgMTIgMTggN1xcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiY2hldnJvbnMtcmlnaHRcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTMgMTcgMTggMTIgMTMgN1xcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjYgMTcgMTEgMTIgNiA3XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJjaGV2cm9ucy11cFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNyAxMSAxMiA2IDcgMTFcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNyAxOCAxMiAxMyA3IDE4XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJjaHJvbWVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCI0XFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIyMS4xN1xcXFxcXFwiIHkxPVxcXFxcXFwiOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjhcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIzLjk1XFxcXFxcXCIgeTE9XFxcXFxcXCI2LjA2XFxcXFxcXCIgeDI9XFxcXFxcXCI4LjU0XFxcXFxcXCIgeTI9XFxcXFxcXCIxNFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEwLjg4XFxcXFxcXCIgeTE9XFxcXFxcXCIyMS45NFxcXFxcXFwiIHgyPVxcXFxcXFwiMTUuNDZcXFxcXFxcIiB5Mj1cXFxcXFxcIjE0XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImNpcmNsZVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJjbGlwYm9hcmRcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE2IDRoMmEyIDIgMCAwIDEgMiAydjE0YTIgMiAwIDAgMS0yIDJINmEyIDIgMCAwIDEtMi0yVjZhMiAyIDAgMCAxIDItMmgyXFxcXFxcXCI+PC9wYXRoPjxyZWN0IHg9XFxcXFxcXCI4XFxcXFxcXCIgeT1cXFxcXFxcIjJcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjhcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCI0XFxcXFxcXCIgcng9XFxcXFxcXCIxXFxcXFxcXCIgcnk9XFxcXFxcXCIxXFxcXFxcXCI+PC9yZWN0PlxcXCIsXFxcImNsb2NrXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxMiA2IDEyIDEyIDE2IDE0XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJjbG91ZC1kcml6emxlXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIxOVxcXFxcXFwiIHgyPVxcXFxcXFwiOFxcXFxcXFwiIHkyPVxcXFxcXFwiMjFcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIxM1xcXFxcXFwiIHgyPVxcXFxcXFwiOFxcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNlxcXFxcXFwiIHkxPVxcXFxcXFwiMTlcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIyMVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE2XFxcXFxcXCIgeTE9XFxcXFxcXCIxM1xcXFxcXFwiIHgyPVxcXFxcXFwiMTZcXFxcXFxcIiB5Mj1cXFxcXFxcIjE1XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjIxXFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMjNcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTVcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxN1xcXFxcXFwiPjwvbGluZT48cGF0aCBkPVxcXFxcXFwiTTIwIDE2LjU4QTUgNSAwIDAgMCAxOCA3aC0xLjI2QTggOCAwIDEgMCA0IDE1LjI1XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImNsb3VkLWxpZ2h0bmluZ1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTkgMTYuOUE1IDUgMCAwIDAgMTggN2gtMS4yNmE4IDggMCAxIDAtMTEuNjIgOVxcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTMgMTEgOSAxNyAxNSAxNyAxMSAyM1xcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwiY2xvdWQtb2ZmXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMi42MSAxNi45NUE1IDUgMCAwIDAgMTggMTBoLTEuMjZhOCA4IDAgMCAwLTcuMDUtNk01IDVhOCA4IDAgMCAwIDQgMTVoOWE1IDUgMCAwIDAgMS43LS4zXFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMVxcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImNsb3VkLXJhaW5cXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjE2XFxcXFxcXCIgeTE9XFxcXFxcXCIxM1xcXFxcXFwiIHgyPVxcXFxcXFwiMTZcXFxcXFxcIiB5Mj1cXFxcXFxcIjIxXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMTNcXFxcXFxcIiB4Mj1cXFxcXFxcIjhcXFxcXFxcIiB5Mj1cXFxcXFxcIjIxXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjE1XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMjNcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk0yMCAxNi41OEE1IDUgMCAwIDAgMTggN2gtMS4yNkE4IDggMCAxIDAgNCAxNS4yNVxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjbG91ZC1zbm93XFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMCAxNy41OEE1IDUgMCAwIDAgMTggOGgtMS4yNkE4IDggMCAxIDAgNCAxNi4yNVxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjE2XFxcXFxcXCIgeDI9XFxcXFxcXCI4LjAxXFxcXFxcXCIgeTI9XFxcXFxcXCIxNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjIwXFxcXFxcXCIgeDI9XFxcXFxcXCI4LjAxXFxcXFxcXCIgeTI9XFxcXFxcXCIyMFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTIuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjE4XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjIyXFxcXFxcXCIgeDI9XFxcXFxcXCIxMi4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMjJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNlxcXFxcXFwiIHkxPVxcXFxcXFwiMTZcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2LjAxXFxcXFxcXCIgeTI9XFxcXFxcXCIxNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE2XFxcXFxcXCIgeTE9XFxcXFxcXCIyMFxcXFxcXFwiIHgyPVxcXFxcXFwiMTYuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjIwXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImNsb3VkXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xOCAxMGgtMS4yNkE4IDggMCAxIDAgOSAyMGg5YTUgNSAwIDAgMCAwLTEwelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjb2RlXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE2IDE4IDIyIDEyIDE2IDZcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI4IDYgMiAxMiA4IDE4XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJjb2RlcGVuXFxcIjpcXFwiPHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMTIgMiAyMiA4LjUgMjIgMTUuNSAxMiAyMiAyIDE1LjUgMiA4LjUgMTIgMlxcXFxcXFwiPjwvcG9seWdvbj48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjE1LjVcXFxcXFxcIj48L2xpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIyIDguNSAxMiAxNS41IDIgOC41XFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMiAxNS41IDEyIDguNSAyMiAxNS41XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyXFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiOC41XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImNvZGVzYW5kYm94XFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMSAxNlY4YTIgMiAwIDAgMC0xLTEuNzNsLTctNGEyIDIgMCAwIDAtMiAwbC03IDRBMiAyIDAgMCAwIDMgOHY4YTIgMiAwIDAgMCAxIDEuNzNsNyA0YTIgMiAwIDAgMCAyIDBsNy00QTIgMiAwIDAgMCAyMSAxNnpcXFxcXFxcIj48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjcuNSA0LjIxIDEyIDYuODEgMTYuNSA0LjIxXFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiNy41IDE5Ljc5IDcuNSAxNC42IDMgMTJcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIyMSAxMiAxNi41IDE0LjYgMTYuNSAxOS43OVxcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjMuMjcgNi45NiAxMiAxMi4wMSAyMC43MyA2Ljk2XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMi4wOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImNvZmZlZVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTggOGgxYTQgNCAwIDAgMSAwIDhoLTFcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0yIDhoMTZ2OWE0IDQgMCAwIDEtNCA0SDZhNCA0IDAgMCAxLTQtNFY4elxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjZcXFxcXFxcIiB5MT1cXFxcXFxcIjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjZcXFxcXFxcIiB5Mj1cXFxcXFxcIjRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMFxcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTBcXFxcXFxcIiB5Mj1cXFxcXFxcIjRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNFxcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTRcXFxcXFxcIiB5Mj1cXFxcXFxcIjRcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiY29sdW1uc1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTIgM2g3YTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMmgtN20wLTE4SDVhMiAyIDAgMCAwLTIgMnYxNGEyIDIgMCAwIDAgMiAyaDdtMC0xOHYxOFxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjb21tYW5kXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xOCAzYTMgMyAwIDAgMC0zIDN2MTJhMyAzIDAgMCAwIDMgMyAzIDMgMCAwIDAgMy0zIDMgMyAwIDAgMC0zLTNINmEzIDMgMCAwIDAtMyAzIDMgMyAwIDAgMCAzIDMgMyAzIDAgMCAwIDMtM1Y2YTMgMyAwIDAgMC0zLTMgMyAzIDAgMCAwLTMgMyAzIDMgMCAwIDAgMyAzaDEyYTMgMyAwIDAgMCAzLTMgMyAzIDAgMCAwLTMtM3pcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiY29tcGFzc1xcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48cG9seWdvbiBwb2ludHM9XFxcXFxcXCIxNi4yNCA3Ljc2IDE0LjEyIDE0LjEyIDcuNzYgMTYuMjQgOS44OCA5Ljg4IDE2LjI0IDcuNzZcXFxcXFxcIj48L3BvbHlnb24+XFxcIixcXFwiY29weVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCI5XFxcXFxcXCIgeT1cXFxcXFxcIjlcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjEzXFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMTNcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PHBhdGggZD1cXFxcXFxcIk01IDE1SDRhMiAyIDAgMCAxLTItMlY0YTIgMiAwIDAgMSAyLTJoOWEyIDIgMCAwIDEgMiAydjFcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiY29ybmVyLWRvd24tbGVmdFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI5IDEwIDQgMTUgOSAyMFxcXFxcXFwiPjwvcG9seWxpbmU+PHBhdGggZD1cXFxcXFxcIk0yMCA0djdhNCA0IDAgMCAxLTQgNEg0XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImNvcm5lci1kb3duLXJpZ2h0XFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE1IDEwIDIwIDE1IDE1IDIwXFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTQgNHY3YTQgNCAwIDAgMCA0IDRoMTJcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiY29ybmVyLWxlZnQtZG93blxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNCAxNSA5IDIwIDQgMTVcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjAgNGgtN2E0IDQgMCAwIDAtNCA0djEyXFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImNvcm5lci1sZWZ0LXVwXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE0IDkgOSA0IDQgOVxcXFxcXFwiPjwvcG9seWxpbmU+PHBhdGggZD1cXFxcXFxcIk0yMCAyMGgtN2E0IDQgMCAwIDEtNC00VjRcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiY29ybmVyLXJpZ2h0LWRvd25cXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTAgMTUgMTUgMjAgMjAgMTVcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNNCA0aDdhNCA0IDAgMCAxIDQgNHYxMlxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjb3JuZXItcmlnaHQtdXBcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTAgOSAxNSA0IDIwIDlcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNNCAyMGg3YTQgNCAwIDAgMCA0LTRWNFxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjb3JuZXItdXAtbGVmdFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI5IDE0IDQgOSA5IDRcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjAgMjB2LTdhNCA0IDAgMCAwLTQtNEg0XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImNvcm5lci11cC1yaWdodFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNSAxNCAyMCA5IDE1IDRcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNNCAyMHYtN2E0IDQgMCAwIDEgNC00aDEyXFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImNwdVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCI0XFxcXFxcXCIgeT1cXFxcXFxcIjRcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE2XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMTZcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PHJlY3QgeD1cXFxcXFxcIjlcXFxcXFxcIiB5PVxcXFxcXFwiOVxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiNlxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjZcXFxcXFxcIj48L3JlY3Q+PGxpbmUgeDE9XFxcXFxcXCI5XFxcXFxcXCIgeTE9XFxcXFxcXCIxXFxcXFxcXCIgeDI9XFxcXFxcXCI5XFxcXFxcXCIgeTI9XFxcXFxcXCI0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTVcXFxcXFxcIiB5MT1cXFxcXFxcIjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjE1XFxcXFxcXCIgeTI9XFxcXFxcXCI0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOVxcXFxcXFwiIHkxPVxcXFxcXFwiMjBcXFxcXFxcIiB4Mj1cXFxcXFxcIjlcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTVcXFxcXFxcIiB5MT1cXFxcXFxcIjIwXFxcXFxcXCIgeDI9XFxcXFxcXCIxNVxcXFxcXFwiIHkyPVxcXFxcXFwiMjNcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyMFxcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjlcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyMFxcXFxcXFwiIHkxPVxcXFxcXFwiMTRcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxNFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjFcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjRcXFxcXFxcIiB5Mj1cXFxcXFxcIjlcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxNFxcXFxcXFwiIHgyPVxcXFxcXFwiNFxcXFxcXFwiIHkyPVxcXFxcXFwiMTRcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiY3JlZGl0LWNhcmRcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiMVxcXFxcXFwiIHk9XFxcXFxcXCI0XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIyMlxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjE2XFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxsaW5lIHgxPVxcXFxcXFwiMVxcXFxcXFwiIHkxPVxcXFxcXFwiMTBcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJjcm9wXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk02LjEzIDFMNiAxNmEyIDIgMCAwIDAgMiAyaDE1XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMSA2LjEzTDE2IDZhMiAyIDAgMCAxIDIgMnYxNVxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJjcm9zc2hhaXJcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIyMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjE4XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjZcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIyXFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCI2XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjE4XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImRhdGFiYXNlXFxcIjpcXFwiPGVsbGlwc2UgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiNVxcXFxcXFwiIHJ4PVxcXFxcXFwiOVxcXFxcXFwiIHJ5PVxcXFxcXFwiM1xcXFxcXFwiPjwvZWxsaXBzZT48cGF0aCBkPVxcXFxcXFwiTTIxIDEyYzAgMS42Ni00IDMtOSAzcy05LTEuMzQtOS0zXFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMyA1djE0YzAgMS42NiA0IDMgOSAzczktMS4zNCA5LTNWNVxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJkZWxldGVcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIxIDRIOGwtNyA4IDcgOGgxM2EyIDIgMCAwIDAgMi0yVjZhMiAyIDAgMCAwLTItMnpcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIxOFxcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjE1XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjE4XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJkaXNjXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiM1xcXFxcXFwiPjwvY2lyY2xlPlxcXCIsXFxcImRpdmlkZS1jaXJjbGVcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIxNlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTZcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCI4XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiOFxcXFxcXFwiPjwvbGluZT48Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+XFxcIixcXFwiZGl2aWRlLXNxdWFyZVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjNcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMThcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTZcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjE2XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjhcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiZGl2aWRlXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCI2XFxcXFxcXCIgcj1cXFxcXFxcIjJcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjVcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIxOVxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxOFxcXFxcXFwiIHI9XFxcXFxcXCIyXFxcXFxcXCI+PC9jaXJjbGU+XFxcIixcXFwiZG9sbGFyLXNpZ25cXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxXFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMjNcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk0xNyA1SDkuNWEzLjUgMy41IDAgMCAwIDAgN2g1YTMuNSAzLjUgMCAwIDEgMCA3SDZcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiZG93bmxvYWQtY2xvdWRcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiOCAxNyAxMiAyMSAxNiAxN1xcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIyMVxcXFxcXFwiPjwvbGluZT48cGF0aCBkPVxcXFxcXFwiTTIwLjg4IDE4LjA5QTUgNSAwIDAgMCAxOCA5aC0xLjI2QTggOCAwIDEgMCAzIDE2LjI5XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImRvd25sb2FkXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMSAxNXY0YTIgMiAwIDAgMS0yIDJINWEyIDIgMCAwIDEtMi0ydi00XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI3IDEwIDEyIDE1IDE3IDEwXFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxNVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjNcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiZHJpYmJibGVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PHBhdGggZD1cXFxcXFxcIk04LjU2IDIuNzVjNC4zNyA2LjAzIDYuMDIgOS40MiA4LjAzIDE3LjcybTIuNTQtMTUuMzhjLTMuNzIgNC4zNS04Ljk0IDUuNjYtMTYuODggNS44NW0xOS41IDEuOWMtMy41LS45My02LjYzLS44Mi04Ljk0IDAtMi41OC45Mi01LjAxIDIuODYtNy40NCA2LjMyXFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImRyb3BsZXRcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTEyIDIuNjlsNS42NiA1LjY2YTggOCAwIDEgMS0xMS4zMSAwelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJlZGl0LTJcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE3IDNhMi44MjggMi44MjggMCAxIDEgNCA0TDcuNSAyMC41IDIgMjJsMS41LTUuNUwxNyAzelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJlZGl0LTNcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTEyIDIwaDlcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xNi41IDMuNWEyLjEyMSAyLjEyMSAwIDAgMSAzIDNMNyAxOWwtNCAxIDEtNEwxNi41IDMuNXpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiZWRpdFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTEgNEg0YTIgMiAwIDAgMC0yIDJ2MTRhMiAyIDAgMCAwIDIgMmgxNGEyIDIgMCAwIDAgMi0ydi03XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMTguNSAyLjVhMi4xMjEgMi4xMjEgMCAwIDEgMyAzTDEyIDE1bC00IDEgMS00IDkuNS05LjV6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImV4dGVybmFsLWxpbmtcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE4IDEzdjZhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJWOGEyIDIgMCAwIDEgMi0yaDZcXFxcXFxcIj48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE1IDMgMjEgMyAyMSA5XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjEwXFxcXFxcXCIgeTE9XFxcXFxcXCIxNFxcXFxcXFwiIHgyPVxcXFxcXFwiMjFcXFxcXFxcIiB5Mj1cXFxcXFxcIjNcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiZXllLW9mZlxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTcuOTQgMTcuOTRBMTAuMDcgMTAuMDcgMCAwIDEgMTIgMjBjLTcgMC0xMS04LTExLThhMTguNDUgMTguNDUgMCAwIDEgNS4wNi01Ljk0TTkuOSA0LjI0QTkuMTIgOS4xMiAwIDAgMSAxMiA0YzcgMCAxMSA4IDExIDhhMTguNSAxOC41IDAgMCAxLTIuMTYgMy4xOW0tNi43Mi0xLjA3YTMgMyAwIDEgMS00LjI0LTQuMjRcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxXFxcXFxcXCIgeDI9XFxcXFxcXCIyM1xcXFxcXFwiIHkyPVxcXFxcXFwiMjNcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiZXllXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xIDEyczQtOCAxMS04IDExIDggMTEgOC00IDgtMTEgOC0xMS04LTExLTh6XFxcXFxcXCI+PC9wYXRoPjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiM1xcXFxcXFwiPjwvY2lyY2xlPlxcXCIsXFxcImZhY2Vib29rXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xOCAyaC0zYTUgNSAwIDAgMC01IDV2M0g3djRoM3Y4aDR2LThoM2wxLTRoLTRWN2ExIDEgMCAwIDEgMS0xaDN6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImZhc3QtZm9yd2FyZFxcXCI6XFxcIjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjEzIDE5IDIyIDEyIDEzIDUgMTMgMTlcXFxcXFxcIj48L3BvbHlnb24+PHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMiAxOSAxMSAxMiAyIDUgMiAxOVxcXFxcXFwiPjwvcG9seWdvbj5cXFwiLFxcXCJmZWF0aGVyXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMC4yNCAxMi4yNGE2IDYgMCAwIDAtOC40OS04LjQ5TDUgMTAuNVYxOWg4LjV6XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMTZcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjJcXFxcXFxcIiB5Mj1cXFxcXFxcIjIyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTcuNVxcXFxcXFwiIHkxPVxcXFxcXFwiMTVcXFxcXFxcIiB4Mj1cXFxcXFxcIjlcXFxcXFxcIiB5Mj1cXFxcXFxcIjE1XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImZpZ21hXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk01IDUuNUEzLjUgMy41IDAgMCAxIDguNSAySDEydjdIOC41QTMuNSAzLjUgMCAwIDEgNSA1LjV6XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMTIgMmgzLjVhMy41IDMuNSAwIDEgMSAwIDdIMTJWMnpcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xMiAxMi41YTMuNSAzLjUgMCAxIDEgNyAwIDMuNSAzLjUgMCAxIDEtNyAwelxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTUgMTkuNUEzLjUgMy41IDAgMCAxIDguNSAxNkgxMnYzLjVhMy41IDMuNSAwIDEgMS03IDB6XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNNSAxMi41QTMuNSAzLjUgMCAwIDEgOC41IDlIMTJ2N0g4LjVBMy41IDMuNSAwIDAgMSA1IDEyLjV6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImZpbGUtbWludXNcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE0IDJINmEyIDIgMCAwIDAtMiAydjE2YTIgMiAwIDAgMCAyIDJoMTJhMiAyIDAgMCAwIDItMlY4elxcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTQgMiAxNCA4IDIwIDhcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiOVxcXFxcXFwiIHkxPVxcXFxcXFwiMTVcXFxcXFxcIiB4Mj1cXFxcXFxcIjE1XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJmaWxlLXBsdXNcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE0IDJINmEyIDIgMCAwIDAtMiAydjE2YTIgMiAwIDAgMCAyIDJoMTJhMiAyIDAgMCAwIDItMlY4elxcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTQgMiAxNCA4IDIwIDhcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjE4XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI5XFxcXFxcXCIgeTE9XFxcXFxcXCIxNVxcXFxcXFwiIHgyPVxcXFxcXFwiMTVcXFxcXFxcIiB5Mj1cXFxcXFxcIjE1XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImZpbGUtdGV4dFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTQgMkg2YTIgMiAwIDAgMC0yIDJ2MTZhMiAyIDAgMCAwIDIgMmgxMmEyIDIgMCAwIDAgMi0yVjh6XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNCAyIDE0IDggMjAgOFxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNlxcXFxcXFwiIHkxPVxcXFxcXFwiMTNcXFxcXFxcIiB4Mj1cXFxcXFxcIjhcXFxcXFxcIiB5Mj1cXFxcXFxcIjEzXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTZcXFxcXFxcIiB5MT1cXFxcXFxcIjE3XFxcXFxcXCIgeDI9XFxcXFxcXCI4XFxcXFxcXCIgeTI9XFxcXFxcXCIxN1xcXFxcXFwiPjwvbGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTAgOSA5IDkgOCA5XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJmaWxlXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xMyAySDZhMiAyIDAgMCAwLTIgMnYxNmEyIDIgMCAwIDAgMiAyaDEyYTIgMiAwIDAgMCAyLTJWOXpcXFxcXFxcIj48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjEzIDIgMTMgOSAyMCA5XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJmaWxtXFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjJcXFxcXFxcIiB5PVxcXFxcXFwiMlxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMjBcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIyMFxcXFxcXFwiIHJ4PVxcXFxcXFwiMi4xOFxcXFxcXFwiIHJ5PVxcXFxcXFwiMi4xOFxcXFxcXFwiPjwvcmVjdD48bGluZSB4MT1cXFxcXFxcIjdcXFxcXFxcIiB5MT1cXFxcXFxcIjJcXFxcXFxcIiB4Mj1cXFxcXFxcIjdcXFxcXFxcIiB5Mj1cXFxcXFxcIjIyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTdcXFxcXFxcIiB5MT1cXFxcXFxcIjJcXFxcXFxcIiB4Mj1cXFxcXFxcIjE3XFxcXFxcXCIgeTI9XFxcXFxcXCIyMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjJcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIyMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyXFxcXFxcXCIgeTE9XFxcXFxcXCI3XFxcXFxcXCIgeDI9XFxcXFxcXCI3XFxcXFxcXCIgeTI9XFxcXFxcXCI3XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTdcXFxcXFxcIiB4Mj1cXFxcXFxcIjdcXFxcXFxcIiB5Mj1cXFxcXFxcIjE3XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTdcXFxcXFxcIiB5MT1cXFxcXFxcIjE3XFxcXFxcXCIgeDI9XFxcXFxcXCIyMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTdcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxN1xcXFxcXFwiIHkxPVxcXFxcXFwiN1xcXFxcXFwiIHgyPVxcXFxcXFwiMjJcXFxcXFxcIiB5Mj1cXFxcXFxcIjdcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiZmlsdGVyXFxcIjpcXFwiPHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMjIgMyAyIDMgMTAgMTIuNDYgMTAgMTkgMTQgMjEgMTQgMTIuNDYgMjIgM1xcXFxcXFwiPjwvcG9seWdvbj5cXFwiLFxcXCJmbGFnXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk00IDE1czEtMSA0LTEgNSAyIDggMiA0LTEgNC0xVjNzLTEgMS00IDEtNS0yLTgtMi00IDEtNCAxelxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjRcXFxcXFxcIiB5MT1cXFxcXFxcIjIyXFxcXFxcXCIgeDI9XFxcXFxcXCI0XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJmb2xkZXItbWludXNcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIyIDE5YTIgMiAwIDAgMS0yIDJINGEyIDIgMCAwIDEtMi0yVjVhMiAyIDAgMCAxIDItMmg1bDIgM2g5YTIgMiAwIDAgMSAyIDJ6XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiOVxcXFxcXFwiIHkxPVxcXFxcXFwiMTRcXFxcXFxcIiB4Mj1cXFxcXFxcIjE1XFxcXFxcXCIgeTI9XFxcXFxcXCIxNFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJmb2xkZXItcGx1c1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjIgMTlhMiAyIDAgMCAxLTIgMkg0YTIgMiAwIDAgMS0yLTJWNWEyIDIgMCAwIDEgMi0yaDVsMiAzaDlhMiAyIDAgMCAxIDIgMnpcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTFcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxN1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjE0XFxcXFxcXCIgeDI9XFxcXFxcXCIxNVxcXFxcXFwiIHkyPVxcXFxcXFwiMTRcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiZm9sZGVyXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMiAxOWEyIDIgMCAwIDEtMiAySDRhMiAyIDAgMCAxLTItMlY1YTIgMiAwIDAgMSAyLTJoNWwyIDNoOWEyIDIgMCAwIDEgMiAyelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJmcmFtZXJcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTUgMTZWOWgxNFYySDVsMTQgMTRoLTdtLTcgMGw3IDd2LTdtLTcgMGg3XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImZyb3duXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxwYXRoIGQ9XFxcXFxcXCJNMTYgMTZzLTEuNS0yLTQtMi00IDItNCAyXFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiOVxcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiOS4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiOVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE1XFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCIxNS4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiOVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJnaWZ0XFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIwIDEyIDIwIDIyIDQgMjIgNCAxMlxcXFxcXFwiPjwvcG9seWxpbmU+PHJlY3QgeD1cXFxcXFxcIjJcXFxcXFxcIiB5PVxcXFxcXFwiN1xcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMjBcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCI1XFxcXFxcXCI+PC9yZWN0PjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjIyXFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiN1xcXFxcXFwiPjwvbGluZT48cGF0aCBkPVxcXFxcXFwiTTEyIDdINy41YTIuNSAyLjUgMCAwIDEgMC01QzExIDIgMTIgNyAxMiA3elxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTEyIDdoNC41YTIuNSAyLjUgMCAwIDAgMC01QzEzIDIgMTIgNyAxMiA3elxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJnaXQtYnJhbmNoXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCI2XFxcXFxcXCIgeTE9XFxcXFxcXCIzXFxcXFxcXCIgeDI9XFxcXFxcXCI2XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT48Y2lyY2xlIGN4PVxcXFxcXFwiMThcXFxcXFxcIiBjeT1cXFxcXFxcIjZcXFxcXFxcIiByPVxcXFxcXFwiM1xcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCI2XFxcXFxcXCIgY3k9XFxcXFxcXCIxOFxcXFxcXFwiIHI9XFxcXFxcXCIzXFxcXFxcXCI+PC9jaXJjbGU+PHBhdGggZD1cXFxcXFxcIk0xOCA5YTkgOSAwIDAgMS05IDlcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiZ2l0LWNvbW1pdFxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiNFxcXFxcXFwiPjwvY2lyY2xlPjxsaW5lIHgxPVxcXFxcXFwiMS4wNVxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjdcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTcuMDFcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIyMi45NlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiZ2l0LW1lcmdlXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjE4XFxcXFxcXCIgY3k9XFxcXFxcXCIxOFxcXFxcXFwiIHI9XFxcXFxcXCIzXFxcXFxcXCI+PC9jaXJjbGU+PGNpcmNsZSBjeD1cXFxcXFxcIjZcXFxcXFxcIiBjeT1cXFxcXFxcIjZcXFxcXFxcIiByPVxcXFxcXFwiM1xcXFxcXFwiPjwvY2lyY2xlPjxwYXRoIGQ9XFxcXFxcXCJNNiAyMVY5YTkgOSAwIDAgMCA5IDlcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiZ2l0LXB1bGwtcmVxdWVzdFxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxOFxcXFxcXFwiIGN5PVxcXFxcXFwiMThcXFxcXFxcIiByPVxcXFxcXFwiM1xcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCI2XFxcXFxcXCIgY3k9XFxcXFxcXCI2XFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT48cGF0aCBkPVxcXFxcXFwiTTEzIDZoM2EyIDIgMCAwIDEgMiAydjdcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCI2XFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCI2XFxcXFxcXCIgeTI9XFxcXFxcXCIyMVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJnaXRodWJcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTkgMTljLTUgMS41LTUtMi41LTctM20xNCA2di0zLjg3YTMuMzcgMy4zNyAwIDAgMC0uOTQtMi42MWMzLjE0LS4zNSA2LjQ0LTEuNTQgNi40NC03QTUuNDQgNS40NCAwIDAgMCAyMCA0Ljc3IDUuMDcgNS4wNyAwIDAgMCAxOS45MSAxUzE4LjczLjY1IDE2IDIuNDhhMTMuMzggMTMuMzggMCAwIDAtNyAwQzYuMjcuNjUgNS4wOSAxIDUuMDkgMUE1LjA3IDUuMDcgMCAwIDAgNSA0Ljc3YTUuNDQgNS40NCAwIDAgMC0xLjUgMy43OGMwIDUuNDIgMy4zIDYuNjEgNi40NCA3QTMuMzcgMy4zNyAwIDAgMCA5IDE4LjEzVjIyXFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImdpdGxhYlxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjIuNjUgMTQuMzlMMTIgMjIuMTMgMS4zNSAxNC4zOWEuODQuODQgMCAwIDEtLjMtLjk0bDEuMjItMy43OCAyLjQ0LTcuNTFBLjQyLjQyIDAgMCAxIDQuODIgMmEuNDMuNDMgMCAwIDEgLjU4IDAgLjQyLjQyIDAgMCAxIC4xMS4xOGwyLjQ0IDcuNDloOC4xbDIuNDQtNy41MUEuNDIuNDIgMCAwIDEgMTguNiAyYS40My40MyAwIDAgMSAuNTggMCAuNDIuNDIgMCAwIDEgLjExLjE4bDIuNDQgNy41MUwyMyAxMy40NWEuODQuODQgMCAwIDEtLjM1Ljk0elxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJnbG9iZVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjJcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIyMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk0xMiAyYTE1LjMgMTUuMyAwIDAgMSA0IDEwIDE1LjMgMTUuMyAwIDAgMS00IDEwIDE1LjMgMTUuMyAwIDAgMS00LTEwIDE1LjMgMTUuMyAwIDAgMSA0LTEwelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJncmlkXFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjNcXFxcXFxcIiB5PVxcXFxcXFwiM1xcXFxcXFwiIHdpZHRoPVxcXFxcXFwiN1xcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjdcXFxcXFxcIj48L3JlY3Q+PHJlY3QgeD1cXFxcXFxcIjE0XFxcXFxcXCIgeT1cXFxcXFxcIjNcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjdcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCI3XFxcXFxcXCI+PC9yZWN0PjxyZWN0IHg9XFxcXFxcXCIxNFxcXFxcXFwiIHk9XFxcXFxcXCIxNFxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiN1xcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjdcXFxcXFxcIj48L3JlY3Q+PHJlY3QgeD1cXFxcXFxcIjNcXFxcXFxcIiB5PVxcXFxcXFwiMTRcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjdcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCI3XFxcXFxcXCI+PC9yZWN0PlxcXCIsXFxcImhhcmQtZHJpdmVcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjIyXFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk01LjQ1IDUuMTFMMiAxMnY2YTIgMiAwIDAgMCAyIDJoMTZhMiAyIDAgMCAwIDItMnYtNmwtMy40NS02Ljg5QTIgMiAwIDAgMCAxNi43NiA0SDcuMjRhMiAyIDAgMCAwLTEuNzkgMS4xMXpcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCI2XFxcXFxcXCIgeTE9XFxcXFxcXCIxNlxcXFxcXFwiIHgyPVxcXFxcXFwiNi4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMTZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMFxcXFxcXFwiIHkxPVxcXFxcXFwiMTZcXFxcXFxcIiB4Mj1cXFxcXFxcIjEwLjAxXFxcXFxcXCIgeTI9XFxcXFxcXCIxNlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJoYXNoXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCI0XFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCIyMFxcXFxcXFwiIHkyPVxcXFxcXFwiOVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjRcXFxcXFxcIiB5MT1cXFxcXFxcIjE1XFxcXFxcXCIgeDI9XFxcXFxcXCIyMFxcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMFxcXFxcXFwiIHkxPVxcXFxcXFwiM1xcXFxcXFwiIHgyPVxcXFxcXFwiOFxcXFxcXFwiIHkyPVxcXFxcXFwiMjFcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNlxcXFxcXFwiIHkxPVxcXFxcXFwiM1xcXFxcXFwiIHgyPVxcXFxcXFwiMTRcXFxcXFxcIiB5Mj1cXFxcXFxcIjIxXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImhlYWRwaG9uZXNcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTMgMTh2LTZhOSA5IDAgMCAxIDE4IDB2NlxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTIxIDE5YTIgMiAwIDAgMS0yIDJoLTFhMiAyIDAgMCAxLTItMnYtM2EyIDIgMCAwIDEgMi0yaDN6TTMgMTlhMiAyIDAgMCAwIDIgMmgxYTIgMiAwIDAgMCAyLTJ2LTNhMiAyIDAgMCAwLTItMkgzelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJoZWFydFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjAuODQgNC42MWE1LjUgNS41IDAgMCAwLTcuNzggMEwxMiA1LjY3bC0xLjA2LTEuMDZhNS41IDUuNSAwIDAgMC03Ljc4IDcuNzhsMS4wNiAxLjA2TDEyIDIxLjIzbDcuNzgtNy43OCAxLjA2LTEuMDZhNS41IDUuNSAwIDAgMCAwLTcuNzh6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcImhlbHAtY2lyY2xlXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxwYXRoIGQ9XFxcXFxcXCJNOS4wOSA5YTMgMyAwIDAgMSA1LjgzIDFjMCAyLTMgMy0zIDNcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTdcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyLjAxXFxcXFxcXCIgeTI9XFxcXFxcXCIxN1xcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJoZXhhZ29uXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMSAxNlY4YTIgMiAwIDAgMC0xLTEuNzNsLTctNGEyIDIgMCAwIDAtMiAwbC03IDRBMiAyIDAgMCAwIDMgOHY4YTIgMiAwIDAgMCAxIDEuNzNsNyA0YTIgMiAwIDAgMCAyIDBsNy00QTIgMiAwIDAgMCAyMSAxNnpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiaG9tZVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMyA5bDktNyA5IDd2MTFhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJ6XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI5IDIyIDkgMTIgMTUgMTIgMTUgMjJcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImltYWdlXFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjNcXFxcXFxcIiB5PVxcXFxcXFwiM1xcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMThcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxOFxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD48Y2lyY2xlIGN4PVxcXFxcXFwiOC41XFxcXFxcXCIgY3k9XFxcXFxcXCI4LjVcXFxcXFxcIiByPVxcXFxcXFwiMS41XFxcXFxcXCI+PC9jaXJjbGU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIxIDE1IDE2IDEwIDUgMjFcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcImluYm94XFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIyIDEyIDE2IDEyIDE0IDE1IDEwIDE1IDggMTIgMiAxMlxcXFxcXFwiPjwvcG9seWxpbmU+PHBhdGggZD1cXFxcXFxcIk01LjQ1IDUuMTFMMiAxMnY2YTIgMiAwIDAgMCAyIDJoMTZhMiAyIDAgMCAwIDItMnYtNmwtMy40NS02Ljg5QTIgMiAwIDAgMCAxNi43NiA0SDcuMjRhMiAyIDAgMCAwLTEuNzkgMS4xMXpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwiaW5mb1xcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxNlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyLjAxXFxcXFxcXCIgeTI9XFxcXFxcXCI4XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImluc3RhZ3JhbVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIyXFxcXFxcXCIgeT1cXFxcXFxcIjJcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjIwXFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMjBcXFxcXFxcIiByeD1cXFxcXFxcIjVcXFxcXFxcIiByeT1cXFxcXFxcIjVcXFxcXFxcIj48L3JlY3Q+PHBhdGggZD1cXFxcXFxcIk0xNiAxMS4zN0E0IDQgMCAxIDEgMTIuNjMgOCA0IDQgMCAwIDEgMTYgMTEuMzd6XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMTcuNVxcXFxcXFwiIHkxPVxcXFxcXFwiNi41XFxcXFxcXCIgeDI9XFxcXFxcXCIxNy41MVxcXFxcXFwiIHkyPVxcXFxcXFwiNi41XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcIml0YWxpY1xcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMTlcXFxcXFxcIiB5MT1cXFxcXFxcIjRcXFxcXFxcIiB4Mj1cXFxcXFxcIjEwXFxcXFxcXCIgeTI9XFxcXFxcXCI0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTRcXFxcXFxcIiB5MT1cXFxcXFxcIjIwXFxcXFxcXCIgeDI9XFxcXFxcXCI1XFxcXFxcXCIgeTI9XFxcXFxcXCIyMFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE1XFxcXFxcXCIgeTE9XFxcXFxcXCI0XFxcXFxcXCIgeDI9XFxcXFxcXCI5XFxcXFxcXCIgeTI9XFxcXFxcXCIyMFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJrZXlcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIxIDJsLTIgMm0tNy42MSA3LjYxYTUuNSA1LjUgMCAxIDEtNy43NzggNy43NzggNS41IDUuNSAwIDAgMSA3Ljc3Ny03Ljc3N3ptMCAwTDE1LjUgNy41bTAgMGwzIDNMMjIgN2wtMy0zbS0zLjUgMy41TDE5IDRcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwibGF5ZXJzXFxcIjpcXFwiPHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMTIgMiAyIDcgMTIgMTIgMjIgNyAxMiAyXFxcXFxcXCI+PC9wb2x5Z29uPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIyIDE3IDEyIDIyIDIyIDE3XFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMiAxMiAxMiAxNyAyMiAxMlxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwibGF5b3V0XFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjNcXFxcXFxcIiB5PVxcXFxcXFwiM1xcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMThcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxOFxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD48bGluZSB4MT1cXFxcXFxcIjNcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjIxXFxcXFxcXCIgeTI9XFxcXFxcXCI5XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOVxcXFxcXFwiIHkxPVxcXFxcXFwiMjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjlcXFxcXFxcIiB5Mj1cXFxcXFxcIjlcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwibGlmZS1idW95XFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiNFxcXFxcXFwiPjwvY2lyY2xlPjxsaW5lIHgxPVxcXFxcXFwiNC45M1xcXFxcXFwiIHkxPVxcXFxcXFwiNC45M1xcXFxcXFwiIHgyPVxcXFxcXFwiOS4xN1xcXFxcXFwiIHkyPVxcXFxcXFwiOS4xN1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE0LjgzXFxcXFxcXCIgeTE9XFxcXFxcXCIxNC44M1xcXFxcXFwiIHgyPVxcXFxcXFwiMTkuMDdcXFxcXFxcIiB5Mj1cXFxcXFxcIjE5LjA3XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTQuODNcXFxcXFxcIiB5MT1cXFxcXFxcIjkuMTdcXFxcXFxcIiB4Mj1cXFxcXFxcIjE5LjA3XFxcXFxcXCIgeTI9XFxcXFxcXCI0LjkzXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTQuODNcXFxcXFxcIiB5MT1cXFxcXFxcIjkuMTdcXFxcXFxcIiB4Mj1cXFxcXFxcIjE4LjM2XFxcXFxcXCIgeTI9XFxcXFxcXCI1LjY0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiNC45M1xcXFxcXFwiIHkxPVxcXFxcXFwiMTkuMDdcXFxcXFxcIiB4Mj1cXFxcXFxcIjkuMTdcXFxcXFxcIiB5Mj1cXFxcXFxcIjE0LjgzXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImxpbmstMlxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTUgN2gzYTUgNSAwIDAgMSA1IDUgNSA1IDAgMCAxLTUgNWgtM20tNiAwSDZhNSA1IDAgMCAxLTUtNSA1IDUgMCAwIDEgNS01aDNcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTZcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcImxpbmtcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTEwIDEzYTUgNSAwIDAgMCA3LjU0LjU0bDMtM2E1IDUgMCAwIDAtNy4wNy03LjA3bC0xLjcyIDEuNzFcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xNCAxMWE1IDUgMCAwIDAtNy41NC0uNTRsLTMgM2E1IDUgMCAwIDAgNy4wNyA3LjA3bDEuNzEtMS43MVxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJsaW5rZWRpblxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTYgOGE2IDYgMCAwIDEgNiA2djdoLTR2LTdhMiAyIDAgMCAwLTItMiAyIDIgMCAwIDAtMiAydjdoLTR2LTdhNiA2IDAgMCAxIDYtNnpcXFxcXFxcIj48L3BhdGg+PHJlY3QgeD1cXFxcXFxcIjJcXFxcXFxcIiB5PVxcXFxcXFwiOVxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiNFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjEyXFxcXFxcXCI+PC9yZWN0PjxjaXJjbGUgY3g9XFxcXFxcXCI0XFxcXFxcXCIgY3k9XFxcXFxcXCI0XFxcXFxcXCIgcj1cXFxcXFxcIjJcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJsaXN0XFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCI2XFxcXFxcXCIgeDI9XFxcXFxcXCIyMVxcXFxcXFwiIHkyPVxcXFxcXFwiNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIyMVxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiMjFcXFxcXFxcIiB5Mj1cXFxcXFxcIjE4XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiM1xcXFxcXFwiIHkxPVxcXFxcXFwiNlxcXFxcXFwiIHgyPVxcXFxcXFwiMy4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjNcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIzLjAxXFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjNcXFxcXFxcIiB5MT1cXFxcXFxcIjE4XFxcXFxcXCIgeDI9XFxcXFxcXCIzLjAxXFxcXFxcXCIgeTI9XFxcXFxcXCIxOFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJsb2FkZXJcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyXFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiNlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjIyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiNC45M1xcXFxcXFwiIHkxPVxcXFxcXFwiNC45M1xcXFxcXFwiIHgyPVxcXFxcXFwiNy43NlxcXFxcXFwiIHkyPVxcXFxcXFwiNy43NlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE2LjI0XFxcXFxcXCIgeTE9XFxcXFxcXCIxNi4yNFxcXFxcXFwiIHgyPVxcXFxcXFwiMTkuMDdcXFxcXFxcIiB5Mj1cXFxcXFxcIjE5LjA3XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMlxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjZcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMThcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIyMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI0LjkzXFxcXFxcXCIgeTE9XFxcXFxcXCIxOS4wN1xcXFxcXFwiIHgyPVxcXFxcXFwiNy43NlxcXFxcXFwiIHkyPVxcXFxcXFwiMTYuMjRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNi4yNFxcXFxcXFwiIHkxPVxcXFxcXFwiNy43NlxcXFxcXFwiIHgyPVxcXFxcXFwiMTkuMDdcXFxcXFxcIiB5Mj1cXFxcXFxcIjQuOTNcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwibG9ja1xcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjExXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIxOFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjExXFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxwYXRoIGQ9XFxcXFxcXCJNNyAxMVY3YTUgNSAwIDAgMSAxMCAwdjRcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwibG9nLWluXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNSAzaDRhMiAyIDAgMCAxIDIgMnYxNGEyIDIgMCAwIDEtMiAyaC00XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxMCAxNyAxNSAxMiAxMCA3XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjE1XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiM1xcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwibG9nLW91dFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNOSAyMUg1YTIgMiAwIDAgMS0yLTJWNWEyIDIgMCAwIDEgMi0yaDRcXFxcXFxcIj48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE2IDE3IDIxIDEyIDE2IDdcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCI5XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJtYWlsXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk00IDRoMTZjMS4xIDAgMiAuOSAyIDJ2MTJjMCAxLjEtLjkgMi0yIDJINGMtMS4xIDAtMi0uOS0yLTJWNmMwLTEuMS45LTIgMi0yelxcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMjIsNiAxMiwxMyAyLDZcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcIm1hcC1waW5cXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIxIDEwYzAgNy05IDEzLTkgMTNzLTktNi05LTEzYTkgOSAwIDAgMSAxOCAwelxcXFxcXFwiPjwvcGF0aD48Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEwXFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJtYXBcXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCIxIDYgMSAyMiA4IDE4IDE2IDIyIDIzIDE4IDIzIDIgMTYgNiA4IDIgMSA2XFxcXFxcXCI+PC9wb2x5Z29uPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMlxcXFxcXFwiIHgyPVxcXFxcXFwiOFxcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNlxcXFxcXFwiIHkxPVxcXFxcXFwiNlxcXFxcXFwiIHgyPVxcXFxcXFwiMTZcXFxcXFxcIiB5Mj1cXFxcXFxcIjIyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcIm1heGltaXplLTJcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTUgMyAyMSAzIDIxIDlcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI5IDIxIDMgMjEgMyAxNVxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIyMVxcXFxcXFwiIHkxPVxcXFxcXFwiM1xcXFxcXFwiIHgyPVxcXFxcXFwiMTRcXFxcXFxcIiB5Mj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiM1xcXFxcXFwiIHkxPVxcXFxcXFwiMjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjEwXFxcXFxcXCIgeTI9XFxcXFxcXCIxNFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJtYXhpbWl6ZVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNOCAzSDVhMiAyIDAgMCAwLTIgMnYzbTE4IDBWNWEyIDIgMCAwIDAtMi0yaC0zbTAgMThoM2EyIDIgMCAwIDAgMi0ydi0zTTMgMTZ2M2EyIDIgMCAwIDAgMiAyaDNcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwibWVoXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMTVcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjkuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjlcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNVxcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiMTUuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjlcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwibWVudVxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiM1xcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjIxXFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjNcXFxcXFxcIiB5MT1cXFxcXFxcIjZcXFxcXFxcIiB4Mj1cXFxcXFxcIjIxXFxcXFxcXCIgeTI9XFxcXFxcXCI2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiM1xcXFxcXFwiIHkxPVxcXFxcXFwiMThcXFxcXFxcIiB4Mj1cXFxcXFxcIjIxXFxcXFxcXCIgeTI9XFxcXFxcXCIxOFxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJtZXNzYWdlLWNpcmNsZVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjEgMTEuNWE4LjM4IDguMzggMCAwIDEtLjkgMy44IDguNSA4LjUgMCAwIDEtNy42IDQuNyA4LjM4IDguMzggMCAwIDEtMy44LS45TDMgMjFsMS45LTUuN2E4LjM4IDguMzggMCAwIDEtLjktMy44IDguNSA4LjUgMCAwIDEgNC43LTcuNiA4LjM4IDguMzggMCAwIDEgMy44LS45aC41YTguNDggOC40OCAwIDAgMSA4IDh2LjV6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcIm1lc3NhZ2Utc3F1YXJlXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMSAxNWEyIDIgMCAwIDEtMiAySDdsLTQgNFY1YTIgMiAwIDAgMSAyLTJoMTRhMiAyIDAgMCAxIDIgMnpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwibWljLW9mZlxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMVxcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPjxwYXRoIGQ9XFxcXFxcXCJNOSA5djNhMyAzIDAgMCAwIDUuMTIgMi4xMk0xNSA5LjM0VjRhMyAzIDAgMCAwLTUuOTQtLjZcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xNyAxNi45NUE3IDcgMCAwIDEgNSAxMnYtMm0xNCAwdjJhNyA3IDAgMCAxLS4xMSAxLjIzXFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjE5XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMjNcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIyM1xcXFxcXFwiIHgyPVxcXFxcXFwiMTZcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcIm1pY1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTIgMWEzIDMgMCAwIDAtMyAzdjhhMyAzIDAgMCAwIDYgMFY0YTMgMyAwIDAgMC0zLTN6XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMTkgMTB2MmE3IDcgMCAwIDEtMTQgMHYtMlxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxOVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMjNcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIyM1xcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJtaW5pbWl6ZS0yXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjQgMTQgMTAgMTQgMTAgMjBcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIyMCAxMCAxNCAxMCAxNCA0XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjE0XFxcXFxcXCIgeTE9XFxcXFxcXCIxMFxcXFxcXFwiIHgyPVxcXFxcXFwiMjFcXFxcXFxcIiB5Mj1cXFxcXFxcIjNcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIzXFxcXFxcXCIgeTE9XFxcXFxcXCIyMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTBcXFxcXFxcIiB5Mj1cXFxcXFxcIjE0XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcIm1pbmltaXplXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk04IDN2M2EyIDIgMCAwIDEtMiAySDNtMTggMGgtM2EyIDIgMCAwIDEtMi0yVjNtMCAxOHYtM2EyIDIgMCAwIDEgMi0yaDNNMyAxNmgzYTIgMiAwIDAgMSAyIDJ2M1xcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJtaW51cy1jaXJjbGVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTZcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcIm1pbnVzLXNxdWFyZVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjNcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMThcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PGxpbmUgeDE9XFxcXFxcXCI4XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTZcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcIm1pbnVzXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCI1XFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTlcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcIm1vbml0b3JcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiMlxcXFxcXFwiIHk9XFxcXFxcXCIzXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIyMFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjE0XFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIyMVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxN1xcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjIxXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcIm1vb25cXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIxIDEyLjc5QTkgOSAwIDEgMSAxMS4yMSAzIDcgNyAwIDAgMCAyMSAxMi43OXpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwibW9yZS1ob3Jpem9udGFsXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxXFxcXFxcXCI+PC9jaXJjbGU+PGNpcmNsZSBjeD1cXFxcXFxcIjE5XFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxXFxcXFxcXCI+PC9jaXJjbGU+PGNpcmNsZSBjeD1cXFxcXFxcIjVcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjFcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJtb3JlLXZlcnRpY2FsXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxXFxcXFxcXCI+PC9jaXJjbGU+PGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCI1XFxcXFxcXCIgcj1cXFxcXFxcIjFcXFxcXFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjE5XFxcXFxcXCIgcj1cXFxcXFxcIjFcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJtb3VzZS1wb2ludGVyXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0zIDNsNy4wNyAxNi45NyAyLjUxLTcuMzkgNy4zOS0yLjUxTDMgM3pcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xMyAxM2w2IDZcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwibW92ZVxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI1IDkgMiAxMiA1IDE1XFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiOSA1IDEyIDIgMTUgNVxcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE1IDE5IDEyIDIyIDkgMTlcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxOSA5IDIyIDEyIDE5IDE1XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjJcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIyMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjIyXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcIm11c2ljXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk05IDE4VjVsMTItMnYxM1xcXFxcXFwiPjwvcGF0aD48Y2lyY2xlIGN4PVxcXFxcXFwiNlxcXFxcXFwiIGN5PVxcXFxcXFwiMThcXFxcXFxcIiByPVxcXFxcXFwiM1xcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCIxOFxcXFxcXFwiIGN5PVxcXFxcXFwiMTZcXFxcXFxcIiByPVxcXFxcXFwiM1xcXFxcXFwiPjwvY2lyY2xlPlxcXCIsXFxcIm5hdmlnYXRpb24tMlxcXCI6XFxcIjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjEyIDIgMTkgMjEgMTIgMTcgNSAyMSAxMiAyXFxcXFxcXCI+PC9wb2x5Z29uPlxcXCIsXFxcIm5hdmlnYXRpb25cXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCIzIDExIDIyIDIgMTMgMjEgMTEgMTMgMyAxMVxcXFxcXFwiPjwvcG9seWdvbj5cXFwiLFxcXCJvY3RhZ29uXFxcIjpcXFwiPHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiNy44NiAyIDE2LjE0IDIgMjIgNy44NiAyMiAxNi4xNCAxNi4xNCAyMiA3Ljg2IDIyIDIgMTYuMTQgMiA3Ljg2IDcuODYgMlxcXFxcXFwiPjwvcG9seWdvbj5cXFwiLFxcXCJwYWNrYWdlXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxNi41XFxcXFxcXCIgeTE9XFxcXFxcXCI5LjRcXFxcXFxcIiB4Mj1cXFxcXFxcIjcuNVxcXFxcXFwiIHkyPVxcXFxcXFwiNC4yMVxcXFxcXFwiPjwvbGluZT48cGF0aCBkPVxcXFxcXFwiTTIxIDE2VjhhMiAyIDAgMCAwLTEtMS43M2wtNy00YTIgMiAwIDAgMC0yIDBsLTcgNEEyIDIgMCAwIDAgMyA4djhhMiAyIDAgMCAwIDEgMS43M2w3IDRhMiAyIDAgMCAwIDIgMGw3LTRBMiAyIDAgMCAwIDIxIDE2elxcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMy4yNyA2Ljk2IDEyIDEyLjAxIDIwLjczIDYuOTZcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjIyLjA4XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwicGFwZXJjbGlwXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMS40NCAxMS4wNWwtOS4xOSA5LjE5YTYgNiAwIDAgMS04LjQ5LTguNDlsOS4xOS05LjE5YTQgNCAwIDAgMSA1LjY2IDUuNjZsLTkuMiA5LjE5YTIgMiAwIDAgMS0yLjgzLTIuODNsOC40OS04LjQ4XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInBhdXNlLWNpcmNsZVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjEwXFxcXFxcXCIgeTE9XFxcXFxcXCIxNVxcXFxcXFwiIHgyPVxcXFxcXFwiMTBcXFxcXFxcIiB5Mj1cXFxcXFxcIjlcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNFxcXFxcXFwiIHkxPVxcXFxcXFwiMTVcXFxcXFxcIiB4Mj1cXFxcXFxcIjE0XFxcXFxcXCIgeTI9XFxcXFxcXCI5XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInBhdXNlXFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjZcXFxcXFxcIiB5PVxcXFxcXFwiNFxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiNFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjE2XFxcXFxcXCI+PC9yZWN0PjxyZWN0IHg9XFxcXFxcXCIxNFxcXFxcXFwiIHk9XFxcXFxcXCI0XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCI0XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMTZcXFxcXFxcIj48L3JlY3Q+XFxcIixcXFwicGVuLXRvb2xcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTEyIDE5bDctNyAzIDMtNyA3LTMtM3pcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xOCAxM2wtMS41LTcuNUwyIDJsMy41IDE0LjVMMTMgMThsNS01elxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTIgMmw3LjU4NiA3LjU4NlxcXFxcXFwiPjwvcGF0aD48Y2lyY2xlIGN4PVxcXFxcXFwiMTFcXFxcXFxcIiBjeT1cXFxcXFxcIjExXFxcXFxcXCIgcj1cXFxcXFxcIjJcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJwZXJjZW50XFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxOVxcXFxcXFwiIHkxPVxcXFxcXFwiNVxcXFxcXFwiIHgyPVxcXFxcXFwiNVxcXFxcXFwiIHkyPVxcXFxcXFwiMTlcXFxcXFxcIj48L2xpbmU+PGNpcmNsZSBjeD1cXFxcXFxcIjYuNVxcXFxcXFwiIGN5PVxcXFxcXFwiNi41XFxcXFxcXCIgcj1cXFxcXFxcIjIuNVxcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCIxNy41XFxcXFxcXCIgY3k9XFxcXFxcXCIxNy41XFxcXFxcXCIgcj1cXFxcXFxcIjIuNVxcXFxcXFwiPjwvY2lyY2xlPlxcXCIsXFxcInBob25lLWNhbGxcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE1LjA1IDVBNSA1IDAgMCAxIDE5IDguOTVNMTUuMDUgMUE5IDkgMCAwIDEgMjMgOC45NG0tMSA3Ljk4djNhMiAyIDAgMCAxLTIuMTggMiAxOS43OSAxOS43OSAwIDAgMS04LjYzLTMuMDcgMTkuNSAxOS41IDAgMCAxLTYtNiAxOS43OSAxOS43OSAwIDAgMS0zLjA3LTguNjdBMiAyIDAgMCAxIDQuMTEgMmgzYTIgMiAwIDAgMSAyIDEuNzIgMTIuODQgMTIuODQgMCAwIDAgLjcgMi44MSAyIDIgMCAwIDEtLjQ1IDIuMTFMOC4wOSA5LjkxYTE2IDE2IDAgMCAwIDYgNmwxLjI3LTEuMjdhMiAyIDAgMCAxIDIuMTEtLjQ1IDEyLjg0IDEyLjg0IDAgMCAwIDIuODEuN0EyIDIgMCAwIDEgMjIgMTYuOTJ6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInBob25lLWZvcndhcmRlZFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxOSAxIDIzIDUgMTkgOVxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNVxcXFxcXFwiIHkxPVxcXFxcXFwiNVxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjVcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk0yMiAxNi45MnYzYTIgMiAwIDAgMS0yLjE4IDIgMTkuNzkgMTkuNzkgMCAwIDEtOC42My0zLjA3IDE5LjUgMTkuNSAwIDAgMS02LTYgMTkuNzkgMTkuNzkgMCAwIDEtMy4wNy04LjY3QTIgMiAwIDAgMSA0LjExIDJoM2EyIDIgMCAwIDEgMiAxLjcyIDEyLjg0IDEyLjg0IDAgMCAwIC43IDIuODEgMiAyIDAgMCAxLS40NSAyLjExTDguMDkgOS45MWExNiAxNiAwIDAgMCA2IDZsMS4yNy0xLjI3YTIgMiAwIDAgMSAyLjExLS40NSAxMi44NCAxMi44NCAwIDAgMCAyLjgxLjdBMiAyIDAgMCAxIDIyIDE2LjkyelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJwaG9uZS1pbmNvbWluZ1xcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNiAyIDE2IDggMjIgOFxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCIyM1xcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTZcXFxcXFxcIiB5Mj1cXFxcXFxcIjhcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk0yMiAxNi45MnYzYTIgMiAwIDAgMS0yLjE4IDIgMTkuNzkgMTkuNzkgMCAwIDEtOC42My0zLjA3IDE5LjUgMTkuNSAwIDAgMS02LTYgMTkuNzkgMTkuNzkgMCAwIDEtMy4wNy04LjY3QTIgMiAwIDAgMSA0LjExIDJoM2EyIDIgMCAwIDEgMiAxLjcyIDEyLjg0IDEyLjg0IDAgMCAwIC43IDIuODEgMiAyIDAgMCAxLS40NSAyLjExTDguMDkgOS45MWExNiAxNiAwIDAgMCA2IDZsMS4yNy0xLjI3YTIgMiAwIDAgMSAyLjExLS40NSAxMi44NCAxMi44NCAwIDAgMCAyLjgxLjdBMiAyIDAgMCAxIDIyIDE2LjkyelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJwaG9uZS1taXNzZWRcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjIzXFxcXFxcXCIgeTE9XFxcXFxcXCIxXFxcXFxcXCIgeDI9XFxcXFxcXCIxN1xcXFxcXFwiIHkyPVxcXFxcXFwiN1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE3XFxcXFxcXCIgeTE9XFxcXFxcXCIxXFxcXFxcXCIgeDI9XFxcXFxcXCIyM1xcXFxcXFwiIHkyPVxcXFxcXFwiN1xcXFxcXFwiPjwvbGluZT48cGF0aCBkPVxcXFxcXFwiTTIyIDE2LjkydjNhMiAyIDAgMCAxLTIuMTggMiAxOS43OSAxOS43OSAwIDAgMS04LjYzLTMuMDcgMTkuNSAxOS41IDAgMCAxLTYtNiAxOS43OSAxOS43OSAwIDAgMS0zLjA3LTguNjdBMiAyIDAgMCAxIDQuMTEgMmgzYTIgMiAwIDAgMSAyIDEuNzIgMTIuODQgMTIuODQgMCAwIDAgLjcgMi44MSAyIDIgMCAwIDEtLjQ1IDIuMTFMOC4wOSA5LjkxYTE2IDE2IDAgMCAwIDYgNmwxLjI3LTEuMjdhMiAyIDAgMCAxIDIuMTEtLjQ1IDEyLjg0IDEyLjg0IDAgMCAwIDIuODEuN0EyIDIgMCAwIDEgMjIgMTYuOTJ6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInBob25lLW9mZlxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTAuNjggMTMuMzFhMTYgMTYgMCAwIDAgMy40MSAyLjZsMS4yNy0xLjI3YTIgMiAwIDAgMSAyLjExLS40NSAxMi44NCAxMi44NCAwIDAgMCAyLjgxLjcgMiAyIDAgMCAxIDEuNzIgMnYzYTIgMiAwIDAgMS0yLjE4IDIgMTkuNzkgMTkuNzkgMCAwIDEtOC42My0zLjA3IDE5LjQyIDE5LjQyIDAgMCAxLTMuMzMtMi42N20tMi42Ny0zLjM0YTE5Ljc5IDE5Ljc5IDAgMCAxLTMuMDctOC42M0EyIDIgMCAwIDEgNC4xMSAyaDNhMiAyIDAgMCAxIDIgMS43MiAxMi44NCAxMi44NCAwIDAgMCAuNyAyLjgxIDIgMiAwIDAgMS0uNDUgMi4xMUw4LjA5IDkuOTFcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIyM1xcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMVxcXFxcXFwiIHkyPVxcXFxcXFwiMjNcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwicGhvbmUtb3V0Z29pbmdcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMjMgNyAyMyAxIDE3IDFcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiMTZcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxXFxcXFxcXCI+PC9saW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjIgMTYuOTJ2M2EyIDIgMCAwIDEtMi4xOCAyIDE5Ljc5IDE5Ljc5IDAgMCAxLTguNjMtMy4wNyAxOS41IDE5LjUgMCAwIDEtNi02IDE5Ljc5IDE5Ljc5IDAgMCAxLTMuMDctOC42N0EyIDIgMCAwIDEgNC4xMSAyaDNhMiAyIDAgMCAxIDIgMS43MiAxMi44NCAxMi44NCAwIDAgMCAuNyAyLjgxIDIgMiAwIDAgMS0uNDUgMi4xMUw4LjA5IDkuOTFhMTYgMTYgMCAwIDAgNiA2bDEuMjctMS4yN2EyIDIgMCAwIDEgMi4xMS0uNDUgMTIuODQgMTIuODQgMCAwIDAgMi44MS43QTIgMiAwIDAgMSAyMiAxNi45MnpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwicGhvbmVcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTIyIDE2LjkydjNhMiAyIDAgMCAxLTIuMTggMiAxOS43OSAxOS43OSAwIDAgMS04LjYzLTMuMDcgMTkuNSAxOS41IDAgMCAxLTYtNiAxOS43OSAxOS43OSAwIDAgMS0zLjA3LTguNjdBMiAyIDAgMCAxIDQuMTEgMmgzYTIgMiAwIDAgMSAyIDEuNzIgMTIuODQgMTIuODQgMCAwIDAgLjcgMi44MSAyIDIgMCAwIDEtLjQ1IDIuMTFMOC4wOSA5LjkxYTE2IDE2IDAgMCAwIDYgNmwxLjI3LTEuMjdhMiAyIDAgMCAxIDIuMTEtLjQ1IDEyLjg0IDEyLjg0IDAgMCAwIDIuODEuN0EyIDIgMCAwIDEgMjIgMTYuOTJ6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInBpZS1jaGFydFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjEuMjEgMTUuODlBMTAgMTAgMCAxIDEgOCAyLjgzXFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMjIgMTJBMTAgMTAgMCAwIDAgMTIgMnYxMHpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwicGxheS1jaXJjbGVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMTAgOCAxNiAxMiAxMCAxNiAxMCA4XFxcXFxcXCI+PC9wb2x5Z29uPlxcXCIsXFxcInBsYXlcXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCI1IDMgMTkgMTIgNSAyMSA1IDNcXFxcXFxcIj48L3BvbHlnb24+XFxcIixcXFwicGx1cy1jaXJjbGVcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjEwXFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjE2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJwbHVzLXNxdWFyZVxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIzXFxcXFxcXCIgeT1cXFxcXFxcIjNcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMThcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjE2XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjE2XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJwbHVzXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiNVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjE5XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiNVxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjE5XFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJwb2NrZXRcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTQgM2gxNmEyIDIgMCAwIDEgMiAydjZhMTAgMTAgMCAwIDEtMTAgMTBBMTAgMTAgMCAwIDEgMiAxMVY1YTIgMiAwIDAgMSAyLTJ6XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI4IDEwIDEyIDE0IDE2IDEwXFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJwb3dlclxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTguMzYgNi42NGE5IDkgMCAxIDEtMTIuNzMgMFxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyXFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwicHJpbnRlclxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI2IDkgNiAyIDE4IDIgMTggOVxcXFxcXFwiPjwvcG9seWxpbmU+PHBhdGggZD1cXFxcXFxcIk02IDE4SDRhMiAyIDAgMCAxLTItMnYtNWEyIDIgMCAwIDEgMi0yaDE2YTIgMiAwIDAgMSAyIDJ2NWEyIDIgMCAwIDEtMiAyaC0yXFxcXFxcXCI+PC9wYXRoPjxyZWN0IHg9XFxcXFxcXCI2XFxcXFxcXCIgeT1cXFxcXFxcIjE0XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIxMlxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjhcXFxcXFxcIj48L3JlY3Q+XFxcIixcXFwicmFkaW9cXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjJcXFxcXFxcIj48L2NpcmNsZT48cGF0aCBkPVxcXFxcXFwiTTE2LjI0IDcuNzZhNiA2IDAgMCAxIDAgOC40OW0tOC40OC0uMDFhNiA2IDAgMCAxIDAtOC40OW0xMS4zMS0yLjgyYTEwIDEwIDAgMCAxIDAgMTQuMTRtLTE0LjE0IDBhMTAgMTAgMCAwIDEgMC0xNC4xNFxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJyZWZyZXNoLWNjd1xcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxIDQgMSAxMCA3IDEwXFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMjMgMjAgMjMgMTQgMTcgMTRcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjAuNDkgOUE5IDkgMCAwIDAgNS42NCA1LjY0TDEgMTBtMjIgNGwtNC42NCA0LjM2QTkgOSAwIDAgMSAzLjUxIDE1XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInJlZnJlc2gtY3dcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMjMgNCAyMyAxMCAxNyAxMFxcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjEgMjAgMSAxNCA3IDE0XFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTMuNTEgOWE5IDkgMCAwIDEgMTQuODUtMy4zNkwyMyAxME0xIDE0bDQuNjQgNC4zNkE5IDkgMCAwIDAgMjAuNDkgMTVcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwicmVwZWF0XFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE3IDEgMjEgNSAxNyA5XFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTMgMTFWOWE0IDQgMCAwIDEgNC00aDE0XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI3IDIzIDMgMTkgNyAxNVxcXFxcXFwiPjwvcG9seWxpbmU+PHBhdGggZD1cXFxcXFxcIk0yMSAxM3YyYTQgNCAwIDAgMS00IDRIM1xcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJyZXdpbmRcXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCIxMSAxOSAyIDEyIDExIDUgMTEgMTlcXFxcXFxcIj48L3BvbHlnb24+PHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMjIgMTkgMTMgMTIgMjIgNSAyMiAxOVxcXFxcXFwiPjwvcG9seWdvbj5cXFwiLFxcXCJyb3RhdGUtY2N3XFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjEgNCAxIDEwIDcgMTBcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNMy41MSAxNWE5IDkgMCAxIDAgMi4xMy05LjM2TDEgMTBcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwicm90YXRlLWN3XFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIzIDQgMjMgMTAgMTcgMTBcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjAuNDkgMTVhOSA5IDAgMSAxLTIuMTItOS4zNkwyMyAxMFxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJyc3NcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTQgMTFhOSA5IDAgMCAxIDkgOVxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTQgNGExNiAxNiAwIDAgMSAxNiAxNlxcXFxcXFwiPjwvcGF0aD48Y2lyY2xlIGN4PVxcXFxcXFwiNVxcXFxcXFwiIGN5PVxcXFxcXFwiMTlcXFxcXFxcIiByPVxcXFxcXFwiMVxcXFxcXFwiPjwvY2lyY2xlPlxcXCIsXFxcInNhdmVcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE5IDIxSDVhMiAyIDAgMCAxLTItMlY1YTIgMiAwIDAgMSAyLTJoMTFsNSA1djExYTIgMiAwIDAgMS0yIDJ6XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNyAyMSAxNyAxMyA3IDEzIDcgMjFcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCI3IDMgNyA4IDE1IDhcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcInNjaXNzb3JzXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjZcXFxcXFxcIiBjeT1cXFxcXFxcIjZcXFxcXFxcIiByPVxcXFxcXFwiM1xcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCI2XFxcXFxcXCIgY3k9XFxcXFxcXCIxOFxcXFxcXFwiIHI9XFxcXFxcXCIzXFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIyMFxcXFxcXFwiIHkxPVxcXFxcXFwiNFxcXFxcXFwiIHgyPVxcXFxcXFwiOC4xMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTUuODhcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNC40N1xcXFxcXFwiIHkxPVxcXFxcXFwiMTQuNDhcXFxcXFxcIiB4Mj1cXFxcXFxcIjIwXFxcXFxcXCIgeTI9XFxcXFxcXCIyMFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjguMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjguMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxMlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJzZWFyY2hcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTFcXFxcXFxcIiBjeT1cXFxcXFxcIjExXFxcXFxcXCIgcj1cXFxcXFxcIjhcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCIyMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTYuNjVcXFxcXFxcIiB5Mj1cXFxcXFxcIjE2LjY1XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInNlbmRcXFwiOlxcXCI8bGluZSB4MT1cXFxcXFxcIjIyXFxcXFxcXCIgeTE9XFxcXFxcXCIyXFxcXFxcXCIgeDI9XFxcXFxcXCIxMVxcXFxcXFwiIHkyPVxcXFxcXFwiMTNcXFxcXFxcIj48L2xpbmU+PHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMjIgMiAxNSAyMiAxMSAxMyAyIDkgMjIgMlxcXFxcXFwiPjwvcG9seWdvbj5cXFwiLFxcXCJzZXJ2ZXJcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiMlxcXFxcXFwiIHk9XFxcXFxcXCIyXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIyMFxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjhcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PHJlY3QgeD1cXFxcXFxcIjJcXFxcXFxcIiB5PVxcXFxcXFwiMTRcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjIwXFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiOFxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD48bGluZSB4MT1cXFxcXFxcIjZcXFxcXFxcIiB5MT1cXFxcXFxcIjZcXFxcXFxcIiB4Mj1cXFxcXFxcIjYuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI2XFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiNi4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwic2V0dGluZ3NcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT48cGF0aCBkPVxcXFxcXFwiTTE5LjQgMTVhMS42NSAxLjY1IDAgMCAwIC4zMyAxLjgybC4wNi4wNmEyIDIgMCAwIDEgMCAyLjgzIDIgMiAwIDAgMS0yLjgzIDBsLS4wNi0uMDZhMS42NSAxLjY1IDAgMCAwLTEuODItLjMzIDEuNjUgMS42NSAwIDAgMC0xIDEuNTFWMjFhMiAyIDAgMCAxLTIgMiAyIDIgMCAwIDEtMi0ydi0uMDlBMS42NSAxLjY1IDAgMCAwIDkgMTkuNGExLjY1IDEuNjUgMCAwIDAtMS44Mi4zM2wtLjA2LjA2YTIgMiAwIDAgMS0yLjgzIDAgMiAyIDAgMCAxIDAtMi44M2wuMDYtLjA2YTEuNjUgMS42NSAwIDAgMCAuMzMtMS44MiAxLjY1IDEuNjUgMCAwIDAtMS41MS0xSDNhMiAyIDAgMCAxLTItMiAyIDIgMCAwIDEgMi0yaC4wOUExLjY1IDEuNjUgMCAwIDAgNC42IDlhMS42NSAxLjY1IDAgMCAwLS4zMy0xLjgybC0uMDYtLjA2YTIgMiAwIDAgMSAwLTIuODMgMiAyIDAgMCAxIDIuODMgMGwuMDYuMDZhMS42NSAxLjY1IDAgMCAwIDEuODIuMzNIOWExLjY1IDEuNjUgMCAwIDAgMS0xLjUxVjNhMiAyIDAgMCAxIDItMiAyIDIgMCAwIDEgMiAydi4wOWExLjY1IDEuNjUgMCAwIDAgMSAxLjUxIDEuNjUgMS42NSAwIDAgMCAxLjgyLS4zM2wuMDYtLjA2YTIgMiAwIDAgMSAyLjgzIDAgMiAyIDAgMCAxIDAgMi44M2wtLjA2LjA2YTEuNjUgMS42NSAwIDAgMC0uMzMgMS44MlY5YTEuNjUgMS42NSAwIDAgMCAxLjUxIDFIMjFhMiAyIDAgMCAxIDIgMiAyIDIgMCAwIDEtMiAyaC0uMDlhMS42NSAxLjY1IDAgMCAwLTEuNTEgMXpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwic2hhcmUtMlxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxOFxcXFxcXFwiIGN5PVxcXFxcXFwiNVxcXFxcXFwiIHI9XFxcXFxcXCIzXFxcXFxcXCI+PC9jaXJjbGU+PGNpcmNsZSBjeD1cXFxcXFxcIjZcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXFxcXFwiMThcXFxcXFxcIiBjeT1cXFxcXFxcIjE5XFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjguNTlcXFxcXFxcIiB5MT1cXFxcXFxcIjEzLjUxXFxcXFxcXCIgeDI9XFxcXFxcXCIxNS40MlxcXFxcXFwiIHkyPVxcXFxcXFwiMTcuNDlcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNS40MVxcXFxcXFwiIHkxPVxcXFxcXFwiNi41MVxcXFxcXFwiIHgyPVxcXFxcXFwiOC41OVxcXFxcXFwiIHkyPVxcXFxcXFwiMTAuNDlcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwic2hhcmVcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTQgMTJ2OGEyIDIgMCAwIDAgMiAyaDEyYTIgMiAwIDAgMCAyLTJ2LThcXFxcXFxcIj48L3BhdGg+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE2IDYgMTIgMiA4IDZcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjJcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJzaGllbGQtb2ZmXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xOS42OSAxNGE2LjkgNi45IDAgMCAwIC4zMS0yVjVsLTgtMy0zLjE2IDEuMThcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk00LjczIDQuNzNMNCA1djdjMCA2IDggMTAgOCAxMGEyMC4yOSAyMC4yOSAwIDAgMCA1LjYyLTQuMzhcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxXFxcXFxcXCIgeDI9XFxcXFxcXCIyM1xcXFxcXFwiIHkyPVxcXFxcXFwiMjNcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwic2hpZWxkXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xMiAyMnM4LTQgOC0xMFY1bC04LTMtOCAzdjdjMCA2IDggMTAgOCAxMHpcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwic2hvcHBpbmctYmFnXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk02IDJMMyA2djE0YTIgMiAwIDAgMCAyIDJoMTRhMiAyIDAgMCAwIDItMlY2bC0zLTR6XFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiM1xcXFxcXFwiIHkxPVxcXFxcXFwiNlxcXFxcXFwiIHgyPVxcXFxcXFwiMjFcXFxcXFxcIiB5Mj1cXFxcXFxcIjZcXFxcXFxcIj48L2xpbmU+PHBhdGggZD1cXFxcXFxcIk0xNiAxMGE0IDQgMCAwIDEtOCAwXFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInNob3BwaW5nLWNhcnRcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiOVxcXFxcXFwiIGN5PVxcXFxcXFwiMjFcXFxcXFxcIiByPVxcXFxcXFwiMVxcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCIyMFxcXFxcXFwiIGN5PVxcXFxcXFwiMjFcXFxcXFxcIiByPVxcXFxcXFwiMVxcXFxcXFwiPjwvY2lyY2xlPjxwYXRoIGQ9XFxcXFxcXCJNMSAxaDRsMi42OCAxMy4zOWEyIDIgMCAwIDAgMiAxLjYxaDkuNzJhMiAyIDAgMCAwIDItMS42MUwyMyA2SDZcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwic2h1ZmZsZVxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNiAzIDIxIDMgMjEgOFxcXFxcXFwiPjwvcG9seWxpbmU+PGxpbmUgeDE9XFxcXFxcXCI0XFxcXFxcXCIgeTE9XFxcXFxcXCIyMFxcXFxcXFwiIHgyPVxcXFxcXFwiMjFcXFxcXFxcIiB5Mj1cXFxcXFxcIjNcXFxcXFxcIj48L2xpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjIxIDE2IDIxIDIxIDE2IDIxXFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjE1XFxcXFxcXCIgeTE9XFxcXFxcXCIxNVxcXFxcXFwiIHgyPVxcXFxcXFwiMjFcXFxcXFxcIiB5Mj1cXFxcXFxcIjIxXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiNFxcXFxcXFwiIHkxPVxcXFxcXFwiNFxcXFxcXFwiIHgyPVxcXFxcXFwiOVxcXFxcXFwiIHkyPVxcXFxcXFwiOVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJzaWRlYmFyXFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjNcXFxcXFxcIiB5PVxcXFxcXFwiM1xcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMThcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxOFxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjNcXFxcXFxcIiB4Mj1cXFxcXFxcIjlcXFxcXFxcIiB5Mj1cXFxcXFxcIjIxXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInNraXAtYmFja1xcXCI6XFxcIjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjE5IDIwIDkgMTIgMTkgNCAxOSAyMFxcXFxcXFwiPjwvcG9seWdvbj48bGluZSB4MT1cXFxcXFxcIjVcXFxcXFxcIiB5MT1cXFxcXFxcIjE5XFxcXFxcXCIgeDI9XFxcXFxcXCI1XFxcXFxcXCIgeTI9XFxcXFxcXCI1XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInNraXAtZm9yd2FyZFxcXCI6XFxcIjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjUgNCAxNSAxMiA1IDIwIDUgNFxcXFxcXFwiPjwvcG9seWdvbj48bGluZSB4MT1cXFxcXFxcIjE5XFxcXFxcXCIgeTE9XFxcXFxcXCI1XFxcXFxcXCIgeDI9XFxcXFxcXCIxOVxcXFxcXFwiIHkyPVxcXFxcXFwiMTlcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwic2xhY2tcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE0LjUgMTBjLS44MyAwLTEuNS0uNjctMS41LTEuNXYtNWMwLS44My42Ny0xLjUgMS41LTEuNXMxLjUuNjcgMS41IDEuNXY1YzAgLjgzLS42NyAxLjUtMS41IDEuNXpcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0yMC41IDEwSDE5VjguNWMwLS44My42Ny0xLjUgMS41LTEuNXMxLjUuNjcgMS41IDEuNS0uNjcgMS41LTEuNSAxLjV6XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNOS41IDE0Yy44MyAwIDEuNS42NyAxLjUgMS41djVjMCAuODMtLjY3IDEuNS0xLjUgMS41UzggMjEuMzMgOCAyMC41di01YzAtLjgzLjY3LTEuNSAxLjUtMS41elxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTMuNSAxNEg1djEuNWMwIC44My0uNjcgMS41LTEuNSAxLjVTMiAxNi4zMyAyIDE1LjUgMi42NyAxNCAzLjUgMTR6XFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNMTQgMTQuNWMwLS44My42Ny0xLjUgMS41LTEuNWg1Yy44MyAwIDEuNS42NyAxLjUgMS41cy0uNjcgMS41LTEuNSAxLjVoLTVjLS44MyAwLTEuNS0uNjctMS41LTEuNXpcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk0xNS41IDE5SDE0djEuNWMwIC44My42NyAxLjUgMS41IDEuNXMxLjUtLjY3IDEuNS0xLjUtLjY3LTEuNS0xLjUtMS41elxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTEwIDkuNUMxMCA4LjY3IDkuMzMgOCA4LjUgOGgtNUMyLjY3IDggMiA4LjY3IDIgOS41UzIuNjcgMTEgMy41IDExaDVjLjgzIDAgMS41LS42NyAxLjUtMS41elxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTguNSA1SDEwVjMuNUMxMCAyLjY3IDkuMzMgMiA4LjUgMlM3IDIuNjcgNyAzLjUgNy42NyA1IDguNSA1elxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJzbGFzaFxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjQuOTNcXFxcXFxcIiB5MT1cXFxcXFxcIjQuOTNcXFxcXFxcIiB4Mj1cXFxcXFxcIjE5LjA3XFxcXFxcXCIgeTI9XFxcXFxcXCIxOS4wN1xcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJzbGlkZXJzXFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCI0XFxcXFxcXCIgeTE9XFxcXFxcXCIyMVxcXFxcXFwiIHgyPVxcXFxcXFwiNFxcXFxcXFwiIHkyPVxcXFxcXFwiMTRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI0XFxcXFxcXCIgeTE9XFxcXFxcXCIxMFxcXFxcXFwiIHgyPVxcXFxcXFwiNFxcXFxcXFwiIHkyPVxcXFxcXFwiM1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjEyXFxcXFxcXCIgeTI9XFxcXFxcXCIzXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjBcXFxcXFxcIiB5MT1cXFxcXFxcIjIxXFxcXFxcXCIgeDI9XFxcXFxcXCIyMFxcXFxcXFwiIHkyPVxcXFxcXFwiMTZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyMFxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjIwXFxcXFxcXCIgeTI9XFxcXFxcXCIzXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMVxcXFxcXFwiIHkxPVxcXFxcXFwiMTRcXFxcXFxcIiB4Mj1cXFxcXFxcIjdcXFxcXFxcIiB5Mj1cXFxcXFxcIjE0XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOVxcXFxcXFwiIHkxPVxcXFxcXFwiOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTVcXFxcXFxcIiB5Mj1cXFxcXFxcIjhcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxN1xcXFxcXFwiIHkxPVxcXFxcXFwiMTZcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxNlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJzbWFydHBob25lXFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjVcXFxcXFxcIiB5PVxcXFxcXFwiMlxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMTRcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIyMFxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiMTIuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjE4XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInNtaWxlXFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxwYXRoIGQ9XFxcXFxcXCJNOCAxNHMxLjUgMiA0IDIgNC0yIDQtMlxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjkuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjlcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNVxcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiMTUuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjlcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwic3BlYWtlclxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCI0XFxcXFxcXCIgeT1cXFxcXFxcIjJcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE2XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMjBcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxNFxcXFxcXFwiIHI9XFxcXFxcXCI0XFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiNlxcXFxcXFwiIHgyPVxcXFxcXFwiMTIuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjZcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwic3F1YXJlXFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjNcXFxcXFxcIiB5PVxcXFxcXFwiM1xcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMThcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxOFxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD5cXFwiLFxcXCJzdGFyXFxcIjpcXFwiPHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMTIgMiAxNS4wOSA4LjI2IDIyIDkuMjcgMTcgMTQuMTQgMTguMTggMjEuMDIgMTIgMTcuNzcgNS44MiAyMS4wMiA3IDE0LjE0IDIgOS4yNyA4LjkxIDguMjYgMTIgMlxcXFxcXFwiPjwvcG9seWdvbj5cXFwiLFxcXCJzdG9wLWNpcmNsZVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48cmVjdCB4PVxcXFxcXFwiOVxcXFxcXFwiIHk9XFxcXFxcXCI5XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCI2XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiNlxcXFxcXFwiPjwvcmVjdD5cXFwiLFxcXCJzdW5cXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjVcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxXFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiM1xcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiNC4yMlxcXFxcXFwiIHkxPVxcXFxcXFwiNC4yMlxcXFxcXFwiIHgyPVxcXFxcXFwiNS42NFxcXFxcXFwiIHkyPVxcXFxcXFwiNS42NFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE4LjM2XFxcXFxcXCIgeTE9XFxcXFxcXCIxOC4zNlxcXFxcXFwiIHgyPVxcXFxcXFwiMTkuNzhcXFxcXFxcIiB5Mj1cXFxcXFxcIjE5Ljc4XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMVxcXFxcXFwiIHkxPVxcXFxcXFwiMTJcXFxcXFxcIiB4Mj1cXFxcXFxcIjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjEyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjFcXFxcXFxcIiB5MT1cXFxcXFxcIjEyXFxcXFxcXCIgeDI9XFxcXFxcXCIyM1xcXFxcXFwiIHkyPVxcXFxcXFwiMTJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI0LjIyXFxcXFxcXCIgeTE9XFxcXFxcXCIxOS43OFxcXFxcXFwiIHgyPVxcXFxcXFwiNS42NFxcXFxcXFwiIHkyPVxcXFxcXFwiMTguMzZcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxOC4zNlxcXFxcXFwiIHkxPVxcXFxcXFwiNS42NFxcXFxcXFwiIHgyPVxcXFxcXFwiMTkuNzhcXFxcXFxcIiB5Mj1cXFxcXFxcIjQuMjJcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwic3VucmlzZVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTcgMThhNSA1IDAgMCAwLTEwIDBcXFxcXFxcIj48L3BhdGg+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjlcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI0LjIyXFxcXFxcXCIgeTE9XFxcXFxcXCIxMC4yMlxcXFxcXFwiIHgyPVxcXFxcXFwiNS42NFxcXFxcXFwiIHkyPVxcXFxcXFwiMTEuNjRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiM1xcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyMVxcXFxcXFwiIHkxPVxcXFxcXFwiMThcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxOFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE4LjM2XFxcXFxcXCIgeTE9XFxcXFxcXCIxMS42NFxcXFxcXFwiIHgyPVxcXFxcXFwiMTkuNzhcXFxcXFxcIiB5Mj1cXFxcXFxcIjEwLjIyXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjNcXFxcXFxcIiB5MT1cXFxcXFxcIjIyXFxcXFxcXCIgeDI9XFxcXFxcXCIxXFxcXFxcXCIgeTI9XFxcXFxcXCIyMlxcXFxcXFwiPjwvbGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiOCA2IDEyIDIgMTYgNlxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwic3Vuc2V0XFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNyAxOGE1IDUgMCAwIDAtMTAgMFxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMlxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjQuMjJcXFxcXFxcIiB5MT1cXFxcXFxcIjEwLjIyXFxcXFxcXCIgeDI9XFxcXFxcXCI1LjY0XFxcXFxcXCIgeTI9XFxcXFxcXCIxMS42NFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjFcXFxcXFxcIiB5MT1cXFxcXFxcIjE4XFxcXFxcXCIgeDI9XFxcXFxcXCIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxOFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCIxOFxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjE4XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTguMzZcXFxcXFxcIiB5MT1cXFxcXFxcIjExLjY0XFxcXFxcXCIgeDI9XFxcXFxcXCIxOS43OFxcXFxcXFwiIHkyPVxcXFxcXFwiMTAuMjJcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyM1xcXFxcXFwiIHkxPVxcXFxcXFwiMjJcXFxcXFxcIiB4Mj1cXFxcXFxcIjFcXFxcXFxcIiB5Mj1cXFxcXFxcIjIyXFxcXFxcXCI+PC9saW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNiA1IDEyIDkgOCA1XFxcXFxcXCI+PC9wb2x5bGluZT5cXFwiLFxcXCJ0YWJsZXRcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiNFxcXFxcXFwiIHk9XFxcXFxcXCIyXFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIxNlxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjIwXFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjE4XFxcXFxcXCIgeDI9XFxcXFxcXCIxMi4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwidGFnXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMC41OSAxMy40MWwtNy4xNyA3LjE3YTIgMiAwIDAgMS0yLjgzIDBMMiAxMlYyaDEwbDguNTkgOC41OWEyIDIgMCAwIDEgMCAyLjgyelxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjdcXFxcXFxcIiB5MT1cXFxcXFxcIjdcXFxcXFxcIiB4Mj1cXFxcXFxcIjcuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjdcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwidGFyZ2V0XFxcIjpcXFwiPGNpcmNsZSBjeD1cXFxcXFxcIjEyXFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIxMFxcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiNlxcXFxcXFwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMlxcXFxcXFwiPjwvY2lyY2xlPlxcXCIsXFxcInRlcm1pbmFsXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjQgMTcgMTAgMTEgNCA1XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxOVxcXFxcXFwiIHgyPVxcXFxcXFwiMjBcXFxcXFxcIiB5Mj1cXFxcXFxcIjE5XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInRoZXJtb21ldGVyXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNCAxNC43NlYzLjVhMi41IDIuNSAwIDAgMC01IDB2MTEuMjZhNC41IDQuNSAwIDEgMCA1IDB6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInRodW1icy1kb3duXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xMCAxNXY0YTMgMyAwIDAgMCAzIDNsNC05VjJINS43MmEyIDIgMCAwIDAtMiAxLjdsLTEuMzggOWEyIDIgMCAwIDAgMiAyLjN6bTctMTNoMi42N0EyLjMxIDIuMzEgMCAwIDEgMjIgNHY3YTIuMzEgMi4zMSAwIDAgMS0yLjMzIDJIMTdcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwidGh1bWJzLXVwXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNCA5VjVhMyAzIDAgMCAwLTMtM2wtNCA5djExaDExLjI4YTIgMiAwIDAgMCAyLTEuN2wxLjM4LTlhMiAyIDAgMCAwLTItMi4zek03IDIySDRhMiAyIDAgMCAxLTItMnYtN2EyIDIgMCAwIDEgMi0yaDNcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwidG9nZ2xlLWxlZnRcXFwiOlxcXCI8cmVjdCB4PVxcXFxcXFwiMVxcXFxcXFwiIHk9XFxcXFxcXCI1XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIyMlxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjE0XFxcXFxcXCIgcng9XFxcXFxcXCI3XFxcXFxcXCIgcnk9XFxcXFxcXCI3XFxcXFxcXCI+PC9yZWN0PjxjaXJjbGUgY3g9XFxcXFxcXCI4XFxcXFxcXCIgY3k9XFxcXFxcXCIxMlxcXFxcXFwiIHI9XFxcXFxcXCIzXFxcXFxcXCI+PC9jaXJjbGU+XFxcIixcXFwidG9nZ2xlLXJpZ2h0XFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjFcXFxcXFxcIiB5PVxcXFxcXFwiNVxcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMjJcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxNFxcXFxcXFwiIHJ4PVxcXFxcXFwiN1xcXFxcXFwiIHJ5PVxcXFxcXFwiN1xcXFxcXFwiPjwvcmVjdD48Y2lyY2xlIGN4PVxcXFxcXFwiMTZcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjNcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJ0b29sXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0xNC43IDYuM2ExIDEgMCAwIDAgMCAxLjRsMS42IDEuNmExIDEgMCAwIDAgMS40IDBsMy43Ny0zLjc3YTYgNiAwIDAgMS03Ljk0IDcuOTRsLTYuOTEgNi45MWEyLjEyIDIuMTIgMCAwIDEtMy0zbDYuOTEtNi45MWE2IDYgMCAwIDEgNy45NC03Ljk0bC0zLjc2IDMuNzZ6XFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInRyYXNoLTJcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMyA2IDUgNiAyMSA2XFxcXFxcXCI+PC9wb2x5bGluZT48cGF0aCBkPVxcXFxcXFwiTTE5IDZ2MTRhMiAyIDAgMCAxLTIgMkg3YTIgMiAwIDAgMS0yLTJWNm0zIDBWNGEyIDIgMCAwIDEgMi0yaDRhMiAyIDAgMCAxIDIgMnYyXFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMTBcXFxcXFxcIiB5MT1cXFxcXFxcIjExXFxcXFxcXCIgeDI9XFxcXFxcXCIxMFxcXFxcXFwiIHkyPVxcXFxcXFwiMTdcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxNFxcXFxcXFwiIHkxPVxcXFxcXFwiMTFcXFxcXFxcIiB4Mj1cXFxcXFxcIjE0XFxcXFxcXCIgeTI9XFxcXFxcXCIxN1xcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ0cmFzaFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIzIDYgNSA2IDIxIDZcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNMTkgNnYxNGEyIDIgMCAwIDEtMiAySDdhMiAyIDAgMCAxLTItMlY2bTMgMFY0YTIgMiAwIDAgMSAyLTJoNGEyIDIgMCAwIDEgMiAydjJcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwidHJlbGxvXFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjNcXFxcXFxcIiB5PVxcXFxcXFwiM1xcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMThcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxOFxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD48cmVjdCB4PVxcXFxcXFwiN1xcXFxcXFwiIHk9XFxcXFxcXCI3XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIzXFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiOVxcXFxcXFwiPjwvcmVjdD48cmVjdCB4PVxcXFxcXFwiMTRcXFxcXFxcIiB5PVxcXFxcXFwiN1xcXFxcXFwiIHdpZHRoPVxcXFxcXFwiM1xcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjVcXFxcXFxcIj48L3JlY3Q+XFxcIixcXFwidHJlbmRpbmctZG93blxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIyMyAxOCAxMy41IDguNSA4LjUgMTMuNSAxIDZcXFxcXFxcIj48L3BvbHlsaW5lPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNyAxOCAyMyAxOCAyMyAxMlxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwidHJlbmRpbmctdXBcXFwiOlxcXCI8cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMjMgNiAxMy41IDE1LjUgOC41IDEwLjUgMSAxOFxcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE3IDYgMjMgNiAyMyAxMlxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwidHJpYW5nbGVcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTEwLjI5IDMuODZMMS44MiAxOGEyIDIgMCAwIDAgMS43MSAzaDE2Ljk0YTIgMiAwIDAgMCAxLjcxLTNMMTMuNzEgMy44NmEyIDIgMCAwIDAtMy40MiAwelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJ0cnVja1xcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIxXFxcXFxcXCIgeT1cXFxcXFxcIjNcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE1XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMTNcXFxcXFxcIj48L3JlY3Q+PHBvbHlnb24gcG9pbnRzPVxcXFxcXFwiMTYgOCAyMCA4IDIzIDExIDIzIDE2IDE2IDE2IDE2IDhcXFxcXFxcIj48L3BvbHlnb24+PGNpcmNsZSBjeD1cXFxcXFxcIjUuNVxcXFxcXFwiIGN5PVxcXFxcXFwiMTguNVxcXFxcXFwiIHI9XFxcXFxcXCIyLjVcXFxcXFxcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVxcXFxcXFwiMTguNVxcXFxcXFwiIGN5PVxcXFxcXFwiMTguNVxcXFxcXFwiIHI9XFxcXFxcXCIyLjVcXFxcXFxcIj48L2NpcmNsZT5cXFwiLFxcXCJ0dlxcXCI6XFxcIjxyZWN0IHg9XFxcXFxcXCIyXFxcXFxcXCIgeT1cXFxcXFxcIjdcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjIwXFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMTVcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE3IDIgMTIgNyA3IDJcXFxcXFxcIj48L3BvbHlsaW5lPlxcXCIsXFxcInR3aXRjaFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjEgMkgzdjE2aDV2NGw0LTRoNWw0LTRWMnptLTEwIDlWN201IDRWN1xcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJ0d2l0dGVyXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMyAzYTEwLjkgMTAuOSAwIDAgMS0zLjE0IDEuNTMgNC40OCA0LjQ4IDAgMCAwLTcuODYgM3YxQTEwLjY2IDEwLjY2IDAgMCAxIDMgNHMtNCA5IDUgMTNhMTEuNjQgMTEuNjQgMCAwIDEtNyAyYzkgNSAyMCAwIDIwLTExLjVhNC41IDQuNSAwIDAgMC0uMDgtLjgzQTcuNzIgNy43MiAwIDAgMCAyMyAzelxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJ0eXBlXFxcIjpcXFwiPHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjQgNyA0IDQgMjAgNCAyMCA3XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjIwXFxcXFxcXCIgeDI9XFxcXFxcXCIxNVxcXFxcXFwiIHkyPVxcXFxcXFwiMjBcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIxMlxcXFxcXFwiIHkxPVxcXFxcXFwiNFxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjIwXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInVtYnJlbGxhXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMyAxMmExMS4wNSAxMS4wNSAwIDAgMC0yMiAwem0tNSA3YTMgMyAwIDAgMS02IDB2LTdcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwidW5kZXJsaW5lXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk02IDN2N2E2IDYgMCAwIDAgNiA2IDYgNiAwIDAgMCA2LTZWM1xcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjRcXFxcXFxcIiB5MT1cXFxcXFxcIjIxXFxcXFxcXCIgeDI9XFxcXFxcXCIyMFxcXFxcXFwiIHkyPVxcXFxcXFwiMjFcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwidW5sb2NrXFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjNcXFxcXFxcIiB5PVxcXFxcXFwiMTFcXFxcXFxcIiB3aWR0aD1cXFxcXFxcIjE4XFxcXFxcXCIgaGVpZ2h0PVxcXFxcXFwiMTFcXFxcXFxcIiByeD1cXFxcXFxcIjJcXFxcXFxcIiByeT1cXFxcXFxcIjJcXFxcXFxcIj48L3JlY3Q+PHBhdGggZD1cXFxcXFxcIk03IDExVjdhNSA1IDAgMCAxIDkuOS0xXFxcXFxcXCI+PC9wYXRoPlxcXCIsXFxcInVwbG9hZC1jbG91ZFxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNiAxNiAxMiAxMiA4IDE2XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIxMlxcXFxcXFwiIHgyPVxcXFxcXFwiMTJcXFxcXFxcIiB5Mj1cXFxcXFxcIjIxXFxcXFxcXCI+PC9saW5lPjxwYXRoIGQ9XFxcXFxcXCJNMjAuMzkgMTguMzlBNSA1IDAgMCAwIDE4IDloLTEuMjZBOCA4IDAgMSAwIDMgMTYuM1xcXFxcXFwiPjwvcGF0aD48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTYgMTYgMTIgMTIgOCAxNlxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwidXBsb2FkXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMSAxNXY0YTIgMiAwIDAgMS0yIDJINWEyIDIgMCAwIDEtMi0ydi00XFxcXFxcXCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxNyA4IDEyIDMgNyA4XFxcXFxcXCI+PC9wb2x5bGluZT48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIzXFxcXFxcXCIgeDI9XFxcXFxcXCIxMlxcXFxcXFwiIHkyPVxcXFxcXFwiMTVcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwidXNlci1jaGVja1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTYgMjF2LTJhNCA0IDAgMCAwLTQtNEg1YTQgNCAwIDAgMC00IDR2MlxcXFxcXFwiPjwvcGF0aD48Y2lyY2xlIGN4PVxcXFxcXFwiOC41XFxcXFxcXCIgY3k9XFxcXFxcXCI3XFxcXFxcXCIgcj1cXFxcXFxcIjRcXFxcXFxcIj48L2NpcmNsZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTcgMTEgMTkgMTMgMjMgOVxcXFxcXFwiPjwvcG9seWxpbmU+XFxcIixcXFwidXNlci1taW51c1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTYgMjF2LTJhNCA0IDAgMCAwLTQtNEg1YTQgNCAwIDAgMC00IDR2MlxcXFxcXFwiPjwvcGF0aD48Y2lyY2xlIGN4PVxcXFxcXFwiOC41XFxcXFxcXCIgY3k9XFxcXFxcXCI3XFxcXFxcXCIgcj1cXFxcXFxcIjRcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjIzXFxcXFxcXCIgeTE9XFxcXFxcXCIxMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTdcXFxcXFxcIiB5Mj1cXFxcXFxcIjExXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInVzZXItcGx1c1xcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMTYgMjF2LTJhNCA0IDAgMCAwLTQtNEg1YTQgNCAwIDAgMC00IDR2MlxcXFxcXFwiPjwvcGF0aD48Y2lyY2xlIGN4PVxcXFxcXFwiOC41XFxcXFxcXCIgY3k9XFxcXFxcXCI3XFxcXFxcXCIgcj1cXFxcXFxcIjRcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjIwXFxcXFxcXCIgeTE9XFxcXFxcXCI4XFxcXFxcXCIgeDI9XFxcXFxcXCIyMFxcXFxcXFwiIHkyPVxcXFxcXFwiMTRcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCIyM1xcXFxcXFwiIHkxPVxcXFxcXFwiMTFcXFxcXFxcIiB4Mj1cXFxcXFxcIjE3XFxcXFxcXCIgeTI9XFxcXFxcXCIxMVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ1c2VyLXhcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE2IDIxdi0yYTQgNCAwIDAgMC00LTRINWE0IDQgMCAwIDAtNCA0djJcXFxcXFxcIj48L3BhdGg+PGNpcmNsZSBjeD1cXFxcXFxcIjguNVxcXFxcXFwiIGN5PVxcXFxcXFwiN1xcXFxcXFwiIHI9XFxcXFxcXCI0XFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCIxOFxcXFxcXFwiIHkxPVxcXFxcXFwiOFxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjEzXFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMjNcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjE4XFxcXFxcXCIgeTI9XFxcXFxcXCIxM1xcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ1c2VyXFxcIjpcXFwiPHBhdGggZD1cXFxcXFxcIk0yMCAyMXYtMmE0IDQgMCAwIDAtNC00SDhhNCA0IDAgMCAwLTQgNHYyXFxcXFxcXCI+PC9wYXRoPjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiN1xcXFxcXFwiIHI9XFxcXFxcXCI0XFxcXFxcXCI+PC9jaXJjbGU+XFxcIixcXFwidXNlcnNcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE3IDIxdi0yYTQgNCAwIDAgMC00LTRINWE0IDQgMCAwIDAtNCA0djJcXFxcXFxcIj48L3BhdGg+PGNpcmNsZSBjeD1cXFxcXFxcIjlcXFxcXFxcIiBjeT1cXFxcXFxcIjdcXFxcXFxcIiByPVxcXFxcXFwiNFxcXFxcXFwiPjwvY2lyY2xlPjxwYXRoIGQ9XFxcXFxcXCJNMjMgMjF2LTJhNCA0IDAgMCAwLTMtMy44N1xcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTE2IDMuMTNhNCA0IDAgMCAxIDAgNy43NVxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJ2aWRlby1vZmZcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTE2IDE2djFhMiAyIDAgMCAxLTIgMkgzYTIgMiAwIDAgMS0yLTJWN2EyIDIgMCAwIDEgMi0yaDJtNS42NiAwSDE0YTIgMiAwIDAgMSAyIDJ2My4zNGwxIDFMMjMgN3YxMFxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjFcXFxcXFxcIiB5MT1cXFxcXFxcIjFcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIyM1xcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ2aWRlb1xcXCI6XFxcIjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjIzIDcgMTYgMTIgMjMgMTcgMjMgN1xcXFxcXFwiPjwvcG9seWdvbj48cmVjdCB4PVxcXFxcXFwiMVxcXFxcXFwiIHk9XFxcXFxcXCI1XFxcXFxcXCIgd2lkdGg9XFxcXFxcXCIxNVxcXFxcXFwiIGhlaWdodD1cXFxcXFxcIjE0XFxcXFxcXCIgcng9XFxcXFxcXCIyXFxcXFxcXCIgcnk9XFxcXFxcXCIyXFxcXFxcXCI+PC9yZWN0PlxcXCIsXFxcInZvaWNlbWFpbFxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCI1LjVcXFxcXFxcIiBjeT1cXFxcXFxcIjExLjVcXFxcXFxcIiByPVxcXFxcXFwiNC41XFxcXFxcXCI+PC9jaXJjbGU+PGNpcmNsZSBjeD1cXFxcXFxcIjE4LjVcXFxcXFxcIiBjeT1cXFxcXFxcIjExLjVcXFxcXFxcIiByPVxcXFxcXFwiNC41XFxcXFxcXCI+PC9jaXJjbGU+PGxpbmUgeDE9XFxcXFxcXCI1LjVcXFxcXFxcIiB5MT1cXFxcXFxcIjE2XFxcXFxcXCIgeDI9XFxcXFxcXCIxOC41XFxcXFxcXCIgeTI9XFxcXFxcXCIxNlxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ2b2x1bWUtMVxcXCI6XFxcIjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjExIDUgNiA5IDIgOSAyIDE1IDYgMTUgMTEgMTkgMTEgNVxcXFxcXFwiPjwvcG9seWdvbj48cGF0aCBkPVxcXFxcXFwiTTE1LjU0IDguNDZhNSA1IDAgMCAxIDAgNy4wN1xcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJ2b2x1bWUtMlxcXCI6XFxcIjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjExIDUgNiA5IDIgOSAyIDE1IDYgMTUgMTEgMTkgMTEgNVxcXFxcXFwiPjwvcG9seWdvbj48cGF0aCBkPVxcXFxcXFwiTTE5LjA3IDQuOTNhMTAgMTAgMCAwIDEgMCAxNC4xNE0xNS41NCA4LjQ2YTUgNSAwIDAgMSAwIDcuMDdcXFxcXFxcIj48L3BhdGg+XFxcIixcXFwidm9sdW1lLXhcXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCIxMSA1IDYgOSAyIDkgMiAxNSA2IDE1IDExIDE5IDExIDVcXFxcXFxcIj48L3BvbHlnb24+PGxpbmUgeDE9XFxcXFxcXCIyM1xcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiMTdcXFxcXFxcIiB5Mj1cXFxcXFxcIjE1XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTdcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjIzXFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ2b2x1bWVcXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCIxMSA1IDYgOSAyIDkgMiAxNSA2IDE1IDExIDE5IDExIDVcXFxcXFxcIj48L3BvbHlnb24+XFxcIixcXFwid2F0Y2hcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTJcXFxcXFxcIiBjeT1cXFxcXFxcIjEyXFxcXFxcXCIgcj1cXFxcXFxcIjdcXFxcXFxcIj48L2NpcmNsZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiMTIgOSAxMiAxMiAxMy41IDEzLjVcXFxcXFxcIj48L3BvbHlsaW5lPjxwYXRoIGQ9XFxcXFxcXCJNMTYuNTEgMTcuMzVsLS4zNSAzLjgzYTIgMiAwIDAgMS0yIDEuODJIOS44M2EyIDIgMCAwIDEtMi0xLjgybC0uMzUtMy44M20uMDEtMTAuN2wuMzUtMy44M0EyIDIgMCAwIDEgOS44MyAxaDQuMzVhMiAyIDAgMCAxIDIgMS44MmwuMzUgMy44M1xcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJ3aWZpLW9mZlxcXCI6XFxcIjxsaW5lIHgxPVxcXFxcXFwiMVxcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPjxwYXRoIGQ9XFxcXFxcXCJNMTYuNzIgMTEuMDZBMTAuOTQgMTAuOTQgMCAwIDEgMTkgMTIuNTVcXFxcXFxcIj48L3BhdGg+PHBhdGggZD1cXFxcXFxcIk01IDEyLjU1YTEwLjk0IDEwLjk0IDAgMCAxIDUuMTctMi4zOVxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTEwLjcxIDUuMDVBMTYgMTYgMCAwIDEgMjIuNTggOVxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTEuNDIgOWExNS45MSAxNS45MSAwIDAgMSA0LjctMi44OFxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTguNTMgMTYuMTFhNiA2IDAgMCAxIDYuOTUgMFxcXFxcXFwiPjwvcGF0aD48bGluZSB4MT1cXFxcXFxcIjEyXFxcXFxcXCIgeTE9XFxcXFxcXCIyMFxcXFxcXFwiIHgyPVxcXFxcXFwiMTIuMDFcXFxcXFxcIiB5Mj1cXFxcXFxcIjIwXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcIndpZmlcXFwiOlxcXCI8cGF0aCBkPVxcXFxcXFwiTTUgMTIuNTVhMTEgMTEgMCAwIDEgMTQuMDggMFxcXFxcXFwiPjwvcGF0aD48cGF0aCBkPVxcXFxcXFwiTTEuNDIgOWExNiAxNiAwIDAgMSAyMS4xNiAwXFxcXFxcXCI+PC9wYXRoPjxwYXRoIGQ9XFxcXFxcXCJNOC41MyAxNi4xMWE2IDYgMCAwIDEgNi45NSAwXFxcXFxcXCI+PC9wYXRoPjxsaW5lIHgxPVxcXFxcXFwiMTJcXFxcXFxcIiB5MT1cXFxcXFxcIjIwXFxcXFxcXCIgeDI9XFxcXFxcXCIxMi4wMVxcXFxcXFwiIHkyPVxcXFxcXFwiMjBcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwid2luZFxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNOS41OSA0LjU5QTIgMiAwIDEgMSAxMSA4SDJtMTAuNTkgMTEuNDFBMiAyIDAgMSAwIDE0IDE2SDJtMTUuNzMtOC4yN0EyLjUgMi41IDAgMSAxIDE5LjUgMTJIMlxcXFxcXFwiPjwvcGF0aD5cXFwiLFxcXCJ4LWNpcmNsZVxcXCI6XFxcIjxjaXJjbGUgY3g9XFxcXFxcXCIxMlxcXFxcXFwiIGN5PVxcXFxcXFwiMTJcXFxcXFxcIiByPVxcXFxcXFwiMTBcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjE1XFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCI5XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjE1XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ4LW9jdGFnb25cXFwiOlxcXCI8cG9seWdvbiBwb2ludHM9XFxcXFxcXCI3Ljg2IDIgMTYuMTQgMiAyMiA3Ljg2IDIyIDE2LjE0IDE2LjE0IDIyIDcuODYgMjIgMiAxNi4xNCAyIDcuODYgNy44NiAyXFxcXFxcXCI+PC9wb2x5Z29uPjxsaW5lIHgxPVxcXFxcXFwiMTVcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjlcXFxcXFxcIiB5Mj1cXFxcXFxcIjE1XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOVxcXFxcXFwiIHkxPVxcXFxcXFwiOVxcXFxcXFwiIHgyPVxcXFxcXFwiMTVcXFxcXFxcIiB5Mj1cXFxcXFxcIjE1XFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcIngtc3F1YXJlXFxcIjpcXFwiPHJlY3QgeD1cXFxcXFxcIjNcXFxcXFxcIiB5PVxcXFxcXFwiM1xcXFxcXFwiIHdpZHRoPVxcXFxcXFwiMThcXFxcXFxcIiBoZWlnaHQ9XFxcXFxcXCIxOFxcXFxcXFwiIHJ4PVxcXFxcXFwiMlxcXFxcXFwiIHJ5PVxcXFxcXFwiMlxcXFxcXFwiPjwvcmVjdD48bGluZSB4MT1cXFxcXFxcIjlcXFxcXFxcIiB5MT1cXFxcXFxcIjlcXFxcXFxcIiB4Mj1cXFxcXFxcIjE1XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjE1XFxcXFxcXCIgeTE9XFxcXFxcXCI5XFxcXFxcXCIgeDI9XFxcXFxcXCI5XFxcXFxcXCIgeTI9XFxcXFxcXCIxNVxcXFxcXFwiPjwvbGluZT5cXFwiLFxcXCJ4XFxcIjpcXFwiPGxpbmUgeDE9XFxcXFxcXCIxOFxcXFxcXFwiIHkxPVxcXFxcXFwiNlxcXFxcXFwiIHgyPVxcXFxcXFwiNlxcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+PGxpbmUgeDE9XFxcXFxcXCI2XFxcXFxcXCIgeTE9XFxcXFxcXCI2XFxcXFxcXCIgeDI9XFxcXFxcXCIxOFxcXFxcXFwiIHkyPVxcXFxcXFwiMThcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwieW91dHViZVxcXCI6XFxcIjxwYXRoIGQ9XFxcXFxcXCJNMjIuNTQgNi40MmEyLjc4IDIuNzggMCAwIDAtMS45NC0yQzE4Ljg4IDQgMTIgNCAxMiA0cy02Ljg4IDAtOC42LjQ2YTIuNzggMi43OCAwIDAgMC0xLjk0IDJBMjkgMjkgMCAwIDAgMSAxMS43NWEyOSAyOSAwIDAgMCAuNDYgNS4zM0EyLjc4IDIuNzggMCAwIDAgMy40IDE5YzEuNzIuNDYgOC42LjQ2IDguNi40NnM2Ljg4IDAgOC42LS40NmEyLjc4IDIuNzggMCAwIDAgMS45NC0yIDI5IDI5IDAgMCAwIC40Ni01LjI1IDI5IDI5IDAgMCAwLS40Ni01LjMzelxcXFxcXFwiPjwvcGF0aD48cG9seWdvbiBwb2ludHM9XFxcXFxcXCI5Ljc1IDE1LjAyIDE1LjUgMTEuNzUgOS43NSA4LjQ4IDkuNzUgMTUuMDJcXFxcXFxcIj48L3BvbHlnb24+XFxcIixcXFwiemFwLW9mZlxcXCI6XFxcIjxwb2x5bGluZSBwb2ludHM9XFxcXFxcXCIxMi40MSA2Ljc1IDEzIDIgMTAuNTcgNC45MlxcXFxcXFwiPjwvcG9seWxpbmU+PHBvbHlsaW5lIHBvaW50cz1cXFxcXFxcIjE4LjU3IDEyLjkxIDIxIDEwIDE1LjY2IDEwXFxcXFxcXCI+PC9wb2x5bGluZT48cG9seWxpbmUgcG9pbnRzPVxcXFxcXFwiOCA4IDMgMTQgMTIgMTQgMTEgMjIgMTYgMTZcXFxcXFxcIj48L3BvbHlsaW5lPjxsaW5lIHgxPVxcXFxcXFwiMVxcXFxcXFwiIHkxPVxcXFxcXFwiMVxcXFxcXFwiIHgyPVxcXFxcXFwiMjNcXFxcXFxcIiB5Mj1cXFxcXFxcIjIzXFxcXFxcXCI+PC9saW5lPlxcXCIsXFxcInphcFxcXCI6XFxcIjxwb2x5Z29uIHBvaW50cz1cXFxcXFxcIjEzIDIgMyAxNCAxMiAxNCAxMSAyMiAyMSAxMCAxMiAxMCAxMyAyXFxcXFxcXCI+PC9wb2x5Z29uPlxcXCIsXFxcInpvb20taW5cXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTFcXFxcXFxcIiBjeT1cXFxcXFxcIjExXFxcXFxcXCIgcj1cXFxcXFxcIjhcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCIyMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTYuNjVcXFxcXFxcIiB5Mj1cXFxcXFxcIjE2LjY1XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiMTFcXFxcXFxcIiB5MT1cXFxcXFxcIjhcXFxcXFxcIiB4Mj1cXFxcXFxcIjExXFxcXFxcXCIgeTI9XFxcXFxcXCIxNFxcXFxcXFwiPjwvbGluZT48bGluZSB4MT1cXFxcXFxcIjhcXFxcXFxcIiB5MT1cXFxcXFxcIjExXFxcXFxcXCIgeDI9XFxcXFxcXCIxNFxcXFxcXFwiIHkyPVxcXFxcXFwiMTFcXFxcXFxcIj48L2xpbmU+XFxcIixcXFwiem9vbS1vdXRcXFwiOlxcXCI8Y2lyY2xlIGN4PVxcXFxcXFwiMTFcXFxcXFxcIiBjeT1cXFxcXFxcIjExXFxcXFxcXCIgcj1cXFxcXFxcIjhcXFxcXFxcIj48L2NpcmNsZT48bGluZSB4MT1cXFxcXFxcIjIxXFxcXFxcXCIgeTE9XFxcXFxcXCIyMVxcXFxcXFwiIHgyPVxcXFxcXFwiMTYuNjVcXFxcXFxcIiB5Mj1cXFxcXFxcIjE2LjY1XFxcXFxcXCI+PC9saW5lPjxsaW5lIHgxPVxcXFxcXFwiOFxcXFxcXFwiIHkxPVxcXFxcXFwiMTFcXFxcXFxcIiB4Mj1cXFxcXFxcIjE0XFxcXFxcXCIgeTI9XFxcXFxcXCIxMVxcXFxcXFwiPjwvbGluZT5cXFwifTtcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9kZWR1cGUuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9kZWR1cGUuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiFcXG4gIENvcHlyaWdodCAoYykgMjAxNiBKZWQgV2F0c29uLlxcbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcXG4qL1xcbi8qIGdsb2JhbCBkZWZpbmUgKi9cXG5cXG4oZnVuY3Rpb24gKCkge1xcblxcdCd1c2Ugc3RyaWN0JztcXG5cXG5cXHR2YXIgY2xhc3NOYW1lcyA9IChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0Ly8gZG9uJ3QgaW5oZXJpdCBmcm9tIE9iamVjdCBzbyB3ZSBjYW4gc2tpcCBoYXNPd25Qcm9wZXJ0eSBjaGVjayBsYXRlclxcblxcdFxcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU1MTgzMjgvY3JlYXRpbmctanMtb2JqZWN0LXdpdGgtb2JqZWN0LWNyZWF0ZW51bGwjYW5zd2VyLTIxMDc5MjMyXFxuXFx0XFx0ZnVuY3Rpb24gU3RvcmFnZU9iamVjdCgpIHt9XFxuXFx0XFx0U3RvcmFnZU9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xcblxcblxcdFxcdGZ1bmN0aW9uIF9wYXJzZUFycmF5IChyZXN1bHRTZXQsIGFycmF5KSB7XFxuXFx0XFx0XFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XFxuXFx0XFx0XFx0XFx0X3BhcnNlKHJlc3VsdFNldCwgYXJyYXlbaV0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xcblxcblxcdFxcdGZ1bmN0aW9uIF9wYXJzZU51bWJlciAocmVzdWx0U2V0LCBudW0pIHtcXG5cXHRcXHRcXHRyZXN1bHRTZXRbbnVtXSA9IHRydWU7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIF9wYXJzZU9iamVjdCAocmVzdWx0U2V0LCBvYmplY3QpIHtcXG5cXHRcXHRcXHRmb3IgKHZhciBrIGluIG9iamVjdCkge1xcblxcdFxcdFxcdFxcdGlmIChoYXNPd24uY2FsbChvYmplY3QsIGspKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gc2V0IHZhbHVlIHRvIGZhbHNlIGluc3RlYWQgb2YgZGVsZXRpbmcgaXQgdG8gYXZvaWQgY2hhbmdpbmcgb2JqZWN0IHN0cnVjdHVyZVxcblxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vd3d3LnNtYXNoaW5nbWFnYXppbmUuY29tLzIwMTIvMTEvd3JpdGluZy1mYXN0LW1lbW9yeS1lZmZpY2llbnQtamF2YXNjcmlwdC8jZGUtcmVmZXJlbmNpbmctbWlzY29uY2VwdGlvbnNcXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHRTZXRba10gPSAhIW9iamVjdFtrXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgU1BBQ0UgPSAvXFxcXHMrLztcXG5cXHRcXHRmdW5jdGlvbiBfcGFyc2VTdHJpbmcgKHJlc3VsdFNldCwgc3RyKSB7XFxuXFx0XFx0XFx0dmFyIGFycmF5ID0gc3RyLnNwbGl0KFNQQUNFKTtcXG5cXHRcXHRcXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xcblxcblxcdFxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcXG5cXHRcXHRcXHRcXHRyZXN1bHRTZXRbYXJyYXlbaV1dID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIF9wYXJzZSAocmVzdWx0U2V0LCBhcmcpIHtcXG5cXHRcXHRcXHRpZiAoIWFyZykgcmV0dXJuO1xcblxcdFxcdFxcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcXG5cXG5cXHRcXHRcXHQvLyAnZm9vIGJhcidcXG5cXHRcXHRcXHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycpIHtcXG5cXHRcXHRcXHRcXHRfcGFyc2VTdHJpbmcocmVzdWx0U2V0LCBhcmcpO1xcblxcblxcdFxcdFxcdC8vIFsnZm9vJywgJ2JhcicsIC4uLl1cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xcblxcdFxcdFxcdFxcdF9wYXJzZUFycmF5KHJlc3VsdFNldCwgYXJnKTtcXG5cXG5cXHRcXHRcXHQvLyB7ICdmb28nOiB0cnVlLCAuLi4gfVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRfcGFyc2VPYmplY3QocmVzdWx0U2V0LCBhcmcpO1xcblxcblxcdFxcdFxcdC8vICcxMzAnXFxuXFx0XFx0XFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnbnVtYmVyJykge1xcblxcdFxcdFxcdFxcdF9wYXJzZU51bWJlcihyZXN1bHRTZXQsIGFyZyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBfY2xhc3NOYW1lcyAoKSB7XFxuXFx0XFx0XFx0Ly8gZG9uJ3QgbGVhayBhcmd1bWVudHNcXG5cXHRcXHRcXHQvLyBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMzItbGVha2luZy1hcmd1bWVudHNcXG5cXHRcXHRcXHR2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcXG5cXHRcXHRcXHR2YXIgYXJncyA9IEFycmF5KGxlbik7XFxuXFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xcblxcdFxcdFxcdFxcdGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBjbGFzc1NldCA9IG5ldyBTdG9yYWdlT2JqZWN0KCk7XFxuXFx0XFx0XFx0X3BhcnNlQXJyYXkoY2xhc3NTZXQsIGFyZ3MpO1xcblxcblxcdFxcdFxcdHZhciBsaXN0ID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICh2YXIgayBpbiBjbGFzc1NldCkge1xcblxcdFxcdFxcdFxcdGlmIChjbGFzc1NldFtrXSkge1xcblxcdFxcdFxcdFxcdFxcdGxpc3QucHVzaChrKVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGxpc3Quam9pbignICcpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gX2NsYXNzTmFtZXM7XFxuXFx0fSkoKTtcXG5cXG5cXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XFxuXFx0fSBlbHNlIGlmICh0cnVlKSB7XFxuXFx0XFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxcblxcdFxcdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGNsYXNzTmFtZXM7XFxuXFx0XFx0fSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xcblxcdH0gZWxzZSB7fVxcbn0oKSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvYXJyYXkvZnJvbS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9hcnJheS9mcm9tLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcXFwiKTtcXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9tb2R1bGVzL2VzLmFycmF5LmZyb20gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzXFxcIik7XFxudmFyIHBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9pbnRlcm5hbHMvcGF0aCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGF0aC5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gcGF0aC5BcnJheS5mcm9tO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWZ1bmN0aW9uLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1mdW5jdGlvbi5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB7XFxuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xcbiAgfSByZXR1cm4gaXQ7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgaWYgKCFpc09iamVjdChpdCkpIHtcXG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcXG4gIH0gcmV0dXJuIGl0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZyb20uanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mcm9tLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9iaW5kLWNvbnRleHQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2JpbmQtY29udGV4dC5qc1xcXCIpO1xcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1xcXCIpO1xcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZy5qc1xcXCIpO1xcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanNcXFwiKTtcXG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanNcXFwiKTtcXG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanNcXFwiKTtcXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xcXCIpO1xcblxcbi8vIGBBcnJheS5mcm9tYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5mcm9tXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XFxuICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XFxuICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XFxuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcXG4gIHZhciBtYXBmbiA9IGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XFxuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XFxuICB2YXIgaW5kZXggPSAwO1xcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoTyk7XFxuICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xcbiAgaWYgKG1hcHBpbmcpIG1hcGZuID0gYmluZChtYXBmbiwgYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XFxuICAvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBpdGVyYWJsZSBvciBpdCdzIGFuIGFycmF5IHdpdGggdGhlIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2UgYSBzaW1wbGUgY2FzZVxcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkpIHtcXG4gICAgaXRlcmF0b3IgPSBpdGVyYXRvck1ldGhvZC5jYWxsKE8pO1xcbiAgICByZXN1bHQgPSBuZXcgQygpO1xcbiAgICBmb3IgKDshKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcXG4gICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nXFxuICAgICAgICA/IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKVxcbiAgICAgICAgOiBzdGVwLnZhbHVlXFxuICAgICAgKTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xcbiAgICByZXN1bHQgPSBuZXcgQyhsZW5ndGgpO1xcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xcbiAgICB9XFxuICB9XFxuICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1xcXCIpO1xcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1sZW5ndGggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qc1xcXCIpO1xcbnZhciB0b0Fic29sdXRlSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXggKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4LmpzXFxcIik7XFxuXFxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cXG4vLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XFxuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcXG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcXG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcXG4gICAgdmFyIHZhbHVlO1xcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcXG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XFxuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcXG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XFxuICB9O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2JpbmQtY29udGV4dC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYmluZC1jb250ZXh0LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hLWZ1bmN0aW9uICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWZ1bmN0aW9uLmpzXFxcIik7XFxuXFxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xcbiAgYUZ1bmN0aW9uKGZuKTtcXG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcXG4gIHN3aXRjaCAobGVuZ3RoKSB7XFxuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0KTtcXG4gICAgfTtcXG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcXG4gICAgfTtcXG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcXG4gICAgfTtcXG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcXG4gICAgfTtcXG4gIH1cXG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcXG4gIH07XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1xcXCIpO1xcblxcbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XFxuICB0cnkge1xcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcXG4gIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgIHZhciByZXR1cm5NZXRob2QgPSBpdGVyYXRvclsncmV0dXJuJ107XFxuICAgIGlmIChyZXR1cm5NZXRob2QgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0dXJuTWV0aG9kLmNhbGwoaXRlcmF0b3IpKTtcXG4gICAgdGhyb3cgZXJyb3I7XFxuICB9XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1xcXCIpO1xcblxcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcXG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XFxuXFxudHJ5IHtcXG4gIHZhciBjYWxsZWQgPSAwO1xcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcXG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcXG4gICAgfSxcXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcXG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xcbiAgICB9XFxuICB9O1xcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcXG4gIEFycmF5LmZyb20oaXRlcmF0b3JXaXRoUmV0dXJuLCBmdW5jdGlvbiAoKSB7IHRocm93IDI7IH0pO1xcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBTS0lQX0NMT1NJTkcpIHtcXG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcXG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xcbiAgdHJ5IHtcXG4gICAgdmFyIG9iamVjdCA9IHt9O1xcbiAgICBvYmplY3RbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZSB9O1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH07XFxuICAgIGV4ZWMob2JqZWN0KTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cXG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGNsYXNzb2ZSYXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzXFxcIik7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG5cXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcXG4vLyBFUzMgd3JvbmcgaGVyZVxcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xcblxcbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXFxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XFxuICB0cnkge1xcbiAgICByZXR1cm4gaXRba2V5XTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cXG59O1xcblxcbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXFxuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXFxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXFxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcXFwiKTtcXG52YXIgb3duS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vd24ta2V5cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanNcXFwiKTtcXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiKTtcXG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XFxuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcXG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XFxuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGtleSA9IGtleXNbaV07XFxuICAgIGlmICghaGFzKHRhcmdldCwga2V5KSkgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xcbiAgfVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cXG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3Rvci5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzXFxcIikuSXRlcmF0b3JQcm90b3R5cGU7XFxudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzXFxcIik7XFxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiKTtcXG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzXFxcIik7XFxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1xcXCIpO1xcblxcbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XFxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcXG4gIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcXG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcXG4gIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XFxuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3RvcjtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xcbiAgcmV0dXJuIHtcXG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcXG4gICAgdmFsdWU6IHZhbHVlXFxuICB9O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1wcmltaXRpdmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qc1xcXCIpO1xcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXFxcIik7XFxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcXG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKGtleSk7XFxuICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCB2YWx1ZSkpO1xcbiAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZXhwb3J0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanNcXFwiKTtcXG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3Rvci5qc1xcXCIpO1xcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanNcXFwiKTtcXG52YXIgc2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzXFxcIik7XFxudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qc1xcXCIpO1xcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hpZGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGUuanNcXFwiKTtcXG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVkZWZpbmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzXFxcIik7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1wdXJlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzXFxcIik7XFxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1xcXCIpO1xcbnZhciBJdGVyYXRvcnNDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMtY29yZS5qc1xcXCIpO1xcblxcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XFxudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XFxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xcbnZhciBLRVlTID0gJ2tleXMnO1xcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcXG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcXG5cXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XFxuICBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xcblxcbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XFxuICAgIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcikgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcXG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcXG4gICAgc3dpdGNoIChLSU5EKSB7XFxuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XFxuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xcbiAgICB9IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcXG4gIH07XFxuXFxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcXG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcXG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcXG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXVxcbiAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXFxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XFxuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xcblxcbiAgLy8gZml4IG5hdGl2ZVxcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XFxuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcXG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XFxuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XFxuICAgICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcXG4gICAgICAgICAgc2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgaGlkZShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xcbiAgICAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XFxuICAgICAgaWYgKElTX1BVUkUpIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcXG4gIGlmIChERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcXG4gICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcXG4gICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmF0aXZlSXRlcmF0b3IuY2FsbCh0aGlzKTsgfTtcXG4gIH1cXG5cXG4gIC8vIGRlZmluZSBpdGVyYXRvclxcbiAgaWYgKCghSVNfUFVSRSB8fCBGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XFxuICAgIGhpZGUoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SLCBkZWZhdWx0SXRlcmF0b3IpO1xcbiAgfVxcbiAgSXRlcmF0b3JzW05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xcblxcbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xcbiAgaWYgKERFRkFVTFQpIHtcXG4gICAgbWV0aG9kcyA9IHtcXG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcXG4gICAgfTtcXG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcXG4gICAgICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgJCh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XFxuICB9XFxuXFxuICByZXR1cm4gbWV0aG9kcztcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcblxcbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcXFwiKTtcXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcXFwiKTtcXG5cXG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XFxuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXFxudmFyIGV4aXN0ID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gZXhpc3QgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xcbm1vZHVsZS5leHBvcnRzID0gW1xcbiAgJ2NvbnN0cnVjdG9yJyxcXG4gICdoYXNPd25Qcm9wZXJ0eScsXFxuICAnaXNQcm90b3R5cGVPZicsXFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcXG4gICd0b1N0cmluZycsXFxuICAndmFsdWVPZidcXG5dO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcXFwiKTtcXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiKS5mO1xcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hpZGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGUuanNcXFwiKTtcXG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVkZWZpbmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzXFxcIik7XFxudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtZ2xvYmFsLmpzXFxcIik7XFxudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanNcXFwiKTtcXG52YXIgaXNGb3JjZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtZm9yY2VkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanNcXFwiKTtcXG5cXG4vKlxcbiAgb3B0aW9ucy50YXJnZXQgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcXG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcXG4gIG9wdGlvbnMuc3RhdCAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XFxuICBvcHRpb25zLnByb3RvICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXFxuICBvcHRpb25zLmZvcmNlZCAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxcbiAgb3B0aW9ucy5iaW5kICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXFxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXFxuICBvcHRpb25zLnVuc2FmZSAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XFxuICBvcHRpb25zLnNoYW0gICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XFxuICBvcHRpb25zLm5vVGFyZ2V0R2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxcbiovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XFxuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XFxuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XFxuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcXG4gIGlmIChHTE9CQUwpIHtcXG4gICAgdGFyZ2V0ID0gZ2xvYmFsO1xcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcXG4gICAgdGFyZ2V0ID0gZ2xvYmFsW1RBUkdFVF0gfHwgc2V0R2xvYmFsKFRBUkdFVCwge30pO1xcbiAgfSBlbHNlIHtcXG4gICAgdGFyZ2V0ID0gKGdsb2JhbFtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XFxuICB9XFxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcXG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcXG4gICAgaWYgKG9wdGlvbnMubm9UYXJnZXRHZXQpIHtcXG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcXG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcXG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XFxuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XFxuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcXG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XFxuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xcbiAgICB9XFxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcXG4gICAgICBoaWRlKHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xcbiAgICB9XFxuICAgIC8vIGV4dGVuZCBnbG9iYWxcXG4gICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcXG4gIH1cXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xcbiAgdHJ5IHtcXG4gICAgcmV0dXJuICEhZXhlYygpO1xcbiAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdG8tc3RyaW5nLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi10by1zdHJpbmcuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBzaGFyZWQoJ25hdGl2ZS1mdW5jdGlvbi10by1zdHJpbmcnLCBGdW5jdGlvbi50b1N0cmluZyk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NsYXNzb2YgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanNcXFwiKTtcXG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzXFxcIik7XFxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcXFwiKTtcXG5cXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxcbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge3ZhciBPID0gJ29iamVjdCc7XFxudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xcbn07XFxuXFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcXG5tb2R1bGUuZXhwb3J0cyA9XFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09IE8gJiYgZ2xvYmFsVGhpcykgfHxcXG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gTyAmJiB3aW5kb3cpIHx8XFxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSBPICYmIHNlbGYpIHx8XFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09IE8gJiYgZ2xvYmFsKSB8fFxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXFxuICBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xcblxcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uLy4uL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcXFwiKSkpXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbm1vZHVsZS5leHBvcnRzID0ge307XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGUuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRlLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1xcXCIpO1xcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcXG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcXG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcXG4gIHJldHVybiBvYmplY3Q7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2h0bWwuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcblxcbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXFxcIik7XFxudmFyIGNyZWF0ZUVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzXFxcIik7XFxuXFxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxcbm1vZHVsZS5leHBvcnRzID0gIURFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XFxuICB9KS5hICE9IDc7XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcXFwiKTtcXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jbGFzc29mLXJhdyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanNcXFwiKTtcXG5cXG52YXIgc3BsaXQgPSAnJy5zcGxpdDtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcXG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcXG4gIHJldHVybiAhT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XFxufSkgPyBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBjbGFzc29mKGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0LmNhbGwoaXQsICcnKSA6IE9iamVjdChpdCk7XFxufSA6IE9iamVjdDtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBOQVRJVkVfV0VBS19NQVAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanNcXFwiKTtcXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXFxcIik7XFxudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZS5qc1xcXCIpO1xcbnZhciBvYmplY3RIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcXFwiKTtcXG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanNcXFwiKTtcXG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRkZW4ta2V5cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanNcXFwiKTtcXG5cXG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xcbnZhciBzZXQsIGdldCwgaGFzO1xcblxcbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcXG59O1xcblxcbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xcbiAgICB2YXIgc3RhdGU7XFxuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcXG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XFxuICAgIH0gcmV0dXJuIHN0YXRlO1xcbiAgfTtcXG59O1xcblxcbmlmIChOQVRJVkVfV0VBS19NQVApIHtcXG4gIHZhciBzdG9yZSA9IG5ldyBXZWFrTWFwKCk7XFxuICB2YXIgd21nZXQgPSBzdG9yZS5nZXQ7XFxuICB2YXIgd21oYXMgPSBzdG9yZS5oYXM7XFxuICB2YXIgd21zZXQgPSBzdG9yZS5zZXQ7XFxuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XFxuICAgIHdtc2V0LmNhbGwoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XFxuICAgIHJldHVybiBtZXRhZGF0YTtcXG4gIH07XFxuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIHdtZ2V0LmNhbGwoc3RvcmUsIGl0KSB8fCB7fTtcXG4gIH07XFxuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIHdtaGFzLmNhbGwoc3RvcmUsIGl0KTtcXG4gIH07XFxufSBlbHNlIHtcXG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcXG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcXG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcXG4gICAgaGlkZShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcXG4gICAgcmV0dXJuIG1ldGFkYXRhO1xcbiAgfTtcXG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcXG4gIH07XFxuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpO1xcbiAgfTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBzZXQ6IHNldCxcXG4gIGdldDogZ2V0LFxcbiAgaGFzOiBoYXMsXFxuICBlbmZvcmNlOiBlbmZvcmNlLFxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3JcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXFxcIik7XFxudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pdGVyYXRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1xcXCIpO1xcblxcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XFxuXFxuLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZVtJVEVSQVRPUl0gPT09IGl0KTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcXFwiKTtcXG5cXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXFxcLnByb3RvdHlwZVxcXFwuLztcXG5cXG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XFxuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XFxuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXFxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcXG4gICAgOiB0eXBlb2YgZGV0ZWN0aW9uID09ICdmdW5jdGlvbicgPyBmYWlscyhkZXRlY3Rpb24pXFxuICAgIDogISFkZXRlY3Rpb247XFxufTtcXG5cXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcXG59O1xcblxcbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZC5OQVRJVkUgPSAnTic7XFxudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBpc0ZvcmNlZDtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMtY29yZS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMtY29yZS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZiAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanNcXFwiKTtcXG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRlLmpzXFxcIik7XFxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1xcXCIpO1xcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXFxcIik7XFxudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtcHVyZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qc1xcXCIpO1xcblxcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcXG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IGZhbHNlO1xcblxcbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcXG5cXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJWAgb2JqZWN0XFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcXG52YXIgSXRlcmF0b3JQcm90b3R5cGUsIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSwgYXJyYXlJdGVyYXRvcjtcXG5cXG5pZiAoW10ua2V5cykge1xcbiAgYXJyYXlJdGVyYXRvciA9IFtdLmtleXMoKTtcXG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcXG4gIGVsc2Uge1xcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihnZXRQcm90b3R5cGVPZihhcnJheUl0ZXJhdG9yKSk7XFxuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xcbiAgfVxcbn1cXG5cXG5pZiAoSXRlcmF0b3JQcm90b3R5cGUgPT0gdW5kZWZpbmVkKSBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xcblxcbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXFxuaWYgKCFJU19QVVJFICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SU1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7fTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XFxuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXFxuICByZXR1cm4gIVN0cmluZyhTeW1ib2woKSk7XFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1xcXCIpO1xcbnZhciBuYXRpdmVGdW5jdGlvblRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXRvLXN0cmluZyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tdG8tc3RyaW5nLmpzXFxcIik7XFxuXFxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChuYXRpdmVGdW5jdGlvblRvU3RyaW5nLmNhbGwoV2Vha01hcCkpO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcXFwiKTtcXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qc1xcXCIpO1xcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzXFxcIik7XFxudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXFxcIik7XFxudmFyIGh0bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaHRtbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qc1xcXCIpO1xcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzXFxcIik7XFxudmFyIHNoYXJlZEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQta2V5ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXFxcIik7XFxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xcblxcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcXG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XFxuXFxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcXG4gIHZhciBsdCA9ICc8JztcXG4gIHZhciBzY3JpcHQgPSAnc2NyaXB0JztcXG4gIHZhciBndCA9ICc+JztcXG4gIHZhciBqcyA9ICdqYXZhJyArIHNjcmlwdCArICc6JztcXG4gIHZhciBpZnJhbWVEb2N1bWVudDtcXG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcbiAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhqcyk7XFxuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyBzY3JpcHQgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvJyArIHNjcmlwdCArIGd0KTtcXG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XFxuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcXG4gIHdoaWxlIChsZW5ndGgtLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcXG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XFxufTtcXG5cXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcXG4gIHZhciByZXN1bHQ7XFxuICBpZiAoTyAhPT0gbnVsbCkge1xcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XFxuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcXG4gICAgLy8gYWRkIFxcXCJfX3Byb3RvX19cXFwiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XFxuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcXG59O1xcblxcbmhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXFxcIik7XFxudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcXFwiKTtcXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcXFwiKTtcXG52YXIgb2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3Qta2V5cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcXG4gIGFuT2JqZWN0KE8pO1xcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xcbiAgdmFyIGkgPSAwO1xcbiAgdmFyIGtleTtcXG4gIHdoaWxlIChsZW5ndGggPiBpKSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaSsrXSwgUHJvcGVydGllc1trZXldKTtcXG4gIHJldHVybiBPO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzXFxcIik7XFxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXFxcIik7XFxudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzXFxcIik7XFxuXFxudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xcblxcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlRGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XFxuICBhbk9iamVjdChPKTtcXG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcXG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xcbiAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XFxuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XFxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XFxuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcXG4gIHJldHVybiBPO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcXFwiKTtcXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzXFxcIik7XFxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcXFwiKTtcXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1xcXCIpO1xcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1wcmltaXRpdmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qc1xcXCIpO1xcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcXFwiKTtcXG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzXFxcIik7XFxuXFxudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XFxuXFxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcXG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcXG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcXG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cXG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoIXByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYuY2FsbChPLCBQKSwgT1tQXSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xcXCIpO1xcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzXFxcIik7XFxuXFxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcXG5cXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcXG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcXFwiKTtcXG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcXFwiKTtcXG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanNcXFwiKTtcXG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzXFxcIik7XFxuXFxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xcblxcbi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXFxubW9kdWxlLmV4cG9ydHMgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xcbiAgTyA9IHRvT2JqZWN0KE8pO1xcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcXG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XFxuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcXG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXFxcIik7XFxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcXFwiKTtcXG52YXIgYXJyYXlJbmNsdWRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanNcXFwiKTtcXG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRkZW4ta2V5cyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanNcXFwiKTtcXG5cXG52YXIgYXJyYXlJbmRleE9mID0gYXJyYXlJbmNsdWRlcyhmYWxzZSk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcXG4gIHZhciBpID0gMDtcXG4gIHZhciByZXN1bHQgPSBbXTtcXG4gIHZhciBrZXk7XFxuICBmb3IgKGtleSBpbiBPKSAhaGFzKGhpZGRlbktleXMsIGtleSkgJiYgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcXG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XFxuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xcXCIpO1xcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzXFxcIik7XFxuXFxuLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXFxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcXG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgZW51bUJ1Z0tleXMpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XFxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XFxuXFxuLy8gTmFzaG9ybiB+IEpESzggYnVnXFxudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICFuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcXG5cXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcXG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XFxufSA6IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHZhbGlkYXRlU2V0UHJvdG90eXBlT2ZBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdmFsaWRhdGUtc2V0LXByb3RvdHlwZS1vZi1hcmd1bWVudHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3ZhbGlkYXRlLXNldC1wcm90b3R5cGUtb2YtYXJndW1lbnRzLmpzXFxcIik7XFxuXFxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XFxuICB2YXIgY29ycmVjdFNldHRlciA9IGZhbHNlO1xcbiAgdmFyIHRlc3QgPSB7fTtcXG4gIHZhciBzZXR0ZXI7XFxuICB0cnkge1xcbiAgICBzZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQ7XFxuICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTtcXG4gICAgY29ycmVjdFNldHRlciA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cXG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xcbiAgICB2YWxpZGF0ZVNldFByb3RvdHlwZU9mQXJndW1lbnRzKE8sIHByb3RvKTtcXG4gICAgaWYgKGNvcnJlY3RTZXR0ZXIpIHNldHRlci5jYWxsKE8sIHByb3RvKTtcXG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xcbiAgICByZXR1cm4gTztcXG4gIH07XFxufSgpIDogdW5kZWZpbmVkKTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcXFwiKTtcXG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanNcXFwiKTtcXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanNcXFwiKTtcXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcXFwiKTtcXG5cXG52YXIgUmVmbGVjdCA9IGdsb2JhbC5SZWZsZWN0O1xcblxcbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcXG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcXG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0KGl0KSk7XFxuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XFxuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qc1xcXCIpO1xcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hpZGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGUuanNcXFwiKTtcXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXFxcIik7XFxudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtZ2xvYmFsLmpzXFxcIik7XFxudmFyIG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdG8tc3RyaW5nICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi10by1zdHJpbmcuanNcXFwiKTtcXG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanNcXFwiKTtcXG5cXG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcXG52YXIgVEVNUExBVEUgPSBTdHJpbmcobmF0aXZlRnVuY3Rpb25Ub1N0cmluZykuc3BsaXQoJ3RvU3RyaW5nJyk7XFxuXFxuc2hhcmVkKCdpbnNwZWN0U291cmNlJywgZnVuY3Rpb24gKGl0KSB7XFxuICByZXR1cm4gbmF0aXZlRnVuY3Rpb25Ub1N0cmluZy5jYWxsKGl0KTtcXG59KTtcXG5cXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xcbiAgdmFyIHVuc2FmZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMudW5zYWZlIDogZmFsc2U7XFxuICB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XFxuICB2YXIgbm9UYXJnZXRHZXQgPSBvcHRpb25zID8gISFvcHRpb25zLm5vVGFyZ2V0R2V0IDogZmFsc2U7XFxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcXG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgJiYgIWhhcyh2YWx1ZSwgJ25hbWUnKSkgaGlkZSh2YWx1ZSwgJ25hbWUnLCBrZXkpO1xcbiAgICBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSkuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8ga2V5IDogJycpO1xcbiAgfVxcbiAgaWYgKE8gPT09IGdsb2JhbCkge1xcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcXG4gICAgZWxzZSBzZXRHbG9iYWwoa2V5LCB2YWx1ZSk7XFxuICAgIHJldHVybjtcXG4gIH0gZWxzZSBpZiAoIXVuc2FmZSkge1xcbiAgICBkZWxldGUgT1trZXldO1xcbiAgfSBlbHNlIGlmICghbm9UYXJnZXRHZXQgJiYgT1trZXldKSB7XFxuICAgIHNpbXBsZSA9IHRydWU7XFxuICB9XFxuICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcXG4gIGVsc2UgaGlkZShPLCBrZXksIHZhbHVlKTtcXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcXG59KShGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgbmF0aXZlRnVuY3Rpb25Ub1N0cmluZy5jYWxsKHRoaXMpO1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcbi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcXFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXFxcIiArIGl0KTtcXG4gIHJldHVybiBpdDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtZ2xvYmFsLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZS5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcXG4gIHRyeSB7XFxuICAgIGhpZGUoZ2xvYmFsLCBrZXksIHZhbHVlKTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgIGdsb2JhbFtrZXldID0gdmFsdWU7XFxuICB9IHJldHVybiB2YWx1ZTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcXFwiKS5mO1xcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcXFwiKTtcXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1xcXCIpO1xcblxcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBTVEFUSUMgPyBpdCA6IGl0LnByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcXG4gICAgZGVmaW5lUHJvcGVydHkoaXQsIFRPX1NUUklOR19UQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xcbiAgfVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanNcXFwiKTtcXG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3VpZCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzXFxcIik7XFxuXFxudmFyIGtleXMgPSBzaGFyZWQoJ2tleXMnKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcXG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcXFwiKTtcXG52YXIgc2V0R2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1nbG9iYWwuanNcXFwiKTtcXG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1wdXJlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzXFxcIik7XFxuXFxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IHNldEdsb2JhbChTSEFSRUQsIHt9KTtcXG5cXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XFxufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xcbiAgdmVyc2lvbjogJzMuMS4zJyxcXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXFxufSk7XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1hdC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLWF0LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbnRlZ2VyICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLmpzXFxcIik7XFxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanNcXFwiKTtcXG5cXG4vLyBDT05WRVJUX1RPX1NUUklORzogdHJ1ZSAgLT4gU3RyaW5nI2F0XFxuLy8gQ09OVkVSVF9UT19TVFJJTkc6IGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHBvcywgQ09OVkVSVF9UT19TVFJJTkcpIHtcXG4gIHZhciBTID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhhdCkpO1xcbiAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XFxuICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xcbiAgdmFyIGZpcnN0LCBzZWNvbmQ7XFxuICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xcbiAgZmlyc3QgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24pO1xcbiAgcmV0dXJuIGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGIHx8IHBvc2l0aW9uICsgMSA9PT0gc2l6ZVxcbiAgICB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxcbiAgICAgID8gQ09OVkVSVF9UT19TVFJJTkcgPyBTLmNoYXJBdChwb3NpdGlvbikgOiBmaXJzdFxcbiAgICAgIDogQ09OVkVSVF9UT19TVFJJTkcgPyBTLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbnRlZ2VyICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLmpzXFxcIik7XFxuXFxudmFyIG1heCA9IE1hdGgubWF4O1xcbnZhciBtaW4gPSBNYXRoLm1pbjtcXG5cXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcXG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXFxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4obGVuZ3RoLCBsZW5ndGgpLlxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcXG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyKGluZGV4KTtcXG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbihpbnRlZ2VyLCBsZW5ndGgpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xcbnZhciBJbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qc1xcXCIpO1xcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZSAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcXG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xcblxcbi8vIGBUb0ludGVnZXJgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW50ZWdlclxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuICByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW50ZWdlciAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qc1xcXCIpO1xcblxcbnZhciBtaW4gPSBNYXRoLm1pbjtcXG5cXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcXG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qc1xcXCIpO1xcblxcbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9vYmplY3RcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xcbiAgcmV0dXJuIE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcmltaXRpdmUuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcXFwiKTtcXG5cXG4vLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcXG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcXG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XFxuICB2YXIgZm4sIHZhbDtcXG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XFxuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XFxuICB0aHJvdyBUeXBlRXJyb3IoXFxcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVxcXCIpO1xcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxudmFyIGlkID0gMDtcXG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XFxuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHBvc3RmaXgpLnRvU3RyaW5nKDM2KSk7XFxufTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdmFsaWRhdGUtc2V0LXByb3RvdHlwZS1vZi1hcmd1bWVudHMuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXFxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdmFsaWRhdGUtc2V0LXByb3RvdHlwZS1vZi1hcmd1bWVudHMuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1xcXCIpO1xcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XFxuICBhbk9iamVjdChPKTtcXG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB7XFxuICAgIHRocm93IFR5cGVFcnJvcihcXFwiQ2FuJ3Qgc2V0IFxcXCIgKyBTdHJpbmcocHJvdG8pICsgJyBhcyBhIHByb3RvdHlwZScpO1xcbiAgfVxcbn07XFxuXFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXFxcIik7XFxudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qc1xcXCIpO1xcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdWlkICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanNcXFwiKTtcXG52YXIgTkFUSVZFX1NZTUJPTCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtc3ltYm9sLmpzXFxcIik7XFxuXFxudmFyIFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XFxudmFyIHN0b3JlID0gc2hhcmVkKCd3a3MnKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID0gTkFUSVZFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV1cXG4gICAgfHwgKE5BVElWRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcXG59O1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZXhwb3J0ICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanNcXFwiKTtcXG52YXIgZnJvbSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1mcm9tICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mcm9tLmpzXFxcIik7XFxudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24gKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbi5qc1xcXCIpO1xcblxcbnZhciBJTkNPUlJFQ1RfSVRFUkFUSU9OID0gIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcXG4gIEFycmF5LmZyb20oaXRlcmFibGUpO1xcbn0pO1xcblxcbi8vIGBBcnJheS5mcm9tYCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5mcm9tXFxuJCh7IHRhcmdldDogJ0FycmF5Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfSVRFUkFUSU9OIH0sIHtcXG4gIGZyb206IGZyb21cXG59KTtcXG5cXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBjb2RlUG9pbnRBdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zdHJpbmctYXQgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1hdC5qc1xcXCIpO1xcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1xcXCIpO1xcbnZhciBkZWZpbmVJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvci5qc1xcXCIpO1xcblxcbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1RSSU5HX0lURVJBVE9SKTtcXG5cXG4vLyBgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXFxuZGVmaW5lSXRlcmF0b3IoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XFxuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcXG4gICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxcbiAgICBzdHJpbmc6IFN0cmluZyhpdGVyYXRlZCksXFxuICAgIGluZGV4OiAwXFxuICB9KTtcXG4vLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2RcXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcXG59LCBmdW5jdGlvbiBuZXh0KCkge1xcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcXG4gIHZhciBzdHJpbmcgPSBzdGF0ZS5zdHJpbmc7XFxuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleDtcXG4gIHZhciBwb2ludDtcXG4gIGlmIChpbmRleCA+PSBzdHJpbmcubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XFxuICBwb2ludCA9IGNvZGVQb2ludEF0KHN0cmluZywgaW5kZXgsIHRydWUpO1xcbiAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xcbn0pO1xcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG52YXIgZztcXHJcXG5cXHJcXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxcclxcbmcgPSAoZnVuY3Rpb24oKSB7XFxyXFxuXFx0cmV0dXJuIHRoaXM7XFxyXFxufSkoKTtcXHJcXG5cXHJcXG50cnkge1xcclxcblxcdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxcclxcblxcdGcgPSBnIHx8IEZ1bmN0aW9uKFxcXCJyZXR1cm4gdGhpc1xcXCIpKCkgfHwgKDEsIGV2YWwpKFxcXCJ0aGlzXFxcIik7XFxyXFxufSBjYXRjaCAoZSkge1xcclxcblxcdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXFxyXFxuXFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFxcXCJvYmplY3RcXFwiKSBnID0gd2luZG93O1xcclxcbn1cXHJcXG5cXHJcXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXFxyXFxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcXHJcXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XFxyXFxuXFxyXFxubW9kdWxlLmV4cG9ydHMgPSBnO1xcclxcblxcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL3NyYy9kZWZhdWx0LWF0dHJzLmpzb25cXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vc3JjL2RlZmF1bHQtYXR0cnMuanNvbiAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHhtbG5zLCB3aWR0aCwgaGVpZ2h0LCB2aWV3Qm94LCBmaWxsLCBzdHJva2UsIHN0cm9rZS13aWR0aCwgc3Ryb2tlLWxpbmVjYXAsIHN0cm9rZS1saW5lam9pbiwgZGVmYXVsdCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXFwieG1sbnNcXFwiOlxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIsXFxcIndpZHRoXFxcIjoyNCxcXFwiaGVpZ2h0XFxcIjoyNCxcXFwidmlld0JveFxcXCI6XFxcIjAgMCAyNCAyNFxcXCIsXFxcImZpbGxcXFwiOlxcXCJub25lXFxcIixcXFwic3Ryb2tlXFxcIjpcXFwiY3VycmVudENvbG9yXFxcIixcXFwic3Ryb2tlLXdpZHRoXFxcIjoyLFxcXCJzdHJva2UtbGluZWNhcFxcXCI6XFxcInJvdW5kXFxcIixcXFwic3Ryb2tlLWxpbmVqb2luXFxcIjpcXFwicm91bmRcXFwifTtcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9zcmMvaWNvbi5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vc3JjL2ljb24uanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG52YXIgX2RlZHVwZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNsYXNzbmFtZXMvZGVkdXBlICovIFxcXCIuL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2RlZHVwZS5qc1xcXCIpO1xcblxcbnZhciBfZGVkdXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZHVwZSk7XFxuXFxudmFyIF9kZWZhdWx0QXR0cnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RlZmF1bHQtYXR0cnMuanNvbiAqLyBcXFwiLi9zcmMvZGVmYXVsdC1hdHRycy5qc29uXFxcIik7XFxuXFxudmFyIF9kZWZhdWx0QXR0cnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmYXVsdEF0dHJzKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbnZhciBJY29uID0gZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gSWNvbihuYW1lLCBjb250ZW50cykge1xcbiAgICB2YXIgdGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XFxuXFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJY29uKTtcXG5cXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcXG4gICAgdGhpcy5jb250ZW50cyA9IGNvbnRlbnRzO1xcbiAgICB0aGlzLnRhZ3MgPSB0YWdzO1xcbiAgICB0aGlzLmF0dHJzID0gX2V4dGVuZHMoe30sIF9kZWZhdWx0QXR0cnMyLmRlZmF1bHQsIHsgY2xhc3M6ICdmZWF0aGVyIGZlYXRoZXItJyArIG5hbWUgfSk7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIENyZWF0ZSBhbiBTVkcgc3RyaW5nLlxcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzXFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxcbiAgICovXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoSWNvbiwgW3tcXG4gICAga2V5OiAndG9TdmcnLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdmcoKSB7XFxuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcXG5cXG4gICAgICB2YXIgY29tYmluZWRBdHRycyA9IF9leHRlbmRzKHt9LCB0aGlzLmF0dHJzLCBhdHRycywgeyBjbGFzczogKDAsIF9kZWR1cGUyLmRlZmF1bHQpKHRoaXMuYXR0cnMuY2xhc3MsIGF0dHJzLmNsYXNzKSB9KTtcXG5cXG4gICAgICByZXR1cm4gJzxzdmcgJyArIGF0dHJzVG9TdHJpbmcoY29tYmluZWRBdHRycykgKyAnPicgKyB0aGlzLmNvbnRlbnRzICsgJzwvc3ZnPic7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIFJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gYEljb25gLlxcbiAgICAgKlxcbiAgICAgKiBBZGRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gSWYgb2xkIGNvZGUgZXhwZWN0cyBgZmVhdGhlci5pY29ucy48bmFtZT5gXFxuICAgICAqIHRvIGJlIGEgc3RyaW5nLCBgdG9TdHJpbmcoKWAgd2lsbCBnZXQgaW1wbGljaXRseSBjYWxsZWQuXFxuICAgICAqXFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6ICd0b1N0cmluZycsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcXG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50cztcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIEljb247XFxufSgpO1xcblxcbi8qKlxcbiAqIENvbnZlcnQgYXR0cmlidXRlcyBvYmplY3QgdG8gc3RyaW5nIG9mIEhUTUwgYXR0cmlidXRlcy5cXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnNcXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxcbiAqL1xcblxcblxcbmZ1bmN0aW9uIGF0dHJzVG9TdHJpbmcoYXR0cnMpIHtcXG4gIHJldHVybiBPYmplY3Qua2V5cyhhdHRycykubWFwKGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgcmV0dXJuIGtleSArICc9XFxcIicgKyBhdHRyc1trZXldICsgJ1xcXCInO1xcbiAgfSkuam9pbignICcpO1xcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBJY29uO1xcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL3NyYy9pY29ucy5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL3NyYy9pY29ucy5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF9pY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pY29uICovIFxcXCIuL3NyYy9pY29uLmpzXFxcIik7XFxuXFxudmFyIF9pY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ljb24pO1xcblxcbnZhciBfaWNvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kaXN0L2ljb25zLmpzb24gKi8gXFxcIi4vZGlzdC9pY29ucy5qc29uXFxcIik7XFxuXFxudmFyIF9pY29uczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pY29ucyk7XFxuXFxudmFyIF90YWdzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90YWdzLmpzb24gKi8gXFxcIi4vc3JjL3RhZ3MuanNvblxcXCIpO1xcblxcbnZhciBfdGFnczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWdzKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbmV4cG9ydHMuZGVmYXVsdCA9IE9iamVjdC5rZXlzKF9pY29uczIuZGVmYXVsdCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcXG4gIHJldHVybiBuZXcgX2ljb24yLmRlZmF1bHQoa2V5LCBfaWNvbnMyLmRlZmF1bHRba2V5XSwgX3RhZ3MyLmRlZmF1bHRba2V5XSk7XFxufSkucmVkdWNlKGZ1bmN0aW9uIChvYmplY3QsIGljb24pIHtcXG4gIG9iamVjdFtpY29uLm5hbWVdID0gaWNvbjtcXG4gIHJldHVybiBvYmplY3Q7XFxufSwge30pO1xcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL3NyYy9pbmRleC5qc1xcXCI6XFxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL3NyYy9pbmRleC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcbnZhciBfaWNvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ljb25zICovIFxcXCIuL3NyYy9pY29ucy5qc1xcXCIpO1xcblxcbnZhciBfaWNvbnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaWNvbnMpO1xcblxcbnZhciBfdG9TdmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvLXN2ZyAqLyBcXFwiLi9zcmMvdG8tc3ZnLmpzXFxcIik7XFxuXFxudmFyIF90b1N2ZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90b1N2Zyk7XFxuXFxudmFyIF9yZXBsYWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZXBsYWNlICovIFxcXCIuL3NyYy9yZXBsYWNlLmpzXFxcIik7XFxuXFxudmFyIF9yZXBsYWNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlcGxhY2UpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7IGljb25zOiBfaWNvbnMyLmRlZmF1bHQsIHRvU3ZnOiBfdG9TdmcyLmRlZmF1bHQsIHJlcGxhY2U6IF9yZXBsYWNlMi5kZWZhdWx0IH07XFxuXFxuLyoqKi8gfSksXFxuXFxuLyoqKi8gXFxcIi4vc3JjL3JlcGxhY2UuanNcXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL3NyYy9yZXBsYWNlLmpzICoqKiFcXG4gIFxcXFwqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IC8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xcblxcblxcbnZhciBfZGVkdXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY2xhc3NuYW1lcy9kZWR1cGUgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvZGVkdXBlLmpzXFxcIik7XFxuXFxudmFyIF9kZWR1cGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVkdXBlKTtcXG5cXG52YXIgX2ljb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pY29ucyAqLyBcXFwiLi9zcmMvaWNvbnMuanNcXFwiKTtcXG5cXG52YXIgX2ljb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ljb25zKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbi8qKlxcbiAqIFJlcGxhY2UgYWxsIEhUTUwgZWxlbWVudHMgdGhhdCBoYXZlIGEgYGRhdGEtZmVhdGhlcmAgYXR0cmlidXRlIHdpdGggU1ZHIG1hcmt1cFxcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGVsZW1lbnQncyBgZGF0YS1mZWF0aGVyYCBhdHRyaWJ1dGUgdmFsdWUuXFxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJzXFxuICovXFxuZnVuY3Rpb24gcmVwbGFjZSgpIHtcXG4gIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XFxuXFxuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmZWF0aGVyLnJlcGxhY2UoKWAgb25seSB3b3JrcyBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnQuJyk7XFxuICB9XFxuXFxuICB2YXIgZWxlbWVudHNUb1JlcGxhY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1mZWF0aGVyXScpO1xcblxcbiAgQXJyYXkuZnJvbShlbGVtZW50c1RvUmVwbGFjZSkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xcbiAgICByZXR1cm4gcmVwbGFjZUVsZW1lbnQoZWxlbWVudCwgYXR0cnMpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIFJlcGxhY2UgYSBzaW5nbGUgSFRNTCBlbGVtZW50IHdpdGggU1ZHIG1hcmt1cFxcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGVsZW1lbnQncyBgZGF0YS1mZWF0aGVyYCBhdHRyaWJ1dGUgdmFsdWUuXFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyc1xcbiAqL1xcbmZ1bmN0aW9uIHJlcGxhY2VFbGVtZW50KGVsZW1lbnQpIHtcXG4gIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XFxuXFxuICB2YXIgZWxlbWVudEF0dHJzID0gZ2V0QXR0cnMoZWxlbWVudCk7XFxuICB2YXIgbmFtZSA9IGVsZW1lbnRBdHRyc1snZGF0YS1mZWF0aGVyJ107XFxuICBkZWxldGUgZWxlbWVudEF0dHJzWydkYXRhLWZlYXRoZXInXTtcXG5cXG4gIHZhciBzdmdTdHJpbmcgPSBfaWNvbnMyLmRlZmF1bHRbbmFtZV0udG9TdmcoX2V4dGVuZHMoe30sIGF0dHJzLCBlbGVtZW50QXR0cnMsIHsgY2xhc3M6ICgwLCBfZGVkdXBlMi5kZWZhdWx0KShhdHRycy5jbGFzcywgZWxlbWVudEF0dHJzLmNsYXNzKSB9KSk7XFxuICB2YXIgc3ZnRG9jdW1lbnQgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHN2Z1N0cmluZywgJ2ltYWdlL3N2Zyt4bWwnKTtcXG4gIHZhciBzdmdFbGVtZW50ID0gc3ZnRG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3ZnJyk7XFxuXFxuICBlbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHN2Z0VsZW1lbnQsIGVsZW1lbnQpO1xcbn1cXG5cXG4vKipcXG4gKiBHZXQgdGhlIGF0dHJpYnV0ZXMgb2YgYW4gSFRNTCBlbGVtZW50LlxcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxcbiAqL1xcbmZ1bmN0aW9uIGdldEF0dHJzKGVsZW1lbnQpIHtcXG4gIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuYXR0cmlidXRlcykucmVkdWNlKGZ1bmN0aW9uIChhdHRycywgYXR0cikge1xcbiAgICBhdHRyc1thdHRyLm5hbWVdID0gYXR0ci52YWx1ZTtcXG4gICAgcmV0dXJuIGF0dHJzO1xcbiAgfSwge30pO1xcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSByZXBsYWNlO1xcblxcbi8qKiovIH0pLFxcblxcbi8qKiovIFxcXCIuL3NyYy90YWdzLmpzb25cXFwiOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIC4vc3JjL3RhZ3MuanNvbiAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGFjdGl2aXR5LCBhaXJwbGF5LCBhbGVydC1jaXJjbGUsIGFsZXJ0LW9jdGFnb24sIGFsZXJ0LXRyaWFuZ2xlLCBhbGlnbi1jZW50ZXIsIGFsaWduLWp1c3RpZnksIGFsaWduLWxlZnQsIGFsaWduLXJpZ2h0LCBhbmNob3IsIGFyY2hpdmUsIGF0LXNpZ24sIGF3YXJkLCBhcGVydHVyZSwgYmFyLWNoYXJ0LCBiYXItY2hhcnQtMiwgYmF0dGVyeSwgYmF0dGVyeS1jaGFyZ2luZywgYmVsbCwgYmVsbC1vZmYsIGJsdWV0b290aCwgYm9vay1vcGVuLCBib29rLCBib29rbWFyaywgYm94LCBicmllZmNhc2UsIGNhbGVuZGFyLCBjYW1lcmEsIGNhc3QsIGNpcmNsZSwgY2xpcGJvYXJkLCBjbG9jaywgY2xvdWQtZHJpenpsZSwgY2xvdWQtbGlnaHRuaW5nLCBjbG91ZC1yYWluLCBjbG91ZC1zbm93LCBjbG91ZCwgY29kZXBlbiwgY29kZXNhbmRib3gsIGNvZGUsIGNvZmZlZSwgY29sdW1ucywgY29tbWFuZCwgY29tcGFzcywgY29weSwgY29ybmVyLWRvd24tbGVmdCwgY29ybmVyLWRvd24tcmlnaHQsIGNvcm5lci1sZWZ0LWRvd24sIGNvcm5lci1sZWZ0LXVwLCBjb3JuZXItcmlnaHQtZG93biwgY29ybmVyLXJpZ2h0LXVwLCBjb3JuZXItdXAtbGVmdCwgY29ybmVyLXVwLXJpZ2h0LCBjcHUsIGNyZWRpdC1jYXJkLCBjcm9wLCBjcm9zc2hhaXIsIGRhdGFiYXNlLCBkZWxldGUsIGRpc2MsIGRvbGxhci1zaWduLCBkcm9wbGV0LCBlZGl0LCBlZGl0LTIsIGVkaXQtMywgZXllLCBleWUtb2ZmLCBleHRlcm5hbC1saW5rLCBmYWNlYm9vaywgZmFzdC1mb3J3YXJkLCBmaWdtYSwgZmlsZS1taW51cywgZmlsZS1wbHVzLCBmaWxlLXRleHQsIGZpbG0sIGZpbHRlciwgZmxhZywgZm9sZGVyLW1pbnVzLCBmb2xkZXItcGx1cywgZm9sZGVyLCBmcmFtZXIsIGZyb3duLCBnaWZ0LCBnaXQtYnJhbmNoLCBnaXQtY29tbWl0LCBnaXQtbWVyZ2UsIGdpdC1wdWxsLXJlcXVlc3QsIGdpdGh1YiwgZ2l0bGFiLCBnbG9iZSwgaGFyZC1kcml2ZSwgaGFzaCwgaGVhZHBob25lcywgaGVhcnQsIGhlbHAtY2lyY2xlLCBoZXhhZ29uLCBob21lLCBpbWFnZSwgaW5ib3gsIGluc3RhZ3JhbSwga2V5LCBsYXllcnMsIGxheW91dCwgbGlmZS1ib3V5LCBsaW5rLCBsaW5rLTIsIGxpbmtlZGluLCBsaXN0LCBsb2NrLCBsb2ctaW4sIGxvZy1vdXQsIG1haWwsIG1hcC1waW4sIG1hcCwgbWF4aW1pemUsIG1heGltaXplLTIsIG1laCwgbWVudSwgbWVzc2FnZS1jaXJjbGUsIG1lc3NhZ2Utc3F1YXJlLCBtaWMtb2ZmLCBtaWMsIG1pbmltaXplLCBtaW5pbWl6ZS0yLCBtaW51cywgbW9uaXRvciwgbW9vbiwgbW9yZS1ob3Jpem9udGFsLCBtb3JlLXZlcnRpY2FsLCBtb3VzZS1wb2ludGVyLCBtb3ZlLCBtdXNpYywgbmF2aWdhdGlvbiwgbmF2aWdhdGlvbi0yLCBvY3RhZ29uLCBwYWNrYWdlLCBwYXBlcmNsaXAsIHBhdXNlLCBwYXVzZS1jaXJjbGUsIHBlbi10b29sLCBwZXJjZW50LCBwaG9uZS1jYWxsLCBwaG9uZS1mb3J3YXJkZWQsIHBob25lLWluY29taW5nLCBwaG9uZS1taXNzZWQsIHBob25lLW9mZiwgcGhvbmUtb3V0Z29pbmcsIHBob25lLCBwbGF5LCBwaWUtY2hhcnQsIHBsYXktY2lyY2xlLCBwbHVzLCBwbHVzLWNpcmNsZSwgcGx1cy1zcXVhcmUsIHBvY2tldCwgcG93ZXIsIHByaW50ZXIsIHJhZGlvLCByZWZyZXNoLWN3LCByZWZyZXNoLWNjdywgcmVwZWF0LCByZXdpbmQsIHJvdGF0ZS1jY3csIHJvdGF0ZS1jdywgcnNzLCBzYXZlLCBzY2lzc29ycywgc2VhcmNoLCBzZW5kLCBzZXR0aW5ncywgc2hhcmUtMiwgc2hpZWxkLCBzaGllbGQtb2ZmLCBzaG9wcGluZy1iYWcsIHNob3BwaW5nLWNhcnQsIHNodWZmbGUsIHNraXAtYmFjaywgc2tpcC1mb3J3YXJkLCBzbGFjaywgc2xhc2gsIHNsaWRlcnMsIHNtYXJ0cGhvbmUsIHNtaWxlLCBzcGVha2VyLCBzdGFyLCBzdG9wLWNpcmNsZSwgc3VuLCBzdW5yaXNlLCBzdW5zZXQsIHRhYmxldCwgdGFnLCB0YXJnZXQsIHRlcm1pbmFsLCB0aGVybW9tZXRlciwgdGh1bWJzLWRvd24sIHRodW1icy11cCwgdG9nZ2xlLWxlZnQsIHRvZ2dsZS1yaWdodCwgdG9vbCwgdHJhc2gsIHRyYXNoLTIsIHRyaWFuZ2xlLCB0cnVjaywgdHYsIHR3aXRjaCwgdHdpdHRlciwgdHlwZSwgdW1icmVsbGEsIHVubG9jaywgdXNlci1jaGVjaywgdXNlci1taW51cywgdXNlci1wbHVzLCB1c2VyLXgsIHVzZXIsIHVzZXJzLCB2aWRlby1vZmYsIHZpZGVvLCB2b2ljZW1haWwsIHZvbHVtZSwgdm9sdW1lLTEsIHZvbHVtZS0yLCB2b2x1bWUteCwgd2F0Y2gsIHdpZmktb2ZmLCB3aWZpLCB3aW5kLCB4LWNpcmNsZSwgeC1vY3RhZ29uLCB4LXNxdWFyZSwgeCwgeW91dHViZSwgemFwLW9mZiwgemFwLCB6b29tLWluLCB6b29tLW91dCwgZGVmYXVsdCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXFwiYWN0aXZpdHlcXFwiOltcXFwicHVsc2VcXFwiLFxcXCJoZWFsdGhcXFwiLFxcXCJhY3Rpb25cXFwiLFxcXCJtb3Rpb25cXFwiXSxcXFwiYWlycGxheVxcXCI6W1xcXCJzdHJlYW1cXFwiLFxcXCJjYXN0XFxcIixcXFwibWlycm9yaW5nXFxcIl0sXFxcImFsZXJ0LWNpcmNsZVxcXCI6W1xcXCJ3YXJuaW5nXFxcIixcXFwiYWxlcnRcXFwiLFxcXCJkYW5nZXJcXFwiXSxcXFwiYWxlcnQtb2N0YWdvblxcXCI6W1xcXCJ3YXJuaW5nXFxcIixcXFwiYWxlcnRcXFwiLFxcXCJkYW5nZXJcXFwiXSxcXFwiYWxlcnQtdHJpYW5nbGVcXFwiOltcXFwid2FybmluZ1xcXCIsXFxcImFsZXJ0XFxcIixcXFwiZGFuZ2VyXFxcIl0sXFxcImFsaWduLWNlbnRlclxcXCI6W1xcXCJ0ZXh0IGFsaWdubWVudFxcXCIsXFxcImNlbnRlclxcXCJdLFxcXCJhbGlnbi1qdXN0aWZ5XFxcIjpbXFxcInRleHQgYWxpZ25tZW50XFxcIixcXFwianVzdGlmaWVkXFxcIl0sXFxcImFsaWduLWxlZnRcXFwiOltcXFwidGV4dCBhbGlnbm1lbnRcXFwiLFxcXCJsZWZ0XFxcIl0sXFxcImFsaWduLXJpZ2h0XFxcIjpbXFxcInRleHQgYWxpZ25tZW50XFxcIixcXFwicmlnaHRcXFwiXSxcXFwiYW5jaG9yXFxcIjpbXSxcXFwiYXJjaGl2ZVxcXCI6W1xcXCJpbmRleFxcXCIsXFxcImJveFxcXCJdLFxcXCJhdC1zaWduXFxcIjpbXFxcIm1lbnRpb25cXFwiLFxcXCJhdFxcXCIsXFxcImVtYWlsXFxcIixcXFwibWVzc2FnZVxcXCJdLFxcXCJhd2FyZFxcXCI6W1xcXCJhY2hpZXZlbWVudFxcXCIsXFxcImJhZGdlXFxcIl0sXFxcImFwZXJ0dXJlXFxcIjpbXFxcImNhbWVyYVxcXCIsXFxcInBob3RvXFxcIl0sXFxcImJhci1jaGFydFxcXCI6W1xcXCJzdGF0aXN0aWNzXFxcIixcXFwiZGlhZ3JhbVxcXCIsXFxcImdyYXBoXFxcIl0sXFxcImJhci1jaGFydC0yXFxcIjpbXFxcInN0YXRpc3RpY3NcXFwiLFxcXCJkaWFncmFtXFxcIixcXFwiZ3JhcGhcXFwiXSxcXFwiYmF0dGVyeVxcXCI6W1xcXCJwb3dlclxcXCIsXFxcImVsZWN0cmljaXR5XFxcIl0sXFxcImJhdHRlcnktY2hhcmdpbmdcXFwiOltcXFwicG93ZXJcXFwiLFxcXCJlbGVjdHJpY2l0eVxcXCJdLFxcXCJiZWxsXFxcIjpbXFxcImFsYXJtXFxcIixcXFwibm90aWZpY2F0aW9uXFxcIixcXFwic291bmRcXFwiXSxcXFwiYmVsbC1vZmZcXFwiOltcXFwiYWxhcm1cXFwiLFxcXCJub3RpZmljYXRpb25cXFwiLFxcXCJzaWxlbnRcXFwiXSxcXFwiYmx1ZXRvb3RoXFxcIjpbXFxcIndpcmVsZXNzXFxcIl0sXFxcImJvb2stb3BlblxcXCI6W1xcXCJyZWFkXFxcIixcXFwibGlicmFyeVxcXCJdLFxcXCJib29rXFxcIjpbXFxcInJlYWRcXFwiLFxcXCJkaWN0aW9uYXJ5XFxcIixcXFwiYm9va2xldFxcXCIsXFxcIm1hZ2F6aW5lXFxcIixcXFwibGlicmFyeVxcXCJdLFxcXCJib29rbWFya1xcXCI6W1xcXCJyZWFkXFxcIixcXFwiY2xpcFxcXCIsXFxcIm1hcmtlclxcXCIsXFxcInRhZ1xcXCJdLFxcXCJib3hcXFwiOltcXFwiY3ViZVxcXCJdLFxcXCJicmllZmNhc2VcXFwiOltcXFwid29ya1xcXCIsXFxcImJhZ1xcXCIsXFxcImJhZ2dhZ2VcXFwiLFxcXCJmb2xkZXJcXFwiXSxcXFwiY2FsZW5kYXJcXFwiOltcXFwiZGF0ZVxcXCJdLFxcXCJjYW1lcmFcXFwiOltcXFwicGhvdG9cXFwiXSxcXFwiY2FzdFxcXCI6W1xcXCJjaHJvbWVjYXN0XFxcIixcXFwiYWlycGxheVxcXCJdLFxcXCJjaXJjbGVcXFwiOltcXFwib2ZmXFxcIixcXFwiemVyb1xcXCIsXFxcInJlY29yZFxcXCJdLFxcXCJjbGlwYm9hcmRcXFwiOltcXFwiY29weVxcXCJdLFxcXCJjbG9ja1xcXCI6W1xcXCJ0aW1lXFxcIixcXFwid2F0Y2hcXFwiLFxcXCJhbGFybVxcXCJdLFxcXCJjbG91ZC1kcml6emxlXFxcIjpbXFxcIndlYXRoZXJcXFwiLFxcXCJzaG93ZXJcXFwiXSxcXFwiY2xvdWQtbGlnaHRuaW5nXFxcIjpbXFxcIndlYXRoZXJcXFwiLFxcXCJib2x0XFxcIl0sXFxcImNsb3VkLXJhaW5cXFwiOltcXFwid2VhdGhlclxcXCJdLFxcXCJjbG91ZC1zbm93XFxcIjpbXFxcIndlYXRoZXJcXFwiLFxcXCJibGl6emFyZFxcXCJdLFxcXCJjbG91ZFxcXCI6W1xcXCJ3ZWF0aGVyXFxcIl0sXFxcImNvZGVwZW5cXFwiOltcXFwibG9nb1xcXCJdLFxcXCJjb2Rlc2FuZGJveFxcXCI6W1xcXCJsb2dvXFxcIl0sXFxcImNvZGVcXFwiOltcXFwic291cmNlXFxcIixcXFwicHJvZ3JhbW1pbmdcXFwiXSxcXFwiY29mZmVlXFxcIjpbXFxcImRyaW5rXFxcIixcXFwiY3VwXFxcIixcXFwibXVnXFxcIixcXFwidGVhXFxcIixcXFwiY2FmZVxcXCIsXFxcImhvdFxcXCIsXFxcImJldmVyYWdlXFxcIl0sXFxcImNvbHVtbnNcXFwiOltcXFwibGF5b3V0XFxcIl0sXFxcImNvbW1hbmRcXFwiOltcXFwia2V5Ym9hcmRcXFwiLFxcXCJjbWRcXFwiLFxcXCJ0ZXJtaW5hbFxcXCIsXFxcInByb21wdFxcXCJdLFxcXCJjb21wYXNzXFxcIjpbXFxcIm5hdmlnYXRpb25cXFwiLFxcXCJzYWZhcmlcXFwiLFxcXCJ0cmF2ZWxcXFwiLFxcXCJkaXJlY3Rpb25cXFwiXSxcXFwiY29weVxcXCI6W1xcXCJjbG9uZVxcXCIsXFxcImR1cGxpY2F0ZVxcXCJdLFxcXCJjb3JuZXItZG93bi1sZWZ0XFxcIjpbXFxcImFycm93XFxcIixcXFwicmV0dXJuXFxcIl0sXFxcImNvcm5lci1kb3duLXJpZ2h0XFxcIjpbXFxcImFycm93XFxcIl0sXFxcImNvcm5lci1sZWZ0LWRvd25cXFwiOltcXFwiYXJyb3dcXFwiXSxcXFwiY29ybmVyLWxlZnQtdXBcXFwiOltcXFwiYXJyb3dcXFwiXSxcXFwiY29ybmVyLXJpZ2h0LWRvd25cXFwiOltcXFwiYXJyb3dcXFwiXSxcXFwiY29ybmVyLXJpZ2h0LXVwXFxcIjpbXFxcImFycm93XFxcIl0sXFxcImNvcm5lci11cC1sZWZ0XFxcIjpbXFxcImFycm93XFxcIl0sXFxcImNvcm5lci11cC1yaWdodFxcXCI6W1xcXCJhcnJvd1xcXCJdLFxcXCJjcHVcXFwiOltcXFwicHJvY2Vzc29yXFxcIixcXFwidGVjaG5vbG9neVxcXCJdLFxcXCJjcmVkaXQtY2FyZFxcXCI6W1xcXCJwdXJjaGFzZVxcXCIsXFxcInBheW1lbnRcXFwiLFxcXCJjY1xcXCJdLFxcXCJjcm9wXFxcIjpbXFxcInBob3RvXFxcIixcXFwiaW1hZ2VcXFwiXSxcXFwiY3Jvc3NoYWlyXFxcIjpbXFxcImFpbVxcXCIsXFxcInRhcmdldFxcXCJdLFxcXCJkYXRhYmFzZVxcXCI6W1xcXCJzdG9yYWdlXFxcIixcXFwibWVtb3J5XFxcIl0sXFxcImRlbGV0ZVxcXCI6W1xcXCJyZW1vdmVcXFwiXSxcXFwiZGlzY1xcXCI6W1xcXCJhbGJ1bVxcXCIsXFxcImNkXFxcIixcXFwiZHZkXFxcIixcXFwibXVzaWNcXFwiXSxcXFwiZG9sbGFyLXNpZ25cXFwiOltcXFwiY3VycmVuY3lcXFwiLFxcXCJtb25leVxcXCIsXFxcInBheW1lbnRcXFwiXSxcXFwiZHJvcGxldFxcXCI6W1xcXCJ3YXRlclxcXCJdLFxcXCJlZGl0XFxcIjpbXFxcInBlbmNpbFxcXCIsXFxcImNoYW5nZVxcXCJdLFxcXCJlZGl0LTJcXFwiOltcXFwicGVuY2lsXFxcIixcXFwiY2hhbmdlXFxcIl0sXFxcImVkaXQtM1xcXCI6W1xcXCJwZW5jaWxcXFwiLFxcXCJjaGFuZ2VcXFwiXSxcXFwiZXllXFxcIjpbXFxcInZpZXdcXFwiLFxcXCJ3YXRjaFxcXCJdLFxcXCJleWUtb2ZmXFxcIjpbXFxcInZpZXdcXFwiLFxcXCJ3YXRjaFxcXCIsXFxcImhpZGVcXFwiLFxcXCJoaWRkZW5cXFwiXSxcXFwiZXh0ZXJuYWwtbGlua1xcXCI6W1xcXCJvdXRib3VuZFxcXCJdLFxcXCJmYWNlYm9va1xcXCI6W1xcXCJsb2dvXFxcIixcXFwic29jaWFsXFxcIl0sXFxcImZhc3QtZm9yd2FyZFxcXCI6W1xcXCJtdXNpY1xcXCJdLFxcXCJmaWdtYVxcXCI6W1xcXCJsb2dvXFxcIixcXFwiZGVzaWduXFxcIixcXFwidG9vbFxcXCJdLFxcXCJmaWxlLW1pbnVzXFxcIjpbXFxcImRlbGV0ZVxcXCIsXFxcInJlbW92ZVxcXCIsXFxcImVyYXNlXFxcIl0sXFxcImZpbGUtcGx1c1xcXCI6W1xcXCJhZGRcXFwiLFxcXCJjcmVhdGVcXFwiLFxcXCJuZXdcXFwiXSxcXFwiZmlsZS10ZXh0XFxcIjpbXFxcImRhdGFcXFwiLFxcXCJ0eHRcXFwiLFxcXCJwZGZcXFwiXSxcXFwiZmlsbVxcXCI6W1xcXCJtb3ZpZVxcXCIsXFxcInZpZGVvXFxcIl0sXFxcImZpbHRlclxcXCI6W1xcXCJmdW5uZWxcXFwiLFxcXCJob3BwZXJcXFwiXSxcXFwiZmxhZ1xcXCI6W1xcXCJyZXBvcnRcXFwiXSxcXFwiZm9sZGVyLW1pbnVzXFxcIjpbXFxcImRpcmVjdG9yeVxcXCJdLFxcXCJmb2xkZXItcGx1c1xcXCI6W1xcXCJkaXJlY3RvcnlcXFwiXSxcXFwiZm9sZGVyXFxcIjpbXFxcImRpcmVjdG9yeVxcXCJdLFxcXCJmcmFtZXJcXFwiOltcXFwibG9nb1xcXCIsXFxcImRlc2lnblxcXCIsXFxcInRvb2xcXFwiXSxcXFwiZnJvd25cXFwiOltcXFwiZW1vamlcXFwiLFxcXCJmYWNlXFxcIixcXFwiYmFkXFxcIixcXFwic2FkXFxcIixcXFwiZW1vdGlvblxcXCJdLFxcXCJnaWZ0XFxcIjpbXFxcInByZXNlbnRcXFwiLFxcXCJib3hcXFwiLFxcXCJiaXJ0aGRheVxcXCIsXFxcInBhcnR5XFxcIl0sXFxcImdpdC1icmFuY2hcXFwiOltcXFwiY29kZVxcXCIsXFxcInZlcnNpb24gY29udHJvbFxcXCJdLFxcXCJnaXQtY29tbWl0XFxcIjpbXFxcImNvZGVcXFwiLFxcXCJ2ZXJzaW9uIGNvbnRyb2xcXFwiXSxcXFwiZ2l0LW1lcmdlXFxcIjpbXFxcImNvZGVcXFwiLFxcXCJ2ZXJzaW9uIGNvbnRyb2xcXFwiXSxcXFwiZ2l0LXB1bGwtcmVxdWVzdFxcXCI6W1xcXCJjb2RlXFxcIixcXFwidmVyc2lvbiBjb250cm9sXFxcIl0sXFxcImdpdGh1YlxcXCI6W1xcXCJsb2dvXFxcIixcXFwidmVyc2lvbiBjb250cm9sXFxcIl0sXFxcImdpdGxhYlxcXCI6W1xcXCJsb2dvXFxcIixcXFwidmVyc2lvbiBjb250cm9sXFxcIl0sXFxcImdsb2JlXFxcIjpbXFxcIndvcmxkXFxcIixcXFwiYnJvd3NlclxcXCIsXFxcImxhbmd1YWdlXFxcIixcXFwidHJhbnNsYXRlXFxcIl0sXFxcImhhcmQtZHJpdmVcXFwiOltcXFwiY29tcHV0ZXJcXFwiLFxcXCJzZXJ2ZXJcXFwiLFxcXCJtZW1vcnlcXFwiLFxcXCJkYXRhXFxcIl0sXFxcImhhc2hcXFwiOltcXFwiaGFzaHRhZ1xcXCIsXFxcIm51bWJlclxcXCIsXFxcInBvdW5kXFxcIl0sXFxcImhlYWRwaG9uZXNcXFwiOltcXFwibXVzaWNcXFwiLFxcXCJhdWRpb1xcXCIsXFxcInNvdW5kXFxcIl0sXFxcImhlYXJ0XFxcIjpbXFxcImxpa2VcXFwiLFxcXCJsb3ZlXFxcIixcXFwiZW1vdGlvblxcXCJdLFxcXCJoZWxwLWNpcmNsZVxcXCI6W1xcXCJxdWVzdGlvbiBtYXJrXFxcIl0sXFxcImhleGFnb25cXFwiOltcXFwic2hhcGVcXFwiLFxcXCJub2RlLmpzXFxcIixcXFwibG9nb1xcXCJdLFxcXCJob21lXFxcIjpbXFxcImhvdXNlXFxcIixcXFwibGl2aW5nXFxcIl0sXFxcImltYWdlXFxcIjpbXFxcInBpY3R1cmVcXFwiXSxcXFwiaW5ib3hcXFwiOltcXFwiZW1haWxcXFwiXSxcXFwiaW5zdGFncmFtXFxcIjpbXFxcImxvZ29cXFwiLFxcXCJjYW1lcmFcXFwiXSxcXFwia2V5XFxcIjpbXFxcInBhc3N3b3JkXFxcIixcXFwibG9naW5cXFwiLFxcXCJhdXRoZW50aWNhdGlvblxcXCIsXFxcInNlY3VyZVxcXCJdLFxcXCJsYXllcnNcXFwiOltcXFwic3RhY2tcXFwiXSxcXFwibGF5b3V0XFxcIjpbXFxcIndpbmRvd1xcXCIsXFxcIndlYnBhZ2VcXFwiXSxcXFwibGlmZS1ib3V5XFxcIjpbXFxcImhlbHBcXFwiLFxcXCJsaWZlIHJpbmdcXFwiLFxcXCJzdXBwb3J0XFxcIl0sXFxcImxpbmtcXFwiOltcXFwiY2hhaW5cXFwiLFxcXCJ1cmxcXFwiXSxcXFwibGluay0yXFxcIjpbXFxcImNoYWluXFxcIixcXFwidXJsXFxcIl0sXFxcImxpbmtlZGluXFxcIjpbXFxcImxvZ29cXFwiLFxcXCJzb2NpYWwgbWVkaWFcXFwiXSxcXFwibGlzdFxcXCI6W1xcXCJvcHRpb25zXFxcIl0sXFxcImxvY2tcXFwiOltcXFwic2VjdXJpdHlcXFwiLFxcXCJwYXNzd29yZFxcXCIsXFxcInNlY3VyZVxcXCJdLFxcXCJsb2ctaW5cXFwiOltcXFwic2lnbiBpblxcXCIsXFxcImFycm93XFxcIixcXFwiZW50ZXJcXFwiXSxcXFwibG9nLW91dFxcXCI6W1xcXCJzaWduIG91dFxcXCIsXFxcImFycm93XFxcIixcXFwiZXhpdFxcXCJdLFxcXCJtYWlsXFxcIjpbXFxcImVtYWlsXFxcIixcXFwibWVzc2FnZVxcXCJdLFxcXCJtYXAtcGluXFxcIjpbXFxcImxvY2F0aW9uXFxcIixcXFwibmF2aWdhdGlvblxcXCIsXFxcInRyYXZlbFxcXCIsXFxcIm1hcmtlclxcXCJdLFxcXCJtYXBcXFwiOltcXFwibG9jYXRpb25cXFwiLFxcXCJuYXZpZ2F0aW9uXFxcIixcXFwidHJhdmVsXFxcIl0sXFxcIm1heGltaXplXFxcIjpbXFxcImZ1bGxzY3JlZW5cXFwiXSxcXFwibWF4aW1pemUtMlxcXCI6W1xcXCJmdWxsc2NyZWVuXFxcIixcXFwiYXJyb3dzXFxcIixcXFwiZXhwYW5kXFxcIl0sXFxcIm1laFxcXCI6W1xcXCJlbW9qaVxcXCIsXFxcImZhY2VcXFwiLFxcXCJuZXV0cmFsXFxcIixcXFwiZW1vdGlvblxcXCJdLFxcXCJtZW51XFxcIjpbXFxcImJhcnNcXFwiLFxcXCJuYXZpZ2F0aW9uXFxcIixcXFwiaGFtYnVyZ2VyXFxcIl0sXFxcIm1lc3NhZ2UtY2lyY2xlXFxcIjpbXFxcImNvbW1lbnRcXFwiLFxcXCJjaGF0XFxcIl0sXFxcIm1lc3NhZ2Utc3F1YXJlXFxcIjpbXFxcImNvbW1lbnRcXFwiLFxcXCJjaGF0XFxcIl0sXFxcIm1pYy1vZmZcXFwiOltcXFwicmVjb3JkXFxcIixcXFwic291bmRcXFwiLFxcXCJtdXRlXFxcIl0sXFxcIm1pY1xcXCI6W1xcXCJyZWNvcmRcXFwiLFxcXCJzb3VuZFxcXCIsXFxcImxpc3RlblxcXCJdLFxcXCJtaW5pbWl6ZVxcXCI6W1xcXCJleGl0IGZ1bGxzY3JlZW5cXFwiLFxcXCJjbG9zZVxcXCJdLFxcXCJtaW5pbWl6ZS0yXFxcIjpbXFxcImV4aXQgZnVsbHNjcmVlblxcXCIsXFxcImFycm93c1xcXCIsXFxcImNsb3NlXFxcIl0sXFxcIm1pbnVzXFxcIjpbXFxcInN1YnRyYWN0XFxcIl0sXFxcIm1vbml0b3JcXFwiOltcXFwidHZcXFwiLFxcXCJzY3JlZW5cXFwiLFxcXCJkaXNwbGF5XFxcIl0sXFxcIm1vb25cXFwiOltcXFwiZGFya1xcXCIsXFxcIm5pZ2h0XFxcIl0sXFxcIm1vcmUtaG9yaXpvbnRhbFxcXCI6W1xcXCJlbGxpcHNpc1xcXCJdLFxcXCJtb3JlLXZlcnRpY2FsXFxcIjpbXFxcImVsbGlwc2lzXFxcIl0sXFxcIm1vdXNlLXBvaW50ZXJcXFwiOltcXFwiYXJyb3dcXFwiLFxcXCJjdXJzb3JcXFwiXSxcXFwibW92ZVxcXCI6W1xcXCJhcnJvd3NcXFwiXSxcXFwibXVzaWNcXFwiOltcXFwibm90ZVxcXCJdLFxcXCJuYXZpZ2F0aW9uXFxcIjpbXFxcImxvY2F0aW9uXFxcIixcXFwidHJhdmVsXFxcIl0sXFxcIm5hdmlnYXRpb24tMlxcXCI6W1xcXCJsb2NhdGlvblxcXCIsXFxcInRyYXZlbFxcXCJdLFxcXCJvY3RhZ29uXFxcIjpbXFxcInN0b3BcXFwiXSxcXFwicGFja2FnZVxcXCI6W1xcXCJib3hcXFwiLFxcXCJjb250YWluZXJcXFwiXSxcXFwicGFwZXJjbGlwXFxcIjpbXFxcImF0dGFjaG1lbnRcXFwiXSxcXFwicGF1c2VcXFwiOltcXFwibXVzaWNcXFwiLFxcXCJzdG9wXFxcIl0sXFxcInBhdXNlLWNpcmNsZVxcXCI6W1xcXCJtdXNpY1xcXCIsXFxcImF1ZGlvXFxcIixcXFwic3RvcFxcXCJdLFxcXCJwZW4tdG9vbFxcXCI6W1xcXCJ2ZWN0b3JcXFwiLFxcXCJkcmF3aW5nXFxcIl0sXFxcInBlcmNlbnRcXFwiOltcXFwiZGlzY291bnRcXFwiXSxcXFwicGhvbmUtY2FsbFxcXCI6W1xcXCJyaW5nXFxcIl0sXFxcInBob25lLWZvcndhcmRlZFxcXCI6W1xcXCJjYWxsXFxcIl0sXFxcInBob25lLWluY29taW5nXFxcIjpbXFxcImNhbGxcXFwiXSxcXFwicGhvbmUtbWlzc2VkXFxcIjpbXFxcImNhbGxcXFwiXSxcXFwicGhvbmUtb2ZmXFxcIjpbXFxcImNhbGxcXFwiLFxcXCJtdXRlXFxcIl0sXFxcInBob25lLW91dGdvaW5nXFxcIjpbXFxcImNhbGxcXFwiXSxcXFwicGhvbmVcXFwiOltcXFwiY2FsbFxcXCJdLFxcXCJwbGF5XFxcIjpbXFxcIm11c2ljXFxcIixcXFwic3RhcnRcXFwiXSxcXFwicGllLWNoYXJ0XFxcIjpbXFxcInN0YXRpc3RpY3NcXFwiLFxcXCJkaWFncmFtXFxcIl0sXFxcInBsYXktY2lyY2xlXFxcIjpbXFxcIm11c2ljXFxcIixcXFwic3RhcnRcXFwiXSxcXFwicGx1c1xcXCI6W1xcXCJhZGRcXFwiLFxcXCJuZXdcXFwiXSxcXFwicGx1cy1jaXJjbGVcXFwiOltcXFwiYWRkXFxcIixcXFwibmV3XFxcIl0sXFxcInBsdXMtc3F1YXJlXFxcIjpbXFxcImFkZFxcXCIsXFxcIm5ld1xcXCJdLFxcXCJwb2NrZXRcXFwiOltcXFwibG9nb1xcXCIsXFxcInNhdmVcXFwiXSxcXFwicG93ZXJcXFwiOltcXFwib25cXFwiLFxcXCJvZmZcXFwiXSxcXFwicHJpbnRlclxcXCI6W1xcXCJmYXhcXFwiLFxcXCJvZmZpY2VcXFwiLFxcXCJkZXZpY2VcXFwiXSxcXFwicmFkaW9cXFwiOltcXFwic2lnbmFsXFxcIl0sXFxcInJlZnJlc2gtY3dcXFwiOltcXFwic3luY2hyb25pc2VcXFwiLFxcXCJhcnJvd3NcXFwiXSxcXFwicmVmcmVzaC1jY3dcXFwiOltcXFwiYXJyb3dzXFxcIl0sXFxcInJlcGVhdFxcXCI6W1xcXCJsb29wXFxcIixcXFwiYXJyb3dzXFxcIl0sXFxcInJld2luZFxcXCI6W1xcXCJtdXNpY1xcXCJdLFxcXCJyb3RhdGUtY2N3XFxcIjpbXFxcImFycm93XFxcIl0sXFxcInJvdGF0ZS1jd1xcXCI6W1xcXCJhcnJvd1xcXCJdLFxcXCJyc3NcXFwiOltcXFwiZmVlZFxcXCIsXFxcInN1YnNjcmliZVxcXCJdLFxcXCJzYXZlXFxcIjpbXFxcImZsb3BweSBkaXNrXFxcIl0sXFxcInNjaXNzb3JzXFxcIjpbXFxcImN1dFxcXCJdLFxcXCJzZWFyY2hcXFwiOltcXFwiZmluZFxcXCIsXFxcIm1hZ25pZmllclxcXCIsXFxcIm1hZ25pZnlpbmcgZ2xhc3NcXFwiXSxcXFwic2VuZFxcXCI6W1xcXCJtZXNzYWdlXFxcIixcXFwibWFpbFxcXCIsXFxcImVtYWlsXFxcIixcXFwicGFwZXIgYWlycGxhbmVcXFwiLFxcXCJwYXBlciBhZXJvcGxhbmVcXFwiXSxcXFwic2V0dGluZ3NcXFwiOltcXFwiY29nXFxcIixcXFwiZWRpdFxcXCIsXFxcImdlYXJcXFwiLFxcXCJwcmVmZXJlbmNlc1xcXCJdLFxcXCJzaGFyZS0yXFxcIjpbXFxcIm5ldHdvcmtcXFwiLFxcXCJjb25uZWN0aW9uc1xcXCJdLFxcXCJzaGllbGRcXFwiOltcXFwic2VjdXJpdHlcXFwiLFxcXCJzZWN1cmVcXFwiXSxcXFwic2hpZWxkLW9mZlxcXCI6W1xcXCJzZWN1cml0eVxcXCIsXFxcImluc2VjdXJlXFxcIl0sXFxcInNob3BwaW5nLWJhZ1xcXCI6W1xcXCJlY29tbWVyY2VcXFwiLFxcXCJjYXJ0XFxcIixcXFwicHVyY2hhc2VcXFwiLFxcXCJzdG9yZVxcXCJdLFxcXCJzaG9wcGluZy1jYXJ0XFxcIjpbXFxcImVjb21tZXJjZVxcXCIsXFxcImNhcnRcXFwiLFxcXCJwdXJjaGFzZVxcXCIsXFxcInN0b3JlXFxcIl0sXFxcInNodWZmbGVcXFwiOltcXFwibXVzaWNcXFwiXSxcXFwic2tpcC1iYWNrXFxcIjpbXFxcIm11c2ljXFxcIl0sXFxcInNraXAtZm9yd2FyZFxcXCI6W1xcXCJtdXNpY1xcXCJdLFxcXCJzbGFja1xcXCI6W1xcXCJsb2dvXFxcIl0sXFxcInNsYXNoXFxcIjpbXFxcImJhblxcXCIsXFxcIm5vXFxcIl0sXFxcInNsaWRlcnNcXFwiOltcXFwic2V0dGluZ3NcXFwiLFxcXCJjb250cm9sc1xcXCJdLFxcXCJzbWFydHBob25lXFxcIjpbXFxcImNlbGxwaG9uZVxcXCIsXFxcImRldmljZVxcXCJdLFxcXCJzbWlsZVxcXCI6W1xcXCJlbW9qaVxcXCIsXFxcImZhY2VcXFwiLFxcXCJoYXBweVxcXCIsXFxcImdvb2RcXFwiLFxcXCJlbW90aW9uXFxcIl0sXFxcInNwZWFrZXJcXFwiOltcXFwiYXVkaW9cXFwiLFxcXCJtdXNpY1xcXCJdLFxcXCJzdGFyXFxcIjpbXFxcImJvb2ttYXJrXFxcIixcXFwiZmF2b3JpdGVcXFwiLFxcXCJsaWtlXFxcIl0sXFxcInN0b3AtY2lyY2xlXFxcIjpbXFxcIm1lZGlhXFxcIixcXFwibXVzaWNcXFwiXSxcXFwic3VuXFxcIjpbXFxcImJyaWdodG5lc3NcXFwiLFxcXCJ3ZWF0aGVyXFxcIixcXFwibGlnaHRcXFwiXSxcXFwic3VucmlzZVxcXCI6W1xcXCJ3ZWF0aGVyXFxcIixcXFwidGltZVxcXCIsXFxcIm1vcm5pbmdcXFwiLFxcXCJkYXlcXFwiXSxcXFwic3Vuc2V0XFxcIjpbXFxcIndlYXRoZXJcXFwiLFxcXCJ0aW1lXFxcIixcXFwiZXZlbmluZ1xcXCIsXFxcIm5pZ2h0XFxcIl0sXFxcInRhYmxldFxcXCI6W1xcXCJkZXZpY2VcXFwiXSxcXFwidGFnXFxcIjpbXFxcImxhYmVsXFxcIl0sXFxcInRhcmdldFxcXCI6W1xcXCJsb2dvXFxcIixcXFwiYnVsbHNleWVcXFwiXSxcXFwidGVybWluYWxcXFwiOltcXFwiY29kZVxcXCIsXFxcImNvbW1hbmQgbGluZVxcXCIsXFxcInByb21wdFxcXCJdLFxcXCJ0aGVybW9tZXRlclxcXCI6W1xcXCJ0ZW1wZXJhdHVyZVxcXCIsXFxcImNlbHNpdXNcXFwiLFxcXCJmYWhyZW5oZWl0XFxcIixcXFwid2VhdGhlclxcXCJdLFxcXCJ0aHVtYnMtZG93blxcXCI6W1xcXCJkaXNsaWtlXFxcIixcXFwiYmFkXFxcIixcXFwiZW1vdGlvblxcXCJdLFxcXCJ0aHVtYnMtdXBcXFwiOltcXFwibGlrZVxcXCIsXFxcImdvb2RcXFwiLFxcXCJlbW90aW9uXFxcIl0sXFxcInRvZ2dsZS1sZWZ0XFxcIjpbXFxcIm9uXFxcIixcXFwib2ZmXFxcIixcXFwic3dpdGNoXFxcIl0sXFxcInRvZ2dsZS1yaWdodFxcXCI6W1xcXCJvblxcXCIsXFxcIm9mZlxcXCIsXFxcInN3aXRjaFxcXCJdLFxcXCJ0b29sXFxcIjpbXFxcInNldHRpbmdzXFxcIixcXFwic3Bhbm5lclxcXCJdLFxcXCJ0cmFzaFxcXCI6W1xcXCJnYXJiYWdlXFxcIixcXFwiZGVsZXRlXFxcIixcXFwicmVtb3ZlXFxcIixcXFwiYmluXFxcIl0sXFxcInRyYXNoLTJcXFwiOltcXFwiZ2FyYmFnZVxcXCIsXFxcImRlbGV0ZVxcXCIsXFxcInJlbW92ZVxcXCIsXFxcImJpblxcXCJdLFxcXCJ0cmlhbmdsZVxcXCI6W1xcXCJkZWx0YVxcXCJdLFxcXCJ0cnVja1xcXCI6W1xcXCJkZWxpdmVyeVxcXCIsXFxcInZhblxcXCIsXFxcInNoaXBwaW5nXFxcIixcXFwidHJhbnNwb3J0XFxcIixcXFwibG9ycnlcXFwiXSxcXFwidHZcXFwiOltcXFwidGVsZXZpc2lvblxcXCIsXFxcInN0cmVhbVxcXCJdLFxcXCJ0d2l0Y2hcXFwiOltcXFwibG9nb1xcXCJdLFxcXCJ0d2l0dGVyXFxcIjpbXFxcImxvZ29cXFwiLFxcXCJzb2NpYWxcXFwiXSxcXFwidHlwZVxcXCI6W1xcXCJ0ZXh0XFxcIl0sXFxcInVtYnJlbGxhXFxcIjpbXFxcInJhaW5cXFwiLFxcXCJ3ZWF0aGVyXFxcIl0sXFxcInVubG9ja1xcXCI6W1xcXCJzZWN1cml0eVxcXCJdLFxcXCJ1c2VyLWNoZWNrXFxcIjpbXFxcImZvbGxvd2VkXFxcIixcXFwic3Vic2NyaWJlZFxcXCJdLFxcXCJ1c2VyLW1pbnVzXFxcIjpbXFxcImRlbGV0ZVxcXCIsXFxcInJlbW92ZVxcXCIsXFxcInVuZm9sbG93XFxcIixcXFwidW5zdWJzY3JpYmVcXFwiXSxcXFwidXNlci1wbHVzXFxcIjpbXFxcIm5ld1xcXCIsXFxcImFkZFxcXCIsXFxcImNyZWF0ZVxcXCIsXFxcImZvbGxvd1xcXCIsXFxcInN1YnNjcmliZVxcXCJdLFxcXCJ1c2VyLXhcXFwiOltcXFwiZGVsZXRlXFxcIixcXFwicmVtb3ZlXFxcIixcXFwidW5mb2xsb3dcXFwiLFxcXCJ1bnN1YnNjcmliZVxcXCIsXFxcInVuYXZhaWxhYmxlXFxcIl0sXFxcInVzZXJcXFwiOltcXFwicGVyc29uXFxcIixcXFwiYWNjb3VudFxcXCJdLFxcXCJ1c2Vyc1xcXCI6W1xcXCJncm91cFxcXCJdLFxcXCJ2aWRlby1vZmZcXFwiOltcXFwiY2FtZXJhXFxcIixcXFwibW92aWVcXFwiLFxcXCJmaWxtXFxcIl0sXFxcInZpZGVvXFxcIjpbXFxcImNhbWVyYVxcXCIsXFxcIm1vdmllXFxcIixcXFwiZmlsbVxcXCJdLFxcXCJ2b2ljZW1haWxcXFwiOltcXFwicGhvbmVcXFwiXSxcXFwidm9sdW1lXFxcIjpbXFxcIm11c2ljXFxcIixcXFwic291bmRcXFwiLFxcXCJtdXRlXFxcIl0sXFxcInZvbHVtZS0xXFxcIjpbXFxcIm11c2ljXFxcIixcXFwic291bmRcXFwiXSxcXFwidm9sdW1lLTJcXFwiOltcXFwibXVzaWNcXFwiLFxcXCJzb3VuZFxcXCJdLFxcXCJ2b2x1bWUteFxcXCI6W1xcXCJtdXNpY1xcXCIsXFxcInNvdW5kXFxcIixcXFwibXV0ZVxcXCJdLFxcXCJ3YXRjaFxcXCI6W1xcXCJjbG9ja1xcXCIsXFxcInRpbWVcXFwiXSxcXFwid2lmaS1vZmZcXFwiOltcXFwiZGlzYWJsZWRcXFwiXSxcXFwid2lmaVxcXCI6W1xcXCJjb25uZWN0aW9uXFxcIixcXFwic2lnbmFsXFxcIixcXFwid2lyZWxlc3NcXFwiXSxcXFwid2luZFxcXCI6W1xcXCJ3ZWF0aGVyXFxcIixcXFwiYWlyXFxcIl0sXFxcIngtY2lyY2xlXFxcIjpbXFxcImNhbmNlbFxcXCIsXFxcImNsb3NlXFxcIixcXFwiZGVsZXRlXFxcIixcXFwicmVtb3ZlXFxcIixcXFwidGltZXNcXFwiLFxcXCJjbGVhclxcXCJdLFxcXCJ4LW9jdGFnb25cXFwiOltcXFwiZGVsZXRlXFxcIixcXFwic3RvcFxcXCIsXFxcImFsZXJ0XFxcIixcXFwid2FybmluZ1xcXCIsXFxcInRpbWVzXFxcIixcXFwiY2xlYXJcXFwiXSxcXFwieC1zcXVhcmVcXFwiOltcXFwiY2FuY2VsXFxcIixcXFwiY2xvc2VcXFwiLFxcXCJkZWxldGVcXFwiLFxcXCJyZW1vdmVcXFwiLFxcXCJ0aW1lc1xcXCIsXFxcImNsZWFyXFxcIl0sXFxcInhcXFwiOltcXFwiY2FuY2VsXFxcIixcXFwiY2xvc2VcXFwiLFxcXCJkZWxldGVcXFwiLFxcXCJyZW1vdmVcXFwiLFxcXCJ0aW1lc1xcXCIsXFxcImNsZWFyXFxcIl0sXFxcInlvdXR1YmVcXFwiOltcXFwibG9nb1xcXCIsXFxcInZpZGVvXFxcIixcXFwicGxheVxcXCJdLFxcXCJ6YXAtb2ZmXFxcIjpbXFxcImZsYXNoXFxcIixcXFwiY2FtZXJhXFxcIixcXFwibGlnaHRuaW5nXFxcIl0sXFxcInphcFxcXCI6W1xcXCJmbGFzaFxcXCIsXFxcImNhbWVyYVxcXCIsXFxcImxpZ2h0bmluZ1xcXCJdLFxcXCJ6b29tLWluXFxcIjpbXFxcIm1hZ25pZnlpbmcgZ2xhc3NcXFwiXSxcXFwiem9vbS1vdXRcXFwiOltcXFwibWFnbmlmeWluZyBnbGFzc1xcXCJdfTtcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyBcXFwiLi9zcmMvdG8tc3ZnLmpzXFxcIjpcXG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcXFxcbiAgISoqKiAuL3NyYy90by1zdmcuanMgKioqIVxcbiAgXFxcXCoqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX2ljb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pY29ucyAqLyBcXFwiLi9zcmMvaWNvbnMuanNcXFwiKTtcXG5cXG52YXIgX2ljb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ljb25zKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbi8qKlxcbiAqIENyZWF0ZSBhbiBTVkcgc3RyaW5nLlxcbiAqIEBkZXByZWNhdGVkXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnNcXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIHRvU3ZnKG5hbWUpIHtcXG4gIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XFxuXFxuICBjb25zb2xlLndhcm4oJ2ZlYXRoZXIudG9TdmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGZlYXRoZXIuaWNvbnNbbmFtZV0udG9TdmcoKSBpbnN0ZWFkLicpO1xcblxcbiAgaWYgKCFuYW1lKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJlcXVpcmVkIGBrZXlgIChpY29uIG5hbWUpIHBhcmFtZXRlciBpcyBtaXNzaW5nLicpO1xcbiAgfVxcblxcbiAgaWYgKCFfaWNvbnMyLmRlZmF1bHRbbmFtZV0pIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBpY29uIG1hdGNoaW5nIFxcXFwnJyArIG5hbWUgKyAnXFxcXCcuIFNlZSB0aGUgY29tcGxldGUgbGlzdCBvZiBpY29ucyBhdCBodHRwczovL2ZlYXRoZXJpY29ucy5jb20nKTtcXG4gIH1cXG5cXG4gIHJldHVybiBfaWNvbnMyLmRlZmF1bHRbbmFtZV0udG9TdmcoYXR0cnMpO1xcbn1cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSB0b1N2ZztcXG5cXG4vKioqLyB9KSxcXG5cXG4vKioqLyAwOlxcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxcXFxuICAhKioqIG11bHRpIGNvcmUtanMvZXMvYXJyYXkvZnJvbSAuL3NyYy9pbmRleC5qcyAqKiohXFxuICBcXFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcbl9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvZXMvYXJyYXkvZnJvbSAqL1xcXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL2FycmF5L2Zyb20uanNcXFwiKTtcXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC9ob21lL3RyYXZpcy9idWlsZC9mZWF0aGVyaWNvbnMvZmVhdGhlci9zcmMvaW5kZXguanMgKi9cXFwiLi9zcmMvaW5kZXguanNcXFwiKTtcXG5cXG5cXG4vKioqLyB9KVxcblxcbi8qKioqKiovIH0pO1xcbn0pO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZlYXRoZXIuanMubWFwXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC9mZWF0aGVyLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vc3JjL2pzL2FwcC5qc1wiOi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2pzL2FwcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovIC8qISBubyBleHBvcnRzIHByb3ZpZGVkICovIC8qKiovZnVuY3Rpb24gc3JjSnNBcHBKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbW9kdWxlc19ib290c3RyYXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kdWxlcy9ib290c3RyYXAgKi8gXFxcIi4vc3JjL2pzL21vZHVsZXMvYm9vdHN0cmFwLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb2R1bGVzX2ZlYXRoZXJfaWNvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kdWxlcy9mZWF0aGVyLWljb25zICovIFxcXCIuL3NyYy9qcy9tb2R1bGVzL2ZlYXRoZXItaWNvbnMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21vZHVsZXNfZHJvcHpvbmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbW9kdWxlcy9kcm9wem9uZSAqLyBcXFwiLi9zcmMvanMvbW9kdWxlcy9kcm9wem9uZS5qc1xcXCIpO1xcbi8qXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiAgUkVRVUlSRURTXFxuICogLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cXG4gKi9cXG5cXG5cXG5cXG5cXG4vKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogIFJFQURZXFxuICogLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cXG4gKi9cXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xcblxcbiAgY29uc29sZS5sb2coJ0FQUCBSRUFEWSEnKTtcXG5cXG59KTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvYXBwLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vc3JjL2pzL21vZHVsZXMvYm9vdHN0cmFwLmpzXCI6LyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy9tb2R1bGVzL2Jvb3RzdHJhcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8gLyohIG5vIGV4cG9ydHMgcHJvdmlkZWQgKi8gLyoqKi9mdW5jdGlvbiBzcmNKc01vZHVsZXNCb290c3RyYXBKcyhtb2R1bGUsX193ZWJwYWNrX2V4cG9ydHNfXyxfX3dlYnBhY2tfcmVxdWlyZV9fKXtcInVzZSBzdHJpY3RcIjtldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBib290c3RyYXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGJvb3RzdHJhcCAqLyBcXFwiLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmVzbS5qc1xcXCIpO1xcbi8qXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiAgUkVRVUlSRURcXG4gKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxcbiAqL1xcblxcblxcbi8qXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiAgR0xPQkFMXFxuICogLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cXG4gKiAgTm90ZTogSWYgeW91IHdhbnQgdG8gbWFrZSBib290c3RyYXAgZ2xvYmFsbHkgYXZhaWxhYmxlLCBlLmcuIGZvciB1c2luZyBgYm9vdHN0cmFwLm1vZGFsYFxcbiAqIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXFxuICovXFxud2luZG93LmJvb3RzdHJhcCA9IGJvb3RzdHJhcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fO1xcblxcbi8qXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiAgUE9QT1ZFUlNcXG4gKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxcbiAqICBOb3RlOiBEaXNhYmxlIHRoaXMgaWYgeW91J3JlIG5vdCB1c2luZyBCb290c3RyYXAncyBQb3BvdmVyc1xcbiAqIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtXFxuICovXFxuY29uc3QgcG9wb3ZlclRyaWdnZXJMaXN0ID0gW11cXG4gIC5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWJzLXRvZ2dsZT1cXFwicG9wb3ZlclxcXCJdJykpO1xcbnBvcG92ZXJUcmlnZ2VyTGlzdC5tYXAoKHBvcG92ZXJUcmlnZ2VyRWwpID0+IHtcXG4gIHJldHVybiBuZXcgYm9vdHN0cmFwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcIlBvcG92ZXJcXFwiXShwb3BvdmVyVHJpZ2dlckVsKTtcXG59KTtcXG5cXG4vKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogIFRPT0xUSVBTXFxuICogLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cXG4gKiAgTm90ZTogRGlzYWJsZSB0aGlzIGlmIHlvdSdyZSBub3QgdXNpbmcgQm9vdHN0cmFwJ3MgVG9vbHRpcHNcXG4gKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxcbiAqL1xcbmNvbnN0IHRvb2x0aXBUcmlnZ2VyTGlzdCA9IFtdLnNsaWNlXFxuICAuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1icy10b2dnbGU9XFxcInRvb2x0aXBcXFwiXScpKTtcXG50b29sdGlwVHJpZ2dlckxpc3QubWFwKCh0b29sdGlwVHJpZ2dlckVsKSA9PiB7XFxuICByZXR1cm4gbmV3IGJvb3RzdHJhcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJUb29sdGlwXFxcIl0odG9vbHRpcFRyaWdnZXJFbCk7XFxufSk7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL2pzL21vZHVsZXMvYm9vdHN0cmFwLmpzP1wiKTsvKioqL30sLyoqKi9cIi4vc3JjL2pzL21vZHVsZXMvZHJvcHpvbmUuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvanMvbW9kdWxlcy9kcm9wem9uZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgbm8gZXhwb3J0cyBwcm92aWRlZCAqLyAvKioqL2Z1bmN0aW9uIHNyY0pzTW9kdWxlc0Ryb3B6b25lSnMobW9kdWxlLF9fd2VicGFja19leHBvcnRzX18sX193ZWJwYWNrX3JlcXVpcmVfXyl7XCJ1c2Ugc3RyaWN0XCI7ZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZHJvcHpvbmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGRyb3B6b25lICovIFxcXCIuL25vZGVfbW9kdWxlcy9kcm9wem9uZS9kaXN0L2Ryb3B6b25lLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGRyb3B6b25lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oZHJvcHpvbmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLypcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqICBSRVFVSVJFRFxcbiAqIGh0dHBzOi8vZHJvcHpvbmUuZ2l0Ym9vay5pby9kcm9wem9uZS9nZXR0aW5nLXN0YXJ0ZWQvaW5zdGFsbGF0aW9uL3dlYnBhY2stcmVjb21tZW5kZWRcXG4gKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxcbiAqL1xcblxcblxcbi8vID8/P1xcbi8vIE1ha2Ugc3VyZSBEcm9wem9uZSBkb2Vzbid0IHRyeSB0byBhdHRhY2ggaXRzZWxmIHRvIHRoZVxcbi8vIGVsZW1lbnQgYXV0b21hdGljYWxseS5cXG4vLyBUaGlzIGJlaGF2aW91ciB3aWxsIGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuXFxuZHJvcHpvbmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuYXV0b0Rpc2NvdmVyID0gZmFsc2U7XFxuXFxuLypcXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAqICBJTklUXFxuICogLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC1cXG4gKi9cXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xcbiAgLy9cXG59KTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvbW9kdWxlcy9kcm9wem9uZS5qcz9cIik7LyoqKi99LC8qKiovXCIuL3NyYy9qcy9tb2R1bGVzL2ZlYXRoZXItaWNvbnMuanNcIjovKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9qcy9tb2R1bGVzL2ZlYXRoZXItaWNvbnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyAvKiEgbm8gZXhwb3J0cyBwcm92aWRlZCAqLyAvKioqL2Z1bmN0aW9uIHNyY0pzTW9kdWxlc0ZlYXRoZXJJY29uc0pzKG1vZHVsZSxfX3dlYnBhY2tfZXhwb3J0c19fLF9fd2VicGFja19yZXF1aXJlX18pe1widXNlIHN0cmljdFwiO2V2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGZlYXRoZXJfaWNvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGZlYXRoZXItaWNvbnMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL2ZlYXRoZXItaWNvbnMvZGlzdC9mZWF0aGVyLmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGZlYXRoZXJfaWNvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihmZWF0aGVyX2ljb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qXFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gKiAgUkVRVUlSRURcXG4gKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxcbiAqL1xcblxcbndpbmRvdy5mZWF0aGVyID0gZmVhdGhlcl9pY29uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYTtcXG5cXG4vKlxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICogIElOSVRcXG4gKiAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLVxcbiAqL1xcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XFxuICBmZWF0aGVyX2ljb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLnJlcGxhY2UoKTtcXG59KTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvanMvbW9kdWxlcy9mZWF0aGVyLWljb25zLmpzP1wiKTsvKioqL30vKioqKioqL30pOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiZXhwb3J0cyIsIm1vZHVsZSIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiciIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ0IiwibW9kZSIsIl9fZXNNb2R1bGUiLCJucyIsImNyZWF0ZSIsImtleSIsImJpbmQiLCJuIiwib2JqZWN0IiwicHJvcGVydHkiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkNyZWF0ZVBvcHBlckpzIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImV2YWwiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNDb250YWluc0pzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldEJvdW5kaW5nQ2xpZW50UmVjdEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldENsaXBwaW5nUmVjdEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRDb21wb3NpdGVSZWN0SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldENvbXB1dGVkU3R5bGVKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXREb2N1bWVudEVsZW1lbnRKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXREb2N1bWVudFJlY3RKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldEhUTUxFbGVtZW50U2Nyb2xsSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldExheW91dFJlY3RKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldE5vZGVOYW1lSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldE5vZGVTY3JvbGxKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRPZmZzZXRQYXJlbnRKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzR2V0UGFyZW50Tm9kZUpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldFNjcm9sbFBhcmVudEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldFZpZXdwb3J0UmVjdEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldFdpbmRvd0pzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0dldFdpbmRvd1Njcm9sbEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNHZXRXaW5kb3dTY3JvbGxCYXJYSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0luc3RhbmNlT2ZKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJEb21VdGlsc0lzU2Nyb2xsUGFyZW50SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliRG9tVXRpbHNJc1RhYmxlRWxlbWVudEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkRvbVV0aWxzTGlzdFNjcm9sbFBhcmVudHNKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9lbnVtcy5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYkVudW1zSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJJbmRleEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYk1vZGlmaWVyc0FwcGx5U3R5bGVzSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzQXJyb3dKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYk1vZGlmaWVyc0NvbXB1dGVTdHlsZXNKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJNb2RpZmllcnNFdmVudExpc3RlbmVyc0pzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzRmxpcEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzSGlkZUpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYk1vZGlmaWVyc0luZGV4SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL29mZnNldC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYk1vZGlmaWVyc09mZnNldEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliTW9kaWZpZXJzUG9wcGVyT2Zmc2V0c0pzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJNb2RpZmllcnNQcmV2ZW50T3ZlcmZsb3dKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXItbGl0ZS5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlBvcHBlckxpdGVKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJQb3BwZXJKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzQ29tcHV0ZUF1dG9QbGFjZW1lbnRKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzQ29tcHV0ZU9mZnNldHNKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZWJvdW5jZS5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzRGVib3VuY2VKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzRGV0ZWN0T3ZlcmZsb3dKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9leHBhbmRUb0hhc2hNYXAuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0V4cGFuZFRvSGFzaE1hcEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2Zvcm1hdC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzRm9ybWF0SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzR2V0QWx0QXhpc0pzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0dldEJhc2VQbGFjZW1lbnRKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0dldEZyZXNoU2lkZU9iamVjdEpzIiwiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzR2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0dldE9wcG9zaXRlUGxhY2VtZW50SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc0dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNHZXRWYXJpYXRpb25KcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tYXRoLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNNYXRoSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc01lcmdlQnlOYW1lSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNNZXJnZVBhZGRpbmdPYmplY3RKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9vcmRlck1vZGlmaWVycy5qcyIsIm5vZGVfbW9kdWxlc1BvcHBlcmpzQ29yZUxpYlV0aWxzT3JkZXJNb2RpZmllcnNKcyIsIi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNSZWN0VG9DbGllbnRSZWN0SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdW5pcXVlQnkuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc1VuaXF1ZUJ5SnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdmFsaWRhdGVNb2RpZmllcnMuanMiLCJub2RlX21vZHVsZXNQb3BwZXJqc0NvcmVMaWJVdGlsc1ZhbGlkYXRlTW9kaWZpZXJzSnMiLCIuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzIiwibm9kZV9tb2R1bGVzUG9wcGVyanNDb3JlTGliVXRpbHNXaXRoaW5KcyIsIi4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcC5lc20uanMiLCJub2RlX21vZHVsZXNCb290c3RyYXBEaXN0SnNCb290c3RyYXBFc21KcyIsIi4vbm9kZV9tb2R1bGVzL2Ryb3B6b25lL2Rpc3QvZHJvcHpvbmUuanMiLCJub2RlX21vZHVsZXNEcm9wem9uZURpc3REcm9wem9uZUpzIiwiLi9ub2RlX21vZHVsZXMvZmVhdGhlci1pY29ucy9kaXN0L2ZlYXRoZXIuanMiLCJub2RlX21vZHVsZXNGZWF0aGVySWNvbnNEaXN0RmVhdGhlckpzIiwiLi9zcmMvanMvYXBwLmpzIiwic3JjSnNBcHBKcyIsIi4vc3JjL2pzL21vZHVsZXMvYm9vdHN0cmFwLmpzIiwic3JjSnNNb2R1bGVzQm9vdHN0cmFwSnMiLCIuL3NyYy9qcy9tb2R1bGVzL2Ryb3B6b25lLmpzIiwic3JjSnNNb2R1bGVzRHJvcHpvbmVKcyIsIi4vc3JjL2pzL21vZHVsZXMvZmVhdGhlci1pY29ucy5qcyIsInNyY0pzTW9kdWxlc0ZlYXRoZXJJY29uc0pzIl0sIm1hcHBpbmdzIjoiYUFBYSxTQUFTQSxRQUFRQyxHQUF1UyxPQUF0TUQsUUFBL0MsbUJBQVRFLFFBQThDLGlCQUFsQkEsT0FBT0MsU0FBNkIsU0FBaUJGLEdBQUssY0FBY0EsR0FBb0IsU0FBaUJBLEdBQUssT0FBT0EsR0FBcUIsbUJBQVRDLFFBQXFCRCxFQUFJRyxjQUFjRixRQUFRRCxJQUFNQyxPQUFPRyxVQUFVLGdCQUFnQkosSUFBc0JBLElBQWMsU0FBVUssR0FFcFcsSUFBSUMsRUFBaUIsR0FDckIsU0FBU0MsRUFBb0JDLEdBQzdCLEdBQUdGLEVBQWlCRSxHQUFtQixPQUFPRixFQUFpQkUsR0FBVUMsUUFDekUsSUFBSUMsRUFBT0osRUFBaUJFLEdBQVUsQ0FBU0csRUFBRUgsRUFBaUJJLEdBQUUsRUFBY0gsUUFBUSxJQUcxRixPQUZBSixFQUFRRyxHQUFVSyxLQUFLSCxFQUFPRCxRQUFRQyxFQUFPQSxFQUFPRCxRQUFRRixHQUM1REcsRUFBT0UsR0FBRSxFQUNGRixFQUFPRCxRQUNkRixFQUFvQk8sRUFBRVQsRUFDdEJFLEVBQW9CUSxFQUFFVCxFQUN0QkMsRUFBb0JTLEVBQUUsU0FBU1AsRUFBUVEsRUFBS0MsR0FBb0JYLEVBQW9CWSxFQUFFVixFQUFRUSxJQUFlRyxPQUFPQyxlQUFlWixFQUFRUSxFQUFLLENBQUNLLFlBQVcsRUFBS0MsSUFBSUwsS0FDcktYLEVBQW9CaUIsRUFBRSxTQUFTZixHQUFvQyxvQkFBVFIsUUFBc0JBLE9BQU93QixhQUFxQkwsT0FBT0MsZUFBZVosRUFBUVIsT0FBT3dCLFlBQVksQ0FBQ0MsTUFBTSxXQUE0Qk4sT0FBT0MsZUFBZVosRUFBUSxhQUFhLENBQUNpQixPQUFNLEtBS2xQbkIsRUFBb0JvQixFQUFFLFNBQVNELEVBQU1FLEdBQWlFLEdBQTNDLEVBQUxBLElBQU9GLEVBQU1uQixFQUFvQm1CLElBQXVCLEVBQUxFLEVBQU8sT0FBT0YsRUFBYyxHQUFRLEVBQUxFLEdBQXlCLFdBQWpCN0IsUUFBUTJCLElBQW1CQSxHQUFPQSxFQUFNRyxXQUFXLE9BQU9ILEVBQWMsSUFBSUksRUFBR1YsT0FBT1csT0FBTyxNQUEwSCxHQUE1R3hCLEVBQW9CaUIsRUFBRU0sR0FBWVYsT0FBT0MsZUFBZVMsRUFBRyxVQUFVLENBQUNSLFlBQVcsRUFBS0ksTUFBTUEsSUFBd0IsRUFBTEUsR0FBc0IsaUJBQVBGLEVBQWdCLElBQUksSUFBSU0sS0FBT04sRUFBT25CLEVBQW9CUyxFQUFFYyxFQUFHRSxFQUFJLFNBQVNBLEdBQUssT0FBT04sRUFBTU0sSUFBT0MsS0FBSyxLQUFLRCxJQUFlLE9BQU9GLEdBQzlmdkIsRUFBb0IyQixFQUFFLFNBQVN4QixHQUFnQixJQUFJUSxFQUFPUixHQUFRQSxFQUFPbUIsV0FBbUIsV0FBc0IsT0FBT25CLEVBQWdCLFNBQVksV0FBNEIsT0FBT0EsR0FBa0UsT0FBakRILEVBQW9CUyxFQUFFRSxFQUFPLElBQUlBLEdBQXVCQSxHQUNqUVgsRUFBb0JZLEVBQUUsU0FBU2dCLEVBQU9DLEdBQVUsT0FBT2hCLE9BQU9oQixVQUFVaUMsZUFBZXhCLEtBQUtzQixFQUFPQyxJQUNuRzdCLEVBQW9CK0IsRUFBRSxHQUNmL0IsRUFBb0JBLEVBQW9CZ0MsRUFBRSxtQkFyQnlTLENBcUJ4TCxDQUFNQyxvREFFdEMsU0FBU0MsMENBQTBDL0IsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUsseXlhQUFtMWFDLDBEQUV4K2EsU0FBU0MsOENBQThDbkMsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssb21DQUFxbkNHLHVFQUVqdUMsU0FBU0MsMkRBQTJEckMsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssd2pCQUFxa0JLLGlFQUVqdEIsU0FBU0MscURBQXFEdkMsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssbWhOQUFnbU5PLGtFQUUvdE4sU0FBU0Msc0RBQXNEekMsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUsscTFHQUFnNEdTLGtFQUVqZ0gsU0FBU0Msc0RBQXNEM0MsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssa2xCQUFtbUJXLG9FQUVsdUIsU0FBU0Msd0RBQXdEN0MsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssNHZCQUE2d0JhLGlFQUVuNUIsU0FBU0MscURBQXFEL0MsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUsseWhGQUE0akZlLHNFQUV2ckYsU0FBU0MsMERBQTBEakQsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssMlpBQXdhaUIsK0RBRXBqQixTQUFTQyxtREFBbURuRCxPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSywwdENBQXl1Q21CLDZEQUV6MkMsU0FBU0MsaURBQWlEckQsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssNFdBQXVYcUIsK0RBRWpmLFNBQVNDLG1EQUFtRHZELE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLDA0Q0FBdTZDdUIsaUVBRW5pRCxTQUFTQyxxREFBcUR6RCxPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSyw0MElBQSsxSXlCLCtEQUVqK0ksU0FBU0MsbURBQW1EM0QsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssK2pEQUFzbEQyQixpRUFFbHRELFNBQVNDLHFEQUFxRDdELE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLHlpREFBZ2tENkIsaUVBRWhzRCxTQUFTQyxxREFBcUQvRCxPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSyxxNkVBQTY3RStCLDJEQUVua0YsU0FBU0MsK0NBQStDakUsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssZ2hCQUEyaEJpQyxpRUFFL29CLFNBQVNDLHFEQUFxRG5FLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLG9zQkFBcXRCbUMscUVBRWoxQixTQUFTQyx5REFBeURyRSxPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSyxtakRBQXdrRHFDLDREQUV0ckQsU0FBU0MsZ0RBQWdEdkUsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssODNDQUFxNUN1QyxnRUFFM2lELFNBQVNDLG9EQUFvRHpFLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLCszQkFBZzVCeUMsZ0VBRS9nQyxTQUFTQyxvREFBb0QzRSxPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSyxvbUJBQSttQjJDLG1FQUUzdUIsU0FBU0MsdURBQXVEN0UsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssaXJFQUE0c0U2Qyw2Q0FFeG5FLFNBQVNDLG1DQUFtQy9FLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLGlySUFBNHNJK0MsNkNBRWhvSSxTQUFTQyxtQ0FBbUNqRixPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSyxtNU9BQWdrUGlELDZEQUVwa1EsU0FBU0Msa0RBQWtEbkYsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssdXhHQUFreUdtRCx1REFFcjZHLFNBQVNDLDRDQUE0Q3JGLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLCt3TUFBMHlNcUQsK0RBRTU0TSxTQUFTQyxvREFBb0R2RixPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSywrOFBBQTA5UHVELGdFQUVybVEsU0FBU0MscURBQXFEekYsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUsscXZEQUFnd0R5RCxzREFFMTRELFNBQVNDLDJDQUEyQzNGLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLDRxT0FBNnVPMkQsc0RBRW4yTyxTQUFTQywyQ0FBMkM3RixPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSywwcUZBQTJyRjZELHVEQUVsdEYsU0FBU0MsNENBQTRDL0YsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssOHFHQUErdUcrRCx3REFFMTZHLFNBQVNDLDZDQUE2Q2pHLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLG01RUFBMDZFaUUsK0RBRXBqRixTQUFTQyxvREFBb0RuRyxPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSyxxbUNBQWduQ21FLGlFQUU3dUMsU0FBU0Msc0RBQXNEckcsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssZzlRQUF1Z1JxRSxtREFFOWxSLFNBQVNDLHdDQUF3Q3ZHLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLGl1RUFBNHdFdUUsOENBRTN3RSxTQUFTQyxvQ0FBb0N6RyxPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSyxxcExBQWd3THlFLGtFQUU1Z00sU0FBU0MsdURBQXVEM0csT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssMmtHQUEwbUcyRSw0REFFbHZHLFNBQVNDLGlEQUFpRDdHLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLDY1RkFBODdGNkUsc0RBRWhrRyxTQUFTQywyQ0FBMkMvRyxPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSyx3aUJBQXFqQitFLDREQUVycUIsU0FBU0MsaURBQWlEakgsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssazBMQUFtNExpRiw2REFFOS9MLFNBQVNDLGtEQUFrRG5ILE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLDhaQUEyYW1GLG9EQUVqakIsU0FBU0MseUNBQXlDckgsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssOGdCQUEyaEJxRix3REFFM29CLFNBQVNDLDZDQUE2Q3ZILE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLG1VQUE4VXVGLDhEQUVoYyxTQUFTQyxtREFBbUR6SCxPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSyxvZkFBaWdCeUYsZ0VBRTduQixTQUFTQyxxREFBcUQzSCxPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSyw0WEFBeVkyRixzRUFFbmdCLFNBQVNDLDJEQUEyRDdILE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLCtZQUEwWjZGLGtFQUVwaUIsU0FBU0MsdURBQXVEL0gsT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssd2dCQUFtaEIrRiwyRUFFNW9CLFNBQVNDLGdFQUFnRWpJLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLGlmQUE0ZmlHLDBEQUV4cEIsU0FBU0MsK0NBQStDbkksT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssNlVBQXdWbUcsa0RBRWxkLFNBQVNDLHVDQUF1Q3JJLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLGloQkFBa2lCcUcseURBRXJwQixTQUFTQyw4Q0FBOEN2SSxPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSywyd0JBQXd4QnVHLGdFQUUxNEIsU0FBU0MscURBQXFEekksT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssMm5CQUE0b0J5Ryw0REFFaHhCLFNBQVNDLGlEQUFpRDNJLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLGlwREFBa3FEMkcsOERBRTV4RCxTQUFTQyxtREFBbUQ3SSxPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSyxrY0FBK2M2RyxzREFFcmxCLFNBQVNDLDJDQUEyQy9JLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLGtmQUErZitHLCtEQUU1bUIsU0FBU0Msb0RBQW9EakosT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssdWtJQUFrb0lpSCxvREFFNXdJLFNBQVNDLHlDQUF5Q25KLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLGdrQkFBbWxCbUgsb0RBRXhtQixTQUFTQywwQ0FBMENySixPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSyxvaDlJQUE0aDlJcUgsMkNBRTN2OUksU0FBU0MsbUNBQW1DdkosT0FBT0QsUUFBUUYscUJBQXFCb0MsS0FBSyxtdXhWQUFreXhWdUgsK0NBRW4zeFYsU0FBU0Msc0NBQXNDekosT0FBT0QsUUFBUUYscUJBQXFCb0MsS0FBSyx3aGtLQUFnL3hLeUgsa0JBRXpteUssU0FBU0MsV0FBVzNKLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLLDY0QkFBMDVCMkgsZ0NBRWwrQixTQUFTQyx3QkFBd0I3SixPQUFPZ0Msb0JBQW9CbkMscUJBQWtDb0MsS0FBSywybURBQXduRDZILCtCQUU1dEQsU0FBU0MsdUJBQXVCL0osT0FBT2dDLG9CQUFvQm5DLHFCQUFrQ29DLEtBQUssay9CQUE2L0IrSCxvQ0FFMWxDLFNBQVNDLDJCQUEyQmpLLE9BQU9nQyxvQkFBb0JuQyxxQkFBa0NvQyxLQUFLIn0=
